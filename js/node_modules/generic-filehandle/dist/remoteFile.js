"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _fileUriToPath = _interopRequireDefault(require("file-uri-to-path"));

var _ = require(".");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var myGlobal = typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {
  fetch: undefined
};

var RemoteFile = /*#__PURE__*/function () {
  (0, _createClass2.default)(RemoteFile, [{
    key: "getBufferFromResponse",
    value: function () {
      var _getBufferFromResponse = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(response) {
        var resp;
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!(typeof response.buffer === 'function')) {
                  _context.next = 4;
                  break;
                }

                return _context.abrupt("return", response.buffer());

              case 4:
                if (!(typeof response.arrayBuffer === 'function')) {
                  _context.next = 11;
                  break;
                }

                _context.next = 7;
                return response.arrayBuffer();

              case 7:
                resp = _context.sent;
                return _context.abrupt("return", Buffer.from(resp));

              case 11:
                throw new TypeError('invalid HTTP response object, has no buffer method, and no arrayBuffer method');

              case 12:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      function getBufferFromResponse(_x) {
        return _getBufferFromResponse.apply(this, arguments);
      }

      return getBufferFromResponse;
    }()
  }]);

  function RemoteFile(source) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck2.default)(this, RemoteFile);
    (0, _defineProperty2.default)(this, "url", void 0);
    (0, _defineProperty2.default)(this, "_stat", void 0);
    (0, _defineProperty2.default)(this, "fetchImplementation", void 0);
    (0, _defineProperty2.default)(this, "baseOverrides", {});
    this.url = source; // if it is a file URL, monkey-patch ourselves to act like a LocalFile

    if (source.startsWith('file://')) {
      var path = (0, _fileUriToPath.default)(source);

      if (!path) {
        throw new TypeError('invalid file url');
      }

      var localFile = new _.LocalFile(path);
      this.read = localFile.read.bind(localFile);
      this.readFile = localFile.readFile.bind(localFile);
      this.stat = localFile.stat.bind(localFile); // eslint-disable-next-line @typescript-eslint/ban-ts-ignore
      // @ts-ignore

      this.fetchImplementation = function () {
        /* intentionally blank */
      };

      return;
    }

    var fetch = opts.fetch || myGlobal.fetch && myGlobal.fetch.bind(myGlobal);

    if (!fetch) {
      throw new TypeError("no fetch function supplied, and none found in global environment");
    }

    if (opts.overrides) {
      this.baseOverrides = opts.overrides;
    }

    this.fetchImplementation = fetch;
  }

  (0, _createClass2.default)(RemoteFile, [{
    key: "fetch",
    value: function () {
      var _fetch = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2(input, init) {
        var response;
        return _regenerator.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.prev = 0;
                _context2.next = 3;
                return this.fetchImplementation(input, init);

              case 3:
                response = _context2.sent;
                _context2.next = 16;
                break;

              case 6:
                _context2.prev = 6;
                _context2.t0 = _context2["catch"](0);

                if (!(_context2.t0.message === 'Failed to fetch')) {
                  _context2.next = 15;
                  break;
                }

                // refetch to to help work around a chrome bug (discussed in generic-filehandle issue #72) in
                // which the chrome cache returns a CORS error for content in its cache.
                // see also https://github.com/GMOD/jbrowse-components/pull/1511
                console.warn("generic-filehandle: refetching ".concat(input, " to attempt to work around chrome CORS header caching bug"));
                _context2.next = 12;
                return this.fetchImplementation(input, _objectSpread(_objectSpread({}, init), {}, {
                  cache: 'reload'
                }));

              case 12:
                response = _context2.sent;
                _context2.next = 16;
                break;

              case 15:
                throw _context2.t0;

              case 16:
                return _context2.abrupt("return", response);

              case 17:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[0, 6]]);
      }));

      function fetch(_x2, _x3) {
        return _fetch.apply(this, arguments);
      }

      return fetch;
    }()
  }, {
    key: "read",
    value: function () {
      var _read = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee3(buffer) {
        var offset,
            length,
            position,
            opts,
            _opts$headers,
            headers,
            signal,
            _opts$overrides,
            overrides,
            args,
            response,
            responseData,
            bytesCopied,
            res,
            sizeMatch,
            _args3 = arguments;

        return _regenerator.default.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                offset = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : 0;
                length = _args3.length > 2 ? _args3[2] : undefined;
                position = _args3.length > 3 && _args3[3] !== undefined ? _args3[3] : 0;
                opts = _args3.length > 4 && _args3[4] !== undefined ? _args3[4] : {};
                _opts$headers = opts.headers, headers = _opts$headers === void 0 ? {} : _opts$headers, signal = opts.signal, _opts$overrides = opts.overrides, overrides = _opts$overrides === void 0 ? {} : _opts$overrides;

                if (length < Infinity) {
                  headers.range = "bytes=".concat(position, "-").concat(position + length);
                } else if (length === Infinity && position !== 0) {
                  headers.range = "bytes=".concat(position, "-");
                }

                args = _objectSpread(_objectSpread(_objectSpread({}, this.baseOverrides), overrides), {}, {
                  headers: _objectSpread(_objectSpread(_objectSpread({}, headers), overrides.headers), this.baseOverrides.headers),
                  method: 'GET',
                  redirect: 'follow',
                  mode: 'cors',
                  signal: signal
                });
                _context3.next = 9;
                return this.fetch(this.url, args);

              case 9:
                response = _context3.sent;

                if (response.ok) {
                  _context3.next = 12;
                  break;
                }

                throw new Error("HTTP ".concat(response.status, " ").concat(response.statusText));

              case 12:
                if (!(response.status === 200 && position === 0 || response.status === 206)) {
                  _context3.next = 21;
                  break;
                }

                _context3.next = 15;
                return this.getBufferFromResponse(response);

              case 15:
                responseData = _context3.sent;
                bytesCopied = responseData.copy(buffer, offset, 0, Math.min(length, responseData.length)); // try to parse out the size of the remote file

                res = response.headers.get('content-range');
                sizeMatch = /\/(\d+)$/.exec(res || '');

                if (sizeMatch && sizeMatch[1]) {
                  this._stat = {
                    size: parseInt(sizeMatch[1], 10)
                  };
                }

                return _context3.abrupt("return", {
                  bytesRead: bytesCopied,
                  buffer: buffer
                });

              case 21:
                if (!(response.status === 200)) {
                  _context3.next = 23;
                  break;
                }

                throw new Error('${this.url} fetch returned status 200, expected 206');

              case 23:
                throw new Error("HTTP ".concat(response.status, " fetching ").concat(this.url));

              case 24:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function read(_x4) {
        return _read.apply(this, arguments);
      }

      return read;
    }()
  }, {
    key: "readFile",
    value: function () {
      var _readFile = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee4() {
        var options,
            encoding,
            opts,
            _opts,
            _opts$headers2,
            headers,
            signal,
            _opts$overrides2,
            overrides,
            args,
            response,
            _args4 = arguments;

        return _regenerator.default.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                options = _args4.length > 0 && _args4[0] !== undefined ? _args4[0] : {};

                if (typeof options === 'string') {
                  encoding = options;
                  opts = {};
                } else {
                  encoding = options.encoding;
                  opts = options;
                  delete opts.encoding;
                }

                _opts = opts, _opts$headers2 = _opts.headers, headers = _opts$headers2 === void 0 ? {} : _opts$headers2, signal = _opts.signal, _opts$overrides2 = _opts.overrides, overrides = _opts$overrides2 === void 0 ? {} : _opts$overrides2;
                args = _objectSpread(_objectSpread({
                  headers: headers,
                  method: 'GET',
                  redirect: 'follow',
                  mode: 'cors',
                  signal: signal
                }, this.baseOverrides), overrides);
                _context4.next = 6;
                return this.fetch(this.url, args);

              case 6:
                response = _context4.sent;

                if (response) {
                  _context4.next = 9;
                  break;
                }

                throw new Error('generic-filehandle failed to fetch');

              case 9:
                if (!(response.status !== 200)) {
                  _context4.next = 11;
                  break;
                }

                throw Object.assign(new Error("HTTP ".concat(response.status, " fetching ").concat(this.url)), {
                  status: response.status
                });

              case 11:
                if (!(encoding === 'utf8')) {
                  _context4.next = 13;
                  break;
                }

                return _context4.abrupt("return", response.text());

              case 13:
                if (!encoding) {
                  _context4.next = 15;
                  break;
                }

                throw new Error("unsupported encoding: ".concat(encoding));

              case 15:
                return _context4.abrupt("return", this.getBufferFromResponse(response));

              case 16:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function readFile() {
        return _readFile.apply(this, arguments);
      }

      return readFile;
    }()
  }, {
    key: "stat",
    value: function () {
      var _stat = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee5() {
        var buf;
        return _regenerator.default.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                if (this._stat) {
                  _context5.next = 6;
                  break;
                }

                buf = Buffer.allocUnsafe(10);
                _context5.next = 4;
                return this.read(buf, 0, 10, 0);

              case 4:
                if (this._stat) {
                  _context5.next = 6;
                  break;
                }

                throw new Error("unable to determine size of file at ".concat(this.url));

              case 6:
                return _context5.abrupt("return", this._stat);

              case 7:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function stat() {
        return _stat.apply(this, arguments);
      }

      return stat;
    }()
  }]);
  return RemoteFile;
}();

exports.default = RemoteFile;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9yZW1vdGVGaWxlLnRzIl0sIm5hbWVzIjpbIm15R2xvYmFsIiwid2luZG93Iiwic2VsZiIsImZldGNoIiwidW5kZWZpbmVkIiwiUmVtb3RlRmlsZSIsInJlc3BvbnNlIiwiYnVmZmVyIiwiYXJyYXlCdWZmZXIiLCJyZXNwIiwiQnVmZmVyIiwiZnJvbSIsIlR5cGVFcnJvciIsInNvdXJjZSIsIm9wdHMiLCJ1cmwiLCJzdGFydHNXaXRoIiwicGF0aCIsImxvY2FsRmlsZSIsIkxvY2FsRmlsZSIsInJlYWQiLCJiaW5kIiwicmVhZEZpbGUiLCJzdGF0IiwiZmV0Y2hJbXBsZW1lbnRhdGlvbiIsIm92ZXJyaWRlcyIsImJhc2VPdmVycmlkZXMiLCJpbnB1dCIsImluaXQiLCJtZXNzYWdlIiwiY29uc29sZSIsIndhcm4iLCJjYWNoZSIsIm9mZnNldCIsImxlbmd0aCIsInBvc2l0aW9uIiwiaGVhZGVycyIsInNpZ25hbCIsIkluZmluaXR5IiwicmFuZ2UiLCJhcmdzIiwibWV0aG9kIiwicmVkaXJlY3QiLCJtb2RlIiwib2siLCJFcnJvciIsInN0YXR1cyIsInN0YXR1c1RleHQiLCJnZXRCdWZmZXJGcm9tUmVzcG9uc2UiLCJyZXNwb25zZURhdGEiLCJieXRlc0NvcGllZCIsImNvcHkiLCJNYXRoIiwibWluIiwicmVzIiwiZ2V0Iiwic2l6ZU1hdGNoIiwiZXhlYyIsIl9zdGF0Iiwic2l6ZSIsInBhcnNlSW50IiwiYnl0ZXNSZWFkIiwib3B0aW9ucyIsImVuY29kaW5nIiwiT2JqZWN0IiwiYXNzaWduIiwidGV4dCIsImJ1ZiIsImFsbG9jVW5zYWZlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7O0FBUUE7Ozs7OztBQUVBLElBQU1BLFFBQVEsR0FDWixPQUFPQyxNQUFQLEtBQWtCLFdBQWxCLEdBQ0lBLE1BREosR0FFSSxPQUFPQyxJQUFQLEtBQWdCLFdBQWhCLEdBQ0FBLElBREEsR0FFQTtBQUFFQyxFQUFBQSxLQUFLLEVBQUVDO0FB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Q1ZDLGtCQUFBQSxJQUFJLEVBQUUsTTtBQUNOTixrQkFBQUEsTUFBTSxFQUFOQTttQkFDRyxLQUFLWCxhLEdBQ0xELFM7O3VCQUVrQixLQUFLdEIsS0FBTCxDQUFXLEtBQUtZLEdBQWhCLEVBQXFCeUIsSUFBckIsQzs7O0FBQWpCbEMsZ0JBQUFBLFE7O29CQUVEQSxROzs7OztzQkFDRyxJQUFJdUMsS0FBSixDQUFVLG9DQUFWLEM7OztzQkFHSnZDLFFBQVEsQ0FBQ3dDLE1BQVQsS0FBb0IsRzs7Ozs7c0JBQ2hCa0IsTUFBTSxDQUFDQyxNQUFQLENBQWMsSUFBSXBCLEtBQUosZ0JBQWtCdkMsUUFBUSxDQUFDd0MsTUFBM0IsdUJBQThDLEtBQUsvQixHQUFuRCxFQUFkLEVBQXlFO0FBQzdFK0Isa0JBQUFBLE1BQU0sRUFBRXhDLFFBQVEsQ0FBQ3dDO0FBRDRELGlCQUF6RSxDOzs7c0JBSUppQixRQUFRLEtBQUssTTs7Ozs7a0RBQ1J6RCxRQUFRLENBQUM0RCxJQUFULEU7OztxQkFFTEgsUTs7Ozs7c0JBQ0ksSUFBSWxCLEtBQUosaUNBQW1Da0IsUUFBbkMsRTs7O2tEQUVELEtBQUtmLHFCQUFMLENBQTJCMUMsUUFBM0IsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFJRixLQUFLb0QsSzs7Ozs7QUFDRlMsZ0JBQUFBLEcsR0FBTXpELE1BQU0sQ0FBQzBELFdBQVAsQ0FBbUIsRUFBbkIsQzs7dUJBQ04sS0FBS2hELElBQUwsQ0FBVStDLEdBQVYsRUFBZSxDQUFmLEVBQWtCLEVBQWxCLEVBQXNCLENBQXRCLEM7OztvQkFDRCxLQUFLVCxLOzs7OztzQkFDRixJQUFJYixLQUFKLCtDQUFpRCxLQUFLOUIsR0FBdEQsRTs7O2tEQUdILEtBQUsyQyxLIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHVyaTJwYXRoIGZyb20gJ2ZpbGUtdXJpLXRvLXBhdGgnXG5pbXBvcnQge1xuICBHZW5lcmljRmlsZWhhbmRsZSxcbiAgRmlsZWhhbmRsZU9wdGlvbnMsXG4gIFN0YXRzLFxuICBGZXRjaGVyLFxuICBQb2x5ZmlsbGVkUmVzcG9uc2UsXG59IGZyb20gJy4vZmlsZWhhbmRsZSdcbmltcG9ydCB7IExvY2FsRmlsZSB9IGZyb20gJy4nXG5cbmNvbnN0IG15R2xvYmFsID1cbiAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgICA/IHdpbmRvd1xuICAgIDogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnXG4gICAgPyBzZWxmXG4gICAgOiB7IGZldGNoOiB1bmRlZmluZWQgfVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZW1vdGVGaWxlIGltcGxlbWVudHMgR2VuZXJpY0ZpbGVoYW5kbGUge1xuICBwcml2YXRlIHVybDogc3RyaW5nXG4gIHByaXZhdGUgX3N0YXQ/OiBTdGF0c1xuICBwcml2YXRlIGZldGNoSW1wbGVtZW50YXRpb246IEZldGNoZXJcbiAgcHJpdmF0ZSBiYXNlT3ZlcnJpZGVzOiBhbnkgPSB7fVxuXG4gIHByaXZhdGUgYXN5bmMgZ2V0QnVmZmVyRnJvbVJlc3BvbnNlKHJlc3BvbnNlOiBQb2x5ZmlsbGVkUmVzcG9uc2UpOiBQcm9taXNlPEJ1ZmZlcj4ge1xuICAgIGlmICh0eXBlb2YgcmVzcG9uc2UuYnVmZmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gcmVzcG9uc2UuYnVmZmVyKClcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiByZXNwb25zZS5hcnJheUJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29uc3QgcmVzcCA9IGF3YWl0IHJlc3BvbnNlLmFycmF5QnVmZmVyKClcbiAgICAgIHJldHVybiBCdWZmZXIuZnJvbShyZXNwKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAnaW52YWxpZCBIVFRQIHJlc3BvbnNlIG9iamVjdCwgaGFzIG5vIGJ1ZmZlciBtZXRob2QsIGFuZCBubyBhcnJheUJ1ZmZlciBtZXRob2QnLFxuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBjb25zdHJ1Y3Rvcihzb3VyY2U6IHN0cmluZywgb3B0czogRmlsZWhhbmRsZU9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMudXJsID0gc291cmNlXG5cbiAgICAvLyBpZiBpdCBpcyBhIGZpbGUgVVJMLCBtb25rZXktcGF0Y2ggb3Vyc2VsdmVzIHRvIGFjdCBsaWtlIGEgTG9jYWxGaWxlXG4gICAgaWYgKHNvdXJjZS5zdGFydHNXaXRoKCdmaWxlOi8vJykpIHtcbiAgICAgIGNvbnN0IHBhdGggPSB1cmkycGF0aChzb3VyY2UpXG4gICAgICBpZiAoIXBhdGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBmaWxlIHVybCcpXG4gICAgICB9XG4gICAgICBjb25zdCBsb2NhbEZpbGUgPSBuZXcgTG9jYWxGaWxlKHBhdGgpXG4gICAgICB0aGlzLnJlYWQgPSBsb2NhbEZpbGUucmVhZC5iaW5kKGxvY2FsRmlsZSlcbiAgICAgIHRoaXMucmVhZEZpbGUgPSBsb2NhbEZpbGUucmVhZEZpbGUuYmluZChsb2NhbEZpbGUpXG4gICAgICB0aGlzLnN0YXQgPSBsb2NhbEZpbGUuc3RhdC5iaW5kKGxvY2FsRmlsZSlcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWlnbm9yZVxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgdGhpcy5mZXRjaEltcGxlbWVudGF0aW9uID0gKCk6IHZvaWQgPT4ge1xuICAgICAgICAvKiBpbnRlbnRpb25hbGx5IGJsYW5rICovXG4gICAgICB9XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBmZXRjaCA9IG9wdHMuZmV0Y2ggfHwgKG15R2xvYmFsLmZldGNoICYmIG15R2xvYmFsLmZldGNoLmJpbmQobXlHbG9iYWwpKVxuICAgIGlmICghZmV0Y2gpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgIGBubyBmZXRjaCBmdW5jdGlvbiBzdXBwbGllZCwgYW5kIG5vbmUgZm91bmQgaW4gZ2xvYmFsIGVudmlyb25tZW50YCxcbiAgICAgIClcbiAgICB9XG4gICAgaWYgKG9wdHMub3ZlcnJpZGVzKSB7XG4gICAgICB0aGlzLmJhc2VPdmVycmlkZXMgPSBvcHRzLm92ZXJyaWRlc1xuICAgIH1cbiAgICB0aGlzLmZldGNoSW1wbGVtZW50YXRpb24gPSBmZXRjaFxuICB9XG5cbiAgcHVibGljIGFzeW5jIGZldGNoKFxuICAgIGlucHV0OiBSZXF1ZXN0SW5mbyxcbiAgICBpbml0OiBSZXF1ZXN0SW5pdCB8IHVuZGVmaW5lZCxcbiAgKTogUHJvbWlzZTxQb2x5ZmlsbGVkUmVzcG9uc2U+IHtcbiAgICBsZXQgcmVzcG9uc2VcbiAgICB0cnkge1xuICAgICAgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoSW1wbGVtZW50YXRpb24oaW5wdXQsIGluaXQpXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGUubWVzc2FnZSA9PT0gJ0ZhaWxlZCB0byBmZXRjaCcpIHtcbiAgICAgICAgLy8gcmVmZXRjaCB0byB0byBoZWxwIHdvcmsgYXJvdW5kIGEgY2hyb21lIGJ1ZyAoZGlzY3Vzc2VkIGluIGdlbmVyaWMtZmlsZWhhbmRsZSBpc3N1ZSAjNzIpIGluXG4gICAgICAgIC8vIHdoaWNoIHRoZSBjaHJvbWUgY2FjaGUgcmV0dXJucyBhIENPUlMgZXJyb3IgZm9yIGNvbnRlbnQgaW4gaXRzIGNhY2hlLlxuICAgICAgICAvLyBzZWUgYWxzbyBodHRwczovL2dpdGh1Yi5jb20vR01PRC9qYnJvd3NlLWNvbXBvbmVudHMvcHVsbC8xNTExXG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBgZ2VuZXJpYy1maWxlaGFuZGxlOiByZWZldGNoaW5nICR7aW5wdXR9IHRvIGF0dGVtcHQgdG8gd29yayBhcm91bmQgY2hyb21lIENPUlMgaGVhZGVyIGNhY2hpbmcgYnVnYCxcbiAgICAgICAgKVxuICAgICAgICByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2hJbXBsZW1lbnRhdGlvbihpbnB1dCwgeyAuLi5pbml0LCBjYWNoZTogJ3JlbG9hZCcgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGVcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3BvbnNlXG4gIH1cblxuICBwdWJsaWMgYXN5bmMgcmVhZChcbiAgICBidWZmZXI6IEJ1ZmZlcixcbiAgICBvZmZzZXQgPSAwLFxuICAgIGxlbmd0aDogbnVtYmVyLFxuICAgIHBvc2l0aW9uID0gMCxcbiAgICBvcHRzOiBGaWxlaGFuZGxlT3B0aW9ucyA9IHt9LFxuICApOiBQcm9taXNlPHsgYnl0ZXNSZWFkOiBudW1iZXI7IGJ1ZmZlcjogQnVmZmVyIH0+IHtcbiAgICBjb25zdCB7IGhlYWRlcnMgPSB7fSwgc2lnbmFsLCBvdmVycmlkZXMgPSB7fSB9ID0gb3B0c1xuICAgIGlmIChsZW5ndGggPCBJbmZpbml0eSkge1xuICAgICAgaGVhZGVycy5yYW5nZSA9IGBieXRlcz0ke3Bvc2l0aW9ufS0ke3Bvc2l0aW9uICsgbGVuZ3RofWBcbiAgICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gSW5maW5pdHkgJiYgcG9zaXRpb24gIT09IDApIHtcbiAgICAgIGhlYWRlcnMucmFuZ2UgPSBgYnl0ZXM9JHtwb3NpdGlvbn0tYFxuICAgIH1cbiAgICBjb25zdCBhcmdzID0ge1xuICAgICAgLi4udGhpcy5iYXNlT3ZlcnJpZGVzLFxuICAgICAgLi4ub3ZlcnJpZGVzLFxuICAgICAgaGVhZGVyczogeyAuLi5oZWFkZXJzLCAuLi5vdmVycmlkZXMuaGVhZGVycywgLi4udGhpcy5iYXNlT3ZlcnJpZGVzLmhlYWRlcnMgfSxcbiAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICByZWRpcmVjdDogJ2ZvbGxvdycsXG4gICAgICBtb2RlOiAnY29ycycsXG4gICAgICBzaWduYWwsXG4gICAgfVxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaCh0aGlzLnVybCwgYXJncylcblxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApXG4gICAgfVxuXG4gICAgaWYgKChyZXNwb25zZS5zdGF0dXMgPT09IDIwMCAmJiBwb3NpdGlvbiA9PT0gMCkgfHwgcmVzcG9uc2Uuc3RhdHVzID09PSAyMDYpIHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlRGF0YSA9IGF3YWl0IHRoaXMuZ2V0QnVmZmVyRnJvbVJlc3BvbnNlKHJlc3BvbnNlKVxuICAgICAgY29uc3QgYnl0ZXNDb3BpZWQgPSByZXNwb25zZURhdGEuY29weShcbiAgICAgICAgYnVmZmVyLFxuICAgICAgICBvZmZzZXQsXG4gICAgICAgIDAsXG4gICAgICAgIE1hdGgubWluKGxlbmd0aCwgcmVzcG9uc2VEYXRhLmxlbmd0aCksXG4gICAgICApXG5cbiAgICAgIC8vIHRyeSB0byBwYXJzZSBvdXQgdGhlIHNpemUgb2YgdGhlIHJlbW90ZSBmaWxlXG4gICAgICBjb25zdCByZXMgPSByZXNwb25zZS5oZWFkZXJzLmdldCgnY29udGVudC1yYW5nZScpXG4gICAgICBjb25zdCBzaXplTWF0Y2ggPSAvXFwvKFxcZCspJC8uZXhlYyhyZXMgfHwgJycpXG4gICAgICBpZiAoc2l6ZU1hdGNoICYmIHNpemVNYXRjaFsxXSkge1xuICAgICAgICB0aGlzLl9zdGF0ID0geyBzaXplOiBwYXJzZUludChzaXplTWF0Y2hbMV0sIDEwKSB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7IGJ5dGVzUmVhZDogYnl0ZXNDb3BpZWQsIGJ1ZmZlciB9XG4gICAgfVxuXG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJyR7dGhpcy51cmx9IGZldGNoIHJldHVybmVkIHN0YXR1cyAyMDAsIGV4cGVjdGVkIDIwNicpXG4gICAgfVxuXG4gICAgLy8gVE9ETzogdHJ5IGhhcmRlciBoZXJlIHRvIGdhdGhlciBtb3JlIGluZm9ybWF0aW9uIGFib3V0IHdoYXQgdGhlIHByb2JsZW0gaXNcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEhUVFAgJHtyZXNwb25zZS5zdGF0dXN9IGZldGNoaW5nICR7dGhpcy51cmx9YClcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyByZWFkRmlsZShcbiAgICBvcHRpb25zOiBGaWxlaGFuZGxlT3B0aW9ucyB8IHN0cmluZyA9IHt9LFxuICApOiBQcm9taXNlPEJ1ZmZlciB8IHN0cmluZz4ge1xuICAgIGxldCBlbmNvZGluZ1xuICAgIGxldCBvcHRzXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBvcHRpb25zXG4gICAgICBvcHRzID0ge31cbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBvcHRpb25zLmVuY29kaW5nXG4gICAgICBvcHRzID0gb3B0aW9uc1xuICAgICAgZGVsZXRlIG9wdHMuZW5jb2RpbmdcbiAgICB9XG4gICAgY29uc3QgeyBoZWFkZXJzID0ge30sIHNpZ25hbCwgb3ZlcnJpZGVzID0ge30gfSA9IG9wdHNcbiAgICBjb25zdCBhcmdzID0ge1xuICAgICAgaGVhZGVycyxcbiAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICByZWRpcmVjdDogJ2ZvbGxvdycsXG4gICAgICBtb2RlOiAnY29ycycsXG4gICAgICBzaWduYWwsXG4gICAgICAuLi50aGlzLmJhc2VPdmVycmlkZXMsXG4gICAgICAuLi5vdmVycmlkZXMsXG4gICAgfVxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaCh0aGlzLnVybCwgYXJncylcblxuICAgIGlmICghcmVzcG9uc2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZ2VuZXJpYy1maWxlaGFuZGxlIGZhaWxlZCB0byBmZXRjaCcpXG4gICAgfVxuXG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICB0aHJvdyBPYmplY3QuYXNzaWduKG5ldyBFcnJvcihgSFRUUCAke3Jlc3BvbnNlLnN0YXR1c30gZmV0Y2hpbmcgJHt0aGlzLnVybH1gKSwge1xuICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgIH0pXG4gICAgfVxuICAgIGlmIChlbmNvZGluZyA9PT0gJ3V0ZjgnKSB7XG4gICAgICByZXR1cm4gcmVzcG9uc2UudGV4dCgpXG4gICAgfVxuICAgIGlmIChlbmNvZGluZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBlbmNvZGluZzogJHtlbmNvZGluZ31gKVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXRCdWZmZXJGcm9tUmVzcG9uc2UocmVzcG9uc2UpXG4gIH1cblxuICBwdWJsaWMgYXN5bmMgc3RhdCgpOiBQcm9taXNlPFN0YXRzPiB7XG4gICAgaWYgKCF0aGlzLl9zdGF0KSB7XG4gICAgICBjb25zdCBidWYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMTApXG4gICAgICBhd2FpdCB0aGlzLnJlYWQoYnVmLCAwLCAxMCwgMClcbiAgICAgIGlmICghdGhpcy5fc3RhdCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuYWJsZSB0byBkZXRlcm1pbmUgc2l6ZSBvZiBmaWxlIGF0ICR7dGhpcy51cmx9YClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRcbiAgfVxufVxuIl19