"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

// Using this you can "await" the file like a normal promise
// https://blog.shovonhasan.com/using-promises-with-filereader/
function readBlobAsArrayBuffer(blob) {
  var fileReader = new FileReader();
  return new Promise(function (resolve, reject) {
    fileReader.onerror = function () {
      fileReader.abort();
      reject(new Error('problem reading blob'));
    };

    fileReader.onabort = function () {
      reject(new Error('blob reading was aborted'));
    };

    fileReader.onload = function () {
      if (fileReader.result && typeof fileReader.result !== 'string') {
        resolve(fileReader.result);
      } else {
        reject(new Error('unknown error reading blob'));
      }
    };

    fileReader.readAsArrayBuffer(blob);
  });
}

function readBlobAsText(blob) {
  var fileReader = new FileReader();
  return new Promise(function (resolve, reject) {
    fileReader.onerror = function () {
      fileReader.abort();
      reject(new Error('problem reading blob'));
    };

    fileReader.onabort = function () {
      reject(new Error('blob reading was aborted'));
    };

    fileReader.onload = function () {
      if (fileReader.result && typeof fileReader.result === 'string') {
        resolve(fileReader.result);
      } else {
        reject(new Error('unknown error reading blob'));
      }
    };

    fileReader.readAsText(blob);
  });
}
/**
 * Blob of binary data fetched from a local file (with FileReader).
 *
 * Adapted by Robert Buels and Garrett Stevens from the BlobFetchable object in
 * the Dalliance Genome Explorer, which is copyright Thomas Down 2006-2011.
 */


var BlobFile = /*#__PURE__*/function () {
  function BlobFile(blob) {
    (0, _classCallCheck2.default)(this, BlobFile);
    (0, _defineProperty2.default)(this, "blob", void 0);
    (0, _defineProperty2.default)(this, "size", void 0);
    this.blob = blob;
    this.size = blob.size;
  }

  (0, _createClass2.default)(BlobFile, [{
    key: "read",
    value: function () {
      var _read = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(buffer) {
        var offset,
            length,
            position,
            start,
            end,
            result,
            resultBuffer,
            bytesCopied,
            _args = arguments;
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                offset = _args.length > 1 && _args[1] !== undefined ? _args[1] : 0;
                length = _args.length > 2 ? _args[2] : undefined;
                position = _args.length > 3 && _args[3] !== undefined ? _args[3] : 0;

                if (length) {
                  _context.next = 5;
                  break;
                }

                return _context.abrupt("return", {
                  bytesRead: 0,
                  buffer: buffer
                });

              case 5:
                start = position;
                end = start + length;
                _context.next = 9;
                return readBlobAsArrayBuffer(this.blob.slice(start, end));

              case 9:
                result = _context.sent;
                resultBuffer = Buffer.from(result);
                bytesCopied = resultBuffer.copy(buffer, offset);
                return _context.abrupt("return", {
                  bytesRead: bytesCopied,
                  buffer: resultBuffer
                });

              case 13:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function read(_x) {
        return _read.apply(this, arguments);
      }

      return read;
    }()
  }, {
    key: "readFile",
    value: function () {
      var _readFile = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2(options) {
        var encoding, result;
        return _regenerator.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (typeof options === 'string') {
                  encoding = options;
                } else {
                  encoding = options && options.encoding;
                }

                if (!(encoding === 'utf8')) {
                  _context2.next = 3;
                  break;
                }

                return _context2.abrupt("return", readBlobAsText(this.blob));

              case 3:
                if (!encoding) {
                  _context2.next = 5;
                  break;
                }

                throw new Error("unsupported encoding: ".concat(encoding));

              case 5:
                _context2.next = 7;
                return readBlobAsArrayBuffer(this.blob);

              case 7:
                result = _context2.sent;
                return _context2.abrupt("return", Buffer.from(result));

              case 9:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function readFile(_x2) {
        return _readFile.apply(this, arguments);
      }

      return readFile;
    }()
  }, {
    key: "stat",
    value: function () {
      var _stat = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee3() {
        return _regenerator.default.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                return _context3.abrupt("return", {
                  size: this.size
                });

              case 1:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function stat() {
        return _stat.apply(this, arguments);
      }

      return stat;
    }()
  }]);
  return BlobFile;
}();

exports.default = BlobFile;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9ibG9iRmlsZS50cyJdLCJuYW1lcyI6WyJyZWFkQmxvYkFzQXJyYXlCdWZmZXIiLCJibG9iIiwiZmlsZVJlYWRlciIsIkZpbGVSZWFkZXIiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsIm9uZXJyb3IiLCJhYm9ydCIsIkVycm9yIiwib25hYm9ydCIsIm9ubG9hZCIsInJlc3VsdCIsInJlYWRBc0FycmF5QnVmZmVyIiwicmVhZEJsb2JBc1RleHQiLCJyZWFkQXNUZXh0IiwiQmxvYkZpbGUiLCJzaXplIiwiYnVmZmVyIiwib2Zmc2V0IiwibGVuZ3RoIiwicG9zaXRpb24iLCJieXRlc1JlYWQiLCJzdGFydCIsImVuZCIsInNsaWNlIiwicmVzdWx0QnVmZmVyIiwiQnVmZmVyIiwiZnJvbSIsImJ5dGVzQ29waWVkIiwiY29weSIsIm9wdGlvbnMiLCJlbmNvZGluZyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVBO0FBQ0E7QUFDQSxTQUFTQSxxQkFBVCxDQUErQkMsSUFBL0IsRUFBaUU7QUFDL0QsTUFBTUMsVUFBVSxHQUFHLElBQUlDLFVBQUosRUFBbkI7QUFFQSxTQUFPLElBQUlDLE9BQUosQ0FBWSxVQUFDQyxPQUFELEVBQVVDLE1BQVYsRUFBMkI7QUFDNUNKLElBQUFBLFVBQVUsQ0FBQ0ssT0FBWCxHQUFxQixZQUFZO0FBQy9CTCxNQUFBQSxVQUFVLENBQUNNLEtBQVg7QUFDQUYsTUFBQUEsTUFBTSxDQUFDLElBQUlHLEtBQUosQ0FBVSxzQkFBVixDQUFELENBQU47QUFDRCxLQUhEOztBQUtBUCxJQUFBQSxVQUFVLENBQUNRLE9BQVgsR0FBcUIsWUFBWTtBQUMvQkosTUFBQUEsTUFBTSxDQUFDLElBQUlHLEtBQUosQ0FBVSwwQkFBVixDQUFELENBQU47QUFDRCxLQUZEOztBQUlBUCxJQUFBQSxVQUFVLENBQUNTLE1BQVgsR0FBb0IsWUFBWTtBQUM5QixVQUFJVCxVQUFVLENBQUNVLE1BQVgsSUFBcUIsT0FBT1YsVUFBVSxDQUFDVSxNQUFsQixLQUE2QixRQUF0RCxFQUFnRTtBQUM5RFAsUUFBQUEsT0FBTyxDQUFDSCxVQUFVLENBQUNVLE1BQVosQ0FBUDtBQUNELE9BRkQsTUFFTztBQUNMTixRQUFBQSxNQUFNLENBQUMsSUFBSUcsS0FBSixDQUFVLDRCQUFWLENBQUQsQ0FBTjtBQUNEO0FBQ0YsS0FORDs7QUFPQVAsSUFBQUEsVUFBVSxDQUFDVyxpQkFBWCxDQUE2QlosSUFBN0I7QUFDRCxHQWxCTSxDQUFQO0FBbUJEOztBQUVELFNBQVNhLGNBQVQsQ0FBd0JiLElBQXhCLEVBQXFEO0FBQ25ELE1BQU1DLFVBQVUsR0FBRyxJQUFJQyxVQUFKLEVBQW5CO0FBRUEsU0FBTyxJQUFJQyxPQUFKLENBQVksVUFBQ0MsT0FBRCxFQUFVQyxNQUFWLEVBQTJCO0FBQzVDSixJQUFBQSxVQUFVLENBQUNLLE9BQVgsR0FBcUIsWUFBWTtBQUMvQkwsTUFBQUEsVUFBVSxDQUFDTSxLQUFYO0FBQ0FGLE1BQUFBLE1BQU0sQ0FBQyxJQUFJRyxLQUFKLENBQVUsc0JBQVYsQ0FBRCxDQUFOO0FBQ0QsS0FIRDs7QUFLQVAsSUFBQUEsVUFBVSxDQUFDUSxPQUFYLEdBQXFCLFlBQVk7QUFDL0JKLE1BQUFBLE1BQU0sQ0FBQyxJQUFJRyxLQUFKLENBQVUsMEJBQVYsQ0FBRCxDQUFOO0FBQ0QsS0FGRDs7QUFJQVAsSUFBQUEsVUFBVSxDQUFDUyxNQUFYLEdBQW9CLFlBQVk7QUFDOUIsVUFBSVQsVUFBVSxDQUFDVSxNQUFYLElBQXFCLE9BQU9WLFVBQVUsQ0FBQ1UsTUFBbEIsS0FBNkIsUUFBdEQsRUFBZ0U7QUFDOURQLFFBQUFBLE9BQU8sQ0FBQ0gsVUFBVSxDQUFDVSxNQUFaLENBQVA7QUFDRCxPQUZELE1BRU87QUFDTE4sUUFBQUEsTUFBTSxDQUFDLElBQUlHLEtBQUosQ0FBVSw0QkFBVixDQUFELENBQU47QUFDRDtBQUNGLEtBTkQ7O0FBT0FQLElBQUFBLFVBQVUsQ0FBQ2EsVUFBWCxDQUFzQmQsSUFBdEI7QUFDRCxHQWxCTSxDQUFQO0FBbUJEO0FBRUQ7Ozs7Ozs7O0lBTXFCZSxRO0FBR25CLG9CQUFtQmYsSUFBbkIsRUFBK0I7QUFBQTtBQUFBO0FBQUE7QUFDN0IsU0FBS0EsSUFBTCxHQUFZQSxJQUFaO0FBQ0EsU0FBS2dCLElBQUwsR0FBWWhCLElBQUksQ0FBQ2dCLElBQWpCO0FBQ0Q7Ozs7OzJHQUdDQyxNOzs7Ozs7Ozs7Ozs7OztBQUNBQyxnQkFBQUEsTSwyREFBUyxDO0FBQ1RDLGdCQUFBQSxNO0FBQ0FDLGdCQUFBQSxRLDJEQUFXLEM7O29CQUlORCxNOzs7OztpREFDSTtBQUFFRSxrQkFBQUEsU0FBUyxFQUFFLENBQWI7QUFBZ0JKLGtCQUFBQSxNQUFNLEVBQU5BO0FBQWhCLGlCOzs7QUFHSEssZ0JBQUFBLEssR0FBUUYsUTtBQUNSRyxnQkFBQUEsRyxHQUFNRCxLQUFLLEdBQUdILE07O3VCQUVDcEIscUJBQXFCLENBQUMsS0FBS0MsSUFBTCxDQUFVd0IsS0FBVixDQUFnQkYsS0FBaEIsRUFBdUJDLEdBQXZCLENBQUQsQzs7O0FBQXBDWixnQkFBQUEsTTtBQUNBYyxnQkFBQUEsWSxHQUFlQyxNQUFNLENBQUNDLElBQVAsQ0FBWWhCLE1BQVosQztBQUVmaUIsZ0JBQUFBLFcsR0FBY0gsWUFBWSxDQUFDSSxJQUFiLENBQWtCWixNQUFsQixFQUEwQkMsTUFBMUIsQztpREFFYjtBQUFFRyxrQkFBQUEsU0FBUyxFQUFFTyxXQUFiO0FBQTBCWCxrQkFBQUEsTUFBTSxFQUFFUTtBQUFsQyxpQjs7Ozs7Ozs7Ozs7Ozs7Ozs7OztnSEFHYUssTzs7Ozs7O0FBRXBCLG9CQUFJLE9BQU9BLE9BQVAsS0FBbUIsUUFBdkIsRUFBaUM7QUFDL0JDLGtCQUFBQSxRQUFRLEdBQUdELE9BQVg7QUFDRCxpQkFGRCxNQUVPO0FBQ0xDLGtCQUFBQSxRQUFRLEdBQUdELE9BQU8sSUFBSUEsT0FBTyxDQUFDQyxRQUE5QjtBQUNEOztzQkFDR0EsUUFBUSxLQUFLLE07Ozs7O2tEQUNSbEIsY0FBYyxDQUFDLEtBQUtiLElBQU4sQzs7O3FCQUVuQitCLFE7Ozs7O3NCQUNJLElBQUl2QixLQUFKLGlDQUFtQ3VCLFFBQW5DLEU7Ozs7dUJBRWFoQyxxQkFBcUIsQ0FBQyxLQUFLQyxJQUFOLEM7OztBQUFwQ1csZ0JBQUFBLE07a0RBQ0NlLE1BQU0sQ0FBQ0MsSUFBUCxDQUFZaEIsTUFBWixDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7a0RBSUE7QUFBRUssa0JBQUFBLElBQUksRUFBRSxLQUFLQTtBQUFiLGlCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgR2VuZXJpY0ZpbGVoYW5kbGUsIEZpbGVoYW5kbGVPcHRpb25zLCBTdGF0cyB9IGZyb20gJy4vZmlsZWhhbmRsZSdcblxuLy8gVXNpbmcgdGhpcyB5b3UgY2FuIFwiYXdhaXRcIiB0aGUgZmlsZSBsaWtlIGEgbm9ybWFsIHByb21pc2Vcbi8vIGh0dHBzOi8vYmxvZy5zaG92b25oYXNhbi5jb20vdXNpbmctcHJvbWlzZXMtd2l0aC1maWxlcmVhZGVyL1xuZnVuY3Rpb24gcmVhZEJsb2JBc0FycmF5QnVmZmVyKGJsb2I6IEJsb2IpOiBQcm9taXNlPEFycmF5QnVmZmVyPiB7XG4gIGNvbnN0IGZpbGVSZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpXG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpOiB2b2lkID0+IHtcbiAgICBmaWxlUmVhZGVyLm9uZXJyb3IgPSAoKTogdm9pZCA9PiB7XG4gICAgICBmaWxlUmVhZGVyLmFib3J0KClcbiAgICAgIHJlamVjdChuZXcgRXJyb3IoJ3Byb2JsZW0gcmVhZGluZyBibG9iJykpXG4gICAgfVxuXG4gICAgZmlsZVJlYWRlci5vbmFib3J0ID0gKCk6IHZvaWQgPT4ge1xuICAgICAgcmVqZWN0KG5ldyBFcnJvcignYmxvYiByZWFkaW5nIHdhcyBhYm9ydGVkJykpXG4gICAgfVxuXG4gICAgZmlsZVJlYWRlci5vbmxvYWQgPSAoKTogdm9pZCA9PiB7XG4gICAgICBpZiAoZmlsZVJlYWRlci5yZXN1bHQgJiYgdHlwZW9mIGZpbGVSZWFkZXIucmVzdWx0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXNvbHZlKGZpbGVSZWFkZXIucmVzdWx0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvcigndW5rbm93biBlcnJvciByZWFkaW5nIGJsb2InKSlcbiAgICAgIH1cbiAgICB9XG4gICAgZmlsZVJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihibG9iKVxuICB9KVxufVxuXG5mdW5jdGlvbiByZWFkQmxvYkFzVGV4dChibG9iOiBCbG9iKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgY29uc3QgZmlsZVJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKClcblxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCk6IHZvaWQgPT4ge1xuICAgIGZpbGVSZWFkZXIub25lcnJvciA9ICgpOiB2b2lkID0+IHtcbiAgICAgIGZpbGVSZWFkZXIuYWJvcnQoKVxuICAgICAgcmVqZWN0KG5ldyBFcnJvcigncHJvYmxlbSByZWFkaW5nIGJsb2InKSlcbiAgICB9XG5cbiAgICBmaWxlUmVhZGVyLm9uYWJvcnQgPSAoKTogdm9pZCA9PiB7XG4gICAgICByZWplY3QobmV3IEVycm9yKCdibG9iIHJlYWRpbmcgd2FzIGFib3J0ZWQnKSlcbiAgICB9XG5cbiAgICBmaWxlUmVhZGVyLm9ubG9hZCA9ICgpOiB2b2lkID0+IHtcbiAgICAgIGlmIChmaWxlUmVhZGVyLnJlc3VsdCAmJiB0eXBlb2YgZmlsZVJlYWRlci5yZXN1bHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJlc29sdmUoZmlsZVJlYWRlci5yZXN1bHQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWplY3QobmV3IEVycm9yKCd1bmtub3duIGVycm9yIHJlYWRpbmcgYmxvYicpKVxuICAgICAgfVxuICAgIH1cbiAgICBmaWxlUmVhZGVyLnJlYWRBc1RleHQoYmxvYilcbiAgfSlcbn1cblxuLyoqXG4gKiBCbG9iIG9mIGJpbmFyeSBkYXRhIGZldGNoZWQgZnJvbSBhIGxvY2FsIGZpbGUgKHdpdGggRmlsZVJlYWRlcikuXG4gKlxuICogQWRhcHRlZCBieSBSb2JlcnQgQnVlbHMgYW5kIEdhcnJldHQgU3RldmVucyBmcm9tIHRoZSBCbG9iRmV0Y2hhYmxlIG9iamVjdCBpblxuICogdGhlIERhbGxpYW5jZSBHZW5vbWUgRXhwbG9yZXIsIHdoaWNoIGlzIGNvcHlyaWdodCBUaG9tYXMgRG93biAyMDA2LTIwMTEuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJsb2JGaWxlIGltcGxlbWVudHMgR2VuZXJpY0ZpbGVoYW5kbGUge1xuICBwcml2YXRlIGJsb2I6IEJsb2JcbiAgcHJpdmF0ZSBzaXplOiBudW1iZXJcbiAgcHVibGljIGNvbnN0cnVjdG9yKGJsb2I6IEJsb2IpIHtcbiAgICB0aGlzLmJsb2IgPSBibG9iXG4gICAgdGhpcy5zaXplID0gYmxvYi5zaXplXG4gIH1cblxuICBwdWJsaWMgYXN5bmMgcmVhZChcbiAgICBidWZmZXI6IEJ1ZmZlcixcbiAgICBvZmZzZXQgPSAwLFxuICAgIGxlbmd0aDogbnVtYmVyLFxuICAgIHBvc2l0aW9uID0gMCxcbiAgKTogUHJvbWlzZTx7IGJ5dGVzUmVhZDogbnVtYmVyOyBidWZmZXI6IEJ1ZmZlciB9PiB7XG4gICAgLy8gc2hvcnQtY2lyY3VpdCBhIHJlYWQgb2YgMCBieXRlcyBoZXJlLCBiZWNhdXNlIGJyb3dzZXJzIGFjdHVhbGx5IHNvbWV0aW1lc1xuICAgIC8vIGNyYXNoIGlmIHlvdSB0cnkgdG8gcmVhZCAwIGJ5dGVzIGZyb20gYSBsb2NhbCBmaWxlIVxuICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICByZXR1cm4geyBieXRlc1JlYWQ6IDAsIGJ1ZmZlciB9XG4gICAgfVxuXG4gICAgY29uc3Qgc3RhcnQgPSBwb3NpdGlvblxuICAgIGNvbnN0IGVuZCA9IHN0YXJ0ICsgbGVuZ3RoXG5cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZWFkQmxvYkFzQXJyYXlCdWZmZXIodGhpcy5ibG9iLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICAgIGNvbnN0IHJlc3VsdEJ1ZmZlciA9IEJ1ZmZlci5mcm9tKHJlc3VsdClcblxuICAgIGNvbnN0IGJ5dGVzQ29waWVkID0gcmVzdWx0QnVmZmVyLmNvcHkoYnVmZmVyLCBvZmZzZXQpXG5cbiAgICByZXR1cm4geyBieXRlc1JlYWQ6IGJ5dGVzQ29waWVkLCBidWZmZXI6IHJlc3VsdEJ1ZmZlciB9XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgcmVhZEZpbGUob3B0aW9ucz86IEZpbGVoYW5kbGVPcHRpb25zIHwgc3RyaW5nKTogUHJvbWlzZTxCdWZmZXIgfCBzdHJpbmc+IHtcbiAgICBsZXQgZW5jb2RpbmdcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IG9wdGlvbnNcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBvcHRpb25zICYmIG9wdGlvbnMuZW5jb2RpbmdcbiAgICB9XG4gICAgaWYgKGVuY29kaW5nID09PSAndXRmOCcpIHtcbiAgICAgIHJldHVybiByZWFkQmxvYkFzVGV4dCh0aGlzLmJsb2IpXG4gICAgfVxuICAgIGlmIChlbmNvZGluZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBlbmNvZGluZzogJHtlbmNvZGluZ31gKVxuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZWFkQmxvYkFzQXJyYXlCdWZmZXIodGhpcy5ibG9iKVxuICAgIHJldHVybiBCdWZmZXIuZnJvbShyZXN1bHQpXG4gIH1cblxuICBwdWJsaWMgYXN5bmMgc3RhdCgpOiBQcm9taXNlPFN0YXRzPiB7XG4gICAgcmV0dXJuIHsgc2l6ZTogdGhpcy5zaXplIH1cbiAgfVxufVxuIl19