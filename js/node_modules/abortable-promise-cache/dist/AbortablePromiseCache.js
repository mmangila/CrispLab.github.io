"use strict";var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");Object.defineProperty(exports, "__esModule", { value: true });exports.default = void 0;var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));var _abortcontrollerPonyfill = require("./abortcontroller-ponyfill");
var _AggregateAbortController = _interopRequireDefault(require("./AggregateAbortController"));
var _AggregateStatusReporter = _interopRequireDefault(require("./AggregateStatusReporter"));var





















AbortablePromiseCache = /*#__PURE__*/function () {
  /**
                                                   * @param {object} args constructor args
                                                   * @param {Function} args.fill fill callback, will be called with sig `fill(data, signal)`
                                                   * @param {object} args.cache backing store to use, must implement `get(key)`, `set(key, val)`,
                                                   *   `delete(key)`, and `keys() -> iterator`
                                                   */




  function AbortablePromiseCache(_ref)





  {var fill = _ref.fill,cache = _ref.cache;(0, _classCallCheck2.default)(this, AbortablePromiseCache);(0, _defineProperty2.default)(this, "cache", void 0);(0, _defineProperty2.default)(this, "fillCallback", void 0);
    if (typeof fill !== 'function')
    throw new TypeError('must pass a fill function');
    if ((0, _typeof2.default)(cache) !== 'object')
    throw new TypeError('must pass a cache object');
    if (
    typeof cache.get !== 'function' ||
    typeof cache.set !== 'function' ||
    typeof cache.delete !== 'function')

    throw new TypeError(
    'cache must implement get(key), set(key, val), and and delete(key)');


    this.cache = cache;
    this.fillCallback = fill;
  }(0, _createClass2.default)(AbortablePromiseCache, [{ key: "evict", value: function evict(















    key, entry) {
      if (this.cache.get(key) === entry) this.cache.delete(key);
    } }, { key: "fill", value: function fill(

    key, data, signal, statusCallback) {var _this = this;
      var aborter = new _AggregateAbortController.default();
      var statusReporter = new _AggregateStatusReporter.default();
      statusReporter.addCallback(statusCallback);
      var newEntry = {
        aborter: aborter,
        promise: this.fillCallback(data, aborter.signal, function (message) {
          statusReporter.callback(message);
        }),
        settled: false,
        statusReporter: statusReporter,
        get aborted() {
          return this.aborter.signal.aborted;
        } };

      newEntry.aborter.addSignal(signal);

      // remove the fill from the cache when its abortcontroller fires, if still in there
      newEntry.aborter.signal.addEventListener('abort', function () {
        if (!newEntry.settled) {
          _this.evict(key, newEntry);
        }
      });

      // chain off the cached promise to record when it settles
      newEntry.promise.
      then(
      function () {
        newEntry.settled = true;
      },
      function (exception) {
        newEntry.settled = true;

        // if the fill throws an error (including abort) and is still in the cache, remove it
        _this.evict(key, newEntry);
      }).

      catch(function (e) {
        // this will only be reached if there is some kind of
        // bad bug in this library
        console.error(e);
        throw e;
      });

      this.cache.set(key, newEntry);
    } }, { key: "has", value: function has(






















    key) {
      return this.cache.has(key);
    }

    /**
       * Callback for getting status of the pending async
       *
       * @callback statusCallback
       * @param {any} status, current status string or message object
       */

    /**
           * @param {any} key cache key to use for this request
           * @param {any} data data passed as the first argument to the fill callback
           * @param {AbortSignal} [signal] optional AbortSignal object that aborts the request
           * @param {statusCallback} a callback to get the current status of a pending async operation
           */ }, { key: "get", value: function get(

    key,
    data,
    signal,
    statusCallback)
    {
      if (!signal && data instanceof _abortcontrollerPonyfill.AbortSignal)
      throw new TypeError(
      'second get argument appears to be an AbortSignal, perhaps you meant to pass `null` for the fill data?');

      var cacheEntry = this.cache.get(key);

      if (cacheEntry) {
        if (cacheEntry.aborted && !cacheEntry.settled) {
          // if it's aborted but has not realized it yet, evict it and redispatch
          this.evict(key, cacheEntry);
          return this.get(key, data, signal, statusCallback);
        }

        if (cacheEntry.settled) {
          // too late to abort, just return it
          return cacheEntry.promise;
        }

        // request is in-flight, add this signal to its list of signals,
        // or if there is no signal, the aborter will become non-abortable
        cacheEntry.aborter.addSignal(signal);
        cacheEntry.statusReporter.addCallback(statusCallback);

        return AbortablePromiseCache.checkSinglePromise(
        cacheEntry.promise,
        signal);

      }

      // if we got here, it is not in the cache. fill.
      this.fill(key, data, signal, statusCallback);
      return AbortablePromiseCache.checkSinglePromise(
      this.cache.get(key).promise,
      signal);

    }

    /**
       * delete the given entry from the cache. if it exists and its fill request has
       * not yet settled, the fill will be signaled to abort.
       *
       * @param {any} key
       */ }, { key: "delete", value: function _delete(
    key) {
      var cachedEntry = this.cache.get(key);
      if (cachedEntry) {
        if (!cachedEntry.settled) cachedEntry.aborter.abort();
        this.cache.delete(key);
      }
    }

    /**
       * Clear all requests from the cache. Aborts any that have not settled.
       * @returns {number} count of entries deleted
       */ }, { key: "clear", value: function clear()
    {
      // iterate without needing regenerator-runtime
      var keyIter = this.cache.keys();
      var deleteCount = 0;
      for (var result = keyIter.next(); !result.done; result = keyIter.next()) {
        this.delete(result.value);
        deleteCount += 1;
      }
      return deleteCount;
    } }], [{ key: "isAbortException", value: function isAbortException(exception) {return (// DOMException
        exception.name === 'AbortError' || // standard-ish non-DOM abort exception
        //@ts-ignore
        exception.code === 'ERR_ABORTED' || // stringified DOMException
        exception.message === 'AbortError: aborted' || // stringified standard-ish exception
        exception.message === 'Error: aborted');} }, { key: "checkSinglePromise", value: function checkSinglePromise(promise, signal) {// check just this signal for having been aborted, and abort the
      // promise if it was, regardless of what happened with the cached
      // response
      function checkForSingleAbort() {if (signal && signal.aborted) throw Object.assign(new Error('aborted'), { code: 'ERR_ABORTED' });}return promise.then(function (result) {checkForSingleAbort();return result;}, function (error) {checkForSingleAbort();throw error;});} }]);return AbortablePromiseCache;}();exports.default = AbortablePromiseCache;