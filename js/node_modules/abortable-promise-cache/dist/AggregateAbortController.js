"use strict";var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");Object.defineProperty(exports, "__esModule", { value: true });exports.default = void 0;var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));var _abortcontrollerPonyfill = require("./abortcontroller-ponyfill");var

NullSignal = function NullSignal() {(0, _classCallCheck2.default)(this, NullSignal);};

/**
                                                                                        * aggregates a number of abort signals, will only fire the aggregated
                                                                                        * abort if all of the input signals have been aborted
                                                                                        */var
AggregateAbortController = /*#__PURE__*/function () {function AggregateAbortController() {(0, _classCallCheck2.default)(this, AggregateAbortController);(0, _defineProperty2.default)(this, "signals",
    new Set());(0, _defineProperty2.default)(this, "abortController",
    new _abortcontrollerPonyfill.AbortController());}(0, _createClass2.default)(AggregateAbortController, [{ key: "addSignal",

    /**
                                                                                                                                * @param {AbortSignal} [signal] optional AbortSignal to add. if falsy,
                                                                                                                                *  will be treated as a null-signal, and this abortcontroller will no
                                                                                                                                *  longer be abortable.
                                                                                                                                */
    //@ts-ignore
    value: function addSignal() {var _this = this;var signal = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new NullSignal();
      if (this.signal.aborted) {
        throw new Error('cannot add a signal, already aborted!');
      }

      // note that a NullSignal will never fire, so if we
      // have one this thing will never actually abort
      this.signals.add(signal);
      if (signal.aborted) {
        // handle the abort immediately if it is already aborted
        // for some reason
        this.handleAborted(signal);
      } else if (typeof signal.addEventListener === 'function') {
        signal.addEventListener('abort', function () {
          _this.handleAborted(signal);
        });
      }
    } }, { key: "handleAborted", value: function handleAborted(

    signal) {
      this.signals.delete(signal);
      if (this.signals.size === 0) {
        this.abortController.abort();
      }
    } }, { key: "abort", value: function abort()





    {
      this.abortController.abort();
    } }, { key: "signal", get: function get() {return this.abortController.signal;} }]);return AggregateAbortController;}();exports.default = AggregateAbortController;