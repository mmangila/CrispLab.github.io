"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _object = _interopRequireDefault(require("object.entries-ponyfill"));

var _abortcontrollerPonyfill = require("./abortcontroller-ponyfill");

/**
 * takes fetch requests and aggregates them at a certain time frequency
 */
var AggregatingFetcher =
/*#__PURE__*/
function () {
  /**
   *
   * @param {object} params
   * @param {number} [params.frequency] number of milliseconds to wait for requests to aggregate
   */
  function AggregatingFetcher(_ref) {
    var _ref$frequency = _ref.frequency,
        frequency = _ref$frequency === void 0 ? 100 : _ref$frequency,
        fetch = _ref.fetch,
        _ref$maxExtraSize = _ref.maxExtraSize,
        maxExtraSize = _ref$maxExtraSize === void 0 ? 32000 : _ref$maxExtraSize,
        _ref$maxFetchSize = _ref.maxFetchSize,
        maxFetchSize = _ref$maxFetchSize === void 0 ? 1000000 : _ref$maxFetchSize;
    (0, _classCallCheck2.default)(this, AggregatingFetcher);
    this.requestQueues = {}; // url => array of requests

    this.fetchCallback = fetch;
    this.frequency = frequency;
    this.maxExtraSize = maxExtraSize;
    this.maxFetchSize = maxFetchSize;
  }

  (0, _createClass2.default)(AggregatingFetcher, [{
    key: "_canAggregate",
    value: function _canAggregate(requestGroup, request) {
      return (// the fetches overlap, or come close
        request.start <= requestGroup.end + this.maxExtraSize && // aggregating would not result in a fetch that is too big
        request.end - request.start + requestGroup.end - requestGroup.start < this.maxFetchSize
      );
    } // returns a promise that only resolves
    // when all of the signals in the given array
    // have fired their abort signal

  }, {
    key: "_allSignalsFired",
    value: function _allSignalsFired(signals) {
      return new Promise(function (resolve) {
        var signalsLeft = signals.filter(function (s) {
          return !s.aborted;
        }).length;
        signals.forEach(function (signal) {
          signal.addEventListener('abort', function () {
            signalsLeft -= 1; // console.log('aggregatingfetcher received an abort')

            if (!signalsLeft) {
              // console.log('aggregatingfetcher aborting aggegated request')
              resolve();
            }
          });
        });
      }).catch(function (e) {
        // eslint-disable-next-line no-console
        console.error(e);
      });
    } // dispatch a request group as a single request
    // and then slice the result back up to satisfy
    // the individual requests

  }, {
    key: "_dispatch",
    value: function _dispatch(_ref2) {
      var url = _ref2.url,
          start = _ref2.start,
          end = _ref2.end,
          requests = _ref2.requests;
      // if any of the requests have an AbortSignal `signal` in their requestOptions,
      // make our aggregating abortcontroller track it, aborting the request if
      // all of the abort signals that are aggregated here have fired
      var abortWholeRequest = new _abortcontrollerPonyfill.AbortController();
      var signals = [];
      requests.forEach(function (_ref3) {
        var requestOptions = _ref3.requestOptions;
        if (requestOptions && requestOptions.signal) signals.push(requestOptions.signal);
      });

      if (signals.length === requests.length) {
        this._allSignalsFired(signals).then(function () {
          return abortWholeRequest.abort();
        });
      }

      this.fetchCallback(url, start, end - 1, {
        signal: abortWholeRequest.signal
      }).then(function (response) {
        var data = response.buffer;
        requests.forEach(function (_ref4) {
          var reqStart = _ref4.start,
              reqEnd = _ref4.end,
              resolve = _ref4.resolve;
          // remember Buffer.slice does not copy, it creates
          // an offset child buffer pointing to the same data
          resolve({
            headers: response.headers,
            buffer: data.slice(reqStart - start, reqEnd - start)
          });
        });
      }, function (err) {
        requests.forEach(function (_ref5) {
          var reject = _ref5.reject;
          return reject(err);
        });
      });
    }
  }, {
    key: "_aggregateAndDispatch",
    value: function _aggregateAndDispatch() {
      var _this = this;

      (0, _object.default)(this.requestQueues).forEach(function (_ref6) {
        var _ref7 = (0, _slicedToArray2.default)(_ref6, 2),
            url = _ref7[0],
            requests = _ref7[1];

        if (!requests || !requests.length) return; // console.log(url, requests)
        // we are now going to aggregate the requests in this url's queue
        // into groups of requests that can be dispatched as one

        var requestsToDispatch = []; // look to see if any of the requests are aborted, and if they are, just
        // reject them now and forget about them

        requests.forEach(function (request) {
          var requestOptions = request.requestOptions,
              reject = request.reject;

          if (requestOptions && requestOptions.signal && requestOptions.signal.aborted) {
            reject(Object.assign(new Error('aborted'), {
              code: 'ERR_ABORTED'
            }));
          } else {
            requestsToDispatch.push(request);
          }
        });
        requestsToDispatch.sort(function (a, b) {
          return a.start - b.start;
        }); // eslint-disable-next-line no-param-reassign

        requests.length = 0;
        if (!requestsToDispatch.length) return;
        var currentRequestGroup;

        for (var i = 0; i < requestsToDispatch.length; i += 1) {
          var next = requestsToDispatch[i];

          if (currentRequestGroup && _this._canAggregate(currentRequestGroup, next)) {
            // aggregate it into the current group
            currentRequestGroup.requests.push(next);
            currentRequestGroup.end = next.end;
          } else {
            // out of range, dispatch the current request group
            if (currentRequestGroup) _this._dispatch(currentRequestGroup); // and start on a new one

            currentRequestGroup = {
              requests: [next],
              url: url,
              start: next.start,
              end: next.end
            };
          }
        }

        if (currentRequestGroup) _this._dispatch(currentRequestGroup);
      });
    }
  }, {
    key: "_enQueue",
    value: function _enQueue(url, request) {
      if (!this.requestQueues[url]) this.requestQueues[url] = [];
      this.requestQueues[url].push(request);
    }
    /**
     *
     * @param {string} url
     * @param {number} start 0-based half-open
     * @param {number} end 0-based half-open
     * @param {object} [requestOptions] options passed to the underlying fetch call
     */

  }, {
    key: "fetch",
    value: function fetch(url, start, end) {
      var _this2 = this;

      var requestOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      return new Promise(function (resolve, reject) {
        _this2._enQueue(url, {
          start: start,
          end: end,
          resolve: resolve,
          reject: reject,
          requestOptions: requestOptions
        });

        if (!_this2.timeout) {
          _this2.timeout = setTimeout(function () {
            _this2.timeout = undefined;

            _this2._aggregateAndDispatch();
          }, _this2.frequency || 1);
        }
      });
    }
  }]);
  return AggregatingFetcher;
}();

module.exports = AggregatingFetcher;