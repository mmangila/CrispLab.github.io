"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

function parseCacheControl(field) {
  if (typeof field !== 'string') {
    return {};
  }

  var parsed = {};
  var invalid = field.toLowerCase().replace( // eslint-disable-next-line no-control-regex,no-useless-escape
  /(?:^|(?:\s*,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, function (match, fieldName, three, four) {
    var value = three || four;
    parsed[fieldName] = value ? value.toLowerCase() : true;
    return '';
  });
  if (invalid) return {}; // parse any things that seem to be numbers

  Object.keys(parsed).forEach(function (key) {
    if (/^[\d]+$/.test(parsed[key])) {
      try {
        var num = parseInt(parsed[key], 10);

        if (!Number.isNaN(num)) {
          parsed[key] = num;
        }
      } catch (e) {
        /* ignore */
      }
    }
  });
  return parsed;
}

var CacheSemantics =
/*#__PURE__*/
function () {
  function CacheSemantics(_ref) {
    var minimumTTL = _ref.minimumTTL;
    (0, _classCallCheck2.default)(this, CacheSemantics);
    this.minimumTTL = minimumTTL;
  }

  (0, _createClass2.default)(CacheSemantics, [{
    key: "calculateChunkExpirationDate",
    value: function calculateChunkExpirationDate(chunkResponse) {
      var _chunkResponse$header = chunkResponse.headers,
          headers = _chunkResponse$header === void 0 ? {} : _chunkResponse$header,
          requestDate = chunkResponse.requestDate,
          responseDate = chunkResponse.responseDate;
      var baselineDate = responseDate || requestDate;

      if (!baselineDate) {
        if (!headers.date) return undefined;
        baselineDate = new Date(headers.date);
      }

      var basePlus = function basePlus(ttl) {
        return new Date(baselineDate.getTime() + ttl);
      }; // results that are not really cacheable expire after the minimum time to live


      if (/\bno-cache\b/.test(headers.pragma)) return basePlus(this.minimumTTL);
      var cacheControl = parseCacheControl(headers['cache-control']);
      if (cacheControl['no-cache'] || cacheControl['no-store'] || cacheControl['must-revalidate']) return basePlus(this.minimumTTL);

      if (cacheControl['max-age'] !== undefined) {
        var ttl = cacheControl['max-age'] * 1000; // max-age is in seconds

        return basePlus(Math.max(ttl, this.minimumTTL));
      } else if (this._coerceToDate(headers.expires)) {
        return this._coerceToDate(headers.expires);
      } else if (this._coerceToDate(headers['last-modified'])) {
        var lastModified = this._coerceToDate(headers['last-modified']);

        var _ttl = (baselineDate.getTime() - lastModified.getTime()) / 10;

        return basePlus(_ttl);
      } // otherwise, we just cache forever


      return undefined;
    }
  }, {
    key: "_coerceToDate",
    value: function _coerceToDate(thing) {
      if (thing) {
        if (thing instanceof Date) return thing;
        if (typeof thing === 'string' || typeof thing === 'number') return new Date(thing);
      }

      return undefined;
    }
    /**
     * check whether a cached chunk response is still valid and can be used
     * @param {object} chunkResponse
     * @returns {boolean}
     */

  }, {
    key: "cachedChunkIsValid",
    value: function cachedChunkIsValid(chunkResponse) {
      var expiration = this.calculateChunkExpirationDate(chunkResponse);
      return !expiration || new Date() <= expiration;
    }
    /**
     * check whether the response for this chunk fetch can be cached
     * @param {object} chunkResponse
     * @returns {boolean}
     */

  }, {
    key: "chunkIsCacheable",
    value: function chunkIsCacheable() {
      // right now, we are caching everything, we just give it a very short
      // time to live if it's not supposed to be cached
      return true;
    }
  }]);
  return CacheSemantics;
}();

module.exports = {
  CacheSemantics: CacheSemantics,
  parseCacheControl: parseCacheControl
};