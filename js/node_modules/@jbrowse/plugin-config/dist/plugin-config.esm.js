import React, { useState, useEffect, lazy } from 'react';
import AdapterType from '@jbrowse/core/pluggableElementTypes/AdapterType';
import WidgetType from '@jbrowse/core/pluggableElementTypes/WidgetType';
import Plugin from '@jbrowse/core/Plugin';
import { observer, PropTypes } from 'mobx-react';
import { types, isStateTreeNode, getType, getEnv, getPropertyMembers, getMembers } from 'mobx-state-tree';
import { ConfigurationSchema, readConfObject, isConfigurationSchemaType, getTypeNamesFromExplicitlyTypedUnion, isConfigurationSlotType } from '@jbrowse/core/configuration';
import { ElementId } from '@jbrowse/core/util/types/mst';
import { BaseFeatureDataAdapter, BaseAdapter } from '@jbrowse/core/data_adapters/BaseAdapter';
import SimpleFeature from '@jbrowse/core/util/simpleFeature';
import { ObservableCreate } from '@jbrowse/core/util/rxjs';
import { toArray } from 'rxjs/operators';
import { openLocation } from '@jbrowse/core/util/io';
import { useDebounce, iterMap } from '@jbrowse/core/util';
import FormControl from '@material-ui/core/FormControl';
import FormHelperText from '@material-ui/core/FormHelperText';
import InputLabel from '@material-ui/core/InputLabel';
import { useTheme, makeStyles } from '@material-ui/core/styles';
import Editor from 'react-simple-code-editor';
import { Light } from 'react-syntax-highlighter';
import json from 'react-syntax-highlighter/dist/cjs/languages/hljs/json';
import a11yDark from 'react-syntax-highlighter/dist/cjs/styles/hljs/a11y-dark';
import a11yLight from 'react-syntax-highlighter/dist/cjs/styles/hljs/a11y-light';
import FormGroup from '@material-ui/core/FormGroup';
import FormLabel from '@material-ui/core/FormLabel';
import { singular } from 'pluralize';
import { FileSelector } from '@jbrowse/core/ui';
import { getSubType, getUnionSubTypes, getPropertyType } from '@jbrowse/core/util/mst-reflection';
import { Paper, IconButton as IconButton$1, TextField as TextField$1, SvgIcon, makeStyles as makeStyles$1, InputLabel as InputLabel$1, List, ListItem, InputAdornment, FormHelperText as FormHelperText$1, Card, CardHeader, CardContent, FormControl as FormControl$1, FormControlLabel, Checkbox, MenuItem } from '@material-ui/core';
import DeleteIcon from '@material-ui/icons/Delete';
import AddIcon from '@material-ui/icons/Add';
import RadioButtonUncheckedIcon from '@material-ui/icons/RadioButtonUnchecked';
import { stringToJexlExpression } from '@jbrowse/core/util/jexlStrings';
import Tooltip from '@material-ui/core/Tooltip';
import IconButton from '@material-ui/core/IconButton';
import HelpIcon from '@material-ui/icons/Help';
import ReactPropTypes from 'prop-types';
import TextField from '@material-ui/core/TextField';
import { ChromePicker } from 'react-color';
import MenuItem$1 from '@material-ui/core/MenuItem';
import Paper$1 from '@material-ui/core/Paper';

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}

function _get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get;
  } else {
    _get = function _get(target, property, receiver) {
      var base = _superPropBase(target, property);

      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(receiver);
      }

      return desc.value;
    };
  }

  return _get(target, property, receiver || target);
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

function _toArray(arr) {
  return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest();
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

function _iterableToArrayLimit(arr, i) {
  var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;

      var F = function () {};

      return {
        s: F,
        n: function () {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function (e) {
          throw e;
        },
        f: F
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var normalCompletion = true,
      didErr = false,
      err;
  return {
    s: function () {
      it = it.call(o);
    },
    n: function () {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function (e) {
      didErr = true;
      err = e;
    },
    f: function () {
      try {
        if (!normalCompletion && it.return != null) it.return();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}

var ConfigurationEditorStateModelFactory = (function (pluginManager) {
  return types.model('ConfigurationEditorWidget', {
    id: ElementId,
    type: types.literal('ConfigurationEditorWidget'),
    // If you add different types of targets, don't forget to account for that
    // in the key of ./components/ConfigurationEditor.js
    target: types.safeReference(pluginManager.pluggableConfigSchemaType('track'))
  }).actions(function (self) {
    return {
      setTarget: function setTarget(newTarget) {
        self.target = newTarget;
      }
    };
  });
});

var configSchema = /*#__PURE__*/ConfigurationSchema('ConfigurationEditorWidget', {});
var HeadingComponent = /*#__PURE__*/observer(function (_ref) {
  var model = _ref.model;

  if (model && model.target) {
    if (model.target.type) {
      return "".concat(model.target.type, " settings");
    }

    if (isStateTreeNode(model.target)) {
      var type = getType(model.target);

      if (type && type.name) {
        return "".concat(type.name.replace('ConfigurationSchema', ''), " settings");
      }
    }
  }

  return 'Settings';
});

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var runtime_1 = /*#__PURE__*/createCommonjsModule(function (module) {
  /**
   * Copyright (c) 2014-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var runtime = function (exports) {

    var Op = Object.prototype;
    var hasOwn = Op.hasOwnProperty;
    var undefined$1; // More compressible than void 0.

    var $Symbol = typeof Symbol === "function" ? Symbol : {};
    var iteratorSymbol = $Symbol.iterator || "@@iterator";
    var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
    var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

    function define(obj, key, value) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
      return obj[key];
    }

    try {
      // IE 8 has a broken Object.defineProperty that only works on DOM objects.
      define({}, "");
    } catch (err) {
      define = function define(obj, key, value) {
        return obj[key] = value;
      };
    }

    function wrap(innerFn, outerFn, self, tryLocsList) {
      // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
      var generator = Object.create(protoGenerator.prototype);
      var context = new Context(tryLocsList || []); // The ._invoke method unifies the implementations of the .next,
      // .throw, and .return methods.

      generator._invoke = makeInvokeMethod(innerFn, self, context);
      return generator;
    }

    exports.wrap = wrap; // Try/catch helper to minimize deoptimizations. Returns a completion
    // record like context.tryEntries[i].completion. This interface could
    // have been (and was previously) designed to take a closure to be
    // invoked without arguments, but in all the cases we care about we
    // already have an existing method we want to call, so there's no need
    // to create a new function object. We can even get away with assuming
    // the method takes exactly one argument, since that happens to be true
    // in every case, so we don't have to touch the arguments object. The
    // only additional allocation required is the completion record, which
    // has a stable shape and so hopefully should be cheap to allocate.

    function tryCatch(fn, obj, arg) {
      try {
        return {
          type: "normal",
          arg: fn.call(obj, arg)
        };
      } catch (err) {
        return {
          type: "throw",
          arg: err
        };
      }
    }

    var GenStateSuspendedStart = "suspendedStart";
    var GenStateSuspendedYield = "suspendedYield";
    var GenStateExecuting = "executing";
    var GenStateCompleted = "completed"; // Returning this object from the innerFn has the same effect as
    // breaking out of the dispatch switch statement.

    var ContinueSentinel = {}; // Dummy constructor functions that we use as the .constructor and
    // .constructor.prototype properties for functions that return Generator
    // objects. For full spec compliance, you may wish to configure your
    // minifier not to mangle the names of these two functions.

    function Generator() {}

    function GeneratorFunction() {}

    function GeneratorFunctionPrototype() {} // This is a polyfill for %IteratorPrototype% for environments that
    // don't natively support it.


    var IteratorPrototype = {};

    IteratorPrototype[iteratorSymbol] = function () {
      return this;
    };

    var getProto = Object.getPrototypeOf;
    var NativeIteratorPrototype = getProto && getProto(getProto(values([])));

    if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
      // This environment has a native %IteratorPrototype%; use it instead
      // of the polyfill.
      IteratorPrototype = NativeIteratorPrototype;
    }

    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
    GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
    GeneratorFunctionPrototype.constructor = GeneratorFunction;
    GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"); // Helper for defining the .next, .throw, and .return methods of the
    // Iterator interface in terms of a single ._invoke method.

    function defineIteratorMethods(prototype) {
      ["next", "throw", "return"].forEach(function (method) {
        define(prototype, method, function (arg) {
          return this._invoke(method, arg);
        });
      });
    }

    exports.isGeneratorFunction = function (genFun) {
      var ctor = typeof genFun === "function" && genFun.constructor;
      return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can
      // do is to check its .name property.
      (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
    };

    exports.mark = function (genFun) {
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
      } else {
        genFun.__proto__ = GeneratorFunctionPrototype;
        define(genFun, toStringTagSymbol, "GeneratorFunction");
      }

      genFun.prototype = Object.create(Gp);
      return genFun;
    }; // Within the body of any async function, `await x` is transformed to
    // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
    // `hasOwn.call(value, "__await")` to determine if the yielded value is
    // meant to be awaited.


    exports.awrap = function (arg) {
      return {
        __await: arg
      };
    };

    function AsyncIterator(generator, PromiseImpl) {
      function invoke(method, arg, resolve, reject) {
        var record = tryCatch(generator[method], generator, arg);

        if (record.type === "throw") {
          reject(record.arg);
        } else {
          var result = record.arg;
          var value = result.value;

          if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
            return PromiseImpl.resolve(value.__await).then(function (value) {
              invoke("next", value, resolve, reject);
            }, function (err) {
              invoke("throw", err, resolve, reject);
            });
          }

          return PromiseImpl.resolve(value).then(function (unwrapped) {
            // When a yielded Promise is resolved, its final value becomes
            // the .value of the Promise<{value,done}> result for the
            // current iteration.
            result.value = unwrapped;
            resolve(result);
          }, function (error) {
            // If a rejected Promise was yielded, throw the rejection back
            // into the async generator function so it can be handled there.
            return invoke("throw", error, resolve, reject);
          });
        }
      }

      var previousPromise;

      function enqueue(method, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function (resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }

        return previousPromise = // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later
        // invocations of the iterator.
        callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      } // Define the unified helper method that is used to implement .next,
      // .throw, and .return (see defineIteratorMethods).


      this._invoke = enqueue;
    }

    defineIteratorMethods(AsyncIterator.prototype);

    AsyncIterator.prototype[asyncIteratorSymbol] = function () {
      return this;
    };

    exports.AsyncIterator = AsyncIterator; // Note that simple async functions are implemented on top of
    // AsyncIterator objects; they just return a Promise for the value of
    // the final result produced by the iterator.

    exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
      if (PromiseImpl === void 0) PromiseImpl = Promise;
      var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
      return exports.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function (result) {
        return result.done ? result.value : iter.next();
      });
    };

    function makeInvokeMethod(innerFn, self, context) {
      var state = GenStateSuspendedStart;
      return function invoke(method, arg) {
        if (state === GenStateExecuting) {
          throw new Error("Generator is already running");
        }

        if (state === GenStateCompleted) {
          if (method === "throw") {
            throw arg;
          } // Be forgiving, per 25.3.3.3.3 of the spec:
          // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume


          return doneResult();
        }

        context.method = method;
        context.arg = arg;

        while (true) {
          var delegate = context.delegate;

          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context);

            if (delegateResult) {
              if (delegateResult === ContinueSentinel) continue;
              return delegateResult;
            }
          }

          if (context.method === "next") {
            // Setting context._sent for legacy support of Babel's
            // function.sent implementation.
            context.sent = context._sent = context.arg;
          } else if (context.method === "throw") {
            if (state === GenStateSuspendedStart) {
              state = GenStateCompleted;
              throw context.arg;
            }

            context.dispatchException(context.arg);
          } else if (context.method === "return") {
            context.abrupt("return", context.arg);
          }

          state = GenStateExecuting;
          var record = tryCatch(innerFn, self, context);

          if (record.type === "normal") {
            // If an exception is thrown from innerFn, we leave state ===
            // GenStateExecuting and loop back for another invocation.
            state = context.done ? GenStateCompleted : GenStateSuspendedYield;

            if (record.arg === ContinueSentinel) {
              continue;
            }

            return {
              value: record.arg,
              done: context.done
            };
          } else if (record.type === "throw") {
            state = GenStateCompleted; // Dispatch the exception by looping back around to the
            // context.dispatchException(context.arg) call above.

            context.method = "throw";
            context.arg = record.arg;
          }
        }
      };
    } // Call delegate.iterator[context.method](context.arg) and handle the
    // result, either by returning a { value, done } result from the
    // delegate iterator, or by modifying context.method and context.arg,
    // setting context.delegate to null, and returning the ContinueSentinel.


    function maybeInvokeDelegate(delegate, context) {
      var method = delegate.iterator[context.method];

      if (method === undefined$1) {
        // A .throw or .return when the delegate iterator has no .throw
        // method always terminates the yield* loop.
        context.delegate = null;

        if (context.method === "throw") {
          // Note: ["return"] must be used for ES3 parsing compatibility.
          if (delegate.iterator["return"]) {
            // If the delegate iterator has a return method, give it a
            // chance to clean up.
            context.method = "return";
            context.arg = undefined$1;
            maybeInvokeDelegate(delegate, context);

            if (context.method === "throw") {
              // If maybeInvokeDelegate(context) changed context.method from
              // "return" to "throw", let that override the TypeError below.
              return ContinueSentinel;
            }
          }

          context.method = "throw";
          context.arg = new TypeError("The iterator does not provide a 'throw' method");
        }

        return ContinueSentinel;
      }

      var record = tryCatch(method, delegate.iterator, context.arg);

      if (record.type === "throw") {
        context.method = "throw";
        context.arg = record.arg;
        context.delegate = null;
        return ContinueSentinel;
      }

      var info = record.arg;

      if (!info) {
        context.method = "throw";
        context.arg = new TypeError("iterator result is not an object");
        context.delegate = null;
        return ContinueSentinel;
      }

      if (info.done) {
        // Assign the result of the finished delegate to the temporary
        // variable specified by delegate.resultName (see delegateYield).
        context[delegate.resultName] = info.value; // Resume execution at the desired location (see delegateYield).

        context.next = delegate.nextLoc; // If context.method was "throw" but the delegate handled the
        // exception, let the outer generator proceed normally. If
        // context.method was "next", forget context.arg since it has been
        // "consumed" by the delegate iterator. If context.method was
        // "return", allow the original .return call to continue in the
        // outer generator.

        if (context.method !== "return") {
          context.method = "next";
          context.arg = undefined$1;
        }
      } else {
        // Re-yield the result returned by the delegate method.
        return info;
      } // The delegate iterator is finished, so forget it and continue with
      // the outer generator.


      context.delegate = null;
      return ContinueSentinel;
    } // Define Generator.prototype.{next,throw,return} in terms of the
    // unified ._invoke helper method.


    defineIteratorMethods(Gp);
    define(Gp, toStringTagSymbol, "Generator"); // A Generator should always return itself as the iterator object when the
    // @@iterator function is called on it. Some browsers' implementations of the
    // iterator prototype chain incorrectly implement this, causing the Generator
    // object to not be returned from this call. This ensures that doesn't happen.
    // See https://github.com/facebook/regenerator/issues/274 for more details.

    Gp[iteratorSymbol] = function () {
      return this;
    };

    Gp.toString = function () {
      return "[object Generator]";
    };

    function pushTryEntry(locs) {
      var entry = {
        tryLoc: locs[0]
      };

      if (1 in locs) {
        entry.catchLoc = locs[1];
      }

      if (2 in locs) {
        entry.finallyLoc = locs[2];
        entry.afterLoc = locs[3];
      }

      this.tryEntries.push(entry);
    }

    function resetTryEntry(entry) {
      var record = entry.completion || {};
      record.type = "normal";
      delete record.arg;
      entry.completion = record;
    }

    function Context(tryLocsList) {
      // The root entry object (effectively a try statement without a catch
      // or a finally block) gives us a place to store values thrown from
      // locations where there is no enclosing try statement.
      this.tryEntries = [{
        tryLoc: "root"
      }];
      tryLocsList.forEach(pushTryEntry, this);
      this.reset(true);
    }

    exports.keys = function (object) {
      var keys = [];

      for (var key in object) {
        keys.push(key);
      }

      keys.reverse(); // Rather than returning an object with a next method, we keep
      // things simple and return the next function itself.

      return function next() {
        while (keys.length) {
          var key = keys.pop();

          if (key in object) {
            next.value = key;
            next.done = false;
            return next;
          }
        } // To avoid creating an additional object, we just hang the .value
        // and .done properties off the next function object itself. This
        // also ensures that the minifier will not anonymize the function.


        next.done = true;
        return next;
      };
    };

    function values(iterable) {
      if (iterable) {
        var iteratorMethod = iterable[iteratorSymbol];

        if (iteratorMethod) {
          return iteratorMethod.call(iterable);
        }

        if (typeof iterable.next === "function") {
          return iterable;
        }

        if (!isNaN(iterable.length)) {
          var i = -1,
              next = function next() {
            while (++i < iterable.length) {
              if (hasOwn.call(iterable, i)) {
                next.value = iterable[i];
                next.done = false;
                return next;
              }
            }

            next.value = undefined$1;
            next.done = true;
            return next;
          };

          return next.next = next;
        }
      } // Return an iterator with no values.


      return {
        next: doneResult
      };
    }

    exports.values = values;

    function doneResult() {
      return {
        value: undefined$1,
        done: true
      };
    }

    Context.prototype = {
      constructor: Context,
      reset: function reset(skipTempReset) {
        this.prev = 0;
        this.next = 0; // Resetting context._sent for legacy support of Babel's
        // function.sent implementation.

        this.sent = this._sent = undefined$1;
        this.done = false;
        this.delegate = null;
        this.method = "next";
        this.arg = undefined$1;
        this.tryEntries.forEach(resetTryEntry);

        if (!skipTempReset) {
          for (var name in this) {
            // Not sure about the optimal order of these conditions:
            if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
              this[name] = undefined$1;
            }
          }
        }
      },
      stop: function stop() {
        this.done = true;
        var rootEntry = this.tryEntries[0];
        var rootRecord = rootEntry.completion;

        if (rootRecord.type === "throw") {
          throw rootRecord.arg;
        }

        return this.rval;
      },
      dispatchException: function dispatchException(exception) {
        if (this.done) {
          throw exception;
        }

        var context = this;

        function handle(loc, caught) {
          record.type = "throw";
          record.arg = exception;
          context.next = loc;

          if (caught) {
            // If the dispatched exception was caught by a catch block,
            // then let that catch block handle the exception normally.
            context.method = "next";
            context.arg = undefined$1;
          }

          return !!caught;
        }

        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          var record = entry.completion;

          if (entry.tryLoc === "root") {
            // Exception thrown outside of any try block that could handle
            // it, so set the completion value of the entire function to
            // throw the exception.
            return handle("end");
          }

          if (entry.tryLoc <= this.prev) {
            var hasCatch = hasOwn.call(entry, "catchLoc");
            var hasFinally = hasOwn.call(entry, "finallyLoc");

            if (hasCatch && hasFinally) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              } else if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }
            } else if (hasCatch) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              }
            } else if (hasFinally) {
              if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }
            } else {
              throw new Error("try statement without catch or finally");
            }
          }
        }
      },
      abrupt: function abrupt(type, arg) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];

          if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
            var finallyEntry = entry;
            break;
          }
        }

        if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
          // Ignore the finally entry if control is not jumping to a
          // location outside the try/catch block.
          finallyEntry = null;
        }

        var record = finallyEntry ? finallyEntry.completion : {};
        record.type = type;
        record.arg = arg;

        if (finallyEntry) {
          this.method = "next";
          this.next = finallyEntry.finallyLoc;
          return ContinueSentinel;
        }

        return this.complete(record);
      },
      complete: function complete(record, afterLoc) {
        if (record.type === "throw") {
          throw record.arg;
        }

        if (record.type === "break" || record.type === "continue") {
          this.next = record.arg;
        } else if (record.type === "return") {
          this.rval = this.arg = record.arg;
          this.method = "return";
          this.next = "end";
        } else if (record.type === "normal" && afterLoc) {
          this.next = afterLoc;
        }

        return ContinueSentinel;
      },
      finish: function finish(finallyLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];

          if (entry.finallyLoc === finallyLoc) {
            this.complete(entry.completion, entry.afterLoc);
            resetTryEntry(entry);
            return ContinueSentinel;
          }
        }
      },
      "catch": function _catch(tryLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];

          if (entry.tryLoc === tryLoc) {
            var record = entry.completion;

            if (record.type === "throw") {
              var thrown = record.arg;
              resetTryEntry(entry);
            }

            return thrown;
          }
        } // The context.catch method must only be called with a location
        // argument that corresponds to a known catch block.


        throw new Error("illegal catch attempt");
      },
      delegateYield: function delegateYield(iterable, resultName, nextLoc) {
        this.delegate = {
          iterator: values(iterable),
          resultName: resultName,
          nextLoc: nextLoc
        };

        if (this.method === "next") {
          // Deliberately forget the last sent value so that we don't
          // accidentally pass it on to the delegate.
          this.arg = undefined$1;
        }

        return ContinueSentinel;
      }
    }; // Regardless of whether this script is executing as a CommonJS module
    // or not, return the runtime object so that we can declare the variable
    // regeneratorRuntime in the outer scope, which allows this module to be
    // injected easily by `bin/regenerator --include-runtime script.js`.

    return exports;
  }( // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
   module.exports );

  try {
    regeneratorRuntime = runtime;
  } catch (accidentalStrictMode) {
    // This module should not be running in strict mode, so the above
    // assignment should always work unless something is misconfigured. Just
    // in case runtime.js accidentally runs in strict mode, we can escape
    // strict mode using a global Function call. This could conceivably fail
    // if a Content Security Policy forbids using Function, but in that case
    // the proper solution is to fix the accidental strict mode problem. If
    // you've misconfigured your bundler to force strict mode and applied a
    // CSP to forbid Function, and you're not willing to fix either of those
    // problems, please detail your unique predicament in a GitHub issue.
    Function("r", "regeneratorRuntime = r")(runtime);
  }
});

/**
 * Adapter that just returns the features defined in its `features` configuration
 * key, like:
 *   `"features": [ { "refName": "ctgA", "start":1, "end":20 }, ... ]`
 */

var FromConfigAdapter = /*#__PURE__*/function (_BaseFeatureDataAdapt) {
  _inherits(FromConfigAdapter, _BaseFeatureDataAdapt);

  var _super = /*#__PURE__*/_createSuper(FromConfigAdapter);

  function FromConfigAdapter(config) {
    var _this;

    _classCallCheck(this, FromConfigAdapter);

    _this = _super.call(this, config);
    var features = readConfObject(config, 'features');
    _this.features = FromConfigAdapter.makeFeatures(features || []);
    return _this;
  }

  _createClass(FromConfigAdapter, [{
    key: "getRefNames",
    value: function () {
      var _getRefNames = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee() {
        var refNames, _iterator, _step, _step$value, refName, features;

        return runtime_1.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                refNames = new Set();
                _iterator = _createForOfIteratorHelper(this.features);

                try {
                  for (_iterator.s(); !(_step = _iterator.n()).done;) {
                    _step$value = _slicedToArray(_step.value, 2), refName = _step$value[0], features = _step$value[1];
                    // add the feature's primary refname
                    refNames.add(refName); // also look in the features for mate or breakend specifications, and add
                    // the refName targets of those

                    features.forEach(function (feature) {
                      // get refNames of generic "mate" records
                      var mate = feature.get('mate');

                      if (mate && mate.refName) {
                        refNames.add(mate.refName);
                      } // get refNames of VCF BND and TRA records


                      var svType = ((feature.get('INFO') || {}).SVTYPE || [])[0];

                      if (svType === 'BND') {
                        var breakendSpecification = (feature.get('ALT') || [])[0];
                        var matePosition = breakendSpecification.MatePosition.split(':');
                        refNames.add(matePosition[0]);
                      } else if (svType === 'TRA') {
                        var chr2 = ((feature.get('INFO') || {}).CHR2 || [])[0];
                        refNames.add(chr2);
                      }
                    });
                  }
                } catch (err) {
                  _iterator.e(err);
                } finally {
                  _iterator.f();
                }

                return _context.abrupt("return", Array.from(refNames));

              case 4:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getRefNames() {
        return _getRefNames.apply(this, arguments);
      }

      return getRefNames;
    }()
  }, {
    key: "getRefNameAliases",
    value: function () {
      var _getRefNameAliases = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2() {
        return runtime_1.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                return _context2.abrupt("return", Array.from(this.features.values()).map(function (featureArray) {
                  return {
                    refName: featureArray[0].get('refName'),
                    aliases: featureArray[0].get('aliases')
                  };
                }));

              case 1:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getRefNameAliases() {
        return _getRefNameAliases.apply(this, arguments);
      }

      return getRefNameAliases;
    }()
  }, {
    key: "getFeatures",
    value: function getFeatures(region) {
      var _this2 = this;

      var refName = region.refName,
          start = region.start,
          end = region.end;
      return ObservableCreate( /*#__PURE__*/function () {
        var _ref = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3(observer) {
          var features, i, f;
          return runtime_1.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  features = _this2.features.get(refName) || [];

                  for (i = 0; i < features.length; i += 1) {
                    f = features[i];

                    if (f.get('end') > start && f.get('start') < end) {
                      observer.next(f);
                    }
                  }

                  observer.complete();

                case 3:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3);
        }));

        return function (_x) {
          return _ref.apply(this, arguments);
        };
      }());
    }
  }, {
    key: "freeResources",
    value: function freeResources()
    /* { region } */
    {}
  }], [{
    key: "makeFeatures",
    value: function makeFeatures(fdata) {
      var features = new Map();

      for (var i = 0; i < fdata.length; i += 1) {
        if (fdata[i]) {
          var f = this.makeFeature(fdata[i]);
          var refName = f.get('refName');
          var bucket = features.get(refName);

          if (!bucket) {
            bucket = [];
            features.set(refName, bucket);
          }

          bucket.push(f);
        }
      } // sort the features on each reference sequence by start coordinate


      var _iterator2 = _createForOfIteratorHelper(features.values()),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var refFeatures = _step2.value;
          refFeatures.sort(function (a, b) {
            return a.get('start') - b.get('start');
          });
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      return features;
    }
  }, {
    key: "makeFeature",
    value: function makeFeature(data) {
      return new SimpleFeature(data);
    }
  }]);

  return FromConfigAdapter;
}(BaseFeatureDataAdapter);

/**
 * Adapter that just returns the features defined in its `features` configuration
 * key, like:
 *   `"features": [ { "refName": "ctgA", "start":1, "end":20 }, ... ]`
 */

var FromConfigRegionsAdapter = /*#__PURE__*/function (_BaseAdapter) {
  _inherits(FromConfigRegionsAdapter, _BaseAdapter);

  var _super = /*#__PURE__*/_createSuper(FromConfigRegionsAdapter);

  function FromConfigRegionsAdapter(config) {
    var _this;

    _classCallCheck(this, FromConfigRegionsAdapter);

    _this = _super.call(this, config);
    var features = readConfObject(config, 'features');
    _this.features = FromConfigAdapter.makeFeatures(features || []);
    return _this;
  }
  /**
   * Get refName, start, and end for all features after collapsing any overlaps
   */


  _createClass(FromConfigRegionsAdapter, [{
    key: "getRegions",
    value: function () {
      var _getRegions = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee() {
        var regions, _iterator, _step, _step$value, refName, features, currentRegion, _iterator2, _step2, feature;

        return runtime_1.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                regions = []; // recall: features are stored in this object sorted by start coordinate

                _iterator = _createForOfIteratorHelper(this.features);

                try {
                  for (_iterator.s(); !(_step = _iterator.n()).done;) {
                    _step$value = _slicedToArray(_step.value, 2), refName = _step$value[0], features = _step$value[1];
                    currentRegion = void 0;
                    _iterator2 = _createForOfIteratorHelper(features);

                    try {
                      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                        feature = _step2.value;

                        if (currentRegion && currentRegion.end >= feature.get('start') && currentRegion.start <= feature.get('end')) {
                          currentRegion.end = feature.get('end');
                        } else {
                          if (currentRegion) {
                            regions.push(currentRegion);
                          }

                          currentRegion = {
                            refName: refName,
                            start: feature.get('start'),
                            end: feature.get('end')
                          };
                        }
                      }
                    } catch (err) {
                      _iterator2.e(err);
                    } finally {
                      _iterator2.f();
                    }

                    if (currentRegion) {
                      regions.push(currentRegion);
                    }
                  } // sort the regions by refName

                } catch (err) {
                  _iterator.e(err);
                } finally {
                  _iterator.f();
                }

                regions.sort(function (a, b) {
                  return a.refName.localeCompare(b.refName);
                });
                return _context.abrupt("return", regions);

              case 5:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getRegions() {
        return _getRegions.apply(this, arguments);
      }

      return getRegions;
    }()
  }, {
    key: "freeResources",
    value: function freeResources()
    /* { region } */
    {}
  }]);

  return FromConfigRegionsAdapter;
}(BaseAdapter);

var FromSequenceConfigAdapter = /*#__PURE__*/function (_FromConfigAdapter) {
  _inherits(FromSequenceConfigAdapter, _FromConfigAdapter);

  var _super = /*#__PURE__*/_createSuper(FromSequenceConfigAdapter);

  function FromSequenceConfigAdapter() {
    _classCallCheck(this, FromSequenceConfigAdapter);

    return _super.apply(this, arguments);
  }

  _createClass(FromSequenceConfigAdapter, [{
    key: "getFeatures",
    value:
    /**
     * Fetch features for a certain region
     * @param region - Region
     * @returns Observable of Feature objects in the region
     */
    function getFeatures(region) {
      var _this = this;

      // TODO: restore commented version below once TSDX supports Rollup v2
      // xref: https://github.com/rollup/rollup/blob/master/CHANGELOG.md#bug-fixes-45
      // return ObservableCreate<Feature>(async observer => {
      //   const feats = await super.getFeatures(region).pipe(toArray()).toPromise()
      var superGetFeatures = _get(_getPrototypeOf(FromSequenceConfigAdapter.prototype), "getFeatures", this);

      return ObservableCreate( /*#__PURE__*/function () {
        var _ref = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(observer) {
          var feats, feat;
          return runtime_1.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _context.next = 2;
                  return superGetFeatures.call(_this, region).pipe(toArray()).toPromise();

                case 2:
                  feats = _context.sent;
                  feat = feats[0];
                  observer.next(new SimpleFeature(_objectSpread2(_objectSpread2({}, feat.toJSON()), {}, {
                    uniqueId: "".concat(feat.id(), ":").concat(region.start, "-").concat(region.end),
                    end: region.end,
                    start: region.start,
                    seq: feat.get('seq').slice(Math.max(region.start - feat.get('start'), 0), Math.max(region.end - feat.get('start'), 0))
                  })));
                  observer.complete();

                case 6:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }));

        return function (_x) {
          return _ref.apply(this, arguments);
        };
      }());
    }
    /**
     * Get refName, start, and end for all features after collapsing any overlaps
     */

  }, {
    key: "getRegions",
    value: function () {
      var _getRegions = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2() {
        var regions, _iterator, _step, _step$value, refName, features, currentRegion, _iterator2, _step2, feature;

        return runtime_1.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                regions = []; // recall: features are stored in this object sorted by start coordinate

                _iterator = _createForOfIteratorHelper(this.features);

                try {
                  for (_iterator.s(); !(_step = _iterator.n()).done;) {
                    _step$value = _slicedToArray(_step.value, 2), refName = _step$value[0], features = _step$value[1];
                    currentRegion = void 0;
                    _iterator2 = _createForOfIteratorHelper(features);

                    try {
                      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                        feature = _step2.value;

                        if (currentRegion && currentRegion.end >= feature.get('start') && currentRegion.start <= feature.get('end')) {
                          currentRegion.end = feature.get('end');
                        } else {
                          if (currentRegion) {
                            regions.push(currentRegion);
                          }

                          currentRegion = {
                            refName: refName,
                            start: feature.get('start'),
                            end: feature.get('end')
                          };
                        }
                      }
                    } catch (err) {
                      _iterator2.e(err);
                    } finally {
                      _iterator2.f();
                    }

                    if (currentRegion) {
                      regions.push(currentRegion);
                    }
                  } // sort the regions by refName

                } catch (err) {
                  _iterator.e(err);
                } finally {
                  _iterator.f();
                }

                regions.sort(function (a, b) {
                  return a.refName.localeCompare(b.refName);
                });
                return _context2.abrupt("return", regions);

              case 5:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getRegions() {
        return _getRegions.apply(this, arguments);
      }

      return getRegions;
    }()
    /**
     * called to provide a hint that data tied to a certain region
     * will not be needed for the forseeable future and can be purged
     * from caches, etc
     */

  }, {
    key: "freeResources",
    value: function freeResources()
    /* { region } */
    {}
  }]);

  return FromSequenceConfigAdapter;
}(FromConfigAdapter);

var configSchema$1 = /*#__PURE__*/ConfigurationSchema('FromConfigAdapter', {
  features: {
    type: 'frozen',
    defaultValue: []
  },
  featureClass: {
    type: 'string',
    defaultValue: 'SimpleFeature'
  }
}, {
  explicitlyTyped: true,
  implicitIdentifier: 'adapterId'
});
var regionsConfigSchema = /*#__PURE__*/ConfigurationSchema('FromConfigRegionsAdapter', {
  features: {
    type: 'frozen',
    defaultValue: []
  },
  featureClass: {
    type: 'string',
    defaultValue: 'SimpleFeature'
  }
}, {
  explicitlyTyped: true,
  implicitIdentifier: 'adapterId'
});
var sequenceConfigSchema = /*#__PURE__*/ConfigurationSchema('FromConfigSequenceAdapter', {
  features: {
    type: 'frozen',
    defaultValue: []
  },
  featureClass: {
    type: 'string',
    defaultValue: 'SimpleFeature'
  }
}, {
  explicitlyTyped: true,
  implicitIdentifier: 'adapterId'
});

var RefNameAliasAdapter = /*#__PURE__*/function (_BaseAdapter) {
  _inherits(RefNameAliasAdapter, _BaseAdapter);

  var _super = /*#__PURE__*/_createSuper(RefNameAliasAdapter);

  function RefNameAliasAdapter(config) {
    var _this;

    _classCallCheck(this, RefNameAliasAdapter);

    _this = _super.call(this, config);
    _this.location = openLocation(readConfObject(config, 'location'));
    _this.promise = _this.downloadResults();
    return _this;
  }

  _createClass(RefNameAliasAdapter, [{
    key: "downloadResults",
    value: function () {
      var _downloadResults = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee() {
        var results;
        return runtime_1.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this.location.readFile('utf8');

              case 2:
                results = _context.sent;
                return _context.abrupt("return", results.trim().split('\n').map(function (row) {
                  var _row$split = row.split('\t'),
                      _row$split2 = _toArray(_row$split),
                      refName = _row$split2[0],
                      aliases = _row$split2.slice(1);

                  return {
                    refName: refName,
                    aliases: aliases
                  };
                }));

              case 4:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function downloadResults() {
        return _downloadResults.apply(this, arguments);
      }

      return downloadResults;
    }()
  }, {
    key: "getRefNameAliases",
    value: function getRefNameAliases() {
      return this.promise;
    }
  }, {
    key: "freeResources",
    value: function () {
      var _freeResources = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2() {
        return runtime_1.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }));

      function freeResources() {
        return _freeResources.apply(this, arguments);
      }

      return freeResources;
    }()
  }]);

  return RefNameAliasAdapter;
}(BaseAdapter);

var refNameAliasAdapterConfigSchema = /*#__PURE__*/ConfigurationSchema('RefNameAliasAdapter', {
  location: {
    type: 'fileLocation',
    defaultValue: {
      uri: '/path/to/my/aliases.txt'
    }
  }
}, {
  explicitlyTyped: true
});

Light.registerLanguage('json', json); // fontSize and fontFamily have to match between Editor and SyntaxHighlighter

var fontSize = '12px'; // Optimize by using system default fonts: https://css-tricks.com/snippets/css/font-stacks/

var fontFamily = 'Consolas, "Andale Mono WT", "Andale Mono", "Lucida Console", "Lucida Sans Typewriter", "DejaVu Sans Mono", "Bitstream Vera Sans Mono", "Liberation Mono", "Nimbus Mono L", Monaco, "Courier New", Courier, monospace';
var useStyles = /*#__PURE__*/makeStyles({
  callbackEditor: {
    fontFamily: fontFamily,
    fontSize: fontSize,
    overflowX: 'auto',
    marginTop: '16px',
    borderBottom: '1px solid rgba(0,0,0,0.42)'
  },
  syntaxHighlighter: {
    margin: 0,
    fontFamily: fontFamily,
    fontSize: fontSize
  },
  error: {
    color: 'red',
    fontSize: '0.8em'
  }
});

function JsonEditor(_ref) {
  var slot = _ref.slot;
  var classes = useStyles();
  var theme = useTheme();

  var _useState = useState(JSON.stringify(slot.value, null, '  ')),
      _useState2 = _slicedToArray(_useState, 2),
      contents = _useState2[0],
      setContents = _useState2[1];

  var _useState3 = useState(),
      _useState4 = _slicedToArray(_useState3, 2),
      error = _useState4[0],
      setError = _useState4[1];

  var debouncedJson = useDebounce(contents, 400);
  useEffect(function () {
    try {
      slot.set(JSON.parse(debouncedJson));
      setError(undefined);
    } catch (e) {
      setError(e.message);
    } // eslint-disable-next-line react-hooks/exhaustive-deps

  }, [debouncedJson]);
  return /*#__PURE__*/React.createElement(React.Fragment, null, error ? /*#__PURE__*/React.createElement("p", {
    className: classes.error
  }, error) : null, /*#__PURE__*/React.createElement(FormControl, {
    error: error
  }, /*#__PURE__*/React.createElement(InputLabel, {
    shrink: true,
    htmlFor: "callback-editor"
  }, slot.name), /*#__PURE__*/React.createElement(Editor, {
    className: classes.callbackEditor,
    value: contents,
    onValueChange: setContents,
    highlight: function highlight(newCode) {
      return /*#__PURE__*/React.createElement(Light, {
        language: "json",
        style: theme.palette.type === 'dark' ? a11yDark : a11yLight,
        className: classes.syntaxHighlighter // override some inline style stuff that's higher specificity
        // than className
        ,
        customStyle: {
          background: 'none',
          padding: 0
        }
      }, newCode);
    },
    padding: 10,
    style: {}
  }), /*#__PURE__*/React.createElement(FormHelperText, null, slot.description)));
}

JsonEditor.propTypes = {
  slot: PropTypes.objectOrObservableObject.isRequired
};
var JsonEditor$1 = /*#__PURE__*/observer(JsonEditor);

var ConfigurationEditorComponent = /*#__PURE__*/lazy(function () {
  return Promise.resolve().then(function () { return ConfigurationEditor$1; });
});

var _default = /*#__PURE__*/function (_Plugin) {
  _inherits(_default, _Plugin);

  var _super = /*#__PURE__*/_createSuper(_default);

  function _default() {
    var _this;

    _classCallCheck(this, _default);

    _this = _super.apply(this, arguments);
    _this.name = 'ConfigurationPlugin';
    return _this;
  }

  _createClass(_default, [{
    key: "install",
    value: function install(pluginManager) {
      pluginManager.addAdapterType(function () {
        return new AdapterType({
          name: 'FromConfigAdapter',
          configSchema: configSchema$1,
          AdapterClass: FromConfigAdapter
        });
      });
      pluginManager.addAdapterType(function () {
        return new AdapterType({
          name: 'FromConfigRegionsAdapter',
          configSchema: regionsConfigSchema,
          AdapterClass: FromConfigRegionsAdapter
        });
      });
      pluginManager.addAdapterType(function () {
        return new AdapterType({
          name: 'FromConfigSequenceAdapter',
          configSchema: sequenceConfigSchema,
          AdapterClass: FromSequenceConfigAdapter
        });
      });
      pluginManager.addAdapterType(function () {
        return new AdapterType({
          name: 'RefNameAliasAdapter',
          configSchema: refNameAliasAdapterConfigSchema,
          AdapterClass: RefNameAliasAdapter
        });
      });
      pluginManager.addWidgetType(function () {
        return new WidgetType({
          name: 'ConfigurationEditorWidget',
          HeadingComponent: HeadingComponent,
          configSchema: configSchema,
          stateModel: ConfigurationEditorStateModelFactory(pluginManager),
          ReactComponent: ConfigurationEditorComponent
        });
      });
    }
  }]);

  return _default;
}(Plugin);

var fontSize$1 = '12px'; // Optimize by using system default fonts:
// https://css-tricks.com/snippets/css/font-stacks/

var fontFamily$1 = 'Consolas, "Andale Mono WT", "Andale Mono", "Lucida Console", "Lucida Sans Typewriter", "DejaVu Sans Mono", "Bitstream Vera Sans Mono", "Liberation Mono", "Nimbus Mono L", Monaco, "Courier New", Courier, monospace';
var useStyles$1 = /*#__PURE__*/makeStyles(function (theme) {
  return {
    callbackEditor: {
      marginTop: '16px',
      borderBottom: "1px solid ".concat(theme.palette.divider),
      fontFamily: fontFamily$1,
      fontSize: fontSize$1
    }
  };
});

function CallbackEditor(_ref) {
  var slot = _ref.slot;
  var classes = useStyles$1();

  var _useState = useState(slot.value),
      _useState2 = _slicedToArray(_useState, 2),
      code = _useState2[0],
      setCode = _useState2[1];

  var _useState3 = useState(),
      _useState4 = _slicedToArray(_useState3, 2),
      error = _useState4[0],
      setCodeError = _useState4[1];

  var debouncedCode = useDebounce(code, 400);
  useEffect(function () {
    try {
      var _getEnv$pluginManager;

      var jexlDebouncedCode = debouncedCode.startsWith('jexl:') ? debouncedCode : "jexl:".concat(debouncedCode);
      stringToJexlExpression(jexlDebouncedCode, (_getEnv$pluginManager = getEnv(slot).pluginManager) === null || _getEnv$pluginManager === void 0 ? void 0 : _getEnv$pluginManager.jexl);
      slot.set(jexlDebouncedCode); // slot.set `jexl:${debouncedCode}`

      setCodeError(null);
    } catch (e) {
      setCodeError(e);
    }
  }, [debouncedCode, slot]); // if default value is a callback, will have to remove jexl:
  // do this last

  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(FormControl, null, /*#__PURE__*/React.createElement(InputLabel, {
    shrink: true,
    htmlFor: "callback-editor"
  }, slot.name), /*#__PURE__*/React.createElement(Editor, {
    className: classes.callbackEditor,
    value: code.startsWith('jexl:') ? code.split('jexl:')[1] : code,
    onValueChange: function onValueChange(newCode) {
      setCode(newCode);
    },
    highlight: function highlight(newCode) {
      return newCode;
    },
    padding: 10,
    style: {
      background: error ? '#fdd' : undefined
    }
  }), /*#__PURE__*/React.createElement(FormHelperText, null, slot.description)), /*#__PURE__*/React.createElement(Tooltip, {
    title: /*#__PURE__*/React.createElement("div", null, "Callbacks are written in Jexl format. Click to learn more.", /*#__PURE__*/React.createElement("br", null), " Names of available context items: ", slot.contextVariable),
    arrow: true
  }, /*#__PURE__*/React.createElement(IconButton, {
    color: "primary",
    onClick: function onClick() {
      var newWindow = window.open('https://github.com/TomFrost/Jexl', '_blank', 'noopener,noreferrer');

      if (newWindow) {
        newWindow.opener = null;
      }
    }
  }, /*#__PURE__*/React.createElement(HelpIcon, null))));
}

CallbackEditor.propTypes = {
  slot: PropTypes.objectOrObservableObject.isRequired
};
var CallbackEditor$1 = /*#__PURE__*/observer(CallbackEditor);

// for alpha, can't pass in an rgba string for example

function serializeColor(color) {
  if (color instanceof Object) {
    var r = color.r,
        g = color.g,
        b = color.b,
        a = color.a;
    return "rgb(".concat(r, ",").concat(g, ",").concat(b, ",").concat(a, ")");
  }

  return color;
}

var useStyles$2 = /*#__PURE__*/makeStyles({
  popover: {
    position: 'absolute',
    zIndex: 2
  },
  cover: {
    position: 'fixed',
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  }
});
function ColorPicker(props) {
  var color = props.color,
      onChange = props.onChange;
  var classes = useStyles$2();

  var _useState = useState(true),
      _useState2 = _slicedToArray(_useState, 2),
      displayColorPicker = _useState2[0],
      setDisplayColorPicker = _useState2[1];

  var handleClose = function handleClose() {
    setDisplayColorPicker(false);
  };

  return /*#__PURE__*/React.createElement("div", null, displayColorPicker ? /*#__PURE__*/React.createElement("div", {
    className: classes.popover
  }, /*#__PURE__*/React.createElement("div", {
    role: "presentation",
    className: classes.cover,
    onClick: handleClose
  }), /*#__PURE__*/React.createElement(ChromePicker, {
    color: color,
    onChange: onChange
  })) : null);
}
ColorPicker.propTypes = {
  color: ReactPropTypes.string.isRequired,
  onChange: ReactPropTypes.func.isRequired
};
var ColorSlot = function ColorSlot(props) {
  var value = props.value,
      label = props.label,
      TextFieldProps = props.TextFieldProps,
      _onChange = props.onChange;

  var _useState3 = useState(false),
      _useState4 = _slicedToArray(_useState3, 2),
      displayed = _useState4[0],
      setDisplayed = _useState4[1];

  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(TextField, Object.assign({
    value: value,
    label: label,
    InputProps: {
      style: {
        color: value,
        borderRightWidth: '25px',
        borderRightStyle: 'solid',
        borderRightColor: value
      }
    },
    onClick: function onClick() {
      return setDisplayed(!displayed);
    },
    onChange: function onChange(event) {
      _onChange(event.target.value);
    }
  }, TextFieldProps)), displayed ? /*#__PURE__*/React.createElement(ColorPicker, {
    color: value,
    onChange: function onChange(event) {
      _onChange(serializeColor(event.rgb));
    }
  }) : null);
};
ColorSlot.propTypes = {
  onChange: ReactPropTypes.func.isRequired,
  label: ReactPropTypes.string,
  TextFieldProps: /*#__PURE__*/ReactPropTypes.shape({}),
  value: ReactPropTypes.string
};
ColorSlot.defaultProps = {
  label: '',
  value: '#000',
  TextFieldProps: {}
};

function ColorEditorSlot(props) {
  var slot = props.slot;
  return /*#__PURE__*/React.createElement(ColorSlot, {
    label: slot.name,
    value: slot.value,
    onChange: function onChange(color) {
      slot.set(color);
    },
    TextFieldProps: {
      helperText: slot.description,
      fullWidth: true
    }
  });
}

ColorEditorSlot.propTypes = {
  slot: /*#__PURE__*/ReactPropTypes.shape({
    name: ReactPropTypes.string.isRequired,
    description: ReactPropTypes.string,
    value: ReactPropTypes.string.isRequired,
    set: ReactPropTypes.func.isRequired
  }).isRequired
};
var ColorEditor = /*#__PURE__*/observer(ColorEditorSlot);

var StringEditor = /*#__PURE__*/observer(function (_ref) {
  var slot = _ref.slot;
  return /*#__PURE__*/React.createElement(TextField$1, {
    label: slot.name // error={filterError}
    ,
    helperText: slot.description,
    fullWidth: true,
    value: slot.value,
    onChange: function onChange(evt) {
      return slot.set(evt.target.value);
    }
  });
});
var TextEditor = /*#__PURE__*/observer(function (_ref2) {
  var slot = _ref2.slot;
  return /*#__PURE__*/React.createElement(TextField$1, {
    label: slot.name,
    helperText: slot.description,
    fullWidth: true,
    multiline: true,
    value: slot.value,
    onChange: function onChange(evt) {
      return slot.set(evt.target.value);
    }
  });
}); // checked checkbox, looks like a styled (x)

var SvgCheckbox = function SvgCheckbox() {
  return /*#__PURE__*/React.createElement(SvgIcon, null, /*#__PURE__*/React.createElement("path", {
    d: "M20.41,3C21.8,5.71 22.35,8.84 22,12C21.8,15.16 20.7,18.29 18.83,21L17.3,20C18.91,17.57 19.85,14.8 20,12C20.34,9.2 19.89,6.43 18.7,4L20.41,3M5.17,3L6.7,4C5.09,6.43 4.15,9.2 4,12C3.66,14.8 4.12,17.57 5.3,20L3.61,21C2.21,18.29 1.65,15.17 2,12C2.2,8.84 3.3,5.71 5.17,3M12.08,10.68L14.4,7.45H16.93L13.15,12.45L15.35,17.37H13.09L11.71,14L9.28,17.33H6.76L10.66,12.21L8.53,7.45H10.8L12.08,10.68Z"
  }));
};

var StringArrayEditor = /*#__PURE__*/observer(function (_ref3) {
  var slot = _ref3.slot;

  var _useState = useState(''),
      _useState2 = _slicedToArray(_useState, 2),
      value = _useState2[0],
      setValue = _useState2[1];

  return /*#__PURE__*/React.createElement(React.Fragment, null, slot.name ? /*#__PURE__*/React.createElement(InputLabel$1, null, slot.name) : null, /*#__PURE__*/React.createElement(List, {
    disablePadding: true
  }, slot.value.map(function (val, idx) {
    return /*#__PURE__*/React.createElement(ListItem, {
      key: idx,
      disableGutters: true
    }, /*#__PURE__*/React.createElement(TextField$1, {
      value: val,
      onChange: function onChange(evt) {
        return slot.setAtIndex(idx, evt.target.value);
      },
      InputProps: {
        endAdornment: /*#__PURE__*/React.createElement(InputAdornment, null, /*#__PURE__*/React.createElement(IconButton$1, {
          color: "secondary",
          onClick: function onClick() {
            return slot.removeAtIndex(idx);
          }
        }, /*#__PURE__*/React.createElement(DeleteIcon, null)))
      }
    }));
  }), /*#__PURE__*/React.createElement(ListItem, {
    disableGutters: true
  }, /*#__PURE__*/React.createElement(TextField$1, {
    value: value,
    placeholder: "add new",
    onChange: function onChange(event) {
      return setValue(event.target.value);
    },
    InputProps: {
      endAdornment: /*#__PURE__*/React.createElement(InputAdornment, null, /*#__PURE__*/React.createElement(IconButton$1, {
        onClick: function onClick() {
          slot.add(value);
          setValue('');
        },
        disabled: value === '',
        color: "secondary",
        "data-testid": "stringArrayAdd-".concat(slot.name)
      }, /*#__PURE__*/React.createElement(AddIcon, null)))
    }
  }))), /*#__PURE__*/React.createElement(FormHelperText$1, null, slot.description));
});
var useMapEditorStyles = /*#__PURE__*/makeStyles$1(function (theme) {
  return {
    card: {
      marginTop: theme.spacing(1)
    }
  };
});
var StringArrayMapEditor = /*#__PURE__*/observer(function (_ref4) {
  var slot = _ref4.slot;
  var classes = useMapEditorStyles();

  var _useState3 = useState(''),
      _useState4 = _slicedToArray(_useState3, 2),
      value = _useState4[0],
      setValue = _useState4[1];

  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(InputLabel$1, null, slot.name), Array.from(slot.value, function (_ref5) {
    var _ref6 = _slicedToArray(_ref5, 2),
        key = _ref6[0],
        val = _ref6[1];

    return /*#__PURE__*/React.createElement(Card, {
      raised: true,
      key: key,
      className: classes.card
    }, /*#__PURE__*/React.createElement(CardHeader, {
      title: key,
      action: /*#__PURE__*/React.createElement(IconButton$1, {
        color: "secondary",
        onClick: function onClick() {
          return slot.remove(key);
        }
      }, /*#__PURE__*/React.createElement(DeleteIcon, null))
    }), /*#__PURE__*/React.createElement(CardContent, null, /*#__PURE__*/React.createElement(StringArrayEditor, {
      slot: {
        value: val,
        description: "Values associated with entry ".concat(key),
        setAtIndex: function setAtIndex(idx, strValue) {
          slot.setAtKeyIndex(key, idx, strValue);
        },
        removeAtIndex: function removeAtIndex(idx) {
          slot.removeAtKeyIndex(key, idx);
        },
        add: function add(strValue) {
          slot.addToKey(key, strValue);
        }
      }
    })));
  }), /*#__PURE__*/React.createElement(Card, {
    raised: true,
    className: classes.card
  }, /*#__PURE__*/React.createElement(CardHeader, {
    disableTypography: true,
    title: /*#__PURE__*/React.createElement(TextField$1, {
      fullWidth: true,
      value: value,
      placeholder: "add new",
      onChange: function onChange(event) {
        return setValue(event.target.value);
      },
      InputProps: {
        endAdornment: /*#__PURE__*/React.createElement(InputAdornment, null, /*#__PURE__*/React.createElement(IconButton$1, {
          disabled: value === '',
          onClick: function onClick() {
            slot.add(value, []);
            setValue('');
          },
          color: "secondary"
        }, /*#__PURE__*/React.createElement(AddIcon, null)))
      }
    })
  })), /*#__PURE__*/React.createElement(FormHelperText$1, null, slot.description));
});
var NumberMapEditor = /*#__PURE__*/observer(function (_ref7) {
  var slot = _ref7.slot;
  var classes = useMapEditorStyles();

  var _useState5 = useState(''),
      _useState6 = _slicedToArray(_useState5, 2),
      value = _useState6[0],
      setValue = _useState6[1];

  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(InputLabel$1, null, slot.name), Array.from(slot.value, function (_ref8) {
    var _ref9 = _slicedToArray(_ref8, 2),
        key = _ref9[0],
        val = _ref9[1];

    return /*#__PURE__*/React.createElement(Card, {
      raised: true,
      key: key,
      className: classes.card
    }, /*#__PURE__*/React.createElement(CardHeader, {
      title: key,
      action: /*#__PURE__*/React.createElement(IconButton$1, {
        color: "secondary",
        onClick: function onClick() {
          return slot.remove(key);
        }
      }, /*#__PURE__*/React.createElement(DeleteIcon, null))
    }), /*#__PURE__*/React.createElement(CardContent, null, /*#__PURE__*/React.createElement(NumberEditor, {
      slot: {
        value: val,
        set: function set(numValue) {
          return slot.add(key, numValue);
        }
      }
    })));
  }), /*#__PURE__*/React.createElement(Card, {
    raised: true,
    className: classes.card
  }, /*#__PURE__*/React.createElement(CardHeader, {
    disableTypography: true,
    title: /*#__PURE__*/React.createElement(TextField$1, {
      fullWidth: true,
      value: value,
      placeholder: "add new",
      onChange: function onChange(event) {
        return setValue(event.target.value);
      },
      InputProps: {
        endAdornment: /*#__PURE__*/React.createElement(InputAdornment, null, /*#__PURE__*/React.createElement(IconButton$1, {
          disabled: value === '',
          onClick: function onClick() {
            slot.add(value, 0);
            setValue('');
          },
          color: "secondary"
        }, /*#__PURE__*/React.createElement(AddIcon, null)))
      }
    })
  })), /*#__PURE__*/React.createElement(FormHelperText$1, null, slot.description));
});
var NumberEditor = /*#__PURE__*/observer(function (_ref10) {
  var slot = _ref10.slot;

  var _useState7 = useState(slot.value),
      _useState8 = _slicedToArray(_useState7, 2),
      val = _useState8[0],
      setVal = _useState8[1];

  useEffect(function () {
    var num = parseFloat(val, 10);

    if (!Number.isNaN(num)) {
      slot.set(num);
    } else {
      slot.reset();
    }
  }, [slot, val]);
  return /*#__PURE__*/React.createElement(TextField$1, {
    label: slot.name,
    helperText: slot.description,
    value: val,
    type: "number",
    onChange: function onChange(evt) {
      return setVal(evt.target.value);
    }
  });
});
var IntegerEditor = /*#__PURE__*/observer(function (_ref11) {
  var slot = _ref11.slot;

  var _useState9 = useState(slot.value),
      _useState10 = _slicedToArray(_useState9, 2),
      val = _useState10[0],
      setVal = _useState10[1];

  useEffect(function () {
    var num = parseInt(val, 10);

    if (!Number.isNaN(num)) {
      slot.set(num);
    }
  }, [slot, val]);
  return /*#__PURE__*/React.createElement(TextField$1, {
    label: slot.name,
    helperText: slot.description,
    value: val,
    type: "number",
    onChange: function onChange(evt) {
      return setVal(evt.target.value);
    }
  });
});
var booleanEditor = /*#__PURE__*/observer(function (_ref12) {
  var slot = _ref12.slot;
  return /*#__PURE__*/React.createElement(FormControl$1, null, /*#__PURE__*/React.createElement(FormControlLabel, {
    label: slot.name,
    control: /*#__PURE__*/React.createElement(Checkbox, {
      checked: slot.value,
      onChange: function onChange(evt) {
        return slot.set(evt.target.checked);
      }
    })
  }), /*#__PURE__*/React.createElement(FormHelperText$1, null, slot.description));
});
var stringEnumEditor = /*#__PURE__*/observer(function (_ref13) {
  var slot = _ref13.slot,
      slotSchema = _ref13.slotSchema;
  var p = getPropertyMembers(getSubType(slotSchema));
  var choices = getUnionSubTypes(getUnionSubTypes(getSubType(getPropertyType(p, 'value')))[1]).map(function (t) {
    return t.value;
  });
  return /*#__PURE__*/React.createElement(TextField$1, {
    value: slot.value,
    label: slot.name,
    select: true // error={filterError}
    ,
    helperText: slot.description,
    fullWidth: true,
    onChange: function onChange(evt) {
      return slot.set(evt.target.value);
    }
  }, choices.map(function (str) {
    return /*#__PURE__*/React.createElement(MenuItem, {
      key: str,
      value: str
    }, str);
  }));
});
var FileSelectorWrapper = /*#__PURE__*/observer(function (_ref14) {
  var slot = _ref14.slot;
  return /*#__PURE__*/React.createElement(FileSelector, {
    location: slot.value,
    setLocation: function setLocation(location) {
      return slot.set(location);
    },
    name: slot.name,
    description: slot.description
  });
});
var valueComponents = {
  string: StringEditor,
  text: TextEditor,
  fileLocation: FileSelectorWrapper,
  stringArray: StringArrayEditor,
  stringArrayMap: StringArrayMapEditor,
  numberMap: NumberMapEditor,
  number: NumberEditor,
  integer: IntegerEditor,
  color: ColorEditor,
  stringEnum: stringEnumEditor,
  "boolean": booleanEditor,
  frozen: JsonEditor$1,
  configRelationships: JsonEditor$1
};
var useSlotEditorStyles = /*#__PURE__*/makeStyles$1(function (theme) {
  return {
    paper: {
      display: 'flex',
      marginBottom: theme.spacing(2),
      position: 'relative',
      overflow: 'visible'
    },
    paperContent: {
      flex: 'auto',
      padding: theme.spacing(1),
      overflow: 'auto'
    },
    slotModeSwitch: {
      width: 24,
      background: theme.palette.secondary.light,
      display: 'flex',
      justifyContent: 'center',
      alignItems: 'center'
    }
  };
});
var SlotEditor = /*#__PURE__*/observer(function (_ref15) {
  var slot = _ref15.slot,
      slotSchema = _ref15.slotSchema;
  var classes = useSlotEditorStyles();
  var type = slot.type;
  var ValueComponent = slot.isCallback ? CallbackEditor$1 : valueComponents[type];

  if (!ValueComponent) {
    console.warn("no slot editor defined for ".concat(type, ", editing as string"));
    ValueComponent = StringEditor;
  }

  if (!(type in valueComponents)) {
    console.warn("SlotEditor needs to implement ".concat(type));
  }

  return /*#__PURE__*/React.createElement(Paper, {
    className: classes.paper
  }, /*#__PURE__*/React.createElement("div", {
    className: classes.paperContent
  }, /*#__PURE__*/React.createElement(ValueComponent, {
    slot: slot,
    slotSchema: slotSchema
  })), /*#__PURE__*/React.createElement("div", {
    className: classes.slotModeSwitch
  }, slot.contextVariable.length ? /*#__PURE__*/React.createElement(IconButton$1, {
    className: classes.slotModeIcon,
    onClick: function onClick() {
      return slot.isCallback ? slot.convertToValue() : slot.convertToCallback();
    },
    title: "convert to ".concat(slot.isCallback ? 'regular value' : 'callback'),
    color: "secondary"
  }, !slot.isCallback ? /*#__PURE__*/React.createElement(RadioButtonUncheckedIcon, null) : /*#__PURE__*/React.createElement(SvgCheckbox, null)) : null));
});

var TypeSelector = /*#__PURE__*/observer(function (_ref) {
  var typeNameChoices = _ref.typeNameChoices,
      slot = _ref.slot,
      slotName = _ref.slotName,
      onChange = _ref.onChange;
  var classes = useSlotEditorStyles();
  return /*#__PURE__*/React.createElement(Paper$1, {
    className: classes.paper
  }, /*#__PURE__*/React.createElement("div", {
    className: classes.paperContent
  }, /*#__PURE__*/React.createElement(TextField, {
    value: slot.type,
    label: "Type",
    select: true // error={filterError}
    ,
    helperText: "Type of ".concat(slotName, " to use"),
    fullWidth: true,
    onChange: onChange
  }, typeNameChoices.map(function (str) {
    return /*#__PURE__*/React.createElement(MenuItem$1, {
      key: str,
      value: str
    }, str);
  }))));
});

var useStyles$3 = /*#__PURE__*/makeStyles(function (theme) {
  return {
    subSchemaContainer: {
      marginLeft: theme.spacing(1),
      borderLeft: "1px solid ".concat(theme.palette.secondary.main),
      paddingLeft: theme.spacing(1),
      marginBottom: theme.spacing(1)
    },
    root: {
      padding: theme.spacing(1, 3, 1, 1),
      background: theme.palette.background["default"],
      overflowX: 'hidden'
    }
  };
});
var Member = /*#__PURE__*/observer(function (props) {
  var classes = useStyles$3();
  var slotName = props.slotName,
      slotSchema = props.slotSchema,
      schema = props.schema,
      _props$slot = props.slot,
      slot = _props$slot === void 0 ? schema[slotName] : _props$slot;
  var typeSelector;

  if (isConfigurationSchemaType(slotSchema)) {
    if (slot.length) {
      return /*#__PURE__*/React.createElement(React.Fragment, null, slot.map(function (subslot, slotIndex) {
        var key = "".concat(singular(slotName), " ").concat(slotIndex + 1);
        return /*#__PURE__*/React.createElement(Member, _extends({}, props, {
          key: key,
          slot: subslot,
          slotName: key
        }));
      }));
    } // if this is an explicitly typed schema, make a type-selecting dropdown
    // that can be used to change its type


    var typeNameChoices = getTypeNamesFromExplicitlyTypedUnion(slotSchema);

    if (typeNameChoices.length) {
      typeSelector = /*#__PURE__*/React.createElement(TypeSelector, {
        typeNameChoices: typeNameChoices,
        slotName: slotName,
        slot: slot,
        onChange: function onChange(evt) {
          if (evt.target.value !== slot.type) {
            schema.setSubschema(slotName, {
              type: evt.target.value
            });
          }
        }
      });
    }

    return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(FormLabel, null, slotName), /*#__PURE__*/React.createElement("div", {
      className: classes.subSchemaContainer
    }, typeSelector, /*#__PURE__*/React.createElement(FormGroup, null, /*#__PURE__*/React.createElement(Schema, {
      schema: slot
    }))));
  }

  if (isConfigurationSlotType(slotSchema)) {
    // this is a regular config slot
    return /*#__PURE__*/React.createElement(SlotEditor, {
      key: slotName,
      slot: slot,
      slotSchema: slotSchema
    });
  }

  return null;
});
var Schema = /*#__PURE__*/observer(function (_ref) {
  var schema = _ref.schema;
  return iterMap(Object.entries(getMembers(schema).properties), function (_ref2) {
    var _ref3 = _slicedToArray(_ref2, 2),
        slotName = _ref3[0],
        slotSchema = _ref3[1];

    return /*#__PURE__*/React.createElement(Member, {
      key: slotName,
      slotName: slotName,
      slotSchema: slotSchema,
      schema: schema
    });
  });
});
var ConfigurationEditor = /*#__PURE__*/observer(function (_ref4) {
  var model = _ref4.model;
  var classes = useStyles$3(); // key forces a re-render, otherwise the same field can end up being used
  // for different tracks since only the backing model changes for example
  // see pr #804

  var key = model.target && readConfObject(model.target, 'trackId');
  return /*#__PURE__*/React.createElement("div", {
    className: classes.root,
    key: key,
    "data-testid": "configEditor"
  }, !model.target ? 'no target set' : /*#__PURE__*/React.createElement(Schema, {
    schema: model.target
  }));
});

var ConfigurationEditor$1 = {
  __proto__: null,
  'default': ConfigurationEditor
};

export default _default;
export { ConfigurationEditorComponent as ConfigurationEditor, JsonEditor$1 as JsonEditor };
//# sourceMappingURL=plugin-config.esm.js.map
