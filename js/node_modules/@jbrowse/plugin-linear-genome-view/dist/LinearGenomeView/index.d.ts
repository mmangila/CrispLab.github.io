import { Region } from '@jbrowse/core/util/types';
import { MenuItem } from '@jbrowse/core/ui';
import BaseResult from '@jbrowse/core/TextSearch/BaseResults';
import { BlockSet, BaseBlock } from '@jbrowse/core/util/blockTypes';
import { Instance } from 'mobx-state-tree';
import PluginManager from '@jbrowse/core/PluginManager';
import { renderToSvg } from './components/LinearGenomeView';
export { default as ReactComponent } from './components/LinearGenomeView';
export interface BpOffset {
    refName?: string;
    index: number;
    offset: number;
    start?: number;
    end?: number;
    coord?: number;
    reversed?: boolean;
    assemblyName?: string;
    oob?: boolean;
}
export interface ExportSvgOptions {
    rasterizeLayers?: boolean;
}
export interface NavLocation {
    refName: string;
    start?: number;
    end?: number;
    assemblyName?: string;
}
export declare const HEADER_BAR_HEIGHT = 48;
export declare const HEADER_OVERVIEW_HEIGHT = 20;
export declare const SCALE_BAR_HEIGHT = 17;
export declare const RESIZE_HANDLE_HEIGHT = 3;
export declare const INTER_REGION_PADDING_WIDTH = 2;
export declare function stateModelFactory(pluginManager: PluginManager): import("mobx-state-tree").IModelType<{
    id: import("mobx-state-tree").IOptionalIType<import("mobx-state-tree").ISimpleType<string>, [undefined]>;
    displayName: import("mobx-state-tree").IMaybe<import("mobx-state-tree").ISimpleType<string>>;
} & {
    id: import("mobx-state-tree").IOptionalIType<import("mobx-state-tree").ISimpleType<string>, [undefined]>;
    type: import("mobx-state-tree").ISimpleType<"LinearGenomeView">;
    offsetPx: import("mobx-state-tree").IType<number | undefined, number, number>;
    bpPerPx: import("mobx-state-tree").IType<number | undefined, number, number>;
    displayedRegions: import("mobx-state-tree").IArrayType<import("mobx-state-tree").IModelType<{
        refName: import("mobx-state-tree").ISimpleType<string>;
        start: import("mobx-state-tree").ISimpleType<number>;
        end: import("mobx-state-tree").ISimpleType<number>;
        reversed: import("mobx-state-tree").IOptionalIType<import("mobx-state-tree").ISimpleType<boolean>, [undefined]>;
    } & {
        assemblyName: import("mobx-state-tree").ISimpleType<string>;
    }, {
        setRefName(newRefName: string): void;
    }, import("mobx-state-tree")._NotCustomized, import("mobx-state-tree")._NotCustomized>>;
    tracks: import("mobx-state-tree").IArrayType<import("mobx-state-tree").IAnyType>;
    hideHeader: import("mobx-state-tree").IType<boolean | undefined, boolean, boolean>;
    hideHeaderOverview: import("mobx-state-tree").IType<boolean | undefined, boolean, boolean>;
    trackSelectorType: import("mobx-state-tree").IOptionalIType<import("mobx-state-tree").ISimpleType<"hierarchical">, [undefined]>;
    trackLabels: import("mobx-state-tree").IType<string | undefined, string, string>;
    showCenterLine: import("mobx-state-tree").IType<boolean | undefined, boolean, boolean>;
}, {
    width: number;
} & {
    readonly menuItems: MenuItem[];
} & {
    setDisplayName(name: string): void;
    setWidth(newWidth: number): void;
} & {
    volatileWidth: number | undefined;
    minimumBlockWidth: number;
    draggingTrackId: string | undefined;
    error: Error | undefined;
    afterDisplayedRegionsSetCallbacks: Function[];
    scaleFactor: number;
    trackRefs: {
        [key: string]: any;
    };
    coarseDynamicBlocks: BaseBlock[];
    coarseTotalBp: number;
    leftOffset: BpOffset | undefined;
    rightOffset: BpOffset | undefined;
    searchResults: BaseResult[] | undefined;
    searchQuery: string | undefined;
} & {
    readonly width: number;
} & {
    readonly initialized: boolean;
    readonly hasDisplayedRegions: boolean;
    readonly isSeqDialogDisplayed: BpOffset | undefined;
    readonly isSearchDialogDisplayed: boolean;
    readonly scaleBarHeight: number;
    readonly headerHeight: number;
    readonly trackHeights: any;
    readonly trackHeightsWithResizeHandles: any;
    readonly height: any;
    readonly interRegionPaddingWidth: number;
    readonly totalBp: number;
    readonly maxBpPerPx: number;
    readonly minBpPerPx: number;
    readonly maxOffset: number;
    readonly minOffset: number;
    readonly displayedRegionsTotalPx: number;
    readonly renderProps: any;
    readonly assemblyNames: string[];
    searchScope(assemblyName: string): {
        assemblyName: string;
        includeAggregateIndexes: boolean;
        tracks: import("mobx-state-tree").IMSTArray<import("mobx-state-tree").IAnyType> & import("mobx-state-tree").IStateTreeNode<import("mobx-state-tree").IArrayType<import("mobx-state-tree").IAnyType>>;
    };
    /**
     * @param refName - refName of the displayedRegion
     * @param coord - coordinate at the displayed Region
     * @param regionNumber - optional param used as identifier when
     * there are multiple displayedRegions with the same refName
     * @returns offsetPx of the displayed region that it lands in
     */
    bpToPx({ refName, coord, regionNumber, }: {
        refName: string;
        coord: number;
        regionNumber?: number | undefined;
    }): {
        index: number;
        offsetPx: number;
    } | undefined;
    /**
     *
     * @param px - px in the view area, return value is the displayed regions
     * @returns BpOffset of the displayed region that it lands in
     */
    pxToBp(px: number): {
        oob: boolean;
        coord: number;
        offset: number;
        index: number;
        refName: string;
        start: number;
        end: number;
        reversed: boolean;
        assemblyName: string;
    };
    getTrack(id: string): any;
    rankSearchResults(results: BaseResult[]): BaseResult[];
    rewriteOnClicks(trackType: string, viewMenuActions: MenuItem[]): void;
    readonly trackTypeActions: Map<string, MenuItem[]>;
    readonly centerLineInfo: {
        oob: boolean;
        coord: number;
        offset: number;
        index: number;
        refName: string;
        start: number;
        end: number;
        reversed: boolean;
        assemblyName: string;
    } | undefined;
} & {
    setWidth(newWidth: number): void;
    setError(error: Error | undefined): void;
    toggleHeader(): void;
    toggleHeaderOverview(): void;
    scrollTo(offsetPx: number): number;
    zoomTo(bpPerPx: number): number;
    setOffsets(left: undefined | BpOffset, right: undefined | BpOffset): void;
    setSearchResults(results: BaseResult[] | undefined, query: string | undefined): void;
    setNewView(bpPerPx: number, offsetPx: number): void;
    horizontallyFlip(): void;
    showTrack(trackId: string, initialSnapshot?: {}, displayInitialSnapshot?: {}): any;
    hideTrack(trackId: string): number;
} & {
    moveTrack(movingTrackId: string, targetTrackId: string): void;
    closeView(): void;
    toggleTrack(trackId: string): void;
    setTrackLabels(setting: 'overlapping' | 'offset' | 'hidden'): void;
    toggleCenterLine(): void;
    setDisplayedRegions(regions: Region[]): void;
    activateTrackSelector(): void;
    navToLocString(locString: string, optAssemblyName?: string | undefined): void;
    /**
     * Navigate to a location based on its refName and optionally start, end,
     * and assemblyName. Can handle if there are multiple displayedRegions
     * from same refName. Only navigates to a location if it is entirely
     * within a displayedRegion. Navigates to the first matching location
     * encountered.
     *
     * Throws an error if navigation was unsuccessful
     *
     * @param location - a proposed location to navigate to
     */
    navTo(query: NavLocation): void;
    navToMultiple(locations: NavLocation[]): void;
    /**
     * Navigate to a location based on user clicking and dragging on the
     * overview scale bar to select a region to zoom into.
     * Can handle if there are multiple displayedRegions from same refName.
     * Only navigates to a location if it is entirely within a displayedRegion.
     *
     * @param leftPx- `object as {start, end, index, offset}`, offset = start of user drag
     * @param rightPx- `object as {start, end, index, offset}`, offset = end of user drag
     */
    zoomToDisplayedRegions(leftPx: BpOffset, rightPx: BpOffset): void;
    /**
     * Helper method for the fetchSequence.
     * Retrieves the corresponding regions that were selected by the rubberband
     *
     * @param leftOffset - `object as {start, end, index, offset}`, offset = start of user drag
     * @param rightOffset - `object as {start, end, index, offset}`, offset = end of user drag
     * @returns array of Region[]
     */
    getSelectedRegions(leftOffset: BpOffset | undefined, rightOffset: BpOffset | undefined): {
        start: number;
        end: number;
        refName: string;
        assemblyName: string;
        key: string;
        offsetPx: number;
    }[];
    afterDisplayedRegionsSet(cb: Function): void;
    /**
     * offset is the base-pair-offset in the displayed region, index is the index of the
     * displayed region in the linear genome view
     *
     * @param start - object as `{start, end, offset, index}`
     * @param end - object as `{start, end, offset, index}`
     */
    moveTo(start: BpOffset, end: BpOffset): void;
    horizontalScroll(distance: number): number;
    /**
     * scrolls the view to center on the given bp. if that is not in any
     * of the displayed regions, does nothing
     * @param bp - basepair at which you want to center the view
     * @param refName - refName of the displayedRegion you are centering at
     * @param regionIndex - index of the displayedRegion
     */
    centerAt(bp: number, refName: string, regionIndex: number): void;
    center(): void;
    showAllRegions(): void;
    showAllRegionsInAssembly(assemblyName?: string | undefined): void;
    setDraggingTrackId(idx?: string | undefined): void;
    setScaleFactor(factor: number): void;
} & {
    slide: (viewWidths: number) => void;
} & {
    zoom: (targetBpPerPx: number) => void;
} & {
    readonly menuItems: MenuItem[];
    readonly staticBlocks: BlockSet;
    readonly dynamicBlocks: BlockSet;
    readonly roundedDynamicBlocks: {
        start: number;
        end: number;
        refName: string;
        assemblyName: string;
        key: string;
        offsetPx: number;
    }[];
    readonly visibleLocStrings: string;
    readonly coarseVisibleLocStrings: string;
} & {
    clearView(): void;
    setCoarseDynamicBlocks(blocks: BlockSet): void;
    afterAttach(): void;
} & {
    exportSvg(opts?: ExportSvgOptions): Promise<void>;
}, import("mobx-state-tree")._NotCustomized, import("mobx-state-tree")._NotCustomized>;
export { renderToSvg };
export declare type LinearGenomeViewStateModel = ReturnType<typeof stateModelFactory>;
export declare type LinearGenomeViewModel = Instance<LinearGenomeViewStateModel>;
