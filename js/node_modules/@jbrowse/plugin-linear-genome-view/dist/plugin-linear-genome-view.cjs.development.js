'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var React = require('react');
var React__default = _interopDefault(React);
var configuration = require('@jbrowse/core/configuration');
var models = require('@jbrowse/core/pluggableElementTypes/models');
var TrackType = _interopDefault(require('@jbrowse/core/pluggableElementTypes/TrackType'));
var DisplayType = _interopDefault(require('@jbrowse/core/pluggableElementTypes/DisplayType'));
var ViewType = _interopDefault(require('@jbrowse/core/pluggableElementTypes/ViewType'));
var Plugin = _interopDefault(require('@jbrowse/core/Plugin'));
var util = require('@jbrowse/core/util');
var LineStyleIcon = _interopDefault(require('@material-ui/icons/LineStyle'));
var CompositeMap = _interopDefault(require('@jbrowse/core/util/compositeMap'));
var simpleFeature = require('@jbrowse/core/util/simpleFeature');
var tracks = require('@jbrowse/core/util/tracks');
var Button = _interopDefault(require('@material-ui/core/Button'));
var Typography = _interopDefault(require('@material-ui/core/Typography'));
var MenuOpenIcon = _interopDefault(require('@material-ui/icons/MenuOpen'));
var mobx = require('mobx');
var mobxStateTree = require('mobx-state-tree');
var ui = require('@jbrowse/core/ui');
var styles = require('@material-ui/core/styles');
var mobxReact = require('mobx-react');
var Tooltip$1 = _interopDefault(require('@material-ui/core/Tooltip'));
var blockTypes = require('@jbrowse/core/util/blockTypes');
var mst = require('@jbrowse/core/util/types/mst');
var RefreshIcon = _interopDefault(require('@material-ui/icons/Refresh'));
var configurationSchema = require('@jbrowse/core/configuration/configurationSchema');
var calculateDynamicBlocks = _interopDefault(require('@jbrowse/core/util/calculateDynamicBlocks'));
var calculateStaticBlocks = _interopDefault(require('@jbrowse/core/util/calculateStaticBlocks'));
var Base1DView = _interopDefault(require('@jbrowse/core/util/Base1DViewModel'));
var Icons = require('@jbrowse/core/ui/Icons');
var SyncAltIcon = _interopDefault(require('@material-ui/icons/SyncAlt'));
var VisibilityIcon = _interopDefault(require('@material-ui/icons/Visibility'));
var LabelIcon = _interopDefault(require('@material-ui/icons/Label'));
var FolderOpenIcon = _interopDefault(require('@material-ui/icons/FolderOpen'));
var clone = _interopDefault(require('clone'));
var fileSaver = require('file-saver');
var server = require('react-dom/server');
var core = require('@material-ui/core');
var colorManipulator = require('@material-ui/core/styles/colorManipulator');
var FormGroup = _interopDefault(require('@material-ui/core/FormGroup'));
var ArrowForwardIcon = _interopDefault(require('@material-ui/icons/ArrowForward'));
var ArrowBackIcon = _interopDefault(require('@material-ui/icons/ArrowBack'));
var BaseResult = require('@jbrowse/core/TextSearch/BaseResults');
var BaseResult__default = _interopDefault(BaseResult);
var CircularProgress = _interopDefault(require('@material-ui/core/CircularProgress'));
var TextField = _interopDefault(require('@material-ui/core/TextField'));
var SearchIcon = _interopDefault(require('@material-ui/icons/Search'));
var Autocomplete = require('@material-ui/lab/Autocomplete');
var Autocomplete__default = _interopDefault(Autocomplete);
var LinearProgress = _interopDefault(require('@material-ui/core/LinearProgress'));
var clsx = _interopDefault(require('clsx'));
var Popover = _interopDefault(require('@material-ui/core/Popover'));
var ReactPropTypes = _interopDefault(require('prop-types'));
var IconButton = _interopDefault(require('@material-ui/core/IconButton'));
var Slider = _interopDefault(require('@material-ui/core/Slider'));
var ZoomIn = _interopDefault(require('@material-ui/icons/ZoomIn'));
var ZoomOut = _interopDefault(require('@material-ui/icons/ZoomOut'));
var Paper = _interopDefault(require('@material-ui/core/Paper'));
var MoreVertIcon = _interopDefault(require('@material-ui/icons/MoreVert'));
var DragIcon = _interopDefault(require('@material-ui/icons/DragIndicator'));
var CloseIcon = _interopDefault(require('@material-ui/icons/Close'));
var normalizeWheel = _interopDefault(require('normalize-wheel'));
var Container = _interopDefault(require('@material-ui/core/Container'));
var Grid = _interopDefault(require('@material-ui/core/Grid'));
var MenuItem = _interopDefault(require('@material-ui/core/MenuItem'));
var ArrowDown = _interopDefault(require('@material-ui/icons/KeyboardArrowDown'));
var Menu = _interopDefault(require('@jbrowse/core/ui/Menu'));
var copy = _interopDefault(require('copy-to-clipboard'));
var GetAppIcon = _interopDefault(require('@material-ui/icons/GetApp'));
var formatFastaStrings = require('@jbrowse/core/util/formatFastaStrings');

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

function _iterableToArrayLimit(arr, i) {
  var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;

      var F = function () {};

      return {
        s: F,
        n: function () {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function (e) {
          throw e;
        },
        f: F
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var normalCompletion = true,
      didErr = false,
      err;
  return {
    s: function () {
      it = it.call(o);
    },
    n: function () {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function (e) {
      didErr = true;
      err = e;
    },
    f: function () {
      try {
        if (!normalCompletion && it.return != null) it.return();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}

var baseLinearDisplayConfigSchema = /*#__PURE__*/configuration.ConfigurationSchema('BaseLinearDisplay', {
  maxDisplayedBpPerPx: {
    type: 'number',
    description: 'maximum bpPerPx that is displayed in the view',
    defaultValue: Number.MAX_VALUE
  }
}, {
  explicitIdentifier: 'displayId'
});

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var runtime_1 = /*#__PURE__*/createCommonjsModule(function (module) {
  /**
   * Copyright (c) 2014-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var runtime = function (exports) {

    var Op = Object.prototype;
    var hasOwn = Op.hasOwnProperty;
    var undefined$1; // More compressible than void 0.

    var $Symbol = typeof Symbol === "function" ? Symbol : {};
    var iteratorSymbol = $Symbol.iterator || "@@iterator";
    var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
    var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

    function define(obj, key, value) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
      return obj[key];
    }

    try {
      // IE 8 has a broken Object.defineProperty that only works on DOM objects.
      define({}, "");
    } catch (err) {
      define = function define(obj, key, value) {
        return obj[key] = value;
      };
    }

    function wrap(innerFn, outerFn, self, tryLocsList) {
      // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
      var generator = Object.create(protoGenerator.prototype);
      var context = new Context(tryLocsList || []); // The ._invoke method unifies the implementations of the .next,
      // .throw, and .return methods.

      generator._invoke = makeInvokeMethod(innerFn, self, context);
      return generator;
    }

    exports.wrap = wrap; // Try/catch helper to minimize deoptimizations. Returns a completion
    // record like context.tryEntries[i].completion. This interface could
    // have been (and was previously) designed to take a closure to be
    // invoked without arguments, but in all the cases we care about we
    // already have an existing method we want to call, so there's no need
    // to create a new function object. We can even get away with assuming
    // the method takes exactly one argument, since that happens to be true
    // in every case, so we don't have to touch the arguments object. The
    // only additional allocation required is the completion record, which
    // has a stable shape and so hopefully should be cheap to allocate.

    function tryCatch(fn, obj, arg) {
      try {
        return {
          type: "normal",
          arg: fn.call(obj, arg)
        };
      } catch (err) {
        return {
          type: "throw",
          arg: err
        };
      }
    }

    var GenStateSuspendedStart = "suspendedStart";
    var GenStateSuspendedYield = "suspendedYield";
    var GenStateExecuting = "executing";
    var GenStateCompleted = "completed"; // Returning this object from the innerFn has the same effect as
    // breaking out of the dispatch switch statement.

    var ContinueSentinel = {}; // Dummy constructor functions that we use as the .constructor and
    // .constructor.prototype properties for functions that return Generator
    // objects. For full spec compliance, you may wish to configure your
    // minifier not to mangle the names of these two functions.

    function Generator() {}

    function GeneratorFunction() {}

    function GeneratorFunctionPrototype() {} // This is a polyfill for %IteratorPrototype% for environments that
    // don't natively support it.


    var IteratorPrototype = {};

    IteratorPrototype[iteratorSymbol] = function () {
      return this;
    };

    var getProto = Object.getPrototypeOf;
    var NativeIteratorPrototype = getProto && getProto(getProto(values([])));

    if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
      // This environment has a native %IteratorPrototype%; use it instead
      // of the polyfill.
      IteratorPrototype = NativeIteratorPrototype;
    }

    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
    GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
    GeneratorFunctionPrototype.constructor = GeneratorFunction;
    GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"); // Helper for defining the .next, .throw, and .return methods of the
    // Iterator interface in terms of a single ._invoke method.

    function defineIteratorMethods(prototype) {
      ["next", "throw", "return"].forEach(function (method) {
        define(prototype, method, function (arg) {
          return this._invoke(method, arg);
        });
      });
    }

    exports.isGeneratorFunction = function (genFun) {
      var ctor = typeof genFun === "function" && genFun.constructor;
      return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can
      // do is to check its .name property.
      (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
    };

    exports.mark = function (genFun) {
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
      } else {
        genFun.__proto__ = GeneratorFunctionPrototype;
        define(genFun, toStringTagSymbol, "GeneratorFunction");
      }

      genFun.prototype = Object.create(Gp);
      return genFun;
    }; // Within the body of any async function, `await x` is transformed to
    // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
    // `hasOwn.call(value, "__await")` to determine if the yielded value is
    // meant to be awaited.


    exports.awrap = function (arg) {
      return {
        __await: arg
      };
    };

    function AsyncIterator(generator, PromiseImpl) {
      function invoke(method, arg, resolve, reject) {
        var record = tryCatch(generator[method], generator, arg);

        if (record.type === "throw") {
          reject(record.arg);
        } else {
          var result = record.arg;
          var value = result.value;

          if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
            return PromiseImpl.resolve(value.__await).then(function (value) {
              invoke("next", value, resolve, reject);
            }, function (err) {
              invoke("throw", err, resolve, reject);
            });
          }

          return PromiseImpl.resolve(value).then(function (unwrapped) {
            // When a yielded Promise is resolved, its final value becomes
            // the .value of the Promise<{value,done}> result for the
            // current iteration.
            result.value = unwrapped;
            resolve(result);
          }, function (error) {
            // If a rejected Promise was yielded, throw the rejection back
            // into the async generator function so it can be handled there.
            return invoke("throw", error, resolve, reject);
          });
        }
      }

      var previousPromise;

      function enqueue(method, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function (resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }

        return previousPromise = // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later
        // invocations of the iterator.
        callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      } // Define the unified helper method that is used to implement .next,
      // .throw, and .return (see defineIteratorMethods).


      this._invoke = enqueue;
    }

    defineIteratorMethods(AsyncIterator.prototype);

    AsyncIterator.prototype[asyncIteratorSymbol] = function () {
      return this;
    };

    exports.AsyncIterator = AsyncIterator; // Note that simple async functions are implemented on top of
    // AsyncIterator objects; they just return a Promise for the value of
    // the final result produced by the iterator.

    exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
      if (PromiseImpl === void 0) PromiseImpl = Promise;
      var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
      return exports.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function (result) {
        return result.done ? result.value : iter.next();
      });
    };

    function makeInvokeMethod(innerFn, self, context) {
      var state = GenStateSuspendedStart;
      return function invoke(method, arg) {
        if (state === GenStateExecuting) {
          throw new Error("Generator is already running");
        }

        if (state === GenStateCompleted) {
          if (method === "throw") {
            throw arg;
          } // Be forgiving, per 25.3.3.3.3 of the spec:
          // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume


          return doneResult();
        }

        context.method = method;
        context.arg = arg;

        while (true) {
          var delegate = context.delegate;

          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context);

            if (delegateResult) {
              if (delegateResult === ContinueSentinel) continue;
              return delegateResult;
            }
          }

          if (context.method === "next") {
            // Setting context._sent for legacy support of Babel's
            // function.sent implementation.
            context.sent = context._sent = context.arg;
          } else if (context.method === "throw") {
            if (state === GenStateSuspendedStart) {
              state = GenStateCompleted;
              throw context.arg;
            }

            context.dispatchException(context.arg);
          } else if (context.method === "return") {
            context.abrupt("return", context.arg);
          }

          state = GenStateExecuting;
          var record = tryCatch(innerFn, self, context);

          if (record.type === "normal") {
            // If an exception is thrown from innerFn, we leave state ===
            // GenStateExecuting and loop back for another invocation.
            state = context.done ? GenStateCompleted : GenStateSuspendedYield;

            if (record.arg === ContinueSentinel) {
              continue;
            }

            return {
              value: record.arg,
              done: context.done
            };
          } else if (record.type === "throw") {
            state = GenStateCompleted; // Dispatch the exception by looping back around to the
            // context.dispatchException(context.arg) call above.

            context.method = "throw";
            context.arg = record.arg;
          }
        }
      };
    } // Call delegate.iterator[context.method](context.arg) and handle the
    // result, either by returning a { value, done } result from the
    // delegate iterator, or by modifying context.method and context.arg,
    // setting context.delegate to null, and returning the ContinueSentinel.


    function maybeInvokeDelegate(delegate, context) {
      var method = delegate.iterator[context.method];

      if (method === undefined$1) {
        // A .throw or .return when the delegate iterator has no .throw
        // method always terminates the yield* loop.
        context.delegate = null;

        if (context.method === "throw") {
          // Note: ["return"] must be used for ES3 parsing compatibility.
          if (delegate.iterator["return"]) {
            // If the delegate iterator has a return method, give it a
            // chance to clean up.
            context.method = "return";
            context.arg = undefined$1;
            maybeInvokeDelegate(delegate, context);

            if (context.method === "throw") {
              // If maybeInvokeDelegate(context) changed context.method from
              // "return" to "throw", let that override the TypeError below.
              return ContinueSentinel;
            }
          }

          context.method = "throw";
          context.arg = new TypeError("The iterator does not provide a 'throw' method");
        }

        return ContinueSentinel;
      }

      var record = tryCatch(method, delegate.iterator, context.arg);

      if (record.type === "throw") {
        context.method = "throw";
        context.arg = record.arg;
        context.delegate = null;
        return ContinueSentinel;
      }

      var info = record.arg;

      if (!info) {
        context.method = "throw";
        context.arg = new TypeError("iterator result is not an object");
        context.delegate = null;
        return ContinueSentinel;
      }

      if (info.done) {
        // Assign the result of the finished delegate to the temporary
        // variable specified by delegate.resultName (see delegateYield).
        context[delegate.resultName] = info.value; // Resume execution at the desired location (see delegateYield).

        context.next = delegate.nextLoc; // If context.method was "throw" but the delegate handled the
        // exception, let the outer generator proceed normally. If
        // context.method was "next", forget context.arg since it has been
        // "consumed" by the delegate iterator. If context.method was
        // "return", allow the original .return call to continue in the
        // outer generator.

        if (context.method !== "return") {
          context.method = "next";
          context.arg = undefined$1;
        }
      } else {
        // Re-yield the result returned by the delegate method.
        return info;
      } // The delegate iterator is finished, so forget it and continue with
      // the outer generator.


      context.delegate = null;
      return ContinueSentinel;
    } // Define Generator.prototype.{next,throw,return} in terms of the
    // unified ._invoke helper method.


    defineIteratorMethods(Gp);
    define(Gp, toStringTagSymbol, "Generator"); // A Generator should always return itself as the iterator object when the
    // @@iterator function is called on it. Some browsers' implementations of the
    // iterator prototype chain incorrectly implement this, causing the Generator
    // object to not be returned from this call. This ensures that doesn't happen.
    // See https://github.com/facebook/regenerator/issues/274 for more details.

    Gp[iteratorSymbol] = function () {
      return this;
    };

    Gp.toString = function () {
      return "[object Generator]";
    };

    function pushTryEntry(locs) {
      var entry = {
        tryLoc: locs[0]
      };

      if (1 in locs) {
        entry.catchLoc = locs[1];
      }

      if (2 in locs) {
        entry.finallyLoc = locs[2];
        entry.afterLoc = locs[3];
      }

      this.tryEntries.push(entry);
    }

    function resetTryEntry(entry) {
      var record = entry.completion || {};
      record.type = "normal";
      delete record.arg;
      entry.completion = record;
    }

    function Context(tryLocsList) {
      // The root entry object (effectively a try statement without a catch
      // or a finally block) gives us a place to store values thrown from
      // locations where there is no enclosing try statement.
      this.tryEntries = [{
        tryLoc: "root"
      }];
      tryLocsList.forEach(pushTryEntry, this);
      this.reset(true);
    }

    exports.keys = function (object) {
      var keys = [];

      for (var key in object) {
        keys.push(key);
      }

      keys.reverse(); // Rather than returning an object with a next method, we keep
      // things simple and return the next function itself.

      return function next() {
        while (keys.length) {
          var key = keys.pop();

          if (key in object) {
            next.value = key;
            next.done = false;
            return next;
          }
        } // To avoid creating an additional object, we just hang the .value
        // and .done properties off the next function object itself. This
        // also ensures that the minifier will not anonymize the function.


        next.done = true;
        return next;
      };
    };

    function values(iterable) {
      if (iterable) {
        var iteratorMethod = iterable[iteratorSymbol];

        if (iteratorMethod) {
          return iteratorMethod.call(iterable);
        }

        if (typeof iterable.next === "function") {
          return iterable;
        }

        if (!isNaN(iterable.length)) {
          var i = -1,
              next = function next() {
            while (++i < iterable.length) {
              if (hasOwn.call(iterable, i)) {
                next.value = iterable[i];
                next.done = false;
                return next;
              }
            }

            next.value = undefined$1;
            next.done = true;
            return next;
          };

          return next.next = next;
        }
      } // Return an iterator with no values.


      return {
        next: doneResult
      };
    }

    exports.values = values;

    function doneResult() {
      return {
        value: undefined$1,
        done: true
      };
    }

    Context.prototype = {
      constructor: Context,
      reset: function reset(skipTempReset) {
        this.prev = 0;
        this.next = 0; // Resetting context._sent for legacy support of Babel's
        // function.sent implementation.

        this.sent = this._sent = undefined$1;
        this.done = false;
        this.delegate = null;
        this.method = "next";
        this.arg = undefined$1;
        this.tryEntries.forEach(resetTryEntry);

        if (!skipTempReset) {
          for (var name in this) {
            // Not sure about the optimal order of these conditions:
            if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
              this[name] = undefined$1;
            }
          }
        }
      },
      stop: function stop() {
        this.done = true;
        var rootEntry = this.tryEntries[0];
        var rootRecord = rootEntry.completion;

        if (rootRecord.type === "throw") {
          throw rootRecord.arg;
        }

        return this.rval;
      },
      dispatchException: function dispatchException(exception) {
        if (this.done) {
          throw exception;
        }

        var context = this;

        function handle(loc, caught) {
          record.type = "throw";
          record.arg = exception;
          context.next = loc;

          if (caught) {
            // If the dispatched exception was caught by a catch block,
            // then let that catch block handle the exception normally.
            context.method = "next";
            context.arg = undefined$1;
          }

          return !!caught;
        }

        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          var record = entry.completion;

          if (entry.tryLoc === "root") {
            // Exception thrown outside of any try block that could handle
            // it, so set the completion value of the entire function to
            // throw the exception.
            return handle("end");
          }

          if (entry.tryLoc <= this.prev) {
            var hasCatch = hasOwn.call(entry, "catchLoc");
            var hasFinally = hasOwn.call(entry, "finallyLoc");

            if (hasCatch && hasFinally) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              } else if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }
            } else if (hasCatch) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              }
            } else if (hasFinally) {
              if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }
            } else {
              throw new Error("try statement without catch or finally");
            }
          }
        }
      },
      abrupt: function abrupt(type, arg) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];

          if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
            var finallyEntry = entry;
            break;
          }
        }

        if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
          // Ignore the finally entry if control is not jumping to a
          // location outside the try/catch block.
          finallyEntry = null;
        }

        var record = finallyEntry ? finallyEntry.completion : {};
        record.type = type;
        record.arg = arg;

        if (finallyEntry) {
          this.method = "next";
          this.next = finallyEntry.finallyLoc;
          return ContinueSentinel;
        }

        return this.complete(record);
      },
      complete: function complete(record, afterLoc) {
        if (record.type === "throw") {
          throw record.arg;
        }

        if (record.type === "break" || record.type === "continue") {
          this.next = record.arg;
        } else if (record.type === "return") {
          this.rval = this.arg = record.arg;
          this.method = "return";
          this.next = "end";
        } else if (record.type === "normal" && afterLoc) {
          this.next = afterLoc;
        }

        return ContinueSentinel;
      },
      finish: function finish(finallyLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];

          if (entry.finallyLoc === finallyLoc) {
            this.complete(entry.completion, entry.afterLoc);
            resetTryEntry(entry);
            return ContinueSentinel;
          }
        }
      },
      "catch": function _catch(tryLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];

          if (entry.tryLoc === tryLoc) {
            var record = entry.completion;

            if (record.type === "throw") {
              var thrown = record.arg;
              resetTryEntry(entry);
            }

            return thrown;
          }
        } // The context.catch method must only be called with a location
        // argument that corresponds to a known catch block.


        throw new Error("illegal catch attempt");
      },
      delegateYield: function delegateYield(iterable, resultName, nextLoc) {
        this.delegate = {
          iterator: values(iterable),
          resultName: resultName,
          nextLoc: nextLoc
        };

        if (this.method === "next") {
          // Deliberately forget the last sent value so that we don't
          // accidentally pass it on to the delegate.
          this.arg = undefined$1;
        }

        return ContinueSentinel;
      }
    }; // Regardless of whether this script is executing as a CommonJS module
    // or not, return the runtime object so that we can declare the variable
    // regeneratorRuntime in the outer scope, which allows this module to be
    // injected easily by `bin/regenerator --include-runtime script.js`.

    return exports;
  }( // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
   module.exports );

  try {
    regeneratorRuntime = runtime;
  } catch (accidentalStrictMode) {
    // This module should not be running in strict mode, so the above
    // assignment should always work unless something is misconfigured. Just
    // in case runtime.js accidentally runs in strict mode, we can escape
    // strict mode using a global Function call. This could conceivably fail
    // if a Content Security Policy forbids using Function, but in that case
    // the proper solution is to fix the accidental strict mode problem. If
    // you've misconfigured your bundler to force strict mode and applied a
    // CSP to forbid Function, and you're not willing to fix either of those
    // problems, please detail your unique predicament in a GitHub issue.
    Function("r", "regeneratorRuntime = r")(runtime);
  }
});

var useStyles = /*#__PURE__*/styles.makeStyles(function (theme) {
  return {
    contentBlock: {
      position: 'relative',
      minHeight: '100%',
      boxSizing: 'border-box',
      whiteSpace: 'nowrap',
      overflow: 'hidden'
    },
    elidedBlock: {
      minHeight: '100%',
      boxSizing: 'border-box',
      backgroundColor: '#999',
      backgroundImage: 'repeating-linear-gradient(90deg, transparent, transparent 1px, rgba(255,255,255,.5) 1px, rgba(255,255,255,.5) 3px)'
    },
    interRegionPaddingBlock: {
      minHeight: '100%',
      backgroundColor: theme.palette.text.primary
    },
    boundaryPaddingBlock: {
      minHeight: '100%',
      backgroundColor: theme.palette.action.disabledBackground
    }
  };
});
var ContentBlock = /*#__PURE__*/mobxReact.observer(function (_ref) {
  var block = _ref.block,
      children = _ref.children;
  var classes = useStyles();
  return /*#__PURE__*/React__default.createElement("div", {
    style: {
      width: "".concat(block.widthPx, "px")
    },
    className: classes.contentBlock
  }, children);
});

function ElidedBlock(_ref2) {
  var width = _ref2.width;
  var classes = useStyles();
  return /*#__PURE__*/React__default.createElement("div", {
    className: classes.elidedBlock,
    style: {
      width: "".concat(width, "px")
    }
  });
}

function InterRegionPaddingBlock(_ref3) {
  var boundary = _ref3.boundary,
      width = _ref3.width,
      _ref3$style = _ref3.style,
      style = _ref3$style === void 0 ? {} : _ref3$style;
  var classes = useStyles();
  return /*#__PURE__*/React__default.createElement("div", {
    style: _objectSpread2(_objectSpread2({}, style), {}, {
      width: "".concat(width, "px")
    }),
    className: boundary ? classes.boundaryPaddingBlock : classes.interRegionPaddingBlock
  });
}

var useStyles$1 = /*#__PURE__*/styles.makeStyles({
  linearBlocks: {
    whiteSpace: 'nowrap',
    textAlign: 'left',
    position: 'absolute',
    minHeight: '100%',
    display: 'flex'
  },
  heightOverflowed: {
    position: 'absolute',
    color: 'rgb(77,77,77)',
    borderBottom: '2px solid rgb(77,77,77)',
    textShadow: 'white 0px 0px 1px',
    whiteSpace: 'nowrap',
    width: '100%',
    fontWeight: 'bold',
    textAlign: 'center',
    zIndex: 2000,
    boxSizing: 'border-box'
  }
});
var RenderedBlocks = /*#__PURE__*/mobxReact.observer(function (_ref) {
  var model = _ref.model;
  var classes = useStyles$1();
  var blockDefinitions = model.blockDefinitions,
      blockState = model.blockState;
  return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, blockDefinitions.map(function (block) {
    if (block instanceof blockTypes.ContentBlock) {
      var state = blockState.get(block.key);
      return /*#__PURE__*/React__default.createElement(ContentBlock, {
        block: block,
        key: "".concat(model.id, "-").concat(block.key)
      }, state && state.ReactComponent ? /*#__PURE__*/React__default.createElement(state.ReactComponent, {
        model: state
      }) : null, state && state.maxHeightReached ? /*#__PURE__*/React__default.createElement("div", {
        className: classes.heightOverflowed,
        style: {
          top: state.layout.getTotalHeight() - 16,
          pointerEvents: 'none',
          height: 16
        }
      }, "Max height reached") : null);
    }

    if (block instanceof blockTypes.ElidedBlock) {
      return /*#__PURE__*/React__default.createElement(ElidedBlock, {
        key: "".concat(model.id, "-").concat(block.key),
        width: block.widthPx
      });
    }

    if (block instanceof blockTypes.InterRegionPaddingBlock) {
      return /*#__PURE__*/React__default.createElement(InterRegionPaddingBlock, {
        key: block.key,
        width: block.widthPx,
        style: {
          background: 'none'
        },
        boundary: block.variant === 'boundary'
      });
    }

    throw new Error("invalid block type ".concat(_typeof(block)));
  }));
});

function LinearBlocks(_ref2) {
  var model = _ref2.model;
  var classes = useStyles$1();
  var blockDefinitions = model.blockDefinitions; // eslint-disable-next-line @typescript-eslint/no-explicit-any

  var viewModel = util.getContainingView(model);
  return /*#__PURE__*/React__default.createElement("div", {
    "data-testid": "Blockset",
    className: classes.linearBlocks,
    style: {
      left: blockDefinitions.offsetPx - viewModel.offsetPx
    }
  }, /*#__PURE__*/React__default.createElement(RenderedBlocks, {
    model: model
  }));
}

LinearBlocks.propTypes = {
  model: mobxReact.PropTypes.observableObject.isRequired
};
var LinearBlocks$1 = /*#__PURE__*/mobxReact.observer(LinearBlocks);

var useStyles$2 = /*#__PURE__*/styles.makeStyles({
  display: {
    position: 'relative',
    whiteSpace: 'nowrap',
    textAlign: 'left',
    width: '100%',
    minHeight: '100%'
  }
});
var Tooltip = /*#__PURE__*/mobxReact.observer(function (props) {
  var model = props.model,
      mouseCoord = props.mouseCoord;
  var featureUnderMouse = model.featureUnderMouse;
  var mouseover = featureUnderMouse ? configuration.getConf(model, 'mouseover', {
    feature: featureUnderMouse
  }) : undefined;
  return mouseover ? /*#__PURE__*/React__default.createElement(Tooltip$1, {
    title: mouseover,
    open: true,
    placement: "right"
  }, /*#__PURE__*/React__default.createElement("div", {
    style: {
      position: 'absolute',
      left: mouseCoord[0],
      top: mouseCoord[1]
    }
  }, ' ')) : null;
});
var BaseLinearDisplay = /*#__PURE__*/mobxReact.observer(function (props) {
  var classes = useStyles$2();
  var theme = styles.useTheme();

  var _useState = React.useState([0, 0]),
      _useState2 = _slicedToArray(_useState, 2),
      mouseCoord = _useState2[0],
      setMouseCoord = _useState2[1];

  var _useState3 = React.useState(),
      _useState4 = _slicedToArray(_useState3, 2),
      contextCoord = _useState4[0],
      setContextCoord = _useState4[1];

  var ref = React.useRef(null);
  var model = props.model,
      children = props.children;
  var TooltipComponent = model.TooltipComponent,
      DisplayMessageComponent = model.DisplayMessageComponent,
      contextMenuItems = model.contextMenuItems,
      height = model.height,
      setContextMenuFeature = model.setContextMenuFeature;
  return /*#__PURE__*/React__default.createElement("div", {
    ref: ref,
    "data-testid": "display-".concat(configuration.getConf(model, 'displayId')),
    className: classes.display,
    onContextMenu: function onContextMenu(event) {
      event.preventDefault();

      if (contextCoord) {
        // There's already a context menu open, so close it
        setContextCoord(undefined);
      } else if (ref.current) {
        setContextCoord([event.clientX, event.clientY]);
      }
    },
    onMouseMove: function onMouseMove(event) {
      if (ref.current) {
        var rect = ref.current.getBoundingClientRect();
        setMouseCoord([event.clientX - rect.left, event.clientY - rect.top]);
      }
    },
    role: "presentation"
  }, DisplayMessageComponent ? /*#__PURE__*/React__default.createElement(DisplayMessageComponent, {
    model: model
  }) : /*#__PURE__*/React__default.createElement(LinearBlocks$1, Object.assign({}, props)), children, /*#__PURE__*/React__default.createElement(TooltipComponent, {
    model: model,
    height: height,
    mouseCoord: mouseCoord
  }), /*#__PURE__*/React__default.createElement(ui.Menu, {
    open: Boolean(contextCoord) && Boolean(contextMenuItems.length),
    onMenuItemClick: function onMenuItemClick(_, callback) {
      callback();
      setContextCoord(undefined);
    },
    onClose: function onClose() {
      setContextCoord(undefined);
      setContextMenuFeature(undefined);
    },
    onExit: function onExit() {
      setContextCoord(undefined);
      setContextMenuFeature(undefined);
    },
    anchorReference: "anchorPosition",
    anchorPosition: contextCoord ? {
      top: contextCoord[1],
      left: contextCoord[0]
    } : undefined,
    style: {
      zIndex: theme.zIndex.tooltip
    },
    menuItems: contextMenuItems,
    "data-testid": "base_linear_display_context_menu"
  }));
});

var useStyles$3 = /*#__PURE__*/styles.makeStyles(function (theme) {
  return {
    loading: {
      paddingLeft: '0.6em',
      backgroundColor: theme.palette.action.disabledBackground,
      backgroundImage: 'repeating-linear-gradient(45deg, transparent, transparent 5px, rgba(255,255,255,.5) 5px, rgba(255,255,255,.5) 10px)',
      height: '100%',
      width: '100%',
      pointerEvents: 'none',
      textAlign: 'center'
    },
    blockMessage: {
      width: '100%',
      background: theme.palette.action.disabledBackground,
      padding: theme.spacing(2),
      pointerEvents: 'none',
      textAlign: 'center'
    },
    blockError: {
      padding: theme.spacing(2),
      width: '100%',
      whiteSpace: 'normal',
      color: theme.palette.error.main,
      overflowY: 'auto'
    },
    blockReactNodeMessage: {
      width: '100%',
      background: theme.palette.action.disabledBackground,
      padding: theme.spacing(2),
      textAlign: 'center'
    },
    dots: {
      '&::after': {
        display: 'inline-block',
        animation: '$ellipsis 1.5s infinite',
        content: '"."',
        width: '1em',
        textAlign: 'left'
      }
    },
    '@keyframes ellipsis': {
      '0%': {
        content: '"."'
      },
      '33%': {
        content: '".."'
      },
      '66%': {
        content: '"..."'
      }
    }
  };
});

function Repeater(_ref) {
  var children = _ref.children;
  return /*#__PURE__*/React__default.createElement("div", {
    style: {
      display: 'flex'
    }
  }, children, children);
} // eslint-disable-next-line @typescript-eslint/no-explicit-any


var LoadingMessage = /*#__PURE__*/mobxReact.observer(function (_ref2) {
  var model = _ref2.model;

  // only show the loading message after 300ms to prevent excessive flickering
  var _useState = React.useState(false),
      _useState2 = _slicedToArray(_useState, 2),
      shown = _useState2[0],
      setShown = _useState2[1];

  var classes = useStyles$3();
  React.useEffect(function () {
    var killed = false;
    var timeout = setTimeout(function () {
      if (!killed) {
        setShown(true);
      }
    }, 300);
    return function () {
      clearTimeout(timeout);
      killed = true;
    };
  }, []);
  var blockStatus = model.status;

  var _getParent = mobxStateTree.getParent(model, 2),
      displayStatus = _getParent.message;

  var status = displayStatus || blockStatus;
  return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, shown ? /*#__PURE__*/React__default.createElement("div", {
    className: classes.loading
  }, /*#__PURE__*/React__default.createElement(Typography, {
    className: classes.dots,
    variant: "body2"
  }, status ? "".concat(status) : 'Loading')) : null);
});

function BlockMessage(_ref3) {
  var messageContent = _ref3.messageContent;
  var classes = useStyles$3();
  return /*#__PURE__*/React__default.isValidElement(messageContent) ? /*#__PURE__*/React__default.createElement("div", {
    className: classes.blockReactNodeMessage
  }, messageContent) : /*#__PURE__*/React__default.createElement(Typography, {
    variant: "body2",
    className: classes.blockMessage
  }, messageContent);
}

function BlockError(_ref4) {
  var error = _ref4.error,
      reload = _ref4.reload,
      displayHeight = _ref4.displayHeight;
  var classes = useStyles$3();
  return /*#__PURE__*/React__default.createElement("div", {
    className: classes.blockError,
    style: {
      height: displayHeight
    }
  }, reload ? /*#__PURE__*/React__default.createElement(Button, {
    "data-testid": "reload_button",
    onClick: reload,
    startIcon: /*#__PURE__*/React__default.createElement(RefreshIcon, null)
  }, "Reload") : null, /*#__PURE__*/React__default.createElement(Typography, {
    color: "error",
    variant: "body2",
    display: "inline"
  }, "".concat(error)));
}

var ServerSideRenderedBlockContent = /*#__PURE__*/mobxReact.observer(function (_ref5) {
  var model = _ref5.model;

  if (model.error) {
    return /*#__PURE__*/React__default.createElement(Repeater, null, /*#__PURE__*/React__default.createElement(BlockError, {
      error: model.error,
      reload: model.reload,
      displayHeight: tracks.getParentRenderProps(model).displayModel.height
    }));
  }

  if (model.message) {
    return /*#__PURE__*/React__default.createElement(Repeater, null, /*#__PURE__*/React__default.createElement(BlockMessage, {
      messageContent: model.message
    }));
  }

  if (!model.filled) {
    return /*#__PURE__*/React__default.createElement(Repeater, null, /*#__PURE__*/React__default.createElement(LoadingMessage, {
      model: model
    }));
  }

  return model.reactElement;
});

var blockState = /*#__PURE__*/mobxStateTree.types.model('BlockState', {
  key: mobxStateTree.types.string,
  region: mst.Region,
  isLeftEndOfDisplayedRegion: false,
  isRightEndOfDisplayedRegion: false
}) // NOTE: all this volatile stuff has to be filled in at once, so that it stays consistent
["volatile"](function () {
  return {
    renderInProgress: undefined,
    filled: false,
    reactElement: undefined,
    features: undefined,
    layout: undefined,
    status: '',
    error: undefined,
    message: undefined,
    maxHeightReached: false,
    ReactComponent: ServerSideRenderedBlockContent,
    renderProps: undefined
  };
}).actions(function (self) {
  var renderInProgress;
  return {
    afterAttach: function afterAttach() {
      var display = util.getContainingDisplay(self);
      util.makeAbortableReaction(self, renderBlockData, renderBlockEffect, // reaction doesn't expect async here
      {
        name: "".concat(display.id, "/").concat(util.assembleLocString(self.region), " rendering"),
        delay: display.renderDelay,
        fireImmediately: true
      }, this.setLoading, this.setRendered, this.setError);
    },
    setStatus: function setStatus(message) {
      self.status = message;
    },
    setLoading: function setLoading(abortController) {
      if (renderInProgress !== undefined) {
        if (!renderInProgress.signal.aborted) {
          renderInProgress.abort();
        }
      }

      self.filled = false;
      self.message = undefined;
      self.reactElement = undefined;
      self.features = undefined;
      self.layout = undefined;
      self.error = undefined;
      self.maxHeightReached = false;
      self.renderProps = undefined;
      renderInProgress = abortController;
    },
    setMessage: function setMessage(messageText) {
      if (renderInProgress && !renderInProgress.signal.aborted) {
        renderInProgress.abort();
      }

      self.filled = false;
      self.message = messageText;
      self.reactElement = undefined;
      self.features = undefined;
      self.layout = undefined;
      self.error = undefined;
      self.maxHeightReached = false;
      self.renderProps = undefined;
      renderInProgress = undefined;
    },
    setRendered: function setRendered(props) {
      if (!props) {
        return;
      }

      var reactElement = props.reactElement,
          features = props.features,
          layout = props.layout,
          maxHeightReached = props.maxHeightReached,
          renderProps = props.renderProps;
      self.filled = true;
      self.message = undefined;
      self.reactElement = reactElement;
      self.features = features;
      self.layout = layout;
      self.error = undefined;
      self.maxHeightReached = maxHeightReached;
      self.renderProps = renderProps;
      renderInProgress = undefined;
    },
    setError: function setError(error) {
      console.error(error);

      if (renderInProgress && !renderInProgress.signal.aborted) {
        renderInProgress.abort();
      } // the rendering failed for some reason


      self.filled = false;
      self.message = undefined;
      self.reactElement = undefined;
      self.features = undefined;
      self.layout = undefined;
      self.maxHeightReached = false;
      self.error = error;
      self.renderProps = undefined;
      renderInProgress = undefined;
    },
    reload: function reload() {
      self.renderInProgress = undefined;
      self.filled = false;
      self.reactElement = undefined;
      self.features = undefined;
      self.layout = undefined;
      self.error = undefined;
      self.message = undefined;
      self.maxHeightReached = false;
      self.ReactComponent = ServerSideRenderedBlockContent;
      self.renderProps = undefined;
      mobxStateTree.getParent(self, 2).reload();
    },
    beforeDestroy: function beforeDestroy() {
      if (renderInProgress && !renderInProgress.signal.aborted) {
        renderInProgress.abort();
      }

      var display = util.getContainingDisplay(self);

      var _getSession = util.getSession(self),
          rpcManager = _getSession.rpcManager;

      var rendererType = display.rendererType;

      var _renderBlockData = renderBlockData(mobxStateTree.cast(self)),
          renderArgs = _renderBlockData.renderArgs; // renderArgs can be undefined if an error occured in this block


      if (renderArgs) {
        rendererType.freeResourcesInClient(rpcManager, JSON.parse(JSON.stringify(renderArgs)))["catch"](function (e) {
          // just console.error if it's something while it's being destroyed
          console.warn('Error while destroying block', e);
        });
      }
    }
  };
});
// this, because the flow doesn't work with autorun

function renderBlockData(self, optDisplay) {
  try {
    var display = optDisplay || util.getContainingDisplay(self);

    var _getSession2 = util.getSession(display),
        assemblyManager = _getSession2.assemblyManager,
        rpcManager = _getSession2.rpcManager;

    var adapterConfig = display.adapterConfig,
        renderProps = display.renderProps,
        rendererType = display.rendererType,
        displayError = display.error,
        parentTrack = display.parentTrack;
    var assemblyNames = tracks.getTrackAssemblyNames(parentTrack);
    var regionAsm = self.region.assemblyName;

    if (!assemblyNames.includes(regionAsm) && !assemblyNames.find(function (name) {
      var _assemblyManager$get;

      return (_assemblyManager$get = assemblyManager.get(name)) === null || _assemblyManager$get === void 0 ? void 0 : _assemblyManager$get.hasName(regionAsm);
    })) {
      throw new Error("region assembly (".concat(regionAsm, ") does not match track assemblies (").concat(assemblyNames, ")"));
    }

    var config = renderProps.config; // This line is to trigger the mobx reaction when the config changes
    // It won't trigger the reaction if it doesn't think we're accessing it

    configuration.readConfObject(config);
    var sessionId = tracks.getRpcSessionId(display);
    var cannotBeRenderedReason = display.regionCannotBeRendered(self.region);
    return {
      rendererType: rendererType,
      rpcManager: rpcManager,
      renderProps: renderProps,
      cannotBeRenderedReason: cannotBeRenderedReason,
      displayError: displayError,
      renderArgs: {
        statusCallback: function statusCallback(message) {
          if (mobxStateTree.isAlive(self)) {
            self.setStatus(message);
          }
        },
        assemblyName: self.region.assemblyName,
        regions: [self.region],
        adapterConfig: adapterConfig,
        rendererType: rendererType.name,
        sessionId: sessionId,
        blockKey: self.key,
        timeout: 1000000
      }
    };
  } catch (e) {
    return {
      displayError: e
    };
  }
}

function renderBlockEffect(_x, _x2, _x3) {
  return _renderBlockEffect.apply(this, arguments);
}

function _renderBlockEffect() {
  _renderBlockEffect = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(props, signal, self) {
    var rendererType, renderProps, rpcManager, renderArgs, cannotBeRenderedReason, displayError, _yield$rendererType$r, reactElement, features, layout, maxHeightReached;

    return runtime_1.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            rendererType = props.rendererType, renderProps = props.renderProps, rpcManager = props.rpcManager, renderArgs = props.renderArgs, cannotBeRenderedReason = props.cannotBeRenderedReason, displayError = props.displayError;

            if (mobxStateTree.isAlive(self)) {
              _context.next = 3;
              break;
            }

            return _context.abrupt("return", undefined);

          case 3:
            if (!displayError) {
              _context.next = 6;
              break;
            }

            self.setError(displayError);
            return _context.abrupt("return", undefined);

          case 6:
            if (!cannotBeRenderedReason) {
              _context.next = 9;
              break;
            }

            self.setMessage(cannotBeRenderedReason);
            return _context.abrupt("return", undefined);

          case 9:
            if (!renderProps.notReady) {
              _context.next = 11;
              break;
            }

            return _context.abrupt("return", undefined);

          case 11:
            _context.next = 13;
            return rendererType.renderInClient(rpcManager, _objectSpread2(_objectSpread2(_objectSpread2({}, renderArgs), renderProps), {}, {
              signal: signal
            }));

          case 13:
            _yield$rendererType$r = _context.sent;
            reactElement = _yield$rendererType$r.reactElement;
            features = _yield$rendererType$r.features;
            layout = _yield$rendererType$r.layout;
            maxHeightReached = _yield$rendererType$r.maxHeightReached;
            return _context.abrupt("return", {
              reactElement: reactElement,
              features: features,
              layout: layout,
              maxHeightReached: maxHeightReached
            });

          case 19:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _renderBlockEffect.apply(this, arguments);
}

var minDisplayHeight = 20;
var defaultDisplayHeight = 100;
var BaseLinearDisplay$1 = /*#__PURE__*/mobxStateTree.types.compose('BaseLinearDisplay', models.BaseDisplay, mobxStateTree.types.model({
  height: mobxStateTree.types.optional(mobxStateTree.types.refinement('displayHeight', mobxStateTree.types.number, function (n) {
    return n >= minDisplayHeight;
  }), defaultDisplayHeight),
  blockState: mobxStateTree.types.map(blockState),
  userBpPerPxLimit: mobxStateTree.types.maybe(mobxStateTree.types.number)
}))["volatile"](function () {
  return {
    message: '',
    featureIdUnderMouse: undefined,
    contextMenuFeature: undefined,
    additionalContextMenuItemCallbacks: [],
    scrollTop: 0
  };
}).views(function (self) {
  return {
    get blockType() {
      return 'staticBlocks';
    },

    get blockDefinitions() {
      var blockType = this.blockType;
      var view = util.getContainingView(self);

      if (!view.initialized) {
        throw new Error('view not initialized yet');
      }

      return view[blockType];
    }

  };
}).views(function (self) {
  return {
    /**
     * set limit to config amount, or user amount if they force load,
     */
    get maxViewBpPerPx() {
      return self.userBpPerPxLimit || configuration.getConf(self, 'maxDisplayedBpPerPx');
    },

    /**
     * how many milliseconds to wait for the display to
     * "settle" before re-rendering a block
     */
    get renderDelay() {
      return 50;
    },

    get TooltipComponent() {
      return Tooltip;
    },

    /**
     * returns a string feature ID if the globally-selected object
     * is probably a feature
     */
    get selectedFeatureId() {
      if (mobxStateTree.isAlive(self)) {
        var session = util.getSession(self);
        var selection = session.selection; // does it quack like a feature?

        if (simpleFeature.isFeature(selection)) {
          return selection.id();
        }
      }

      return undefined;
    },

    /**
     * if a display-level message should be displayed instead of the blocks,
     * make this return a react component
     */
    get DisplayMessageComponent() {
      return undefined;
    }

  };
}).views(function (self) {
  return {
    /**
     * a CompositeMap of `featureId -> feature obj` that
     * just looks in all the block data for that feature
     */
    get features() {
      var featureMaps = [];

      var _iterator = _createForOfIteratorHelper(self.blockState.values()),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var block = _step.value;

          if (block && block.features) {
            featureMaps.push(block.features);
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      return new CompositeMap(featureMaps);
    },

    get featureUnderMouse() {
      return self.featureIdUnderMouse ? this.features.get(self.featureIdUnderMouse) : undefined;
    },

    /**
     * returns per-base block layouts as the data structure
     * `Map<blockKey, Map<featureId, LayoutRecord>>`
     *
     * this per-block is needed to avoid cross-contamination of
     * layouts across blocks especially when building the rtree
     */
    get blockLayoutFeatures() {
      var layoutMaps = new Map();

      var _iterator2 = _createForOfIteratorHelper(self.blockState.values()),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var block = _step2.value;

          if (block && block.layout && block.layout.rectangles) {
            layoutMaps.set(block.key, block.layout.getRectangles());
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      return layoutMaps;
    },

    getFeatureOverlapping: function getFeatureOverlapping(blockKey, x, y) {
      var _self$blockState$get, _self$blockState$get$;

      return (_self$blockState$get = self.blockState.get(blockKey)) === null || _self$blockState$get === void 0 ? void 0 : (_self$blockState$get$ = _self$blockState$get.layout) === null || _self$blockState$get$ === void 0 ? void 0 : _self$blockState$get$.getByCoord(x, y);
    },
    getFeatureByID: function getFeatureByID(id) {
      var ret;
      self.blockState.forEach(function (block) {
        var _block$layout;

        var val = block === null || block === void 0 ? void 0 : (_block$layout = block.layout) === null || _block$layout === void 0 ? void 0 : _block$layout.getByID(id);

        if (val) {
          ret = val;
        }
      });
      return ret;
    }
  };
}).actions(function (self) {
  return {
    afterAttach: function afterAttach() {
      var _this = this;

      // watch the parent's blocks to update our block state when they change
      var blockWatchDisposer = mobx.autorun(function () {
        // create any blocks that we need to create
        var blocksPresent = {};
        var view = util.getContainingView(self);

        if (view.initialized) {
          self.blockDefinitions.contentBlocks.forEach(function (block) {
            blocksPresent[block.key] = true;

            if (!self.blockState.has(block.key)) {
              _this.addBlock(block.key, block);
            }
          }); // delete any blocks we need go delete

          self.blockState.forEach(function (_, key) {
            if (!blocksPresent[key]) {
              _this.deleteBlock(key);
            }
          });
        }
      });
      mobxStateTree.addDisposer(self, blockWatchDisposer);
    },
    setHeight: function setHeight(displayHeight) {
      if (displayHeight > minDisplayHeight) {
        self.height = displayHeight;
      } else {
        self.height = minDisplayHeight;
      }

      return self.height;
    },
    resizeHeight: function resizeHeight(distance) {
      var oldHeight = self.height;
      var newHeight = this.setHeight(self.height + distance);
      return newHeight - oldHeight;
    },
    setScrollTop: function setScrollTop(scrollTop) {
      self.scrollTop = scrollTop;
    },
    // sets the new bpPerPxLimit if user chooses to force load
    setUserBpPerPxLimit: function setUserBpPerPxLimit(limit) {
      self.userBpPerPxLimit = limit;
    },
    // base display reload does nothing, see specialized displays for details
    setMessage: function setMessage(message) {
      self.message = message;
    },
    addBlock: function addBlock(key, block) {
      self.blockState.set(key, blockState.create({
        key: key,
        region: block.toRegion()
      }));
    },
    deleteBlock: function deleteBlock(key) {
      self.blockState["delete"](key);
    },
    selectFeature: function selectFeature(feature) {
      var session = util.getSession(self);

      if (util.isSessionModelWithWidgets(session)) {
        var featureWidget = session.addWidget('BaseFeatureWidget', 'baseFeature', {
          featureData: feature.toJSON(),
          view: util.getContainingView(self)
        });
        session.showWidget(featureWidget);
      }

      if (util.isSelectionContainer(session)) {
        session.setSelection(feature);
      }
    },
    clearFeatureSelection: function clearFeatureSelection() {
      var session = util.getSession(self);
      session.clearSelection();
    },
    setFeatureIdUnderMouse: function setFeatureIdUnderMouse(feature) {
      self.featureIdUnderMouse = feature;
    },
    reload: function reload() {
      var temp = JSON.parse(JSON.stringify(self.blockState));
      Object.keys(temp).forEach(function (blockState) {
        temp[blockState].key += '-reload';
      });
      self.blockState = temp;
    },
    addAdditionalContextMenuItemCallback: function addAdditionalContextMenuItemCallback(callback) {
      self.additionalContextMenuItemCallbacks.push(callback);
    },
    setContextMenuFeature: function setContextMenuFeature(feature) {
      self.contextMenuFeature = feature;
    }
  };
}).views(function (self) {
  return {
    regionCannotBeRenderedText: function regionCannotBeRenderedText(_region) {
      var view = util.getContainingView(self);

      if (view && view.bpPerPx > self.maxViewBpPerPx) {
        return 'Zoom in to see features';
      }

      return '';
    },

    /**
     * @param region -
     * @returns falsy if the region is fine to try rendering. Otherwise,
     *  return a react node + string of text.
     *  string of text describes why it cannot be rendered
     *  react node allows user to force load at current setting
     */
    regionCannotBeRendered: function regionCannotBeRendered(_region) {
      var view = util.getContainingView(self);

      if (view && view.bpPerPx > self.maxViewBpPerPx) {
        return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement(Typography, {
          component: "span",
          variant: "body2"
        }, "Zoom in to see features or", ' '), /*#__PURE__*/React__default.createElement(Button, {
          "data-testid": "reload_button",
          onClick: function onClick() {
            self.setUserBpPerPxLimit(view.bpPerPx);
            self.reload();
          },
          variant: "outlined"
        }, "Force Load"), /*#__PURE__*/React__default.createElement(Typography, {
          component: "span",
          variant: "body2"
        }, "(force load may be slow)"));
      }

      return undefined;
    },

    get trackMenuItems() {
      return [];
    },

    // distinct set of display items that are particular to this display type.
    // for base, there are none
    //
    // note: this attribute is helpful when composing together multiple
    // subdisplays so that you don't repeat the "about this track" from each
    // child display
    get composedTrackMenuItems() {
      return [];
    },

    get contextMenuItems() {
      var _getEnv = mobxStateTree.getEnv(self),
          pluginManager = _getEnv.pluginManager;

      var contextMenuItems = self.contextMenuFeature ? [{
        label: 'Open feature details',
        icon: MenuOpenIcon,
        onClick: function onClick() {
          if (self.contextMenuFeature) {
            self.selectFeature(self.contextMenuFeature);
          }
        }
      }] : [];
      self.additionalContextMenuItemCallbacks.forEach(function (callback) {
        var menuItems = callback(self.contextMenuFeature, self, pluginManager);
        contextMenuItems.push.apply(contextMenuItems, _toConsumableArray(menuItems));
      });
      return contextMenuItems;
    },

    get composedRenderProps() {
      return _objectSpread2(_objectSpread2({}, tracks.getParentRenderProps(self)), {}, {
        rpcDriverName: self.rpcDriverName,
        displayModel: self,
        onFeatureClick: function onFeatureClick(_, featureId) {
          var f = featureId || self.featureIdUnderMouse;

          if (!f) {
            self.clearFeatureSelection();
          } else {
            var feature = self.features.get(f);
            self.selectFeature(feature);
          }
        },
        onClick: function onClick() {
          self.clearFeatureSelection();
        },
        // similar to click but opens a menu with further options
        onFeatureContextMenu: function onFeatureContextMenu(_, featureId) {
          var f = featureId || self.featureIdUnderMouse;

          if (!f) {
            self.clearFeatureSelection();
          } else {
            // feature id under mouse passed to context menu
            self.setContextMenuFeature(self.features.get(f));
          }
        },
        onMouseMove: function onMouseMove(_, featureId) {
          self.setFeatureIdUnderMouse(featureId);
        },
        onMouseLeave: function onMouseLeave(_) {
          self.setFeatureIdUnderMouse(undefined);
        },
        onContextMenu: function onContextMenu() {
          self.setContextMenuFeature(undefined);
          self.clearFeatureSelection();
        }
      });
    },

    get renderProps() {
      return this.composedRenderProps;
    }

  };
}).actions(function (self) {
  return {
    renderSvg: function renderSvg(opts) {
      return _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee() {
        var height, id, overrideHeight, view, viewOffsetPx, dynamicBlocks, width, renderings;
        return runtime_1.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                height = self.height, id = self.id;
                overrideHeight = opts.overrideHeight;
                view = util.getContainingView(self);
                viewOffsetPx = view.offsetPx, dynamicBlocks = view.roundedDynamicBlocks, width = view.width;
                _context.next = 6;
                return Promise.all(dynamicBlocks.map(function (block) {
                  var blockState$1 = blockState.create({
                    key: block.key,
                    region: block
                  }); // regionCannotBeRendered can return jsx so look for plaintext
                  // version, or just get the default if none available

                  // regionCannotBeRendered can return jsx so look for plaintext
                  // version, or just get the default if none available
                  var cannotBeRenderedReason = self.regionCannotBeRenderedText(block) || self.regionCannotBeRendered(block);

                  if (cannotBeRenderedReason) {
                    return {
                      reactElement: /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement("rect", {
                        x: 0,
                        y: 0,
                        width: width,
                        height: 20,
                        fill: "#aaa"
                      }), /*#__PURE__*/React__default.createElement("text", {
                        x: 0,
                        y: 15
                      }, cannotBeRenderedReason))
                    };
                  }

                  var _renderBlockData = renderBlockData(blockState$1, self),
                      rpcManager = _renderBlockData.rpcManager,
                      renderArgs = _renderBlockData.renderArgs,
                      renderProps = _renderBlockData.renderProps,
                      rendererType = _renderBlockData.rendererType;

                  return rendererType.renderInClient(rpcManager, _objectSpread2(_objectSpread2(_objectSpread2({}, renderArgs), renderProps), {}, {
                    exportSVG: opts
                  }));
                }));

              case 6:
                renderings = _context.sent;
                return _context.abrupt("return", /*#__PURE__*/React__default.createElement(React__default.Fragment, null, renderings.map(function (rendering, index) {
                  var offsetPx = dynamicBlocks[index].offsetPx;
                  var offset = offsetPx - viewOffsetPx; // stabalize clipid under test for snapshot

                  // stabalize clipid under test for snapshot
                  var clipid = "clip-".concat(typeof jest === 'undefined' ? id : 'jest', "-").concat(index);
                  return /*#__PURE__*/React__default.createElement(React__default.Fragment, {
                    key: "frag-".concat(index)
                  }, /*#__PURE__*/React__default.createElement("defs", null, /*#__PURE__*/React__default.createElement("clipPath", {
                    id: clipid
                  }, /*#__PURE__*/React__default.createElement("rect", {
                    x: 0,
                    y: 0,
                    width: width,
                    height: overrideHeight || height
                  }))), /*#__PURE__*/React__default.createElement("g", {
                    transform: "translate(".concat(offset, " 0)")
                  }, /*#__PURE__*/React__default.createElement("g", {
                    clipPath: "url(#".concat(clipid, ")")
                  }, /*#__PURE__*/React__default.isValidElement(rendering.reactElement) ? rendering.reactElement : /*#__PURE__*/React__default.createElement("g", {
                    dangerouslySetInnerHTML: {
                      __html: rendering.html
                    }
                  }))));
                })));

              case 8:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }))();
    }
  };
}).postProcessSnapshot(function (self) {
  var rest = _objectWithoutProperties(self, ["blockState"]);

  return rest;
});

function configSchemaFactory(pluginManager) {
  return configuration.ConfigurationSchema('LinearBareDisplay', {
    renderer: pluginManager.pluggableConfigSchemaType('renderer')
  }, {
    baseConfiguration: baseLinearDisplayConfigSchema,
    explicitlyTyped: true
  });
}

function stateModelFactory(configSchema) {
  return mobxStateTree.types.compose('LinearBareDisplay', BaseLinearDisplay$1, mobxStateTree.types.model({
    type: mobxStateTree.types.literal('LinearBareDisplay'),
    configuration: configurationSchema.ConfigurationReference(configSchema)
  })).views(function (self) {
    return {
      get renderProps() {
        return _objectSpread2(_objectSpread2(_objectSpread2({}, self.composedRenderProps), tracks.getParentRenderProps(self)), {}, {
          rpcDriverName: self.rpcDriverName,
          config: self.configuration.renderer
        });
      },

      get rendererTypeName() {
        return self.configuration.renderer.type;
      }

    };
  });
}

var filter = /*#__PURE__*/Autocomplete.createFilterOptions({
  trim: true,
  matchFrom: 'start',
  ignoreCase: true,
  limit: 101
});
var helperSearchText = "Search for features or navigate to a location using syntax \"chr1:1-100\" or \"chr1:1..100\"";
var useStyles$4 = /*#__PURE__*/styles.makeStyles(function () {
  return {
    customWidth: {
      maxWidth: 150
    }
  };
});

function fetchResults(_x, _x2, _x3) {
  return _fetchResults.apply(this, arguments);
}

function _fetchResults() {
  _fetchResults = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(self, query, assemblyName) {
    var session, _getEnv, pluginManager, rankSearchResults, textSearchManager, searchScope, args, searchResults;

    return runtime_1.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            session = util.getSession(self);
            _getEnv = mobxStateTree.getEnv(session), pluginManager = _getEnv.pluginManager;
            rankSearchResults = self.rankSearchResults;
            textSearchManager = pluginManager.rootModel.textSearchManager;
            searchScope = self.searchScope(assemblyName);
            args = {
              queryString: query,
              searchType: 'prefix'
            };
            _context2.next = 8;
            return textSearchManager === null || textSearchManager === void 0 ? void 0 : textSearchManager.search(args, searchScope, rankSearchResults);

          case 8:
            _context2.t0 = _context2.sent;

            if (_context2.t0) {
              _context2.next = 11;
              break;
            }

            _context2.t0 = [];

          case 11:
            searchResults = _context2.t0;
            return _context2.abrupt("return", searchResults);

          case 13:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _fetchResults.apply(this, arguments);
}

function RefNameAutocomplete(_ref) {
  var model = _ref.model,
      onSelect = _ref.onSelect,
      assemblyName = _ref.assemblyName,
      style = _ref.style,
      value = _ref.value,
      _ref$TextFieldProps = _ref.TextFieldProps,
      TextFieldProps = _ref$TextFieldProps === void 0 ? {} : _ref$TextFieldProps;
  var classes = useStyles$4();
  var session = util.getSession(model);

  var _useState = React.useState(false),
      _useState2 = _slicedToArray(_useState, 2),
      open = _useState2[0],
      setOpen = _useState2[1];

  var _useState3 = React.useState(),
      _useState4 = _slicedToArray(_useState3, 2),
      setError = _useState4[1];

  var _useState5 = React.useState(''),
      _useState6 = _slicedToArray(_useState5, 2),
      currentSearch = _useState6[0],
      setCurrentSearch = _useState6[1];

  var debouncedSearch = util.useDebounce(currentSearch, 350);

  var _useState7 = React.useState([]),
      _useState8 = _slicedToArray(_useState7, 2),
      searchOptions = _useState8[0],
      setSearchOptions = _useState8[1];

  var assemblyManager = session.assemblyManager;
  var coarseVisibleLocStrings = model.coarseVisibleLocStrings;
  var assembly = assemblyName && assemblyManager.get(assemblyName);
  var regions = React.useMemo(function () {
    return assembly && assembly.regions || [];
  }, [assembly]); // default options for dropdown

  var limitOption = [{
    group: 'reference sequence',
    result: new BaseResult__default({
      refName: '',
      label: '',
      renderingComponent: /*#__PURE__*/React__default.createElement(Tooltip$1, {
        title: 'Displaying first 100 refNames. Search for more results'
      }, /*#__PURE__*/React__default.createElement(Typography, {
        noWrap: true
      }, 'more results...'))
    })
  }];
  var options = React.useMemo(function () {
    var defaultOptions = regions.map(function (option) {
      var defaultOption = {
        group: 'reference sequence',
        result: new BaseResult.RefSequenceResult({
          refName: option.refName,
          label: option.refName,
          matchedAttribute: 'refName'
        })
      };
      return defaultOption;
    });
    return defaultOptions;
  }, [regions]);
  options = options.length > 100 ? options.slice(0, 100).concat(limitOption) : options;
  React.useEffect(function () {
    var active = true;

    _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee() {
      var results, searchResults, adapterResults;
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.prev = 0;
              results = [];

              if (!(debouncedSearch && debouncedSearch !== '' && assemblyName)) {
                _context.next = 7;
                break;
              }

              _context.next = 5;
              return fetchResults(model, debouncedSearch, assemblyName);

            case 5:
              searchResults = _context.sent;
              results = results.concat(searchResults);

            case 7:
              if (results.length > 0 && active) {
                adapterResults = results.map(function (result) {
                  var newOption = {
                    group: 'text search results',
                    result: result
                  };
                  return newOption;
                });
                setSearchOptions(adapterResults);
              }

              _context.next = 14;
              break;

            case 10:
              _context.prev = 10;
              _context.t0 = _context["catch"](0);
              console.error(_context.t0);

              if (active) {
                setError(_context.t0);
              }

            case 14:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, null, [[0, 10]]);
    }))();

    return function () {
      active = false;
    };
  }, [assemblyName, debouncedSearch, model]);

  function _onChange(selectedOption) {
    if (selectedOption && assemblyName) {
      if (typeof selectedOption === 'string') {
        // handles string inputs on keyPress enter
        var newResult = new BaseResult__default({
          label: selectedOption
        });
        onSelect(newResult);
      } else {
        var result = selectedOption.result;
        onSelect(result);
      }
    }
  }

  return /*#__PURE__*/React__default.createElement(Autocomplete__default, {
    id: "refNameAutocomplete-".concat(model.id),
    "data-testid": "autocomplete",
    freeSolo: true,
    disableListWrap: true,
    disableClearable: true,
    includeInputInList: true,
    clearOnBlur: true,
    selectOnFocus: true,
    disabled: !assemblyName,
    style: style,
    value: coarseVisibleLocStrings || value || '',
    open: open,
    onOpen: function onOpen() {
      return setOpen(true);
    },
    onClose: function onClose() {
      setOpen(false);
      setCurrentSearch('');
      setSearchOptions([]);
    },
    options: searchOptions.length === 0 ? options : searchOptions,
    groupBy: function groupBy(option) {
      return String(option.group);
    },
    filterOptions: function filterOptions(possibleOptions, params) {
      return filter(possibleOptions, params);
    },
    ListboxProps: {
      style: {
        maxHeight: 250
      }
    },
    onChange: function onChange(_, selectedOption) {
      return _onChange(selectedOption);
    },
    renderInput: function renderInput(params) {
      var helperText = TextFieldProps.helperText,
          _TextFieldProps$Input = TextFieldProps.InputProps,
          InputProps = _TextFieldProps$Input === void 0 ? {} : _TextFieldProps$Input;

      var TextFieldInputProps = _objectSpread2(_objectSpread2(_objectSpread2({}, params.InputProps), InputProps), {}, {
        endAdornment: /*#__PURE__*/React__default.createElement(React__default.Fragment, null, regions.length === 0 && searchOptions.length === 0 ? /*#__PURE__*/React__default.createElement(CircularProgress, {
          color: "inherit",
          size: 20
        }) : /*#__PURE__*/React__default.createElement(Tooltip$1, {
          title: helperSearchText,
          leaveDelay: 300,
          placement: "top",
          classes: {
            tooltip: classes.customWidth
          }
        }, /*#__PURE__*/React__default.createElement(core.InputAdornment, {
          position: "end",
          style: {
            marginRight: 7
          }
        }, /*#__PURE__*/React__default.createElement(SearchIcon, null))), params.InputProps.endAdornment)
      });

      return /*#__PURE__*/React__default.createElement(TextField, Object.assign({}, params, TextFieldProps, {
        helperText: helperText,
        value: coarseVisibleLocStrings || value || '',
        InputProps: TextFieldInputProps,
        placeholder: "Search for location",
        onChange: function onChange(e) {
          setCurrentSearch(e.target.value);
        }
      }));
    },
    renderOption: function renderOption(option, _ref3) {
      var inputValue = _ref3.inputValue;
      var result = option.result;
      var rendering = result.getLabel(); // if renderingComponent is provided render that

      var component = result.getRenderingComponent();

      if (component) {
        if ( /*#__PURE__*/React__default.isValidElement(component)) {
          return component;
        }
      }

      if (currentSearch !== '' && inputValue.length <= rendering.length) {
        return /*#__PURE__*/React__default.createElement(Typography, {
          noWrap: true
        }, /*#__PURE__*/React__default.createElement("b", null, rendering.slice(0, inputValue.length)), rendering.slice(inputValue.length));
      }

      return /*#__PURE__*/React__default.createElement(Typography, {
        noWrap: true
      }, rendering);
    },
    getOptionLabel: function getOptionLabel(option) {
      // needed for filtering options and value
      return (typeof option === 'string' ? option : option.result.getLabel()) || '';
    }
  });
}

var RefNameAutocomplete$1 = /*#__PURE__*/mobxReact.observer(RefNameAutocomplete);

/**
 * Given a scale ( bp/px ) and minimum distances (px) between major and minor
 * gridlines, return an object like `{ majorPitch: bp, minorPitch: bp }` giving
 * the gridline pitches to use.
 */
function chooseGridPitch(scale, minMajorPitchPx, minMinorPitchPx) {
  scale = Math.abs(scale);
  var minMajorPitchBp = minMajorPitchPx * scale;
  var majorMagnitude = parseInt(Number(minMajorPitchBp).toExponential().split(/e/i)[1], 10);
  var majorPitch = Math.pow(10, majorMagnitude);

  while (majorPitch < minMajorPitchBp) {
    majorPitch *= 2;

    if (majorPitch >= minMajorPitchBp) {
      break;
    }

    majorPitch *= 2.5;
  }

  majorPitch = Math.max(majorPitch, 5);
  var majorPitchPx = majorPitch / scale;
  var minorPitch = 0;

  if (!(majorPitch % 10) && majorPitchPx / 10 >= minMinorPitchPx) {
    minorPitch = majorPitch / 10;
  } else if (!(majorPitch % 5) && majorPitchPx / 5 >= minMinorPitchPx) {
    minorPitch = majorPitch / 5;
  } else if (!(majorPitch % 2) && majorPitchPx / 2 >= minMinorPitchPx) {
    minorPitch = majorPitch / 2;
  }

  return {
    majorPitch: majorPitch,
    minorPitch: minorPitch
  };
}
function makeTicks(start, end, bpPerPx) {
  var emitMajor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
  var emitMinor = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
  var gridPitch = chooseGridPitch(bpPerPx, 60, 15);
  var minBase = start;
  var maxBase = end;

  if (minBase === null || maxBase === null) {
    return [];
  }

  if (bpPerPx < 0) {
    var _ref = [maxBase, minBase];
    minBase = _ref[0];
    maxBase = _ref[1];
  } // add 20px additional on the right and left to allow us to draw the ends
  // of labels that lie a little outside our region


  minBase -= Math.abs(20 * bpPerPx) - 1;
  maxBase += Math.abs(20 * bpPerPx) + 1;
  var iterPitch = gridPitch.minorPitch || gridPitch.majorPitch;
  var index = 0;
  var ticks = [];

  for (var base = Math.ceil(minBase / iterPitch) * iterPitch; base < maxBase; base += iterPitch) {
    if (emitMinor && base % (gridPitch.majorPitch * 2)) {
      ticks.push({
        type: 'minor',
        base: base - 1,
        index: index
      });
      index += 1;
    } else if (emitMajor && !(base % (gridPitch.majorPitch * 2))) {
      ticks.push({
        type: 'major',
        base: base - 1,
        index: index
      });
      index += 1;
    }
  }

  return ticks;
}

var useStyles$5 = /*#__PURE__*/styles.makeStyles(function (theme) {
  var background = theme.palette.tertiary ? colorManipulator.fade(theme.palette.tertiary.main, 0.7) : colorManipulator.fade(theme.palette.primary.main, 0.7);
  return {
    rubberBand: {
      height: '100%',
      background: background,
      position: 'absolute',
      zIndex: 10,
      textAlign: 'center',
      overflow: 'hidden'
    },
    rubberBandControl: {
      cursor: 'crosshair',
      width: '100%',
      minHeight: 8
    },
    rubberBandText: {
      color: theme.palette.tertiary ? theme.palette.tertiary.contrastText : theme.palette.primary.contrastText
    },
    popover: {
      mouseEvents: 'none',
      cursor: 'crosshair'
    },
    paper: {
      paddingLeft: theme.spacing(1),
      paddingRight: theme.spacing(1)
    },
    guide: {
      pointerEvents: 'none',
      height: '100%',
      width: 1,
      position: 'absolute',
      zIndex: 10
    }
  };
});

function OverviewRubberBand(_ref) {
  var model = _ref.model,
      overview = _ref.overview,
      _ref$ControlComponent = _ref.ControlComponent,
      ControlComponent = _ref$ControlComponent === void 0 ? /*#__PURE__*/React__default.createElement("div", null) : _ref$ControlComponent;

  var _useState = React.useState(),
      _useState2 = _slicedToArray(_useState, 2),
      startX = _useState2[0],
      setStartX = _useState2[1];

  var _useState3 = React.useState(),
      _useState4 = _slicedToArray(_useState3, 2),
      currentX = _useState4[0],
      setCurrentX = _useState4[1];

  var _useState5 = React.useState(),
      _useState6 = _slicedToArray(_useState5, 2),
      guideX = _useState6[0],
      setGuideX = _useState6[1];

  var controlsRef = React.useRef(null);
  var rubberBandRef = React.useRef(null);
  var classes = useStyles$5();
  var mouseDragging = startX !== undefined;
  React.useEffect(function () {
    function globalMouseMove(event) {
      if (controlsRef.current && mouseDragging) {
        var relativeX = event.clientX - controlsRef.current.getBoundingClientRect().left;
        setCurrentX(relativeX);
      }
    }

    function globalMouseUp() {
      if (controlsRef.current && startX !== undefined && currentX !== undefined) {
        if (Math.abs(currentX - startX) > 3) {
          model.zoomToDisplayedRegions(overview.pxToBp(startX), overview.pxToBp(currentX));
        }
      }
      /* handling clicking and centering at a specific Bp */


      if (controlsRef.current && startX !== undefined && currentX === undefined) {
        var clickedAt = overview.pxToBp(startX);
        model.centerAt(Math.round(clickedAt.coord), clickedAt.refName, clickedAt.index);
      }

      setStartX(undefined);
      setCurrentX(undefined);

      if (startX !== undefined) {
        setGuideX(undefined);
      }
    }

    function globalKeyDown(event) {
      if (event.key === 'Escape') {
        setStartX(undefined);
        setCurrentX(undefined);
      }
    }

    if (mouseDragging) {
      window.addEventListener('mousemove', globalMouseMove, true);
      window.addEventListener('mouseup', globalMouseUp, true);
      window.addEventListener('keydown', globalKeyDown, true);
      return function () {
        window.removeEventListener('mousemove', globalMouseMove, true);
        window.removeEventListener('mouseup', globalMouseUp, true);
        window.removeEventListener('keydown', globalKeyDown, true);
      };
    }

    return function () {};
  }, [mouseDragging, currentX, startX, model, overview]);

  function mouseDown(event) {
    event.preventDefault();
    event.stopPropagation();

    if (controlsRef.current) {
      setStartX(event.clientX - controlsRef.current.getBoundingClientRect().left);
    }
  }

  function mouseMove(event) {
    if (controlsRef.current) {
      setGuideX(event.clientX - controlsRef.current.getBoundingClientRect().left);
    }
  }

  function mouseOut() {
    setGuideX(undefined);
  }

  if (startX === undefined) {
    return /*#__PURE__*/React__default.createElement("div", {
      style: {
        position: 'relative'
      }
    }, guideX !== undefined ? /*#__PURE__*/React__default.createElement(Tooltip$1, {
      open: !mouseDragging,
      placement: "top",
      title: util.stringify(overview.pxToBp(guideX)),
      arrow: true
    }, /*#__PURE__*/React__default.createElement("div", {
      className: classes.guide,
      style: {
        left: guideX
      }
    })) : null, /*#__PURE__*/React__default.createElement("div", {
      className: classes.rubberBandControl,
      role: "presentation",
      ref: controlsRef,
      onMouseDown: mouseDown,
      onMouseOut: mouseOut,
      onMouseMove: mouseMove
    }, ControlComponent));
  }

  var left = startX || 0;
  var width = 0;

  if (startX !== undefined && currentX !== undefined) {
    left = currentX < startX ? currentX : startX;
    width = currentX - startX;
  } // calculate the start and end bp of drag


  var leftBpOffset;
  var rightBpOffset;

  if (startX) {
    leftBpOffset = overview.pxToBp(startX);
    rightBpOffset = overview.pxToBp(startX + width);

    if (currentX && currentX < startX) {
      var _ref2 = [rightBpOffset, leftBpOffset];
      leftBpOffset = _ref2[0];
      rightBpOffset = _ref2[1];
    }
  }

  return /*#__PURE__*/React__default.createElement("div", {
    style: {
      position: 'relative'
    }
  }, rubberBandRef.current ? /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement(Popover, {
    className: classes.popover,
    classes: {
      paper: classes.paper
    },
    open: true,
    anchorEl: rubberBandRef.current,
    anchorOrigin: {
      vertical: 'top',
      horizontal: 'left'
    },
    transformOrigin: {
      vertical: 'bottom',
      horizontal: 'right'
    },
    keepMounted: true,
    disableRestoreFocus: true
  }, /*#__PURE__*/React__default.createElement(Typography, null, leftBpOffset ? util.stringify(leftBpOffset) : '')), /*#__PURE__*/React__default.createElement(Popover, {
    className: classes.popover,
    classes: {
      paper: classes.paper
    },
    open: true,
    anchorEl: rubberBandRef.current,
    anchorOrigin: {
      vertical: 'top',
      horizontal: 'right'
    },
    transformOrigin: {
      vertical: 'bottom',
      horizontal: 'left'
    },
    keepMounted: true,
    disableRestoreFocus: true
  }, /*#__PURE__*/React__default.createElement(Typography, null, rightBpOffset ? util.stringify(rightBpOffset) : ''))) : null, /*#__PURE__*/React__default.createElement("div", {
    ref: rubberBandRef,
    className: classes.rubberBand,
    style: {
      left: left,
      width: Math.abs(width),
      height: HEADER_OVERVIEW_HEIGHT
    }
  }), /*#__PURE__*/React__default.createElement("div", {
    "data-testid": "rubberBand_controls",
    className: classes.rubberBandControl,
    role: "presentation",
    ref: controlsRef,
    onMouseDown: mouseDown,
    onMouseOut: mouseOut,
    onMouseMove: mouseMove
  }, ControlComponent));
}

OverviewRubberBand.propTypes = {
  model: mobxReact.PropTypes.objectOrObservableObject.isRequired,
  overview: mobxReact.PropTypes.objectOrObservableObject.isRequired,
  ControlComponent: ReactPropTypes.node
};
OverviewRubberBand.defaultProps = {
  ControlComponent: /*#__PURE__*/React__default.createElement("div", null)
};
var OverviewRubberBand$1 = /*#__PURE__*/mobxReact.observer(OverviewRubberBand);

// import { Region } from '@jbrowse/core/util/types'
var useStyles$6 = /*#__PURE__*/styles.makeStyles(function (theme) {
  var scaleBarColor = theme.palette.tertiary ? theme.palette.tertiary.light : theme.palette.primary.light;
  return {
    scaleBar: {
      width: '100%',
      height: HEADER_OVERVIEW_HEIGHT,
      overflow: 'hidden'
    },
    scaleBarContig: {
      backgroundColor: theme.palette.background["default"],
      position: 'absolute',
      top: 0,
      height: HEADER_OVERVIEW_HEIGHT,
      border: '1px solid',
      borderBottomColor: 'black'
    },
    scaleBarContigForward: {
      backgroundImage: "url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 15 9'%3E%3Cpath d='M-.1 0L6 4.5L-.1 9' fill='none' stroke='%23ddd'/%3E%3C/svg%3E\")",
      backgroundRepeat: 'repeat'
    },
    scaleBarContigReverse: {
      backgroundImage: "url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 15 9'%3E%3Cpath d='M6 0L0 4.5L6 9' fill='none' stroke='%23ddd'/%3E%3C/svg%3E\")",
      backgroundRepeat: 'repeat'
    },
    scaleBarRegionIncompleteLeft: {
      width: 10,
      height: 17.5,
      background: "linear-gradient(-225deg,black 3px, transparent 1px),\n      linear-gradient(45deg, black 3px, transparent 1px)",
      backgroundRepeat: 'repeat-y',
      backgroundSize: '10px 8px',
      borderTopLeftRadius: '2px',
      borderBottomLeftRadius: '2px',
      "float": 'left'
    },
    scaleBarRegionIncompleteRight: {
      width: 10,
      height: 17.5,
      background: "linear-gradient(225deg, black 3px, transparent 1px),\n      linear-gradient(-45deg, black 3px, transparent 1px)",
      backgroundRepeat: 'repeat-y',
      backgroundSize: '10px 8px',
      borderTopRightRadius: '2px',
      borderBottomRightRadius: '2px',
      "float": 'right'
    },
    scaleBarRefName: {
      position: 'absolute',
      fontWeight: 'bold',
      lineHeight: 'normal',
      pointerEvents: 'none',
      left: 5
    },
    scaleBarLabel: {
      height: HEADER_OVERVIEW_HEIGHT,
      width: 1,
      position: 'absolute',
      display: 'flex',
      justifyContent: 'center',
      pointerEvents: 'none'
    },
    scaleBarVisibleRegion: {
      background: colorManipulator.fade(scaleBarColor, 0.3),
      position: 'absolute',
      height: HEADER_OVERVIEW_HEIGHT,
      pointerEvents: 'none',
      top: -1,
      zIndex: 100,
      borderWidth: 1,
      borderStyle: 'solid',
      borderColor: colorManipulator.fade(scaleBarColor, 0.8),
      boxSizing: 'content-box'
    },
    overview: {
      height: HEADER_BAR_HEIGHT,
      position: 'relative'
    },
    overviewSvg: {
      position: 'absolute'
    }
  };
});
var wholeSeqSpacer = 2;
var Polygon = /*#__PURE__*/mobxReact.observer(function (_ref) {
  var model = _ref.model,
      overview = _ref.overview;
  var theme = styles.useTheme();
  var classes = useStyles$6();
  var offsetPx = model.offsetPx,
      _model$dynamicBlocks = model.dynamicBlocks,
      contentBlocks = _model$dynamicBlocks.contentBlocks,
      totalWidthPxWithoutBorders = _model$dynamicBlocks.totalWidthPxWithoutBorders;
  var polygonColor = theme.palette.tertiary ? theme.palette.tertiary.light : theme.palette.primary.light;

  if (!contentBlocks.length) {
    return null;
  }

  var firstBlock = contentBlocks[0];
  var lastBlock = contentBlocks[contentBlocks.length - 1];
  var topLeft = overview.bpToPx({
    refName: firstBlock.refName,
    coord: firstBlock.reversed ? firstBlock.end : firstBlock.start,
    regionNumber: firstBlock.regionNumber
  });
  var topRight = overview.bpToPx({
    refName: lastBlock.refName,
    coord: lastBlock.reversed ? lastBlock.start : lastBlock.end,
    regionNumber: lastBlock.regionNumber
  });
  var startPx = Math.max(0, -offsetPx);
  var endPx = startPx + totalWidthPxWithoutBorders + contentBlocks.length * model.interRegionPaddingWidth / 2;
  var points = [[startPx, HEADER_BAR_HEIGHT], [endPx, HEADER_BAR_HEIGHT], [topRight, 0], [topLeft, 0]];
  return /*#__PURE__*/React__default.createElement("svg", {
    height: HEADER_BAR_HEIGHT,
    width: "100%",
    className: classes.overviewSvg
  }, points && /*#__PURE__*/React__default.createElement("polygon", {
    points: points.toString(),
    fill: colorManipulator.fade(polygonColor, 0.3),
    stroke: colorManipulator.fade(polygonColor, 0.8)
  }));
});
var ScaleBar = /*#__PURE__*/mobxReact.observer(function (_ref2) {
  var model = _ref2.model,
      scale = _ref2.scale,
      overview = _ref2.overview;
  var classes = useStyles$6();
  var visibleRegions = model.dynamicBlocks;

  var _getSession = util.getSession(model),
      assemblyManager = _getSession.assemblyManager;

  var gridPitch = chooseGridPitch(scale, 120, 15);
  var overviewVisibleRegions = overview.dynamicBlocks;

  if (!visibleRegions.contentBlocks.length) {
    return null;
  }

  var firstBlock = visibleRegions.contentBlocks[0];
  var firstOverviewPx = overview.bpToPx({
    refName: firstBlock.refName,
    regionNumber: firstBlock.regionNumber,
    coord: firstBlock.reversed ? firstBlock.end : firstBlock.start
  }) || 0;
  var lastBlock = visibleRegions.contentBlocks[visibleRegions.contentBlocks.length - 1];
  var lastOverviewPx = overview.bpToPx({
    refName: lastBlock.refName,
    coord: lastBlock.reversed ? lastBlock.start : lastBlock.end,
    regionNumber: lastBlock.regionNumber
  }) || 0;
  return /*#__PURE__*/React__default.createElement("div", {
    className: classes.scaleBar
  }, /*#__PURE__*/React__default.createElement("div", {
    className: classes.scaleBarVisibleRegion,
    style: {
      width: lastOverviewPx - firstOverviewPx,
      left: firstOverviewPx
    }
  }), overviewVisibleRegions.map(function (seq, idx) {
    var assembly = assemblyManager.get(seq.assemblyName);
    var refNameColor;

    if (assembly) {
      refNameColor = assembly.getRefNameColor(seq.refName);
    }

    var regionLength = seq.end - seq.start;
    var tickLabels = [];

    for (var index = 0; index < Math.floor(regionLength / gridPitch.majorPitch); index++) {
      var offsetLabel = (index + 1) * gridPitch.majorPitch;
      tickLabels.push(seq.reversed ? seq.end - offsetLabel : seq.start + offsetLabel);
    }

    return !(seq instanceof blockTypes.ContentBlock) ? /*#__PURE__*/React__default.createElement("div", {
      key: "".concat(JSON.stringify(seq), "-").concat(idx),
      className: classes.scaleBarContig,
      style: {
        width: seq.widthPx,
        left: seq.offsetPx,
        backgroundColor: '#999',
        backgroundImage: 'repeating-linear-gradient(90deg, transparent, transparent 1px, rgba(255,255,255,.5) 1px, rgba(255,255,255,.5) 3px)'
      }
    }) : /*#__PURE__*/React__default.createElement("div", {
      key: "".concat(JSON.stringify(seq), "-").concat(idx),
      className: clsx(classes.scaleBarContig, seq.reversed ? classes.scaleBarContigReverse : classes.scaleBarContigForward),
      style: {
        left: seq.offsetPx,
        width: seq.widthPx,
        borderColor: refNameColor
      }
    }, /*#__PURE__*/React__default.createElement(core.Typography, {
      style: {
        color: refNameColor
      },
      className: classes.scaleBarRefName
    }, seq.refName), tickLabels.map(function (tickLabel, labelIdx) {
      return /*#__PURE__*/React__default.createElement(core.Typography, {
        key: "".concat(JSON.stringify(seq), "-").concat(tickLabel, "-").concat(labelIdx),
        className: classes.scaleBarLabel,
        variant: "body2",
        style: {
          left: (labelIdx + 1) * gridPitch.majorPitch / scale,
          pointerEvents: 'none',
          color: refNameColor
        }
      }, tickLabel.toLocaleString('en-US'));
    }));
  }));
});

function OverviewScaleBar(_ref3) {
  var model = _ref3.model,
      children = _ref3.children;
  var classes = useStyles$6();
  var width = model.width,
      displayedRegions = model.displayedRegions;
  var overview = Base1DView.create({
    displayedRegions: JSON.parse(JSON.stringify(displayedRegions)),
    interRegionPaddingWidth: 0,
    minimumBlockWidth: model.minimumBlockWidth
  });
  overview.setVolatileWidth(width);
  overview.showAllRegions();
  var scale = model.totalBp / (width - (displayedRegions.length - 1) * wholeSeqSpacer);
  return !displayedRegions.length ? /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement("div", {
    className: classes.scaleBar
  }, /*#__PURE__*/React__default.createElement(LinearProgress, {
    variant: "indeterminate",
    style: {
      marginTop: 4,
      width: '100%'
    }
  })), /*#__PURE__*/React__default.createElement("div", null, children)) : /*#__PURE__*/React__default.createElement("div", null, /*#__PURE__*/React__default.createElement(OverviewRubberBand$1, {
    model: model,
    overview: overview,
    ControlComponent: /*#__PURE__*/React__default.createElement(ScaleBar, {
      model: model,
      overview: overview,
      scale: scale
    })
  }), /*#__PURE__*/React__default.createElement("div", {
    className: classes.overview
  }, /*#__PURE__*/React__default.createElement(Polygon, {
    model: model,
    overview: overview
  }), children));
}

var OverviewScaleBar$1 = /*#__PURE__*/mobxReact.observer(OverviewScaleBar);

var useStyles$7 = /*#__PURE__*/styles.makeStyles({
  container: {
    display: 'flex',
    flexDirection: 'row',
    alignItems: 'center'
  },
  slider: {
    width: 70
  }
});

function ZoomControls(_ref) {
  var model = _ref.model;
  var classes = useStyles$7();
  var maxBpPerPx = model.maxBpPerPx,
      minBpPerPx = model.minBpPerPx,
      bpPerPx = model.bpPerPx,
      scaleFactor = model.scaleFactor;

  var _useState = React.useState(-Math.log2(bpPerPx) * 100),
      _useState2 = _slicedToArray(_useState, 2),
      value = _useState2[0],
      setValue = _useState2[1];

  React.useEffect(function () {
    setValue(-Math.log2(bpPerPx) * 100);
  }, [setValue, bpPerPx]);
  return /*#__PURE__*/React__default.createElement("div", {
    className: classes.container
  }, /*#__PURE__*/React__default.createElement(IconButton, {
    "data-testid": "zoom_out",
    onClick: function onClick() {
      model.zoom(bpPerPx * 2);
    },
    disabled: bpPerPx >= maxBpPerPx - 0.0001 || scaleFactor !== 1,
    color: "secondary"
  }, /*#__PURE__*/React__default.createElement(ZoomOut, null)), /*#__PURE__*/React__default.createElement(Slider, {
    className: classes.slider,
    value: value,
    min: -Math.log2(maxBpPerPx) * 100,
    max: -Math.log2(minBpPerPx) * 100,
    onChange: function onChange(_, val) {
      return setValue(val);
    },
    onChangeCommitted: function onChangeCommitted() {
      return model.zoomTo(Math.pow(2, -value / 100));
    },
    disabled: scaleFactor !== 1
  }), /*#__PURE__*/React__default.createElement(IconButton, {
    "data-testid": "zoom_in",
    onClick: function onClick() {
      model.zoom(model.bpPerPx / 2);
    },
    disabled: bpPerPx <= minBpPerPx + 0.0001 || scaleFactor !== 1,
    color: "secondary"
  }, /*#__PURE__*/React__default.createElement(ZoomIn, null)));
}

var ZoomControls$1 = /*#__PURE__*/mobxReact.observer(ZoomControls);

var WIDGET_HEIGHT = 32;
var SPACING = 7;
var useStyles$8 = /*#__PURE__*/styles.makeStyles(function (theme) {
  return {
    headerBar: {
      height: HEADER_BAR_HEIGHT,
      display: 'flex'
    },
    headerForm: {
      flexWrap: 'nowrap',
      marginRight: 7
    },
    spacer: {
      flexGrow: 1
    },
    input: {},
    headerRefName: {
      minWidth: 100
    },
    panButton: {
      background: colorManipulator.fade(theme.palette.background.paper, 0.8),
      height: WIDGET_HEIGHT,
      margin: SPACING
    },
    bp: {
      display: 'flex',
      alignItems: 'center',
      marginLeft: 5
    },
    toggleButton: {
      height: 44,
      border: 'none',
      margin: theme.spacing(0.5)
    },
    buttonSpacer: {
      marginRight: theme.spacing(2)
    }
  };
});
var Controls = /*#__PURE__*/mobxReact.observer(function (_ref) {
  var model = _ref.model;
  var classes = useStyles$8();
  return /*#__PURE__*/React__default.createElement(Button, {
    onClick: model.activateTrackSelector,
    className: classes.toggleButton,
    title: "Open track selector",
    value: "track_select",
    color: "secondary"
  }, /*#__PURE__*/React__default.createElement(Icons.TrackSelector, {
    className: classes.buttonSpacer
  }));
});

function PanControls(_ref2) {
  var model = _ref2.model;
  var classes = useStyles$8();
  return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement(Button, {
    variant: "outlined",
    className: classes.panButton,
    onClick: function onClick() {
      return model.slide(-0.9);
    }
  }, /*#__PURE__*/React__default.createElement(ArrowBackIcon, null)), /*#__PURE__*/React__default.createElement(Button, {
    variant: "outlined",
    className: classes.panButton,
    onClick: function onClick() {
      return model.slide(0.9);
    }
  }, /*#__PURE__*/React__default.createElement(ArrowForwardIcon, null)));
}

var RegionWidth = /*#__PURE__*/mobxReact.observer(function (_ref3) {
  var model = _ref3.model;
  var classes = useStyles$8();
  var coarseTotalBp = model.coarseTotalBp;
  return /*#__PURE__*/React__default.createElement(Typography, {
    variant: "body2",
    color: "textSecondary",
    className: classes.bp
  }, "".concat(Math.round(coarseTotalBp).toLocaleString('en-US'), " bp"));
});
var LinearGenomeViewHeader = /*#__PURE__*/mobxReact.observer(function (_ref4) {
  var model = _ref4.model;
  var classes = useStyles$8();
  var theme = styles.useTheme();
  var session = util.getSession(model);
  var assemblyManager = session.assemblyManager;

  var _getEnv = mobxStateTree.getEnv(session),
      pluginManager = _getEnv.pluginManager;

  var textSearchManager = pluginManager.rootModel.textSearchManager;
  var contentBlocks = model.coarseDynamicBlocks,
      displayedRegions = model.displayedRegions,
      rankSearchResults = model.rankSearchResults;

  var _ref5 = contentBlocks[0] || {
    refName: ''
  },
      assemblyName = _ref5.assemblyName,
      refName = _ref5.refName;

  var assembly = assemblyName && assemblyManager.get(assemblyName);
  var regions = assembly && assembly.regions || [];
  var searchScope = model.searchScope(assemblyName);

  function setDisplayedRegion(_x) {
    return _setDisplayedRegion.apply(this, arguments);
  }

  function _setDisplayedRegion() {
    _setDisplayedRegion = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(result) {
      var newRegionValue, newRegion, results;
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (!result) {
                _context.next = 15;
                break;
              }

              newRegionValue = result.getLocation(); // need to fix finding region

              newRegion = regions.find(function (region) {
                return newRegionValue === region.refName;
              });

              if (!newRegion) {
                _context.next = 8;
                break;
              }

              model.setDisplayedRegions([newRegion]); // we use showAllRegions after setDisplayedRegions to make the entire
              // region visible, xref #1703

              model.showAllRegions();
              _context.next = 15;
              break;

            case 8:
              _context.next = 10;
              return textSearchManager === null || textSearchManager === void 0 ? void 0 : textSearchManager.search({
                queryString: newRegionValue.toLocaleLowerCase(),
                searchType: 'exact'
              }, searchScope, rankSearchResults);

            case 10:
              _context.t0 = _context.sent;

              if (_context.t0) {
                _context.next = 13;
                break;
              }

              _context.t0 = [];

            case 13:
              results = _context.t0;

              // distinguishes between locstrings and search strings
              if (results.length > 0) {
                model.setSearchResults(results, newRegionValue.toLocaleLowerCase());
              } else {
                try {
                  newRegionValue !== '' && model.navToLocString(newRegionValue);
                } catch (e) {
                  if ("".concat(e) === "Error: Unknown reference sequence \"".concat(newRegionValue, "\"")) {
                    model.setSearchResults(results, newRegionValue.toLocaleLowerCase());
                  } else {
                    console.warn(e);
                    session.notify("".concat(e), 'warning');
                  }
                }
              }

            case 15:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _setDisplayedRegion.apply(this, arguments);
  }

  var controls = /*#__PURE__*/React__default.createElement("div", {
    className: classes.headerBar
  }, /*#__PURE__*/React__default.createElement(Controls, {
    model: model
  }), /*#__PURE__*/React__default.createElement("div", {
    className: classes.spacer
  }), /*#__PURE__*/React__default.createElement(FormGroup, {
    row: true,
    className: classes.headerForm
  }, /*#__PURE__*/React__default.createElement(PanControls, {
    model: model
  }), /*#__PURE__*/React__default.createElement(RefNameAutocomplete$1, {
    onSelect: setDisplayedRegion,
    assemblyName: assemblyName,
    value: displayedRegions.length > 1 ? '' : refName,
    model: model,
    TextFieldProps: {
      variant: 'outlined',
      className: classes.headerRefName,
      style: {
        margin: SPACING,
        minWidth: '175px'
      },
      InputProps: {
        style: {
          padding: 0,
          height: WIDGET_HEIGHT,
          background: colorManipulator.fade(theme.palette.background.paper, 0.8)
        }
      }
    }
  })), /*#__PURE__*/React__default.createElement(RegionWidth, {
    model: model
  }), /*#__PURE__*/React__default.createElement(ZoomControls$1, {
    model: model
  }), /*#__PURE__*/React__default.createElement("div", {
    className: classes.spacer
  }));

  if (model.hideHeaderOverview) {
    return controls;
  }

  return /*#__PURE__*/React__default.createElement(OverviewScaleBar$1, {
    model: model
  }, controls);
});

var useStyles$9 = /*#__PURE__*/styles.makeStyles(function (theme) {
  return {
    root: {
      background: colorManipulator.fade(theme.palette.background.paper, 0.8),
      '&:hover': {
        background: theme.palette.background.paper
      },
      transition: theme.transitions.create(['background'], {
        duration: theme.transitions.duration.shortest
      })
    },
    trackName: {
      margin: '0 auto',
      width: '90%',
      fontSize: '0.8rem',
      pointerEvents: 'none'
    },
    dragHandle: {
      cursor: 'grab',
      color: '#135560'
    },
    dragHandleIcon: {
      display: 'inline-block',
      verticalAlign: 'middle',
      pointerEvents: 'none'
    },
    iconButton: {
      padding: theme.spacing(1)
    }
  };
});
var TrackLabel = /*#__PURE__*/React__default.forwardRef(function (props, ref) {
  var classes = useStyles$9();

  var _React$useState = React__default.useState(null),
      _React$useState2 = _slicedToArray(_React$useState, 2),
      anchorEl = _React$useState2[0],
      setAnchorEl = _React$useState2[1];

  var track = props.track,
      className = props.className;
  var view = util.getContainingView(track);
  var session = util.getSession(track);
  var trackConf = track.configuration;
  var trackId = configuration.getConf(track, 'trackId');

  var handleClick = function handleClick(event) {
    setAnchorEl(event.currentTarget);
  };

  var handleClose = function handleClose() {
    setAnchorEl(null);
  };

  var onDragStart = function onDragStart(event) {
    var target = event.target;

    if (target.parentNode) {
      event.dataTransfer.setDragImage(target.parentNode, 20, 20);
      view.setDraggingTrackId(track.id);
    }
  };

  var onDragEnd = function onDragEnd() {
    view.setDraggingTrackId(undefined);
  };

  var trackName = configuration.getConf(track, 'name');

  if (configuration.getConf(track, 'type') === 'ReferenceSequenceTrack') {
    trackName = 'Reference Sequence';
    session.assemblies.forEach(function (assembly) {
      if (assembly.sequence === trackConf) {
        trackName = "Reference Sequence (".concat(configuration.readConfObject(assembly, 'name'), ")");
      }
    });
  }

  function handleMenuItemClick(_, callback) {
    callback();
    handleClose();
  }

  return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement(Paper, {
    ref: ref,
    className: clsx(className, classes.root)
  }, /*#__PURE__*/React__default.createElement("span", {
    draggable: true,
    className: classes.dragHandle,
    onDragStart: onDragStart,
    onDragEnd: onDragEnd,
    "data-testid": "dragHandle-".concat(view.id, "-").concat(trackId)
  }, /*#__PURE__*/React__default.createElement(DragIcon, {
    className: classes.dragHandleIcon
  })), /*#__PURE__*/React__default.createElement(IconButton, {
    onClick: function onClick() {
      return view.hideTrack(trackId);
    },
    className: classes.iconButton,
    title: "close this track",
    color: "secondary"
  }, /*#__PURE__*/React__default.createElement(CloseIcon, null)), /*#__PURE__*/React__default.createElement(Typography, {
    variant: "body1",
    component: "span",
    className: classes.trackName
  }, trackName), /*#__PURE__*/React__default.createElement(IconButton, {
    "aria-controls": "simple-menu",
    "aria-haspopup": "true",
    onClick: handleClick,
    className: classes.iconButton,
    color: "secondary",
    "data-testid": "track_menu_icon",
    disabled: !track.trackMenuItems.length
  }, /*#__PURE__*/React__default.createElement(MoreVertIcon, null))), /*#__PURE__*/React__default.createElement(ui.Menu, {
    anchorEl: anchorEl,
    onMenuItemClick: handleMenuItemClick,
    open: Boolean(anchorEl),
    onClose: handleClose,
    menuItems: [].concat(_toConsumableArray(session.getTrackActionMenuItems ? session.getTrackActionMenuItems(trackConf) : []), _toConsumableArray(track.trackMenuItems)).sort(function (a, b) {
      return (b.priority || 0) - (a.priority || 0);
    })
  }));
});
var TrackLabel$1 = /*#__PURE__*/mobxReact.observer(TrackLabel);

var useStyles$a = /*#__PURE__*/styles.makeStyles(function (theme) {
  return {
    root: {},
    resizeHandle: {
      height: RESIZE_HANDLE_HEIGHT,
      boxSizing: 'border-box',
      position: 'relative',
      zIndex: 2
    },
    overlay: {
      pointerEvents: 'none',
      position: 'absolute',
      top: 0,
      left: 0,
      width: '100%',
      zIndex: 3,
      borderRadius: theme.shape.borderRadius
    },
    renderingComponentContainer: {
      position: 'absolute',
      // -1 offset because of the 1px border of the Paper
      left: -1,
      height: '100%',
      width: '100%'
    },
    trackLabel: {
      zIndex: 3,
      margin: theme.spacing(1)
    },
    trackLabelInline: {
      position: 'relative',
      display: 'inline-block'
    },
    trackLabelOverlap: {
      position: 'absolute'
    },
    trackRenderingContainer: {
      overflowY: 'auto',
      overflowX: 'hidden',
      whiteSpace: 'nowrap',
      position: 'relative',
      background: 'none',
      zIndex: 2,
      boxSizing: 'content-box'
    }
  };
});

function TrackContainer(props) {
  var classes = useStyles$a();
  var model = props.model,
      track = props.track;
  var display = track.displays[0];
  var horizontalScroll = model.horizontalScroll,
      draggingTrackId = model.draggingTrackId,
      moveTrack = model.moveTrack;
  var height = display.height;
  var view = util.getContainingView(display);
  var trackId = configuration.getConf(track, 'trackId');
  var ref = React.useRef(null);
  React.useEffect(function () {
    if (ref.current) {
      model.trackRefs[trackId] = ref.current;
    }

    return function () {
      delete model.trackRefs[trackId];
    };
  }, [model.trackRefs, trackId]);

  function onDragEnter() {
    if (draggingTrackId !== undefined && mobxStateTree.isAlive(display) && draggingTrackId !== display.id) {
      moveTrack(draggingTrackId, track.id);
    }
  }

  var debouncedOnDragEnter = util.useDebouncedCallback(onDragEnter, 100);
  var RenderingComponent = display.RenderingComponent,
      DisplayBlurb = display.DisplayBlurb;
  var dimmed = draggingTrackId !== undefined && draggingTrackId !== display.id;
  return /*#__PURE__*/React__default.createElement("div", {
    className: classes.root
  }, view.trackLabels !== 'hidden' ? /*#__PURE__*/React__default.createElement(TrackLabel$1, {
    track: track,
    className: clsx(classes.trackLabel, view.trackLabels === 'overlapping' ? classes.trackLabelOverlap : classes.trackLabelInline)
  }) : null, /*#__PURE__*/React__default.createElement(Paper, {
    variant: "outlined",
    className: classes.trackRenderingContainer,
    style: {
      height: height
    },
    onScroll: function onScroll(event) {
      var target = event.target;
      display.setScrollTop(target.scrollTop);
    },
    onDragEnter: debouncedOnDragEnter,
    "data-testid": "trackRenderingContainer-".concat(view.id, "-").concat(trackId),
    role: "presentation"
  }, /*#__PURE__*/React__default.createElement("div", {
    ref: ref,
    className: classes.renderingComponentContainer,
    style: {
      transform: "scaleX(".concat(model.scaleFactor, ")")
    }
  }, /*#__PURE__*/React__default.createElement(RenderingComponent, {
    model: display,
    blockState: {},
    onHorizontalScroll: horizontalScroll
  })), DisplayBlurb ? /*#__PURE__*/React__default.createElement("div", {
    style: {
      position: 'absolute',
      left: 0,
      top: display.height - 20
    }
  }, ' ', /*#__PURE__*/React__default.createElement(DisplayBlurb, {
    model: display
  })) : null), /*#__PURE__*/React__default.createElement("div", {
    className: classes.overlay,
    style: {
      height: display.height,
      background: dimmed ? 'rgba(0, 0, 0, 0.4)' : undefined
    },
    onDragEnter: debouncedOnDragEnter
  }), /*#__PURE__*/React__default.createElement(ui.ResizeHandle, {
    onDrag: display.resizeHeight,
    className: classes.resizeHandle
  }));
}

var TrackContainer$1 = /*#__PURE__*/mobxReact.observer(TrackContainer);

var useStyles$b = /*#__PURE__*/styles.makeStyles(function (theme) {
  var background = theme.palette.tertiary ? colorManipulator.fade(theme.palette.tertiary.main, 0.7) : colorManipulator.fade(theme.palette.primary.main, 0.7);
  return {
    rubberBand: {
      height: '100%',
      background: background,
      position: 'absolute',
      zIndex: 10,
      textAlign: 'center',
      overflow: 'hidden'
    },
    rubberBandControl: {
      cursor: 'crosshair',
      width: '100%',
      minHeight: 8
    },
    rubberBandText: {
      color: theme.palette.tertiary ? theme.palette.tertiary.contrastText : theme.palette.primary.contrastText
    },
    popover: {
      mouseEvents: 'none',
      cursor: 'crosshair'
    },
    paper: {
      paddingLeft: theme.spacing(1),
      paddingRight: theme.spacing(1)
    },
    guide: {
      pointerEvents: 'none',
      height: '100%',
      width: 1,
      position: 'absolute',
      zIndex: 10
    }
  };
});
var VerticalGuide = /*#__PURE__*/mobxReact.observer(function (_ref) {
  var model = _ref.model,
      coordX = _ref.coordX;
  var classes = useStyles$b();
  return /*#__PURE__*/React__default.createElement(Tooltip$1, {
    open: true,
    placement: "top",
    title: util.stringify(model.pxToBp(coordX)),
    arrow: true
  }, /*#__PURE__*/React__default.createElement("div", {
    className: classes.guide,
    style: {
      left: coordX,
      background: 'red'
    }
  }));
});

function RubberBand(_ref2) {
  var model = _ref2.model,
      _ref2$ControlComponen = _ref2.ControlComponent,
      ControlComponent = _ref2$ControlComponen === void 0 ? /*#__PURE__*/React__default.createElement("div", null) : _ref2$ControlComponen;

  var _useState = React.useState(),
      _useState2 = _slicedToArray(_useState, 2),
      startX = _useState2[0],
      setStartX = _useState2[1];

  var _useState3 = React.useState(),
      _useState4 = _slicedToArray(_useState3, 2),
      currentX = _useState4[0],
      setCurrentX = _useState4[1]; // clientX and clientY used for anchorPosition for menu
  // offsetX used for calculations about width of selection


  var _useState5 = React.useState(),
      _useState6 = _slicedToArray(_useState5, 2),
      anchorPosition = _useState6[0],
      setAnchorPosition = _useState6[1];

  var _useState7 = React.useState(),
      _useState8 = _slicedToArray(_useState7, 2),
      guideX = _useState8[0],
      setGuideX = _useState8[1];

  var controlsRef = React.useRef(null);
  var rubberBandRef = React.useRef(null);
  var classes = useStyles$b();
  var mouseDragging = startX !== undefined && anchorPosition === undefined;
  React.useEffect(function () {
    function globalMouseMove(event) {
      if (controlsRef.current && mouseDragging) {
        var relativeX = event.clientX - controlsRef.current.getBoundingClientRect().left;
        setCurrentX(relativeX);
      }
    }

    function globalMouseUp(event) {
      if (startX !== undefined && controlsRef.current) {
        var clientX = event.clientX,
            clientY = event.clientY;
        var ref = controlsRef.current;
        var offsetX = clientX - ref.getBoundingClientRect().left; // as stated above, store both clientX/Y and offsetX for different
        // purposes

        setAnchorPosition({
          offsetX: offsetX,
          clientX: clientX,
          clientY: clientY
        });
        setGuideX(undefined);
      }
    }

    if (mouseDragging) {
      window.addEventListener('mousemove', globalMouseMove);
      window.addEventListener('mouseup', globalMouseUp);
      return function () {
        window.removeEventListener('mousemove', globalMouseMove);
        window.removeEventListener('mouseup', globalMouseUp);
      };
    }

    return function () {};
  }, [startX, mouseDragging, anchorPosition]);
  React.useEffect(function () {
    if (!mouseDragging && currentX !== undefined && startX !== undefined && Math.abs(currentX - startX) <= 3) {
      handleClose();
    }
  }, [mouseDragging, currentX, startX, model.bpPerPx]);

  function mouseDown(event) {
    event.preventDefault();
    event.stopPropagation();
    var relativeX = event.clientX - event.target.getBoundingClientRect().left;
    setStartX(relativeX);
    setCurrentX(relativeX);
  }

  function mouseMove(event) {
    var target = event.target;
    setGuideX(event.clientX - target.getBoundingClientRect().left);
  }

  function mouseOut() {
    setGuideX(undefined);
    model.setOffsets(undefined, undefined);
  }

  function zoomToRegion() {
    if (startX === undefined || anchorPosition === undefined) {
      return;
    }

    var leftPx = startX;
    var rightPx = anchorPosition.offsetX;

    if (rightPx < leftPx) {
      var _ref3 = [rightPx, leftPx];
      leftPx = _ref3[0];
      rightPx = _ref3[1];
    }

    var leftOffset = model.pxToBp(leftPx);
    var rightOffset = model.pxToBp(rightPx);
    model.moveTo(leftOffset, rightOffset);
  }

  function getSequence() {
    if (startX === undefined || anchorPosition === undefined) {
      return;
    }

    var leftPx = startX;
    var rightPx = anchorPosition.offsetX; // handles clicking and draging to the left

    if (rightPx < leftPx) {
      var _ref4 = [rightPx, leftPx];
      leftPx = _ref4[0];
      rightPx = _ref4[1];
    }

    var leftOffset = model.pxToBp(leftPx);
    var rightOffset = model.pxToBp(rightPx);
    model.setOffsets(leftOffset, rightOffset);
  }

  function handleClose() {
    setAnchorPosition(undefined);
    setStartX(undefined);
    setCurrentX(undefined);
  }

  var open = Boolean(anchorPosition);

  function handleMenuItemClick(_, callback) {
    callback();
    handleClose();
  }

  var menuItems = [{
    label: 'Zoom to region',
    icon: ZoomIn,
    onClick: function onClick() {
      zoomToRegion();
      handleClose();
    }
  }, {
    label: 'Get sequence',
    disabled: currentX !== undefined && startX !== undefined && Math.abs(currentX - startX) * model.bpPerPx > 500000000,
    icon: MenuOpenIcon,
    onClick: function onClick() {
      getSequence();
      handleClose();
    }
  }];

  if (startX === undefined) {
    return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, guideX !== undefined ? /*#__PURE__*/React__default.createElement(VerticalGuide, {
      model: model,
      coordX: guideX
    }) : null, /*#__PURE__*/React__default.createElement("div", {
      "data-testid": "rubberBand_controls",
      className: classes.rubberBandControl,
      role: "presentation",
      ref: controlsRef,
      onMouseDown: mouseDown,
      onMouseOut: mouseOut,
      onMouseMove: mouseMove
    }, ControlComponent));
  }
  /* Calculating Pixels for Mouse Dragging */


  var right = anchorPosition ? anchorPosition.offsetX : currentX || 0;
  var left = right < startX ? right : startX;
  var width = Math.abs(right - startX);
  var leftBpOffset = model.pxToBp(left);
  var rightBpOffset = model.pxToBp(left + width);
  var numOfBpSelected = Math.ceil(width * model.bpPerPx);
  return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, rubberBandRef.current ? /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement(Popover, {
    className: classes.popover,
    classes: {
      paper: classes.paper
    },
    open: true,
    anchorEl: rubberBandRef.current,
    anchorOrigin: {
      vertical: 'top',
      horizontal: 'left'
    },
    transformOrigin: {
      vertical: 'bottom',
      horizontal: 'right'
    },
    keepMounted: true,
    disableRestoreFocus: true
  }, /*#__PURE__*/React__default.createElement(Typography, null, util.stringify(leftBpOffset))), /*#__PURE__*/React__default.createElement(Popover, {
    className: classes.popover,
    classes: {
      paper: classes.paper
    },
    open: true,
    anchorEl: rubberBandRef.current,
    anchorOrigin: {
      vertical: 'top',
      horizontal: 'right'
    },
    transformOrigin: {
      vertical: 'bottom',
      horizontal: 'left'
    },
    keepMounted: true,
    disableRestoreFocus: true
  }, /*#__PURE__*/React__default.createElement(Typography, null, util.stringify(rightBpOffset)))) : null, /*#__PURE__*/React__default.createElement("div", {
    ref: rubberBandRef,
    className: classes.rubberBand,
    style: {
      left: left,
      width: width
    }
  }, /*#__PURE__*/React__default.createElement(Typography, {
    variant: "h6",
    className: classes.rubberBandText
  }, numOfBpSelected.toLocaleString('en-US'), " bp")), /*#__PURE__*/React__default.createElement("div", {
    "data-testid": "rubberBand_controls",
    className: classes.rubberBandControl,
    role: "presentation",
    ref: controlsRef,
    onMouseDown: mouseDown,
    onMouseOut: mouseOut,
    onMouseMove: mouseMove
  }, ControlComponent), anchorPosition ? /*#__PURE__*/React__default.createElement(ui.Menu, {
    anchorReference: "anchorPosition",
    anchorPosition: {
      left: anchorPosition.clientX,
      top: anchorPosition.clientY
    },
    onMenuItemClick: handleMenuItemClick,
    open: open,
    onClose: handleClose,
    menuItems: menuItems
  }) : null);
}

RubberBand.propTypes = {
  model: mobxReact.PropTypes.objectOrObservableObject.isRequired,
  ControlComponent: ReactPropTypes.node
};
RubberBand.defaultProps = {
  ControlComponent: /*#__PURE__*/React__default.createElement("div", null)
};
var RubberBand$1 = /*#__PURE__*/mobxReact.observer(RubberBand);

var useStyles$c = /*#__PURE__*/styles.makeStyles(function (theme) {
  return {
    scaleBarContainer: {
      overflow: 'hidden',
      position: 'relative'
    },
    scaleBarZoomContainer: {
      position: 'relative',
      zIndex: 1
    },
    scaleBar: {
      position: 'absolute',
      display: 'flex',
      pointerEvents: 'none'
    },
    majorTickLabel: {
      fontSize: '11px',
      zIndex: 1,
      background: theme.palette.background.paper,
      lineHeight: 'normal',
      pointerEvents: 'none'
    },
    tick: {
      position: 'absolute',
      width: 0,
      display: 'flex',
      justifyContent: 'center',
      pointerEvents: 'none'
    },
    refLabel: {
      fontSize: '11px',
      position: 'absolute',
      left: '2px',
      top: '-1px',
      fontWeight: 'bold',
      lineHeight: 'normal',
      zIndex: 1,
      pointerEvents: 'none',
      background: theme.palette.background.paper
    }
  };
});
var RenderedRefNameLabels = /*#__PURE__*/mobxReact.observer(function (_ref) {
  var model = _ref.model;
  var classes = useStyles$c(); // find the block that needs pinning to the left side for context

  var lastLeftBlock = 0;
  model.staticBlocks.forEach(function (block, i) {
    if (block.offsetPx - model.offsetPx < 0) {
      lastLeftBlock = i;
    }
  });
  return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, model.staticBlocks.map(function (block, index) {
    return block instanceof blockTypes.ContentBlock && (block.isLeftEndOfDisplayedRegion || index === lastLeftBlock) ? /*#__PURE__*/React__default.createElement(Typography, {
      key: "refLabel-".concat(block.key, "-").concat(index),
      style: {
        left: index === lastLeftBlock ? Math.max(0, -model.offsetPx) : block.offsetPx - model.offsetPx - 1,
        paddingLeft: index === lastLeftBlock ? 0 : 1
      },
      className: classes.refLabel,
      "data-testid": "refLabel-".concat(block.refName)
    }, block.refName) : null;
  }));
});
var RenderedScaleBarLabels = /*#__PURE__*/mobxReact.observer(function (_ref2) {
  var model = _ref2.model;
  var classes = useStyles$c();
  return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, model.staticBlocks.map(function (block, index) {
    if (block instanceof blockTypes.ContentBlock) {
      var ticks = makeTicks(block.start, block.end, model.bpPerPx, true, false);
      return /*#__PURE__*/React__default.createElement(ContentBlock, {
        key: "".concat(block.key, "-").concat(index),
        block: block
      }, ticks.map(function (tick) {
        if (tick.type === 'major') {
          var x = (block.reversed ? block.end - tick.base : tick.base - block.start) / model.bpPerPx;
          var baseNumber = (tick.base + 1).toLocaleString('en-US');
          return /*#__PURE__*/React__default.createElement("div", {
            key: tick.base,
            className: classes.tick,
            style: {
              left: x
            }
          }, baseNumber ? /*#__PURE__*/React__default.createElement(Typography, {
            className: classes.majorTickLabel
          }, baseNumber) : null);
        }

        return null;
      }));
    }

    if (block instanceof blockTypes.ElidedBlock) {
      return /*#__PURE__*/React__default.createElement(ElidedBlock, {
        key: block.key,
        width: block.widthPx
      });
    }

    if (block instanceof blockTypes.InterRegionPaddingBlock) {
      return /*#__PURE__*/React__default.createElement(InterRegionPaddingBlock, {
        key: block.key,
        width: block.widthPx,
        style: {
          background: 'none'
        },
        boundary: block.variant === 'boundary'
      });
    }

    return null;
  }));
});
var ScaleBar$1 = /*#__PURE__*/React__default.forwardRef(function (_ref3, ref) {
  var model = _ref3.model,
      style = _ref3.style,
      className = _ref3.className,
      other = _objectWithoutProperties(_ref3, ["model", "style", "className"]);

  var classes = useStyles$c();
  var offsetLeft = model.staticBlocks.offsetPx - model.offsetPx;
  return /*#__PURE__*/React__default.createElement(Paper, Object.assign({
    "data-resizer": "true" // used to avoid click-and-drag scrolls on trackscontainer
    ,
    className: clsx(classes.scaleBarContainer, className),
    variant: "outlined",
    ref: ref,
    style: style
  }, other), /*#__PURE__*/React__default.createElement("div", {
    className: classes.scaleBarZoomContainer,
    style: {
      transform: model.scaleFactor !== 1 ? "scaleX(".concat(model.scaleFactor, ")") : undefined
    }
  }, /*#__PURE__*/React__default.createElement("div", {
    className: classes.scaleBar,
    style: _objectSpread2({
      left: offsetLeft - 1,
      width: model.staticBlocks.totalWidthPx
    }, style)
  }, /*#__PURE__*/React__default.createElement(RenderedScaleBarLabels, {
    model: model
  }))), /*#__PURE__*/React__default.createElement(RenderedRefNameLabels, {
    model: model
  }));
});
var ScaleBar$2 = /*#__PURE__*/mobxReact.observer(ScaleBar$1);

var useStyles$d = /*#__PURE__*/styles.makeStyles(function (theme) {
  return {
    verticalGuidesZoomContainer: {
      position: 'absolute',
      height: '100%',
      width: '100%',
      zIndex: 1,
      pointerEvents: 'none'
    },
    verticalGuidesContainer: {
      position: 'absolute',
      height: '100%',
      zIndex: 1,
      pointerEvents: 'none',
      display: 'flex'
    },
    tick: {
      position: 'absolute',
      height: '100%',
      width: 1
    },
    majorTick: {
      background: theme.palette.text.hint
    },
    minorTick: {
      background: theme.palette.divider
    }
  };
});
var RenderedVerticalGuides = /*#__PURE__*/mobxReact.observer(function (_ref) {
  var model = _ref.model;
  var classes = useStyles$d();
  return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, model.staticBlocks.map(function (block, index) {
    if (block instanceof blockTypes.ContentBlock) {
      var ticks = makeTicks(block.start, block.end, model.bpPerPx);
      return /*#__PURE__*/React__default.createElement(ContentBlock, {
        key: "".concat(block.key, "-").concat(index),
        block: block
      }, ticks.map(function (tick) {
        var x = (block.reversed ? block.end - tick.base : tick.base - block.start) / model.bpPerPx;
        return /*#__PURE__*/React__default.createElement("div", {
          key: tick.base,
          className: clsx(classes.tick, tick.type === 'major' || tick.type === 'labeledMajor' ? classes.majorTick : classes.minorTick),
          style: {
            left: x
          }
        });
      }));
    }

    if (block instanceof blockTypes.ElidedBlock) {
      return /*#__PURE__*/React__default.createElement(ElidedBlock, {
        key: block.key,
        width: block.widthPx
      });
    }

    if (block instanceof blockTypes.InterRegionPaddingBlock) {
      return /*#__PURE__*/React__default.createElement(InterRegionPaddingBlock, {
        key: block.key,
        width: block.widthPx,
        boundary: block.variant === 'boundary'
      });
    }

    return null;
  }));
});

function VerticalGuides(_ref2) {
  var model = _ref2.model;
  var classes = useStyles$d(); // find the block that needs pinning to the left side for context

  var offsetLeft = model.staticBlocks.offsetPx - model.offsetPx;
  return /*#__PURE__*/React__default.createElement("div", {
    className: classes.verticalGuidesZoomContainer,
    style: {
      transform: model.scaleFactor !== 1 ? "scaleX(".concat(model.scaleFactor, ")") : undefined
    }
  }, /*#__PURE__*/React__default.createElement("div", {
    className: classes.verticalGuidesContainer,
    style: {
      left: offsetLeft,
      width: model.staticBlocks.totalWidthPx
    }
  }, /*#__PURE__*/React__default.createElement(RenderedVerticalGuides, {
    model: model
  })));
}

var VerticalGuides$1 = /*#__PURE__*/mobxReact.observer(VerticalGuides);

var useStyles$e = /*#__PURE__*/styles.makeStyles(function () {
  return {
    centerLineContainer: {
      background: 'transparent',
      height: '100%',
      zIndex: 5,
      position: 'absolute',
      border: '1px black dashed',
      borderTop: 'none',
      borderBottom: 'none',
      pointerEvents: 'none'
    },
    centerLineText: {
      position: 'absolute',
      pointerEvents: 'none',
      whiteSpace: 'nowrap',
      fontWeight: 'bold'
    }
  };
});

function CenterLine(_ref) {
  var model = _ref.model;
  var bpPerPx = model.bpPerPx,
      centerLineInfo = model.centerLineInfo,
      trackHeights = model.trackHeights,
      tracks = model.tracks,
      width = model.width;
  var ref = React.useRef(null);
  var classes = useStyles$e();
  var startingPosition = width / 2;
  return tracks.length ? /*#__PURE__*/React__default.createElement("div", {
    "data-testid": "centerline_container",
    className: classes.centerLineContainer,
    role: "presentation",
    ref: ref,
    style: {
      left: "".concat(startingPosition, "px"),
      width: Math.max(1 / bpPerPx, 1)
    }
  }, centerLineInfo && /*#__PURE__*/React__default.createElement("div", {
    "data-testid": "centerline_text",
    className: classes.centerLineText,
    role: "presentation",
    style: {
      left: Math.max(1 / bpPerPx, 1) + 5,
      top: trackHeights
    }
  }, centerLineInfo.refName, ":", ' ', Math.max(Math.round(centerLineInfo.offset) + 1, 0))) : null;
}

CenterLine.propTypes = {
  model: mobxReact.PropTypes.objectOrObservableObject.isRequired
};
var CenterLine$1 = /*#__PURE__*/mobxReact.observer(CenterLine);

var useStyles$f = /*#__PURE__*/styles.makeStyles(function (theme) {
  return {
    tracksContainer: {
      position: 'relative',
      borderRadius: theme.shape.borderRadius,
      overflow: 'hidden'
    },
    spacer: {
      position: 'relative',
      height: RESIZE_HANDLE_HEIGHT
    }
  };
});

function TracksContainer(_ref) {
  var children = _ref.children,
      model = _ref.model;
  var classes = useStyles$f(); // refs are to store these variables to avoid repeated rerenders associated
  // with useState/setState

  var delta = React.useRef(0);
  var scheduled = React.useRef(false);
  var timeout = React.useRef();
  var ref = React.useRef(null);
  var prevX = React.useRef(0);

  var _useState = React.useState(false),
      _useState2 = _slicedToArray(_useState, 2),
      mouseDragging = _useState2[0],
      setMouseDragging = _useState2[1];

  React.useEffect(function () {
    var cleanup = function cleanup() {};

    function globalMouseMove(event) {
      event.preventDefault();
      var currX = event.clientX;
      var distance = currX - prevX.current;

      if (distance) {
        // use rAF to make it so multiple event handlers aren't fired per-frame
        // see https://calendar.perfplanet.com/2013/the-runtime-performance-checklist/
        if (!scheduled.current) {
          scheduled.current = true;
          window.requestAnimationFrame(function () {
            model.horizontalScroll(-distance);
            scheduled.current = false;
            prevX.current = event.clientX;
          });
        }
      }
    }

    function globalMouseUp() {
      prevX.current = 0;

      if (mouseDragging) {
        setMouseDragging(false);
      }
    }

    if (mouseDragging) {
      window.addEventListener('mousemove', globalMouseMove, true);
      window.addEventListener('mouseup', globalMouseUp, true);

      cleanup = function cleanup() {
        window.removeEventListener('mousemove', globalMouseMove, true);
        window.removeEventListener('mouseup', globalMouseUp, true);
      };
    }

    return cleanup;
  }, [model, mouseDragging, prevX]);

  function mouseDown(event) {
    // check if clicking a draggable element or a resize handle
    var target = event.target;

    if (target.draggable || target.dataset.resizer) {
      return;
    } // otherwise do click and drag scroll


    if (event.button === 0) {
      prevX.current = event.clientX;
      setMouseDragging(true);
    }
  } // this local mouseup is used in addition to the global because sometimes
  // the global add/remove are not called in time, resulting in issue #533


  function mouseUp(event) {
    event.preventDefault();
    setMouseDragging(false);
  }

  function mouseLeave(event) {
    event.preventDefault();
  }

  React.useEffect(function () {
    var curr = ref.current; // if ctrl is held down, zoom in with y-scroll
    // else scroll horizontally with x-scroll

    function onWheel(origEvent) {
      var event = normalizeWheel(origEvent);

      if (origEvent.ctrlKey === true) {
        origEvent.preventDefault();
        delta.current += event.pixelY / 500;
        model.setScaleFactor(delta.current < 0 ? 1 - delta.current : 1 / (1 + delta.current));

        if (timeout.current) {
          clearTimeout(timeout.current);
        }

        timeout.current = setTimeout(function () {
          model.setScaleFactor(1);
          model.zoomTo(delta.current > 0 ? model.bpPerPx * (1 + delta.current) : model.bpPerPx / (1 - delta.current));
          delta.current = 0;
        }, 300);
      } else {
        // this is needed to stop the event from triggering "back button
        // action" on MacOSX etc.  but is a heuristic to avoid preventing the
        // inner-track scroll behavior
        if (Math.abs(event.pixelX) > Math.abs(2 * event.pixelY)) {
          origEvent.preventDefault();
        }

        delta.current += event.pixelX;

        if (!scheduled.current) {
          // use rAF to make it so multiple event handlers aren't fired per-frame
          // see https://calendar.perfplanet.com/2013/the-runtime-performance-checklist/
          scheduled.current = true;
          window.requestAnimationFrame(function () {
            model.horizontalScroll(delta.current);
            delta.current = 0;
            scheduled.current = false;
          });
        }
      }
    }

    if (curr) {
      curr.addEventListener('wheel', onWheel);
      return function () {
        curr.removeEventListener('wheel', onWheel);
      };
    }

    return function () {};
  }, [model]);
  return /*#__PURE__*/React__default.createElement("div", {
    ref: ref,
    role: "presentation",
    className: classes.tracksContainer,
    onMouseDown: mouseDown,
    onMouseUp: mouseUp,
    onMouseLeave: mouseLeave
  }, /*#__PURE__*/React__default.createElement(VerticalGuides$1, {
    model: model
  }), model.showCenterLine ? /*#__PURE__*/React__default.createElement(CenterLine$1, {
    model: model
  }) : null, /*#__PURE__*/React__default.createElement(RubberBand$1, {
    model: model,
    ControlComponent: /*#__PURE__*/React__default.createElement(ScaleBar$2, {
      model: model,
      style: {
        height: SCALE_BAR_HEIGHT,
        boxSizing: 'border-box'
      }
    })
  }), /*#__PURE__*/React__default.createElement("div", {
    className: classes.spacer
  }), children);
}

var TracksContainer$1 = /*#__PURE__*/mobxReact.observer(TracksContainer);

var useStyles$g = /*#__PURE__*/styles.makeStyles(function (theme) {
  return {
    dialogContent: {
      width: '80em'
    },
    closeButton: {
      position: 'absolute',
      right: theme.spacing(1),
      top: theme.spacing(1),
      color: theme.palette.grey[500]
    }
  };
});
function SearchResultsDialog(_ref) {
  var _model$searchResults;

  var model = _ref.model,
      optAssemblyName = _ref.optAssemblyName,
      handleClose = _ref.handleClose;
  var classes = useStyles$g();
  var session = util.getSession(model);

  var _getEnv = mobxStateTree.getEnv(session),
      pluginManager = _getEnv.pluginManager;

  var assemblyManager = session.assemblyManager;
  var assemblyName = optAssemblyName;

  if (model.displayedRegions.length > 0) {
    var _model$displayedRegio;

    assemblyName = (_model$displayedRegio = model.displayedRegions[0]) === null || _model$displayedRegio === void 0 ? void 0 : _model$displayedRegio.assemblyName;
  }

  if (!assemblyName) {
    throw new Error("Assembly name not found");
  }

  var assembly = assemblyManager.get(assemblyName);

  if (!assembly) {
    throw new Error("assembly ".concat(assemblyName, " not found"));
  }

  if (!assembly.regions) {
    throw new Error("assembly ".concat(assemblyName, " regions not loaded"));
  }

  var assemblyRegions = assembly.regions;

  function handleClick(location) {
    try {
      var newRegion = assemblyRegions.find(function (region) {
        return location === region.refName;
      });

      if (newRegion) {
        model.setDisplayedRegions([newRegion]); // we use showAllRegions after setDisplayedRegions to make the entire
        // region visible, xref #1703

        model.showAllRegions();
      } else {
        model.navToLocString(location, assemblyName);
      }
    } catch (e) {
      console.warn(e);
      session.notify("".concat(e), 'warning');
    }
  }

  function handleShowTrack(trackId) {
    var trackConfigSchema = pluginManager.pluggableConfigSchemaType('track');
    var configuration = mobxStateTree.resolveIdentifier(trackConfigSchema, mobxStateTree.getRoot(model), trackId); // check if we have any tracks with that configuration

    var shownTracks = model.tracks.filter(function (t) {
      return t.configuration === configuration;
    });

    if (shownTracks.length === 0) {
      model.showTrack(trackId);
    }
  }

  function getTrackName(trackId) {
    if (trackId) {
      var trackConfigSchema = pluginManager.pluggableConfigSchemaType('track');
      var configuration = mobxStateTree.resolveIdentifier(trackConfigSchema, mobxStateTree.getRoot(model), trackId);

      if (configuration) {
        var _configuration$name;

        return (_configuration$name = configuration.name) === null || _configuration$name === void 0 ? void 0 : _configuration$name.value;
      }
    }

    return '';
  }

  return /*#__PURE__*/React__default.createElement(core.Dialog, {
    open: true,
    maxWidth: "xl",
    onClose: handleClose
  }, /*#__PURE__*/React__default.createElement(core.DialogTitle, {
    id: "search-results-dialog"
  }, "Search Results", handleClose ? /*#__PURE__*/React__default.createElement(core.IconButton, {
    "data-testid": "close-resultsDialog",
    className: classes.closeButton,
    onClick: function onClick() {
      handleClose();
    }
  }, /*#__PURE__*/React__default.createElement(CloseIcon, null)) : null), /*#__PURE__*/React__default.createElement(core.Divider, null), /*#__PURE__*/React__default.createElement(core.DialogContent, null, ((_model$searchResults = model.searchResults) === null || _model$searchResults === void 0 ? void 0 : _model$searchResults.length) === 0 || model.searchResults === undefined ? /*#__PURE__*/React__default.createElement(core.Typography, null, "No results found for ", /*#__PURE__*/React__default.createElement("b", null, model.searchQuery)) : /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement(core.DialogContentText, {
    id: "alert-dialog-slide-description"
  }, "Showing results for ", /*#__PURE__*/React__default.createElement("b", null, model.searchQuery)), /*#__PURE__*/React__default.createElement(core.TableContainer, {
    component: core.Paper
  }, /*#__PURE__*/React__default.createElement(core.Table, null, /*#__PURE__*/React__default.createElement(core.TableHead, null, /*#__PURE__*/React__default.createElement(core.TableRow, null, /*#__PURE__*/React__default.createElement(core.TableCell, null, "Name"), /*#__PURE__*/React__default.createElement(core.TableCell, {
    align: "right"
  }, "Location"), /*#__PURE__*/React__default.createElement(core.TableCell, {
    align: "right"
  }, "Track"), /*#__PURE__*/React__default.createElement(core.TableCell, {
    align: "right"
  }))), /*#__PURE__*/React__default.createElement(core.TableBody, null, model.searchResults.map(function (result, index) {
    return /*#__PURE__*/React__default.createElement(core.TableRow, {
      key: "".concat(result.getLabel(), "-").concat(index)
    }, /*#__PURE__*/React__default.createElement(core.TableCell, {
      component: "th",
      scope: "row"
    }, result.getLabel()), /*#__PURE__*/React__default.createElement(core.TableCell, {
      align: "right"
    }, result.getLocation()), /*#__PURE__*/React__default.createElement(core.TableCell, {
      align: "right"
    }, getTrackName(result.getTrackId()) || 'N/A'), /*#__PURE__*/React__default.createElement(core.TableCell, {
      align: "right"
    }, /*#__PURE__*/React__default.createElement(core.Button, {
      onClick: function onClick() {
        handleClick(result.getLocation());
        handleClose();
      },
      color: "primary",
      variant: "contained"
    }, "Go to location")), /*#__PURE__*/React__default.createElement(core.TableCell, {
      align: "right"
    }, /*#__PURE__*/React__default.createElement(core.Button, {
      onClick: function onClick() {
        handleClick(result.getLocation());
        var resultTrackId = result.getTrackId();

        if (resultTrackId) {
          handleShowTrack(resultTrackId);
        }

        handleClose();
      },
      disabled: !getTrackName(result.getTrackId()),
      color: "primary",
      variant: "contained"
    }, "Show Track")));
  })))))), /*#__PURE__*/React__default.createElement(core.Divider, null), /*#__PURE__*/React__default.createElement(core.DialogActions, null, /*#__PURE__*/React__default.createElement(core.Button, {
    onClick: function onClick() {
      handleClose();
    },
    color: "primary"
  }, "Cancel")));
}

var useStyles$h = /*#__PURE__*/styles.makeStyles(function (theme) {
  return {
    importFormContainer: {
      padding: theme.spacing(2)
    },
    importFormEntry: {
      minWidth: 180
    },
    button: {
      margin: theme.spacing(2)
    }
  };
});
var ImportForm = /*#__PURE__*/mobxReact.observer(function (_ref) {
  var model = _ref.model;
  var classes = useStyles$h();
  var session = util.getSession(model);
  var assemblyNames = session.assemblyNames,
      assemblyManager = session.assemblyManager;

  var _getEnv = mobxStateTree.getEnv(session),
      pluginManager = _getEnv.pluginManager;

  var textSearchManager = pluginManager.rootModel.textSearchManager;
  var rankSearchResults = model.rankSearchResults;

  var _useState = React.useState(0),
      _useState2 = _slicedToArray(_useState, 2),
      selectedAssemblyIdx = _useState2[0],
      setSelectedAssemblyIdx = _useState2[1];

  var _useState3 = React.useState(undefined),
      _useState4 = _slicedToArray(_useState3, 2),
      selectedRegion = _useState4[0],
      setSelectedRegion = _useState4[1];

  var _useState5 = React.useState([]),
      _useState6 = _slicedToArray(_useState5, 2),
      assemblyRegions = _useState6[0],
      setAssemblyRegions = _useState6[1];

  var error = !assemblyNames.length ? 'No configured assemblies' : '';
  var hasError = Boolean(error);
  var assemblyName = assemblyNames[selectedAssemblyIdx];
  var displayName = assemblyName && !error ? selectedAssemblyIdx : '';
  var searchScope = model.searchScope(assemblyName);
  React.useEffect(function () {
    var done = false;

    _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee() {
      var assembly, regions;
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (!assemblyName) {
                _context.next = 5;
                break;
              }

              _context.next = 3;
              return assemblyManager.waitForAssembly(assemblyName);

            case 3:
              assembly = _context.sent;

              if (assembly && assembly.regions) {
                regions = assembly.regions;

                if (!done && regions) {
                  setSelectedRegion(regions[0].refName);
                  setAssemblyRegions(regions);
                }
              }

            case 5:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }))();

    return function () {
      done = true;
    };
  }, [assemblyManager, assemblyName]);

  function setSelectedValue(selectedOption) {
    setSelectedRegion(selectedOption.getLocation());
  }

  function handleSelectedRegion(_x) {
    return _handleSelectedRegion.apply(this, arguments);
  }

  function _handleSelectedRegion() {
    _handleSelectedRegion = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(input) {
      var newRegion, results;
      return runtime_1.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              newRegion = assemblyRegions.find(function (r) {
                return selectedRegion === r.refName;
              });

              if (!newRegion) {
                _context2.next = 6;
                break;
              }

              model.setDisplayedRegions([newRegion]); // we use showAllRegions after setDisplayedRegions to make the entire
              // region visible, xref #1703

              model.showAllRegions();
              _context2.next = 13;
              break;

            case 6:
              _context2.next = 8;
              return textSearchManager === null || textSearchManager === void 0 ? void 0 : textSearchManager.search({
                queryString: input.toLocaleLowerCase(),
                searchType: 'exact'
              }, searchScope, rankSearchResults);

            case 8:
              _context2.t0 = _context2.sent;

              if (_context2.t0) {
                _context2.next = 11;
                break;
              }

              _context2.t0 = [];

            case 11:
              results = _context2.t0;

              if (results.length > 0) {
                model.setSearchResults(results, input.toLocaleLowerCase());
              } else {
                try {
                  input && model.navToLocString(input, assemblyName);
                } catch (e) {
                  if ("".concat(e) === "Error: Unknown reference sequence \"".concat(input, "\"")) {
                    model.setSearchResults(results, input.toLocaleLowerCase());
                  } else {
                    console.warn(e);
                    session.notify("".concat(e), 'warning');
                  }
                }
              }

            case 13:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));
    return _handleSelectedRegion.apply(this, arguments);
  }

  return /*#__PURE__*/React__default.createElement("div", null, model.isSearchDialogDisplayed ? /*#__PURE__*/React__default.createElement(SearchResultsDialog, {
    model: model,
    optAssemblyName: assemblyName,
    handleClose: function handleClose() {
      model.setSearchResults(undefined, undefined);
    }
  }) : null, /*#__PURE__*/React__default.createElement(Container, {
    className: classes.importFormContainer
  }, /*#__PURE__*/React__default.createElement(Grid, {
    container: true,
    spacing: 1,
    justify: "center",
    alignItems: "center"
  }, /*#__PURE__*/React__default.createElement(Grid, {
    item: true
  }, /*#__PURE__*/React__default.createElement(TextField, {
    select: true,
    variant: "outlined",
    value: displayName,
    onChange: function onChange(event) {
      setSelectedAssemblyIdx(Number(event.target.value));
    },
    label: "Assembly",
    helperText: error || 'Select assembly to view',
    error: hasError,
    disabled: hasError,
    margin: "normal",
    className: classes.importFormEntry
  }, assemblyNames.map(function (name, idx) {
    return /*#__PURE__*/React__default.createElement(MenuItem, {
      key: name,
      value: idx
    }, name);
  }))), /*#__PURE__*/React__default.createElement(Grid, {
    item: true
  }, assemblyName ? selectedRegion !== undefined && model.volatileWidth ? /*#__PURE__*/React__default.createElement(RefNameAutocomplete$1, {
    model: model,
    assemblyName: error ? undefined : assemblyNames[selectedAssemblyIdx],
    value: selectedRegion,
    onSelect: function onSelect(option) {
      setSelectedValue(option);
    },
    TextFieldProps: {
      margin: 'normal',
      variant: 'outlined',
      className: classes.importFormEntry,
      helperText: 'Enter a sequence or locstring',
      onBlur: function onBlur(event) {
        if (event.target.value !== '') {
          setSelectedRegion(event.target.value);
        }
      },
      onKeyPress: function onKeyPress(event) {
        var inputValue = event.target.value; // maybe check regular expression here to see if it's a locstring
        // try defaulting exact matches to first exact match

        if (event.key === 'Enter') {
          handleSelectedRegion(inputValue);
        }
      }
    }
  }) : /*#__PURE__*/React__default.createElement(CircularProgress, {
    role: "progressbar",
    color: "inherit",
    size: 20,
    disableShrink: true
  }) : null), /*#__PURE__*/React__default.createElement(Grid, {
    item: true
  }, /*#__PURE__*/React__default.createElement(Button, {
    disabled: !selectedRegion,
    className: classes.button,
    onClick: function onClick() {
      if (selectedRegion) {
        handleSelectedRegion(selectedRegion);
      }
    },
    variant: "contained",
    color: "primary"
  }, "Open"), /*#__PURE__*/React__default.createElement(Button, {
    disabled: !selectedRegion,
    className: classes.button,
    onClick: function onClick() {
      model.showAllRegionsInAssembly(assemblyName);
    },
    variant: "contained",
    color: "secondary"
  }, "Show all regions in assembly")))));
});

var MiniControls = /*#__PURE__*/mobxReact.observer(function (props) {
  var model = props.model;
  var bpPerPx = model.bpPerPx,
      maxBpPerPx = model.maxBpPerPx,
      minBpPerPx = model.minBpPerPx,
      scaleFactor = model.scaleFactor;

  var _useState = React.useState(),
      _useState2 = _slicedToArray(_useState, 2),
      anchorEl = _useState2[0],
      setAnchorEl = _useState2[1];

  return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement(Paper, {
    style: {
      background: '#aaa7'
    }
  }, /*#__PURE__*/React__default.createElement(IconButton, {
    color: "secondary",
    onClick: function onClick(event) {
      setAnchorEl(event.currentTarget);
    }
  }, /*#__PURE__*/React__default.createElement(ArrowDown, null)), /*#__PURE__*/React__default.createElement(IconButton, {
    "data-testid": "zoom_out",
    onClick: function onClick() {
      model.zoom(bpPerPx * 2);
    },
    disabled: bpPerPx >= maxBpPerPx - 0.0001 || scaleFactor !== 1,
    color: "secondary"
  }, /*#__PURE__*/React__default.createElement(ZoomOut, null)), /*#__PURE__*/React__default.createElement(IconButton, {
    "data-testid": "zoom_in",
    onClick: function onClick() {
      model.zoom(model.bpPerPx / 2);
    },
    disabled: bpPerPx <= minBpPerPx + 0.0001 || scaleFactor !== 1,
    color: "secondary"
  }, /*#__PURE__*/React__default.createElement(ZoomIn, null))), /*#__PURE__*/React__default.createElement(Menu, {
    anchorEl: anchorEl,
    open: Boolean(anchorEl),
    onMenuItemClick: function onMenuItemClick(_, callback) {
      callback();
      setAnchorEl(undefined);
    },
    onClose: function onClose() {
      setAnchorEl(undefined);
    },
    menuItems: model.menuItems
  }));
});

var useStyles$i = /*#__PURE__*/styles.makeStyles(function (theme) {
  return {
    loadingMessage: {
      padding: theme.spacing(5)
    },
    closeButton: {
      position: 'absolute',
      right: theme.spacing(1),
      top: theme.spacing(1),
      color: theme.palette.grey[500]
    },
    dialogContent: {
      width: '80em'
    },
    textAreaFont: {
      fontFamily: 'Courier New'
    }
  };
});
/**
 * Fetches and returns a list features for a given list of regions
 * @param selectedRegions - Region[]
 * @returns Features[]
 */

function fetchSequence(_x, _x2) {
  return _fetchSequence.apply(this, arguments);
}

function _fetchSequence() {
  _fetchSequence = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(self, selectedRegions) {
    var _self$leftOffset, _self$rightOffset, _assemblyManager$get;

    var session, assemblyName, rpcManager, assemblyManager, assemblyConfig, adapterConfig, sessionId, chunks;
    return runtime_1.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            session = util.getSession(self);
            assemblyName = ((_self$leftOffset = self.leftOffset) === null || _self$leftOffset === void 0 ? void 0 : _self$leftOffset.assemblyName) || ((_self$rightOffset = self.rightOffset) === null || _self$rightOffset === void 0 ? void 0 : _self$rightOffset.assemblyName) || '';
            rpcManager = session.rpcManager, assemblyManager = session.assemblyManager;
            assemblyConfig = (_assemblyManager$get = assemblyManager.get(assemblyName)) === null || _assemblyManager$get === void 0 ? void 0 : _assemblyManager$get.configuration; // assembly configuration

            adapterConfig = configuration.readConfObject(assemblyConfig, ['sequence', 'adapter']);
            sessionId = 'getSequence';
            _context2.next = 8;
            return Promise.all(selectedRegions.map(function (region) {
              return rpcManager.call(sessionId, 'CoreGetFeatures', {
                adapterConfig: adapterConfig,
                region: region,
                sessionId: sessionId
              });
            }));

          case 8:
            chunks = _context2.sent;
            return _context2.abrupt("return", chunks.map(function (chunk) {
              return chunk[0];
            }));

          case 10:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _fetchSequence.apply(this, arguments);
}

function SequenceDialog(_ref) {
  var model = _ref.model,
      handleClose = _ref.handleClose;
  var classes = useStyles$i();
  var session = util.getSession(model);

  var _useState = React.useState(),
      _useState2 = _slicedToArray(_useState, 2),
      error = _useState2[0],
      setError = _useState2[1];

  var _useState3 = React.useState(''),
      _useState4 = _slicedToArray(_useState3, 2),
      sequence = _useState4[0],
      setSequence = _useState4[1];

  var loading = Boolean(!sequence) || Boolean(error);
  var leftOffset = model.leftOffset,
      rightOffset = model.rightOffset; // avoid infinite looping of useEffect
  // random note: the current selected region can't be a computed because it
  // uses action on base1dview even though it's on the ephemeral base1dview

  var regionsSelected = React.useMemo(function () {
    return model.getSelectedRegions(leftOffset, rightOffset);
  }, [model, leftOffset, rightOffset]);
  React.useEffect(function () {
    var active = true;

    function formatSequence(seqChunks) {
      var sequenceChunks = [];
      var incompleteSeqErrs = [];
      seqChunks.forEach(function (chunk) {
        var chunkSeq = chunk.get('seq');
        var chunkRefName = chunk.get('refName');
        var chunkStart = chunk.get('start') + 1;
        var chunkEnd = chunk.get('end');
        var chunkLocstring = "".concat(chunkRefName, ":").concat(chunkStart, "-").concat(chunkEnd);

        if (chunkSeq) {
          sequenceChunks.push({
            header: chunkLocstring,
            seq: chunkSeq
          });

          if (chunkSeq.length !== chunkEnd - chunkStart + 1) {
            incompleteSeqErrs.push("".concat(chunkLocstring, " returned ").concat(chunkSeq.length.toLocaleString(), " bases, but should have returned ").concat((chunkEnd - chunkStart).toLocaleString()));
          }
        }
      });

      if (incompleteSeqErrs.length > 0) {
        session.notify("Unable to retrieve complete reference sequence from regions:".concat(incompleteSeqErrs.join()));
      }

      setSequence(formatFastaStrings.formatSeqFasta(sequenceChunks));
    }

    _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee() {
      var chunks;
      return runtime_1.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.prev = 0;

              if (!(regionsSelected.length > 0)) {
                _context.next = 8;
                break;
              }

              _context.next = 4;
              return fetchSequence(model, regionsSelected);

            case 4:
              chunks = _context.sent;

              if (active) {
                formatSequence(chunks);
              }

              _context.next = 9;
              break;

            case 8:
              throw new Error('Selected region is out of bounds');

            case 9:
              _context.next = 15;
              break;

            case 11:
              _context.prev = 11;
              _context.t0 = _context["catch"](0);
              console.error(_context.t0);

              if (active) {
                setError(_context.t0);
              }

            case 15:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, null, [[0, 11]]);
    }))();

    return function () {
      active = false;
    };
  }, [model, session, regionsSelected, setSequence]);
  var sequenceTooLarge = sequence.length > 1000000;
  return /*#__PURE__*/React__default.createElement(core.Dialog, {
    "data-testid": "sequence-dialog",
    maxWidth: "xl",
    open: true,
    onClose: handleClose,
    "aria-labelledby": "alert-dialog-title",
    "aria-describedby": "alert-dialog-description"
  }, /*#__PURE__*/React__default.createElement(core.DialogTitle, {
    id: "alert-dialog-title"
  }, "Reference sequence", handleClose ? /*#__PURE__*/React__default.createElement(core.IconButton, {
    "data-testid": "close-seqDialog",
    className: classes.closeButton,
    onClick: function onClick() {
      handleClose();
      model.setOffsets(undefined, undefined);
    }
  }, /*#__PURE__*/React__default.createElement(CloseIcon, null)) : null), /*#__PURE__*/React__default.createElement(core.Divider, null), /*#__PURE__*/React__default.createElement(core.DialogContent, null, error ? /*#__PURE__*/React__default.createElement(core.Typography, {
    color: "error"
  }, "".concat(error)) : null, loading && !error ? /*#__PURE__*/React__default.createElement(core.Container, null, "Retrieving reference sequence...", /*#__PURE__*/React__default.createElement(core.CircularProgress, {
    style: {
      marginLeft: 10
    },
    size: 20,
    disableShrink: true
  })) : null, sequence !== undefined ? /*#__PURE__*/React__default.createElement(core.TextField, {
    "data-testid": "rubberband-sequence",
    variant: "outlined",
    multiline: true,
    rows: 3,
    rowsMax: 5,
    disabled: sequenceTooLarge,
    className: classes.dialogContent,
    fullWidth: true,
    value: sequenceTooLarge ? 'Reference sequence too large to display, use the download FASTA button' : sequence,
    InputProps: {
      readOnly: true,
      classes: {
        input: classes.textAreaFont
      }
    }
  }) : null), /*#__PURE__*/React__default.createElement(core.DialogActions, null, /*#__PURE__*/React__default.createElement(core.Button, {
    onClick: function onClick() {
      copy(sequence || '');
      session.notify('Copied to clipboard', 'success');
    },
    disabled: loading || sequenceTooLarge,
    color: "primary",
    startIcon: /*#__PURE__*/React__default.createElement(Icons.ContentCopy, null)
  }, "Copy to clipboard"), /*#__PURE__*/React__default.createElement(core.Button, {
    onClick: function onClick() {
      var seqFastaFile = new Blob([sequence || ''], {
        type: 'text/x-fasta;charset=utf-8'
      });
      fileSaver.saveAs(seqFastaFile, 'jbrowse_ref_seq.fa');
    },
    disabled: loading,
    color: "primary",
    startIcon: /*#__PURE__*/React__default.createElement(GetAppIcon, null)
  }, "Download FASTA"), /*#__PURE__*/React__default.createElement(core.Button, {
    onClick: function onClick() {
      handleClose();
      model.setOffsets(undefined, undefined);
    },
    color: "primary",
    autoFocus: true
  }, "Close")));
}

var SequenceDialog$1 = /*#__PURE__*/mobxReact.observer(SequenceDialog);

function mathPower(num) {
  if (num < 999) {
    return String(num);
  }

  return "".concat(mathPower(~~(num / 1000)), ",").concat("00".concat(~~(num % 1000)).substr(-3, 3));
}

var useStyles$j = /*#__PURE__*/styles.makeStyles(function () {
  return (
    /* theme */
    {
      majorTickLabel: {
        fontSize: '11px'
      },
      majorTick: {
        stroke: '#555'
      },
      minorTick: {
        stroke: '#999'
      }
    }
  );
});

function Ruler(_ref) {
  var start = _ref.start,
      end = _ref.end,
      bpPerPx = _ref.bpPerPx,
      reversed = _ref.reversed,
      major = _ref.major,
      minor = _ref.minor;
  var classes = useStyles$j();
  var ticks = makeTicks(start, end, bpPerPx, major, minor);
  return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, ticks.map(function (tick) {
    var x = (reversed ? end - tick.base : tick.base - start) / bpPerPx;
    return /*#__PURE__*/React__default.createElement("line", {
      key: tick.base,
      x1: x,
      x2: x,
      y1: 0,
      y2: tick.type === 'major' ? 6 : 4,
      strokeWidth: 1,
      stroke: tick.type === 'major' ? '#555' : '#999',
      className: tick.type === 'major' ? classes.majorTick : classes.minorTick,
      "data-bp": tick.base
    });
  }), ticks.filter(function (tick) {
    return tick.type === 'major';
  }).map(function (tick) {
    var x = (reversed ? end - tick.base : tick.base - start) / bpPerPx;
    return /*#__PURE__*/React__default.createElement("text", {
      x: x - 3,
      y: 7 + 11,
      key: "label-".concat(tick.base),
      style: {
        fontSize: '11px'
      },
      className: classes.majorTickLabel
    }, mathPower(tick.base + 1));
  }));
}

Ruler.propTypes = {
  start: ReactPropTypes.number.isRequired,
  end: ReactPropTypes.number.isRequired,
  bpPerPx: ReactPropTypes.number.isRequired,
  reversed: ReactPropTypes.bool,
  major: ReactPropTypes.bool,
  minor: ReactPropTypes.bool
};
Ruler.defaultProps = {
  reversed: false,
  major: true,
  minor: true
};
var Ruler$1 = /*#__PURE__*/mobxReact.observer(Ruler);

var useStyles$k = /*#__PURE__*/core.makeStyles(function (theme) {
  return {
    errorMessage: {
      textAlign: 'center',
      paddingTop: theme.spacing(1),
      paddingBottom: theme.spacing(1)
    },
    spacer: {
      marginRight: theme.spacing(2)
    }
  };
});
var LinearGenomeView = /*#__PURE__*/mobxReact.observer(function (_ref) {
  var model = _ref.model;
  var tracks = model.tracks,
      error = model.error,
      hideHeader = model.hideHeader,
      initialized = model.initialized,
      hasDisplayedRegions = model.hasDisplayedRegions;
  var classes = useStyles$k();

  if (!initialized) {
    return null;
  }

  if (!hasDisplayedRegions) {
    return /*#__PURE__*/React__default.createElement(ImportForm, {
      model: model
    });
  }

  return /*#__PURE__*/React__default.createElement("div", {
    style: {
      position: 'relative'
    }
  }, model.isSeqDialogDisplayed ? /*#__PURE__*/React__default.createElement(SequenceDialog$1, {
    model: model,
    handleClose: function handleClose() {
      model.setOffsets(undefined, undefined);
    }
  }) : null, model.isSearchDialogDisplayed ? /*#__PURE__*/React__default.createElement(SearchResultsDialog, {
    model: model,
    handleClose: function handleClose() {
      model.setSearchResults(undefined, undefined);
    }
  }) : null, !hideHeader ? /*#__PURE__*/React__default.createElement(LinearGenomeViewHeader, {
    model: model
  }) : /*#__PURE__*/React__default.createElement("div", {
    style: {
      position: 'absolute',
      right: 0,
      zIndex: 1001
    }
  }, /*#__PURE__*/React__default.createElement(MiniControls, {
    model: model
  })), error ? /*#__PURE__*/React__default.createElement(core.Paper, {
    variant: "outlined",
    className: classes.errorMessage
  }, /*#__PURE__*/React__default.createElement(core.Typography, {
    color: "error"
  }, error.message)) : /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement(TracksContainer$1, {
    model: model
  }, !tracks.length ? /*#__PURE__*/React__default.createElement(core.Paper, {
    variant: "outlined",
    className: classes.errorMessage
  }, /*#__PURE__*/React__default.createElement(core.Typography, null, "No tracks active."), /*#__PURE__*/React__default.createElement(core.Button, {
    variant: "contained",
    color: "primary",
    onClick: model.activateTrackSelector,
    style: {
      zIndex: 1000
    }
  }, /*#__PURE__*/React__default.createElement(Icons.TrackSelector, {
    className: classes.spacer
  }), "Open track selector")) : tracks.map(function (track) {
    return /*#__PURE__*/React__default.createElement(TrackContainer$1, {
      key: track.id,
      model: model,
      track: track
    });
  }))));
});

function ScaleBar$3(_ref2) {
  var model = _ref2.model,
      fontSize = _ref2.fontSize;
  var offsetPx = model.offsetPx,
      _model$dynamicBlocks = model.dynamicBlocks,
      totalWidthPx = _model$dynamicBlocks.totalWidthPxWithoutBorders,
      totalBp = _model$dynamicBlocks.totalBp;
  var displayBp;

  if (Math.floor(totalBp / 1000000) > 0) {
    displayBp = "".concat(parseFloat((totalBp / 1000000).toPrecision(3)), "Mbp");
  } else if (Math.floor(totalBp / 1000) > 0) {
    displayBp = "".concat(parseFloat((totalBp / 1000).toPrecision(3)), "Kbp");
  } else {
    displayBp = "".concat(Math.floor(totalBp), "bp");
  }

  var x0 = Math.max(-offsetPx, 0);
  var x1 = x0 + totalWidthPx;
  return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement("line", {
    x1: x0,
    x2: x1,
    y1: 10,
    y2: 10,
    stroke: "black"
  }), /*#__PURE__*/React__default.createElement("line", {
    x1: x0,
    x2: x0,
    y1: 5,
    y2: 15,
    stroke: "black"
  }), /*#__PURE__*/React__default.createElement("line", {
    x1: x1,
    x2: x1,
    y1: 5,
    y2: 15,
    stroke: "black"
  }), /*#__PURE__*/React__default.createElement("text", {
    x: x0 + (x1 - x0) / 2,
    y: fontSize * 2,
    textAnchor: "middle",
    fontSize: fontSize
  }, displayBp));
}

function SVGRuler(_ref3) {
  var model = _ref3.model,
      fontSize = _ref3.fontSize,
      width = _ref3.width;
  var contentBlocks = model.dynamicBlocks.contentBlocks,
      viewOffsetPx = model.offsetPx,
      bpPerPx = model.bpPerPx;
  var renderRuler = contentBlocks.length < 5;
  return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement("defs", null, /*#__PURE__*/React__default.createElement("clipPath", {
    id: "clip-ruler"
  }, /*#__PURE__*/React__default.createElement("rect", {
    x: 0,
    y: 0,
    width: width,
    height: 20
  }))), contentBlocks.map(function (block) {
    var offsetLeft = block.offsetPx - viewOffsetPx;
    return /*#__PURE__*/React__default.createElement("g", {
      key: "".concat(block.key),
      transform: "translate(".concat(offsetLeft, " 0)")
    }, /*#__PURE__*/React__default.createElement("text", {
      x: offsetLeft / bpPerPx,
      y: fontSize,
      fontSize: fontSize
    }, block.refName), renderRuler ? /*#__PURE__*/React__default.createElement("g", {
      transform: "translate(0 20)",
      clipPath: "url(#clip-ruler)"
    }, /*#__PURE__*/React__default.createElement(Ruler$1, {
      start: block.start,
      end: block.end,
      bpPerPx: bpPerPx,
      reversed: block.reversed
    })) : /*#__PURE__*/React__default.createElement("line", {
      strokeWidth: 1,
      stroke: "black",
      x1: block.start / bpPerPx,
      x2: block.end / bpPerPx,
      y1: 20,
      y2: 20
    }));
  }));
}

var fontSize = 15;
var rulerHeight = 50;
var textHeight = fontSize + 5;
var paddingHeight = 20;
var headerHeight = textHeight + 20;

var totalHeight = function totalHeight(tracks) {
  return tracks.reduce(function (accum, track) {
    var display = track.displays[0];
    return accum + display.height + paddingHeight + textHeight;
  }, 0);
}; // SVG component, ruler and assembly name


var SVGHeader = function SVGHeader(_ref4) {
  var model = _ref4.model;
  var width = model.width,
      assemblyNames = model.assemblyNames;
  var assemblyName = assemblyNames.length > 1 ? '' : assemblyNames[0];
  return /*#__PURE__*/React__default.createElement("g", {
    id: "header"
  }, /*#__PURE__*/React__default.createElement("text", {
    x: 0,
    y: fontSize,
    fontSize: fontSize
  }, assemblyName), /*#__PURE__*/React__default.createElement("g", {
    transform: "translate(0 ".concat(fontSize, ")")
  }, /*#__PURE__*/React__default.createElement(ScaleBar$3, {
    model: model,
    fontSize: fontSize
  })), /*#__PURE__*/React__default.createElement("g", {
    transform: "translate(0 ".concat(rulerHeight, ")")
  }, /*#__PURE__*/React__default.createElement(SVGRuler, {
    model: model,
    fontSize: fontSize,
    width: width
  })));
}; // SVG component, region separator


var SVGRegionSeparators = function SVGRegionSeparators(_ref5) {
  var model = _ref5.model;
  var dynamicBlocks = model.dynamicBlocks,
      tracks = model.tracks;
  var initialOffset = headerHeight + rulerHeight + 20;
  var height = totalHeight(tracks);
  return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, dynamicBlocks.contentBlocks.slice(1).map(function (block) {
    return /*#__PURE__*/React__default.createElement("line", {
      key: block.key,
      x1: block.offsetPx - model.offsetPx,
      x2: block.offsetPx - model.offsetPx,
      y1: initialOffset,
      y2: height,
      stroke: "black",
      strokeOpacity: 0.3
    });
  }));
}; // SVG component, tracks


function SVGTracks(_ref6) {
  var displayResults = _ref6.displayResults,
      model = _ref6.model,
      offset = _ref6.offset;
  return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, displayResults.map(function (_ref7) {
    var track = _ref7.track,
        result = _ref7.result;
    var current = offset;
    var trackName = configuration.getConf(track, 'name') || "Reference sequence (".concat(configuration.readConfObject(mobxStateTree.getParent(track.configuration), 'name'), ")");
    var display = track.displays[0];
    offset += display.height + paddingHeight + textHeight;
    return /*#__PURE__*/React__default.createElement("g", {
      key: track.configuration.trackId,
      transform: "translate(0 ".concat(current, ")")
    }, /*#__PURE__*/React__default.createElement("text", {
      fontSize: fontSize,
      x: Math.max(-model.offsetPx, 0)
    }, trackName), /*#__PURE__*/React__default.createElement("g", {
      transform: "translate(0 ".concat(textHeight, ")")
    }, result));
  }));
} // render LGV to SVG


function renderToSvg(_x, _x2) {
  return _renderToSvg.apply(this, arguments);
}

function _renderToSvg() {
  _renderToSvg = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(model, opts) {
    var width, tracks, shift, offset, height, displayResults;
    return runtime_1.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return mobx.when(function () {
              return model.initialized;
            });

          case 2:
            width = model.width, tracks = model.tracks;
            shift = 50;
            offset = headerHeight + rulerHeight + 20;
            height = totalHeight(tracks) + offset;
            _context2.next = 8;
            return Promise.all(tracks.map( /*#__PURE__*/function () {
              var _ref8 = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(track) {
                var display, result;
                return runtime_1.wrap(function _callee$(_context) {
                  while (1) {
                    switch (_context.prev = _context.next) {
                      case 0:
                        display = track.displays[0];
                        _context.next = 3;
                        return mobx.when(function () {
                          return display.ready !== undefined ? display.ready : true;
                        });

                      case 3:
                        _context.next = 5;
                        return display.renderSvg(opts);

                      case 5:
                        result = _context.sent;
                        return _context.abrupt("return", {
                          track: track,
                          result: result
                        });

                      case 7:
                      case "end":
                        return _context.stop();
                    }
                  }
                }, _callee);
              }));

              return function (_x3) {
                return _ref8.apply(this, arguments);
              };
            }()));

          case 8:
            displayResults = _context2.sent;
            return _context2.abrupt("return", server.renderToStaticMarkup( /*#__PURE__*/React__default.createElement("svg", {
              width: width,
              height: height,
              xmlns: "http://www.w3.org/2000/svg",
              xmlnsXlink: "http://www.w3.org/1999/xlink",
              viewBox: [0, 0, width + shift * 2, height].toString()
            }, /*#__PURE__*/React__default.createElement("rect", {
              width: width + shift * 2,
              height: height,
              fill: "white"
            }), /*#__PURE__*/React__default.createElement("g", {
              stroke: "none",
              transform: "translate(".concat(shift, " ").concat(fontSize, ")")
            }, /*#__PURE__*/React__default.createElement(SVGHeader, {
              model: model
            }), /*#__PURE__*/React__default.createElement(SVGTracks, {
              model: model,
              displayResults: displayResults,
              offset: offset
            }), /*#__PURE__*/React__default.createElement(SVGRegionSeparators, {
              model: model
            })))));

          case 10:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _renderToSvg.apply(this, arguments);
}

var LinearGenomeView$1 = {
  __proto__: null,
  'default': LinearGenomeView,
  renderToSvg: renderToSvg
};

var useStyles$l = /*#__PURE__*/styles.makeStyles(function (theme) {
  return {
    closeButton: {
      position: 'absolute',
      right: theme.spacing(1),
      top: theme.spacing(1),
      color: theme.palette.grey[500]
    }
  };
});
function ExportSvgDlg(_ref) {
  var model = _ref.model,
      handleClose = _ref.handleClose;

  var _useState = React.useState(typeof OffscreenCanvas !== 'undefined'),
      _useState2 = _slicedToArray(_useState, 2),
      rasterizeLayers = _useState2[0],
      setRasterizeLayers = _useState2[1];

  var _useState3 = React.useState(false),
      _useState4 = _slicedToArray(_useState3, 2),
      loading = _useState4[0],
      setLoading = _useState4[1];

  var _useState5 = React.useState(),
      _useState6 = _slicedToArray(_useState5, 2),
      error = _useState6[0],
      setError = _useState6[1];

  var classes = useStyles$l();
  return /*#__PURE__*/React__default.createElement(core.Dialog, {
    open: true,
    onClose: handleClose
  }, /*#__PURE__*/React__default.createElement(core.DialogTitle, null, "Export SVG", /*#__PURE__*/React__default.createElement(core.IconButton, {
    className: classes.closeButton,
    onClick: handleClose
  }, /*#__PURE__*/React__default.createElement(CloseIcon, null))), /*#__PURE__*/React__default.createElement(core.DialogContent, null, error ? /*#__PURE__*/React__default.createElement("div", {
    style: {
      color: 'red'
    }
  }, "".concat(error)) : loading ? /*#__PURE__*/React__default.createElement("div", null, /*#__PURE__*/React__default.createElement(core.CircularProgress, {
    size: 20,
    style: {
      marginRight: 20
    }
  }), /*#__PURE__*/React__default.createElement(core.Typography, {
    display: "inline"
  }, "Creating SVG")) : null, typeof OffscreenCanvas !== 'undefined' ? /*#__PURE__*/React__default.createElement(core.FormControlLabel, {
    control: /*#__PURE__*/React__default.createElement(core.Checkbox, {
      checked: rasterizeLayers,
      onChange: function onChange() {
        return setRasterizeLayers(function (val) {
          return !val;
        });
      }
    }),
    label: "Rasterize canvas based tracks? File may be much larger if this is turned off"
  }) : /*#__PURE__*/React__default.createElement(core.Typography, null, "Note: rasterizing layers not yet supported in this browser, so SVG size may be large"), /*#__PURE__*/React__default.createElement(core.Button, {
    variant: "contained",
    color: "primary",
    type: "submit",
    onClick: function () {
      var _onClick = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee() {
        return runtime_1.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                setLoading(true);
                setError(undefined);
                _context.prev = 2;
                _context.next = 5;
                return model.exportSvg({
                  rasterizeLayers: rasterizeLayers
                });

              case 5:
                handleClose();
                _context.next = 11;
                break;

              case 8:
                _context.prev = 8;
                _context.t0 = _context["catch"](2);
                setError(_context.t0);

              case 11:
                _context.prev = 11;
                setLoading(false);
                return _context.finish(11);

              case 14:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, null, [[2, 8, 11, 14]]);
      }));

      function onClick() {
        return _onClick.apply(this, arguments);
      }

      return onClick;
    }()
  }, "Submit")));
}

var useStyles$m = /*#__PURE__*/styles.makeStyles(function (theme) {
  return {
    closeButton: {
      position: 'absolute',
      right: theme.spacing(1),
      top: theme.spacing(1),
      color: theme.palette.grey[500]
    }
  };
});

function ReturnToImportFormDialog(_ref) {
  var model = _ref.model,
      handleClose = _ref.handleClose;
  var classes = useStyles$m();
  return /*#__PURE__*/React__default.createElement(core.Dialog, {
    maxWidth: "xl",
    open: true,
    onClose: handleClose
  }, /*#__PURE__*/React__default.createElement(core.DialogTitle, null, "Reference sequence", handleClose ? /*#__PURE__*/React__default.createElement(core.IconButton, {
    className: classes.closeButton,
    onClick: function onClick() {
      handleClose();
    }
  }, /*#__PURE__*/React__default.createElement(CloseIcon, null)) : null), /*#__PURE__*/React__default.createElement(core.Divider, null), /*#__PURE__*/React__default.createElement(core.DialogContent, null, /*#__PURE__*/React__default.createElement(core.Typography, null, "Are you sure you want to return to the import form? This will lose your current view")), /*#__PURE__*/React__default.createElement(core.DialogActions, null, /*#__PURE__*/React__default.createElement(core.Button, {
    onClick: function onClick() {
      model.clearView();
      handleClose();
    },
    variant: "contained",
    color: "primary",
    autoFocus: true
  }, "OK"), /*#__PURE__*/React__default.createElement(core.Button, {
    onClick: function onClick() {
      handleClose();
    },
    color: "secondary",
    variant: "contained",
    autoFocus: true
  }, "Cancel")));
}

var ReturnToImportFormDlg = /*#__PURE__*/mobxReact.observer(ReturnToImportFormDialog);

function calculateVisibleLocStrings(contentBlocks) {
  if (!contentBlocks.length) {
    return '';
  }

  var isSingleAssemblyName = contentBlocks.every(function (block) {
    return block.assemblyName === contentBlocks[0].assemblyName;
  });
  var locs = contentBlocks.map(function (block) {
    return util.assembleLocString(_objectSpread2(_objectSpread2({}, block), {}, {
      start: Math.round(block.start),
      end: Math.round(block.end),
      assemblyName: isSingleAssemblyName ? undefined : block.assemblyName
    }));
  });
  return locs.join(';');
}

var HEADER_BAR_HEIGHT = 48;
var HEADER_OVERVIEW_HEIGHT = 20;
var SCALE_BAR_HEIGHT = 17;
var RESIZE_HANDLE_HEIGHT = 3;
var INTER_REGION_PADDING_WIDTH = 2;
function stateModelFactory$1(pluginManager) {
  return mobxStateTree.types.compose(models.BaseViewModel, mobxStateTree.types.model('LinearGenomeView', {
    id: mst.ElementId,
    type: mobxStateTree.types.literal('LinearGenomeView'),
    offsetPx: 0,
    bpPerPx: 1,
    displayedRegions: mobxStateTree.types.array(mst.Region),
    // we use an array for the tracks because the tracks are displayed in a
    // specific order that we need to keep.
    tracks: mobxStateTree.types.array(pluginManager.pluggableMstType('track', 'stateModel')),
    hideHeader: false,
    hideHeaderOverview: false,
    trackSelectorType: mobxStateTree.types.optional(mobxStateTree.types.enumeration(['hierarchical']), 'hierarchical'),
    trackLabels: 'overlapping',
    showCenterLine: false
  }))["volatile"](function () {
    return {
      volatileWidth: undefined,
      minimumBlockWidth: 3,
      draggingTrackId: undefined,
      error: undefined,
      // array of callbacks to run after the next set of the displayedRegions,
      // which is basically like an onLoad
      afterDisplayedRegionsSetCallbacks: [],
      scaleFactor: 1,
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      trackRefs: {},
      coarseDynamicBlocks: [],
      coarseTotalBp: 0,
      leftOffset: undefined,
      rightOffset: undefined,
      searchResults: undefined,
      searchQuery: undefined
    };
  }).views(function (self) {
    return {
      get width() {
        if (self.volatileWidth === undefined) {
          throw new Error('width undefined, make sure to check for model.initialized');
        }

        return self.volatileWidth;
      }

    };
  }).views(function (self) {
    return {
      get initialized() {
        var _getSession = util.getSession(self),
            assemblyManager = _getSession.assemblyManager; // if the assemblyManager is tracking a given assembly name, wait for
        // it to be loaded. this is done by looking in the assemblyManager's
        // assembly list, and then waiting on it's initialized state which is
        // updated later


        var assembliesInitialized = this.assemblyNames.every(function (assemblyName) {
          var _assemblyManager$asse;

          if ((_assemblyManager$asse = assemblyManager.assemblyList) !== null && _assemblyManager$asse !== void 0 && _assemblyManager$asse.map(function (asm) {
            return asm.name;
          }).includes(assemblyName)) {
            return (assemblyManager.get(assemblyName) || {}).initialized;
          }

          return true;
        });
        return self.volatileWidth !== undefined && assembliesInitialized;
      },

      get hasDisplayedRegions() {
        return self.displayedRegions.length > 0;
      },

      get isSeqDialogDisplayed() {
        return self.leftOffset && self.rightOffset;
      },

      get isSearchDialogDisplayed() {
        return self.searchResults !== undefined;
      },

      get scaleBarHeight() {
        return SCALE_BAR_HEIGHT + RESIZE_HANDLE_HEIGHT;
      },

      get headerHeight() {
        if (self.hideHeader) {
          return 0;
        }

        if (self.hideHeaderOverview) {
          return HEADER_BAR_HEIGHT;
        }

        return HEADER_BAR_HEIGHT + HEADER_OVERVIEW_HEIGHT;
      },

      get trackHeights() {
        return self.tracks.map(function (t) {
          return t.displays[0].height;
        }).reduce(function (a, b) {
          return a + b;
        }, 0);
      },

      get trackHeightsWithResizeHandles() {
        return this.trackHeights + self.tracks.length * RESIZE_HANDLE_HEIGHT;
      },

      get height() {
        return this.trackHeightsWithResizeHandles + this.headerHeight + this.scaleBarHeight;
      },

      get interRegionPaddingWidth() {
        return INTER_REGION_PADDING_WIDTH;
      },

      get totalBp() {
        var totalbp = 0;
        self.displayedRegions.forEach(function (region) {
          totalbp += region.end - region.start;
        });
        return totalbp;
      },

      get maxBpPerPx() {
        return this.totalBp / (self.width * 0.9);
      },

      get minBpPerPx() {
        return 1 / 50;
      },

      get maxOffset() {
        // objectively determined to keep the linear genome on the main screen
        var leftPadding = 10;
        return this.displayedRegionsTotalPx - leftPadding;
      },

      get minOffset() {
        // objectively determined to keep the linear genome on the main screen
        var rightPadding = 30;
        return -self.width + rightPadding;
      },

      get displayedRegionsTotalPx() {
        return this.totalBp / self.bpPerPx;
      },

      get renderProps() {
        return _objectSpread2(_objectSpread2({}, tracks.getParentRenderProps(self)), {}, {
          bpPerPx: self.bpPerPx,
          highResolutionScaling: configuration.getConf(util.getSession(self), 'highResolutionScaling')
        });
      },

      get assemblyNames() {
        return _toConsumableArray(new Set(self.displayedRegions.map(function (region) {
          return region.assemblyName;
        })));
      },

      searchScope: function searchScope(assemblyName) {
        return {
          assemblyName: assemblyName,
          includeAggregateIndexes: true,
          tracks: self.tracks
        };
      },

      /**
       * @param refName - refName of the displayedRegion
       * @param coord - coordinate at the displayed Region
       * @param regionNumber - optional param used as identifier when
       * there are multiple displayedRegions with the same refName
       * @returns offsetPx of the displayed region that it lands in
       */
      bpToPx: function bpToPx(_ref) {
        var refName = _ref.refName,
            coord = _ref.coord,
            regionNumber = _ref.regionNumber;
        var offsetBp = 0;
        var interRegionPaddingBp = this.interRegionPaddingWidth * self.bpPerPx;
        var minimumBlockBp = self.minimumBlockWidth * self.bpPerPx;
        var index = self.displayedRegions.findIndex(function (region, idx) {
          var len = region.end - region.start;

          if (refName === region.refName && coord >= region.start && coord <= region.end) {
            if (regionNumber ? regionNumber === idx : true) {
              offsetBp += region.reversed ? region.end - coord : coord - region.start;
              return true;
            }
          } // add the interRegionPaddingWidth if the boundary is in the screen
          // e.g. offset>=0 && offset<width


          if (len > minimumBlockBp && offsetBp / self.bpPerPx >= 0 && offsetBp / self.bpPerPx < self.width) {
            offsetBp += len + interRegionPaddingBp;
          } else {
            offsetBp += len;
          }

          return false;
        });
        var foundRegion = self.displayedRegions[index];

        if (foundRegion) {
          return {
            index: index,
            offsetPx: Math.round(offsetBp / self.bpPerPx)
          };
        }

        return undefined;
      },

      /**
       *
       * @param px - px in the view area, return value is the displayed regions
       * @returns BpOffset of the displayed region that it lands in
       */
      pxToBp: function pxToBp(px) {
        var bpSoFar = 0;
        var bp = (self.offsetPx + px) * self.bpPerPx;
        var n = self.displayedRegions.length;

        if (bp < 0) {
          var region = self.displayedRegions[0];
          var offset = bp;
          return _objectSpread2(_objectSpread2({}, mobxStateTree.getSnapshot(region)), {}, {
            oob: true,
            coord: region.reversed ? Math.floor(region.end - offset) + 1 : Math.floor(region.start + offset) + 1,
            offset: offset,
            index: 0
          });
        }

        var interRegionPaddingBp = this.interRegionPaddingWidth * self.bpPerPx;
        var minimumBlockBp = self.minimumBlockWidth * self.bpPerPx;

        for (var index = 0; index < self.displayedRegions.length; index += 1) {
          var _region = self.displayedRegions[index];
          var len = _region.end - _region.start;

          var _offset = bp - bpSoFar;

          if (len + bpSoFar > bp && bpSoFar <= bp) {
            return _objectSpread2(_objectSpread2({}, mobxStateTree.getSnapshot(_region)), {}, {
              oob: false,
              offset: _offset,
              coord: _region.reversed ? Math.floor(_region.end - _offset) + 1 : Math.floor(_region.start + _offset) + 1,
              index: index
            });
          } // add the interRegionPaddingWidth if the boundary is in the screen
          // e.g. offset>0 && offset<width


          if (_region.end - _region.start > minimumBlockBp && _offset / self.bpPerPx > 0 && _offset / self.bpPerPx < self.width) {
            bpSoFar += len + interRegionPaddingBp;
          } else {
            bpSoFar += len;
          }
        }

        if (bp >= bpSoFar) {
          var _region2 = self.displayedRegions[n - 1];

          var _len = _region2.end - _region2.start;

          var _offset2 = bp - bpSoFar + _len;

          return _objectSpread2(_objectSpread2({}, mobxStateTree.getSnapshot(_region2)), {}, {
            oob: true,
            offset: _offset2,
            coord: _region2.reversed ? Math.floor(_region2.end - _offset2) + 1 : Math.floor(_region2.start + _offset2) + 1,
            index: n - 1
          });
        }

        return {
          coord: 0,
          index: 0,
          refName: '',
          oob: true,
          assemblyName: '',
          offset: 0,
          start: 0,
          end: 0,
          reversed: false
        };
      },
      getTrack: function getTrack(id) {
        return self.tracks.find(function (t) {
          return t.configuration.trackId === id;
        });
      },
      rankSearchResults: function rankSearchResults(results) {
        // order of rank
        var openTrackIds = self.tracks.map(function (track) {
          return track.configuration.trackId;
        });
        results.forEach(function (result) {
          if (openTrackIds !== []) {
            if (openTrackIds.includes(result.trackId)) {
              result.updateScore(result.getScore() + 1);
            }
          }
        });
        return results;
      },
      // modifies view menu action onClick to apply to all tracks of same type
      rewriteOnClicks: function rewriteOnClicks(trackType, viewMenuActions) {
        var _this = this;

        viewMenuActions.forEach(function (action) {
          // go to lowest level menu
          if ('subMenu' in action) {
            _this.rewriteOnClicks(trackType, action.subMenu);
          }

          if ('onClick' in action) {
            var holdOnClick = action.onClick;

            action.onClick = function () {
              for (var _len2 = arguments.length, args = new Array(_len2), _key = 0; _key < _len2; _key++) {
                args[_key] = arguments[_key];
              }

              self.tracks.forEach(function (track) {
                if (track.type === trackType) {
                  holdOnClick.apply(track, [track].concat(args));
                }
              });
            };
          }
        });
      },

      get trackTypeActions() {
        var _this2 = this;

        var allActions = new Map();
        self.tracks.forEach(function (track) {
          var trackInMap = allActions.get(track.type);

          if (!trackInMap) {
            var viewMenuActions = clone(track.viewMenuActions);

            _this2.rewriteOnClicks(track.type, viewMenuActions);

            allActions.set(track.type, viewMenuActions);
          }
        });
        return allActions;
      },

      get centerLineInfo() {
        return self.displayedRegions.length ? this.pxToBp(self.width / 2) : undefined;
      }

    };
  }).actions(function (self) {
    return {
      setWidth: function setWidth(newWidth) {
        self.volatileWidth = newWidth;
      },
      setError: function setError(error) {
        self.error = error;
      },
      toggleHeader: function toggleHeader() {
        self.hideHeader = !self.hideHeader;
      },
      toggleHeaderOverview: function toggleHeaderOverview() {
        self.hideHeaderOverview = !self.hideHeaderOverview;
      },
      scrollTo: function scrollTo(offsetPx) {
        var newOffsetPx = util.clamp(offsetPx, self.minOffset, self.maxOffset);
        self.offsetPx = newOffsetPx;
        return newOffsetPx;
      },
      zoomTo: function zoomTo(bpPerPx) {
        var newBpPerPx = util.clamp(bpPerPx, self.minBpPerPx, self.maxBpPerPx);

        if (newBpPerPx === self.bpPerPx) {
          return newBpPerPx;
        }

        var oldBpPerPx = self.bpPerPx;
        self.bpPerPx = newBpPerPx;

        if (Math.abs(oldBpPerPx - newBpPerPx) < 0.000001) {
          console.warn('zoomTo bpPerPx rounding error');
          return oldBpPerPx;
        } // tweak the offset so that the center of the view remains at the same coordinate


        var viewWidth = self.width;
        this.scrollTo(Math.round((self.offsetPx + viewWidth / 2) * oldBpPerPx / newBpPerPx - viewWidth / 2));
        return newBpPerPx;
      },
      setOffsets: function setOffsets(left, right) {
        // sets offsets used in the get sequence dialog
        self.leftOffset = left;
        self.rightOffset = right;
      },
      setSearchResults: function setSearchResults(results, query) {
        self.searchResults = results;
        self.searchQuery = query;
      },
      setNewView: function setNewView(bpPerPx, offsetPx) {
        this.zoomTo(bpPerPx);
        this.scrollTo(offsetPx);
      },
      horizontallyFlip: function horizontallyFlip() {
        self.displayedRegions = mobxStateTree.cast(self.displayedRegions.slice().reverse().map(function (region) {
          return _objectSpread2(_objectSpread2({}, region), {}, {
            reversed: !region.reversed
          });
        }));
        this.scrollTo(self.totalBp / self.bpPerPx - self.offsetPx - self.width);
      },
      showTrack: function showTrack(trackId) {
        var initialSnapshot = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var displayInitialSnapshot = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var trackConfigSchema = pluginManager.pluggableConfigSchemaType('track');
        var configuration = mobxStateTree.resolveIdentifier(trackConfigSchema, mobxStateTree.getRoot(self), trackId);
        var trackType = pluginManager.getTrackType(configuration.type);

        if (!trackType) {
          throw new Error("unknown track type ".concat(configuration.type));
        }

        var viewType = pluginManager.getViewType(self.type);
        var supportedDisplays = viewType.displayTypes.map(function (displayType) {
          return displayType.name;
        });
        var displayConf = configuration.displays.find(function (d) {
          return supportedDisplays.includes(d.type);
        });

        if (!displayConf) {
          throw new Error("could not find a compatible display for view type ".concat(self.type));
        }

        var track = trackType.stateModel.create(_objectSpread2(_objectSpread2({}, initialSnapshot), {}, {
          type: configuration.type,
          configuration: configuration,
          displays: [_objectSpread2({
            type: displayConf.type,
            configuration: displayConf
          }, displayInitialSnapshot)]
        }));
        self.tracks.push(track);
        return track;
      },
      hideTrack: function hideTrack(trackId) {
        var trackConfigSchema = pluginManager.pluggableConfigSchemaType('track');
        var configuration = mobxStateTree.resolveIdentifier(trackConfigSchema, mobxStateTree.getRoot(self), trackId); // if we have any tracks with that configuration, turn them off

        var shownTracks = self.tracks.filter(function (t) {
          return t.configuration === configuration;
        });
        mobx.transaction(function () {
          return shownTracks.forEach(function (t) {
            return self.tracks.remove(t);
          });
        });
        return shownTracks.length;
      }
    };
  }).actions(function (self) {
    return {
      moveTrack: function moveTrack(movingTrackId, targetTrackId) {
        var oldIndex = self.tracks.findIndex(function (track) {
          return track.id === movingTrackId;
        });

        if (oldIndex === -1) {
          throw new Error("Track ID ".concat(movingTrackId, " not found"));
        }

        var newIndex = self.tracks.findIndex(function (track) {
          return track.id === targetTrackId;
        });

        if (newIndex === -1) {
          throw new Error("Track ID ".concat(targetTrackId, " not found"));
        }

        var track = mobxStateTree.getSnapshot(self.tracks[oldIndex]);
        self.tracks.splice(oldIndex, 1);
        self.tracks.splice(newIndex, 0, track);
      },
      closeView: function closeView() {
        var parent = util.getContainingView(self);

        if (parent) {
          // I am embedded in a some other view
          if (util.isViewContainer(parent)) {
            parent.removeView(self);
          }
        } else {
          // I am part of a session
          util.getSession(self).removeView(self);
        }
      },
      toggleTrack: function toggleTrack(trackId) {
        // if we have any tracks with that configuration, turn them off
        var hiddenCount = self.hideTrack(trackId); // if none had that configuration, turn one on

        if (!hiddenCount) {
          self.showTrack(trackId);
        }
      },
      setTrackLabels: function setTrackLabels(setting) {
        self.trackLabels = setting;
      },
      toggleCenterLine: function toggleCenterLine() {
        self.showCenterLine = !self.showCenterLine;
      },
      setDisplayedRegions: function setDisplayedRegions(regions) {
        self.displayedRegions = mobxStateTree.cast(regions);
        self.zoomTo(self.bpPerPx);
      },
      activateTrackSelector: function activateTrackSelector() {
        if (self.trackSelectorType === 'hierarchical') {
          var session = util.getSession(self);

          if (util.isSessionModelWithWidgets(session)) {
            var selector = session.addWidget('HierarchicalTrackSelectorWidget', 'hierarchicalTrackSelector', {
              view: self
            });
            session.showWidget(selector);
            return selector;
          }
        }

        throw new Error("invalid track selector type ".concat(self.trackSelectorType));
      },
      navToLocString: function navToLocString(locString, optAssemblyName) {
        var _getSession2 = util.getSession(self),
            assemblyManager = _getSession2.assemblyManager;

        var isValidRefName = assemblyManager.isValidRefName;
        var locStrings = locString.split(';');

        if (self.displayedRegions.length > 1) {
          var locations = locStrings.map(function (ls) {
            return util.parseLocString(ls, isValidRefName);
          });
          this.navToMultiple(locations);
          return;
        }

        var assemblyName = optAssemblyName;
        var defaultRefName = '';

        if (self.displayedRegions.length !== 0) {
          // defaults
          assemblyName = self.displayedRegions[0].assemblyName;
          defaultRefName = self.displayedRegions[0].refName;
        }

        var assembly = assemblyName && assemblyManager.get(assemblyName);

        if (!assembly) {
          throw new Error("Could not find assembly ".concat(assemblyName));
        }

        var _assembly = assembly,
            regions = _assembly.regions;

        if (!regions) {
          throw new Error("Regions for assembly ".concat(assemblyName, " not yet loaded"));
        }

        if (locStrings.length > 1) {
          throw new Error('Navigating to multiple locations is not allowed when viewing a whole chromosome');
        }

        var parsedLocString = util.parseLocString(locStrings[0], function (refName) {
          return isValidRefName(refName, assemblyName);
        });
        var changedAssembly = false;

        if (parsedLocString.assemblyName && parsedLocString.assemblyName !== assemblyName) {
          var newAssembly = assemblyManager.get(parsedLocString.assemblyName);

          if (!newAssembly) {
            throw new Error("Could not find assembly ".concat(parsedLocString.assemblyName));
          }

          assembly = newAssembly;
          changedAssembly = true;
          var newRegions = newAssembly.regions;

          if (!newRegions) {
            throw new Error("Regions for assembly ".concat(parsedLocString.assemblyName, " not yet loaded"));
          }

          regions = newRegions;
        }

        var canonicalRefName = assembly.getCanonicalRefName(parsedLocString.refName);

        if (!canonicalRefName) {
          throw new Error("Could not find refName ".concat(parsedLocString.refName, " in ").concat(assembly.name));
        }

        if (changedAssembly || canonicalRefName !== defaultRefName) {
          var newDisplayedRegion = regions.find(function (region) {
            return region.refName === canonicalRefName;
          });

          if (newDisplayedRegion) {
            this.setDisplayedRegions([newDisplayedRegion]);
          } else {
            throw new Error("Could not find refName ".concat(parsedLocString.refName, " in ").concat(assembly.name));
          }
        }

        var displayedRegion = regions.find(function (region) {
          return region.refName === canonicalRefName;
        });

        if (displayedRegion) {
          var _parsedLocString$star, _parsedLocString$end;

          var start = util.clamp((_parsedLocString$star = parsedLocString === null || parsedLocString === void 0 ? void 0 : parsedLocString.start) !== null && _parsedLocString$star !== void 0 ? _parsedLocString$star : 0, 0, displayedRegion.end);
          var end = util.clamp((_parsedLocString$end = parsedLocString === null || parsedLocString === void 0 ? void 0 : parsedLocString.end) !== null && _parsedLocString$end !== void 0 ? _parsedLocString$end : displayedRegion.end, 0, displayedRegion.end);
          this.navTo(_objectSpread2(_objectSpread2({}, parsedLocString), {}, {
            start: start,
            end: end
          }));
        }
      },

      /**
       * Navigate to a location based on its refName and optionally start, end,
       * and assemblyName. Can handle if there are multiple displayedRegions
       * from same refName. Only navigates to a location if it is entirely
       * within a displayedRegion. Navigates to the first matching location
       * encountered.
       *
       * Throws an error if navigation was unsuccessful
       *
       * @param location - a proposed location to navigate to
       */
      navTo: function navTo(query) {
        this.navToMultiple([query]);
      },
      navToMultiple: function navToMultiple(locations) {
        var firstLocation = locations[0];
        var refName = firstLocation.refName;
        var start = firstLocation.start,
            end = firstLocation.end,
            _firstLocation$assemb = firstLocation.assemblyName,
            assemblyName = _firstLocation$assemb === void 0 ? self.assemblyNames[0] : _firstLocation$assemb;

        if (start !== undefined && end !== undefined && start > end) {
          throw new Error("start \"".concat(start + 1, "\" is greater than end \"").concat(end, "\""));
        }

        var session = util.getSession(self);
        var assemblyManager = session.assemblyManager;
        var assembly = assemblyManager.get(assemblyName);

        if (assembly) {
          var canonicalRefName = assembly.getCanonicalRefName(refName);

          if (canonicalRefName) {
            refName = canonicalRefName;
          }
        }

        var s = start;
        var e = end;
        var refNameMatched = false;

        var predicate = function predicate(r) {
          if (refName === r.refName) {
            refNameMatched = true;

            if (s === undefined) {
              s = r.start;
            }

            if (e === undefined) {
              e = r.end;
            }

            if (s >= r.start && s <= r.end && e <= r.end && e >= r.start) {
              return true;
            }

            s = start;
            e = end;
          }

          return false;
        };

        var lastIndex = util.findLastIndex(self.displayedRegions, predicate);
        var index;

        while (index !== lastIndex) {
          try {
            var previousIndex = index;
            index = self.displayedRegions.slice(previousIndex === undefined ? 0 : previousIndex + 1).findIndex(predicate);

            if (previousIndex !== undefined) {
              index += previousIndex + 1;
            }

            if (!refNameMatched) {
              throw new Error("could not find a region with refName \"".concat(refName, "\""));
            }

            if (s === undefined) {
              throw new Error("could not find a region with refName \"".concat(refName, "\" that contained an end position ").concat(e));
            }

            if (e === undefined) {
              throw new Error("could not find a region with refName \"".concat(refName, "\" that contained a start position ").concat(s + 1));
            }

            if (index === -1) {
              throw new Error("could not find a region that completely contained \"".concat(util.assembleLocString(firstLocation), "\""));
            }

            if (locations.length === 1) {
              var f = self.displayedRegions[index];
              this.moveTo({
                index: index,
                offset: f.reversed ? f.end - e : s - f.start
              }, {
                index: index,
                offset: f.reversed ? f.end - s : e - f.start
              });
              return;
            }

            var locationIndex = 0;
            var locationStart = 0;
            var locationEnd = 0;

            for (locationIndex; locationIndex < locations.length; locationIndex++) {
              var location = locations[locationIndex];
              var region = self.displayedRegions[index + locationIndex];
              locationStart = location.start || region.start;
              locationEnd = location.end || region.end;

              if (location.refName !== region.refName) {
                throw new Error("Entered location ".concat(util.assembleLocString(location), " does not match with displayed regions"));
              }

              if (locationIndex > 0) {
                // does it reach the left side?
                var matchesLeft = region.reversed ? locationEnd === region.end : locationStart === region.start;

                if (!matchesLeft) {
                  throw new Error("".concat(region.reversed ? 'End' : 'Start', " of region ").concat(util.assembleLocString(location), " should be ").concat((region.reversed ? region.end : region.start + 1).toLocaleString('en-US'), ", but it is not"));
                }
              }

              var isLast = locationIndex === locations.length - 1;

              if (!isLast) {
                // does it reach the right side?
                var matchesRight = region.reversed ? locationStart === region.start : locationEnd === region.end;

                if (!matchesRight) {
                  throw new Error("".concat(region.reversed ? 'Start' : 'End', " of region ").concat(util.assembleLocString(location), " should be ").concat((region.reversed ? region.start + 1 : region.end).toLocaleString('en-US'), ", but it is not"));
                }
              }
            }

            locationIndex -= 1;
            var startDisplayedRegion = self.displayedRegions[index];
            var endDisplayedRegion = self.displayedRegions[index + locationIndex];
            this.moveTo({
              index: index,
              offset: startDisplayedRegion.reversed ? startDisplayedRegion.end - e : s - startDisplayedRegion.start
            }, {
              index: index + locationIndex,
              offset: endDisplayedRegion.reversed ? endDisplayedRegion.end - locationStart : locationEnd - endDisplayedRegion.start
            });
            return;
          } catch (error) {
            if (index === lastIndex) {
              throw error;
            }
          }
        }
      },

      /**
       * Navigate to a location based on user clicking and dragging on the
       * overview scale bar to select a region to zoom into.
       * Can handle if there are multiple displayedRegions from same refName.
       * Only navigates to a location if it is entirely within a displayedRegion.
       *
       * @param leftPx- `object as {start, end, index, offset}`, offset = start of user drag
       * @param rightPx- `object as {start, end, index, offset}`, offset = end of user drag
       */
      zoomToDisplayedRegions: function zoomToDisplayedRegions(leftPx, rightPx) {
        if (leftPx === undefined || rightPx === undefined) {
          return;
        }

        var singleRefSeq = leftPx.refName === rightPx.refName && leftPx.index === rightPx.index; // zooming into one displayed Region

        if (singleRefSeq && rightPx.offset < leftPx.offset || leftPx.index > rightPx.index) {
          var _ref2 = [rightPx, leftPx];
          leftPx = _ref2[0];
          rightPx = _ref2[1];
        }

        var startOffset = {
          start: leftPx.start,
          end: leftPx.end,
          index: leftPx.index,
          offset: leftPx.offset
        };
        var endOffset = {
          start: rightPx.start,
          end: rightPx.end,
          index: rightPx.index,
          offset: rightPx.offset
        };

        if (startOffset && endOffset) {
          this.moveTo(startOffset, endOffset);
        } else {
          var session = util.getSession(self);
          session.notify('No regions found to navigate to', 'warning');
        }
      },

      /**
       * Helper method for the fetchSequence.
       * Retrieves the corresponding regions that were selected by the rubberband
       *
       * @param leftOffset - `object as {start, end, index, offset}`, offset = start of user drag
       * @param rightOffset - `object as {start, end, index, offset}`, offset = end of user drag
       * @returns array of Region[]
       */
      getSelectedRegions: function getSelectedRegions(leftOffset, rightOffset) {
        var simView = Base1DView.create(_objectSpread2(_objectSpread2({}, mobxStateTree.getSnapshot(self)), {}, {
          interRegionPaddingWidth: self.interRegionPaddingWidth
        }));
        simView.setVolatileWidth(self.width);
        simView.zoomToDisplayedRegions(leftOffset, rightOffset);
        return simView.dynamicBlocks.contentBlocks.map(function (region) {
          return _objectSpread2(_objectSpread2({}, region), {}, {
            start: Math.floor(region.start),
            end: Math.ceil(region.end)
          });
        });
      },
      // schedule something to be run after the next time displayedRegions is set
      afterDisplayedRegionsSet: function afterDisplayedRegionsSet(cb) {
        self.afterDisplayedRegionsSetCallbacks.push(cb);
      },

      /**
       * offset is the base-pair-offset in the displayed region, index is the index of the
       * displayed region in the linear genome view
       *
       * @param start - object as `{start, end, offset, index}`
       * @param end - object as `{start, end, offset, index}`
       */
      moveTo: function moveTo(start, end) {
        // find locations in the modellist
        var bpSoFar = 0;

        if (start.index === end.index) {
          bpSoFar += end.offset - start.offset;
        } else {
          var s = self.displayedRegions[start.index];
          bpSoFar += s.end - s.start - start.offset;

          if (end.index - start.index >= 2) {
            for (var i = start.index + 1; i < end.index; i += 1) {
              bpSoFar += self.displayedRegions[i].end - self.displayedRegions[i].start;
            }
          }

          bpSoFar += end.offset;
        }

        var targetBpPerPx = bpSoFar / (self.width - self.interRegionPaddingWidth * (end.index - start.index));
        var newBpPerPx = self.zoomTo(targetBpPerPx); // If our target bpPerPx was smaller than the allowed minBpPerPx, adjust
        // the scroll so the requested range is in the middle of the screen

        var extraBp = 0;

        if (targetBpPerPx < newBpPerPx) {
          extraBp = (newBpPerPx - targetBpPerPx) * self.width / 2;
        }

        var bpToStart = -extraBp;

        for (var _i = 0; _i < self.displayedRegions.length; _i += 1) {
          var region = self.displayedRegions[_i];

          if (start.index === _i) {
            bpToStart += start.offset;
            break;
          } else {
            bpToStart += region.end - region.start;
          }
        }

        self.scrollTo(Math.round(bpToStart / self.bpPerPx) + self.interRegionPaddingWidth * start.index);
      },
      horizontalScroll: function horizontalScroll(distance) {
        var oldOffsetPx = self.offsetPx; // newOffsetPx is the actual offset after the scroll is clamped

        var newOffsetPx = self.scrollTo(self.offsetPx + distance);
        return newOffsetPx - oldOffsetPx;
      },

      /**
       * scrolls the view to center on the given bp. if that is not in any
       * of the displayed regions, does nothing
       * @param bp - basepair at which you want to center the view
       * @param refName - refName of the displayedRegion you are centering at
       * @param regionIndex - index of the displayedRegion
       */
      centerAt: function centerAt(bp, refName, regionIndex) {
        var centerPx = self.bpToPx({
          refName: refName,
          coord: bp,
          regionNumber: regionIndex
        });

        if (centerPx) {
          self.scrollTo(Math.round(centerPx.offsetPx - self.width / 2));
        }
      },
      center: function center() {
        var centerBp = self.totalBp / 2;
        self.scrollTo(Math.round(centerBp / self.bpPerPx - self.width / 2));
      },
      showAllRegions: function showAllRegions() {
        self.zoomTo(self.maxBpPerPx);
        this.center();
      },
      showAllRegionsInAssembly: function showAllRegionsInAssembly(assemblyName) {
        var session = util.getSession(self);
        var assemblyManager = session.assemblyManager;

        if (!assemblyName) {
          var assemblyNames = _toConsumableArray(new Set(self.displayedRegions.map(function (region) {
            return region.assemblyName;
          })));

          if (assemblyNames.length > 1) {
            session.notify("Can't perform this with multiple assemblies currently");
            return;
          }

          var _assemblyNames = _slicedToArray(assemblyNames, 1);

          assemblyName = _assemblyNames[0];
        }

        var assembly = assemblyManager.get(assemblyName);

        if (assembly) {
          var regions = assembly.regions;

          if (regions) {
            this.setDisplayedRegions(regions);
            self.zoomTo(self.maxBpPerPx);
            this.center();
          }
        }
      },
      setDraggingTrackId: function setDraggingTrackId(idx) {
        self.draggingTrackId = idx;
      },
      setScaleFactor: function setScaleFactor(factor) {
        self.scaleFactor = factor;
      }
    };
  }).actions(function (self) {
    var cancelLastAnimation = function cancelLastAnimation() {};

    function slide(viewWidths) {
      var _springAnimate = util.springAnimate(self.offsetPx, self.offsetPx + self.width * viewWidths, self.scrollTo),
          _springAnimate2 = _slicedToArray(_springAnimate, 2),
          animate = _springAnimate2[0],
          cancelAnimation = _springAnimate2[1];

      cancelLastAnimation();
      cancelLastAnimation = cancelAnimation;
      animate();
    }

    return {
      slide: slide
    };
  }).actions(function (self) {
    var cancelLastAnimation = function cancelLastAnimation() {};

    function zoom(targetBpPerPx) {
      self.zoomTo(self.bpPerPx);

      if ( // already zoomed all the way in
      targetBpPerPx < self.bpPerPx && self.bpPerPx === self.minBpPerPx || // already zoomed all the way out
      targetBpPerPx > self.bpPerPx && self.bpPerPx === self.maxBpPerPx) {
        return;
      }

      var factor = self.bpPerPx / targetBpPerPx;

      var _springAnimate3 = util.springAnimate(1, factor, self.setScaleFactor, function () {
        self.zoomTo(targetBpPerPx);
        self.setScaleFactor(1);
      }),
          _springAnimate4 = _slicedToArray(_springAnimate3, 2),
          animate = _springAnimate4[0],
          cancelAnimation = _springAnimate4[1];

      cancelLastAnimation();
      cancelLastAnimation = cancelAnimation;
      animate();
    }

    return {
      zoom: zoom
    };
  }).views(function (self) {
    var currentlyCalculatedStaticBlocks;
    var stringifiedCurrentlyCalculatedStaticBlocks = '';
    return {
      get menuItems() {
        var menuItems = [{
          label: 'Return to import form',
          onClick: function onClick() {
            util.getSession(self).setDialogComponent(ReturnToImportFormDlg, {
              model: self
            });
          },
          icon: FolderOpenIcon
        }, {
          label: 'Export SVG',
          onClick: function onClick() {
            util.getSession(self).setDialogComponent(ExportSvgDlg, {
              model: self
            });
          }
        }, {
          label: 'Open track selector',
          onClick: self.activateTrackSelector,
          icon: Icons.TrackSelector
        }, {
          label: 'Horizontally flip',
          icon: SyncAltIcon,
          onClick: self.horizontallyFlip
        }, {
          label: 'Show all regions in assembly',
          icon: VisibilityIcon,
          onClick: self.showAllRegionsInAssembly
        }, {
          label: 'Show center line',
          icon: VisibilityIcon,
          type: 'checkbox',
          checked: self.showCenterLine,
          onClick: self.toggleCenterLine
        }, {
          type: 'divider'
        }, {
          label: 'Show header',
          icon: VisibilityIcon,
          type: 'checkbox',
          checked: !self.hideHeader,
          onClick: self.toggleHeader
        }, {
          label: 'Show header overview',
          icon: VisibilityIcon,
          type: 'checkbox',
          checked: !self.hideHeaderOverview,
          onClick: self.toggleHeaderOverview,
          disabled: self.hideHeader
        }, {
          label: 'Track labels',
          icon: LabelIcon,
          subMenu: [{
            label: 'Overlapping',
            icon: VisibilityIcon,
            type: 'radio',
            checked: self.trackLabels === 'overlapping',
            onClick: function onClick() {
              return self.setTrackLabels('overlapping');
            }
          }, {
            label: 'Offset',
            icon: VisibilityIcon,
            type: 'radio',
            checked: self.trackLabels === 'offset',
            onClick: function onClick() {
              return self.setTrackLabels('offset');
            }
          }, {
            label: 'Hidden',
            icon: VisibilityIcon,
            type: 'radio',
            checked: self.trackLabels === 'hidden',
            onClick: function onClick() {
              return self.setTrackLabels('hidden');
            }
          }]
        }]; // add track's view level menu options

        var _iterator = _createForOfIteratorHelper(self.trackTypeActions.entries()),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var _step$value = _slicedToArray(_step.value, 2),
                key = _step$value[0],
                value = _step$value[1];

            if (value.length) {
              menuItems.push({
                type: 'divider'
              }, {
                type: 'subHeader',
                label: key
              });
              value.forEach(function (action) {
                menuItems.push(action);
              });
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        return menuItems;
      },

      get staticBlocks() {
        var ret = calculateStaticBlocks(self);
        var sret = JSON.stringify(ret);

        if (stringifiedCurrentlyCalculatedStaticBlocks !== sret) {
          currentlyCalculatedStaticBlocks = ret;
          stringifiedCurrentlyCalculatedStaticBlocks = sret;
        }

        return currentlyCalculatedStaticBlocks;
      },

      get dynamicBlocks() {
        return calculateDynamicBlocks(self);
      },

      get roundedDynamicBlocks() {
        return this.dynamicBlocks.contentBlocks.map(function (block) {
          return _objectSpread2(_objectSpread2({}, block), {}, {
            start: Math.floor(block.start),
            end: Math.ceil(block.end)
          });
        });
      },

      get visibleLocStrings() {
        return calculateVisibleLocStrings(this.dynamicBlocks.contentBlocks);
      },

      get coarseVisibleLocStrings() {
        return calculateVisibleLocStrings(self.coarseDynamicBlocks);
      }

    };
  }).actions(function (self) {
    return {
      // this "clears the view" and makes the view return to the import form
      clearView: function clearView() {
        self.setDisplayedRegions([]);
        self.tracks.clear(); // it is necessary to run these after setting displayed regions empty
        // or else model.offsetPx gets set to Infinity and breaks
        // mobx-state-tree snapshot

        self.scrollTo(0);
        self.zoomTo(10);
      },
      setCoarseDynamicBlocks: function setCoarseDynamicBlocks(blocks) {
        self.coarseDynamicBlocks = blocks.contentBlocks;
        self.coarseTotalBp = blocks.totalBp;
      },
      afterAttach: function afterAttach() {
        var _this3 = this;

        mobxStateTree.addDisposer(self, mobx.autorun(function () {
          if (self.initialized) {
            _this3.setCoarseDynamicBlocks(self.dynamicBlocks);
          }
        }, {
          delay: 150
        }));
      }
    };
  }).actions(function (self) {
    return {
      exportSvg: function exportSvg() {
        var _arguments = arguments;
        return _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee() {
          var opts, html, blob;
          return runtime_1.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  opts = _arguments.length > 0 && _arguments[0] !== undefined ? _arguments[0] : {};
                  _context.next = 3;
                  return renderToSvg(self, opts);

                case 3:
                  html = _context.sent;
                  blob = new Blob([html], {
                    type: 'image/svg+xml'
                  });
                  fileSaver.saveAs(blob, 'image.svg');

                case 6:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }))();
      }
    };
  });
}

var SetMaxHeightDlg = /*#__PURE__*/React.lazy(function () {
  return Promise.resolve().then(function () { return SetMaxHeight$1; });
});

var stateModelFactory$2 = function stateModelFactory(configSchema) {
  return mobxStateTree.types.compose('LinearBasicDisplay', BaseLinearDisplay$1, mobxStateTree.types.model({
    type: mobxStateTree.types.literal('LinearBasicDisplay'),
    trackShowLabels: mobxStateTree.types.maybe(mobxStateTree.types["boolean"]),
    trackDisplayMode: mobxStateTree.types.maybe(mobxStateTree.types.string),
    trackMaxHeight: mobxStateTree.types.maybe(mobxStateTree.types.number),
    configuration: configuration.ConfigurationReference(configSchema)
  })).views(function (self) {
    return {
      get rendererTypeName() {
        return configuration.getConf(self, ['renderer', 'type']);
      },

      get showLabels() {
        var showLabels = configuration.getConf(self, ['renderer', 'showLabels']);
        return self.trackShowLabels !== undefined ? self.trackShowLabels : showLabels;
      },

      get maxHeight() {
        var maxHeight = configuration.getConf(self, ['renderer', 'maxHeight']);
        return self.trackMaxHeight !== undefined ? self.trackMaxHeight : maxHeight;
      },

      get displayMode() {
        var displayMode = configuration.getConf(self, ['renderer', 'displayMode']);
        return self.trackDisplayMode !== undefined ? self.trackDisplayMode : displayMode;
      },

      get rendererConfig() {
        var configBlob = configuration.getConf(self, ['renderer']) || {};
        return self.rendererType.configSchema.create(_objectSpread2(_objectSpread2({}, configBlob), {}, {
          showLabels: this.showLabels,
          displayMode: this.displayMode,
          maxHeight: this.maxHeight
        }), mobxStateTree.getEnv(self));
      }

    };
  }).actions(function (self) {
    return {
      toggleShowLabels: function toggleShowLabels() {
        self.trackShowLabels = !self.showLabels;
      },
      setDisplayMode: function setDisplayMode(val) {
        self.trackDisplayMode = val;
      },
      setMaxHeight: function setMaxHeight(val) {
        self.trackMaxHeight = val;
      }
    };
  }).views(function (self) {
    var trackMenuItems = self.trackMenuItems;
    return {
      get renderProps() {
        var config = self.rendererConfig;
        return _objectSpread2(_objectSpread2(_objectSpread2({}, self.composedRenderProps), tracks.getParentRenderProps(self)), {}, {
          config: config
        });
      },

      get trackMenuItems() {
        var displayModes = ['compact', 'reducedRepresentation', 'normal', 'collapse'];
        return [].concat(_toConsumableArray(trackMenuItems), [{
          label: 'Show labels',
          icon: VisibilityIcon,
          type: 'checkbox',
          checked: self.showLabels,
          onClick: function onClick() {
            self.toggleShowLabels();
          }
        }, {
          label: 'Display mode',
          icon: VisibilityIcon,
          subMenu: displayModes.map(function (val) {
            return {
              label: val,
              onClick: function onClick() {
                self.setDisplayMode(val);
              }
            };
          })
        }, {
          label: 'Set max height',
          onClick: function onClick() {
            util.getSession(self).setDialogComponent(SetMaxHeightDlg, {
              model: self
            });
          }
        }]);
      }

    };
  });
};

function configSchemaFactory$1(pluginManager) {
  return configuration.ConfigurationSchema('LinearBasicDisplay', {
    mouseover: {
      type: 'string',
      description: 'what to display in a given mouseover',
      defaultValue: "jexl:get(feature,'name')",
      contextVariable: ['feature']
    },
    renderer: pluginManager.pluggableConfigSchemaType('renderer'),
    // overrides base
    maxDisplayedBpPerPx: {
      type: 'number',
      description: 'maximum bpPerPx that is displayed in the view',
      defaultValue: 1000
    }
  }, {
    baseConfiguration: baseLinearDisplayConfigSchema,
    explicitlyTyped: true
  });
}

var LinearGenomeViewPlugin = /*#__PURE__*/function (_Plugin) {
  _inherits(LinearGenomeViewPlugin, _Plugin);

  var _super = /*#__PURE__*/_createSuper(LinearGenomeViewPlugin);

  function LinearGenomeViewPlugin() {
    var _this;

    _classCallCheck(this, LinearGenomeViewPlugin);

    _this = _super.apply(this, arguments);
    _this.name = 'LinearGenomeViewPlugin';
    _this.exports = {
      BaseLinearDisplayComponent: BaseLinearDisplay,
      BaseLinearDisplay: BaseLinearDisplay$1,
      baseLinearDisplayConfigSchema: baseLinearDisplayConfigSchema
    };
    return _this;
  }

  _createClass(LinearGenomeViewPlugin, [{
    key: "install",
    value: function install(pluginManager) {
      pluginManager.addTrackType(function () {
        var configSchema = configuration.ConfigurationSchema('FeatureTrack', {}, {
          baseConfiguration: models.createBaseTrackConfig(pluginManager),
          explicitIdentifier: 'trackId'
        });
        return new TrackType({
          name: 'FeatureTrack',
          configSchema: configSchema,
          stateModel: models.createBaseTrackModel(pluginManager, 'FeatureTrack', configSchema)
        });
      });
      pluginManager.addTrackType(function () {
        var configSchema = configuration.ConfigurationSchema('BasicTrack', {}, {
          baseConfiguration: models.createBaseTrackConfig(pluginManager),
          explicitIdentifier: 'trackId'
        });
        return new TrackType({
          name: 'BasicTrack',
          configSchema: configSchema,
          stateModel: models.createBaseTrackModel(pluginManager, 'BasicTrack', configSchema)
        });
      });
      pluginManager.addDisplayType(function () {
        var configSchema = configSchemaFactory(pluginManager);
        return new DisplayType({
          name: 'LinearBareDisplay',
          configSchema: configSchema,
          stateModel: stateModelFactory(configSchema),
          trackType: 'BasicTrack',
          viewType: 'LinearGenomeView',
          ReactComponent: BaseLinearDisplay
        });
      });
      pluginManager.addDisplayType(function () {
        var configSchema = configSchemaFactory$1(pluginManager);
        return new DisplayType({
          name: 'LinearBasicDisplay',
          configSchema: configSchema,
          stateModel: stateModelFactory$2(configSchema),
          trackType: 'FeatureTrack',
          viewType: 'LinearGenomeView',
          ReactComponent: BaseLinearDisplay
        });
      });
      pluginManager.addViewType(function () {
        return new ViewType({
          name: 'LinearGenomeView',
          stateModel: stateModelFactory$1(pluginManager),
          ReactComponent: /*#__PURE__*/React.lazy(function () {
            return Promise.resolve().then(function () { return LinearGenomeView$1; });
          })
        });
      });
    }
  }, {
    key: "configure",
    value: function configure(pluginManager) {
      if (util.isAbstractMenuManager(pluginManager.rootModel)) {
        pluginManager.rootModel.appendToSubMenu(['File', 'Add'], {
          label: 'Linear genome view',
          icon: LineStyleIcon,
          onClick: function onClick(session) {
            session.addView('LinearGenomeView', {});
          }
        });
      }
    }
  }]);

  return LinearGenomeViewPlugin;
}(Plugin);

var useStyles$n = /*#__PURE__*/core.makeStyles(function (theme) {
  return {
    root: {
      width: 500
    },
    closeButton: {
      position: 'absolute',
      right: theme.spacing(1),
      top: theme.spacing(1),
      color: theme.palette.grey[500]
    },
    field: {
      margin: theme.spacing(2)
    }
  };
});

function SetMaxHeightDlg$1(props) {
  var model = props.model,
      handleClose = props.handleClose;
  var classes = useStyles$n();
  var _model$maxHeight = model.maxHeight,
      maxHeight = _model$maxHeight === void 0 ? '' : _model$maxHeight;

  var _useState = React.useState("".concat(maxHeight)),
      _useState2 = _slicedToArray(_useState, 2),
      max = _useState2[0],
      setMax = _useState2[1];

  return /*#__PURE__*/React__default.createElement(core.Dialog, {
    open: true,
    onClose: handleClose,
    "aria-labelledby": "alert-dialog-title",
    "aria-describedby": "alert-dialog-description"
  }, /*#__PURE__*/React__default.createElement(core.DialogTitle, {
    id: "alert-dialog-title"
  }, "Filter options", /*#__PURE__*/React__default.createElement(core.IconButton, {
    "aria-label": "close",
    className: classes.closeButton,
    onClick: handleClose
  }, /*#__PURE__*/React__default.createElement(CloseIcon, null))), /*#__PURE__*/React__default.createElement(core.DialogContent, null, /*#__PURE__*/React__default.createElement("div", {
    className: classes.root
  }, /*#__PURE__*/React__default.createElement(core.Typography, null, "Set max height for the track"), /*#__PURE__*/React__default.createElement(core.TextField, {
    value: max,
    onChange: function onChange(event) {
      setMax(event.target.value);
    },
    placeholder: "Enter max score"
  }), /*#__PURE__*/React__default.createElement(core.Button, {
    variant: "contained",
    color: "primary",
    type: "submit",
    style: {
      marginLeft: 20
    },
    onClick: function onClick() {
      model.setMaxHeight(max !== '' && !Number.isNaN(+max) ? +max : undefined);
      handleClose();
    }
  }, "Submit"))));
}

var SetMaxHeight = /*#__PURE__*/mobxReact.observer(SetMaxHeightDlg$1);

var SetMaxHeight$1 = {
  __proto__: null,
  'default': SetMaxHeight
};

exports.BaseLinearDisplay = BaseLinearDisplay$1;
exports.BaseLinearDisplayComponent = BaseLinearDisplay;
exports.baseLinearDisplayConfigSchema = baseLinearDisplayConfigSchema;
exports.default = LinearGenomeViewPlugin;
exports.linearBareDisplayConfigSchemaFactory = configSchemaFactory;
exports.linearBasicDisplayConfigSchemaFactory = configSchemaFactory$1;
exports.linearBasicDisplayModelFactory = stateModelFactory$2;
exports.renderToSvg = renderToSvg;
//# sourceMappingURL=plugin-linear-genome-view.cjs.development.js.map
