"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _react = _interopRequireDefault(require("react"));

var _styles = require("@material-ui/core/styles");

var _server = require("react-dom/server");

var _mobxStateTree = require("mobx-state-tree");

var _util = require("../../util");

var _RendererType2 = _interopRequireDefault(require("./RendererType"));

var _serializableFilterChain = _interopRequireDefault(require("./util/serializableFilterChain"));

var _ui = require("../../ui");

var _ServerSideRenderedContent = _interopRequireDefault(require("./ServerSideRenderedContent"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var ServerSideRenderer = /*#__PURE__*/function (_RendererType) {
  (0, _inherits2.default)(ServerSideRenderer, _RendererType);

  var _super = _createSuper(ServerSideRenderer);

  function ServerSideRenderer() {
    (0, _classCallCheck2.default)(this, ServerSideRenderer);
    return _super.apply(this, arguments);
  }

  (0, _createClass2.default)(ServerSideRenderer, [{
    key: "serializeArgsInClient",
    value:
    /**
     * directly modifies the render arguments to prepare them to be serialized and
     * sent to the worker.
     *
     * @param args - the arguments passed to render
     * @returns the same object
     */
    function serializeArgsInClient(args) {
      return _objectSpread(_objectSpread({}, args), {}, {
        config: (0, _mobxStateTree.isStateTreeNode)(args.config) ? (0, _mobxStateTree.getSnapshot)(args.config) : args.config,
        filters: args.filters && args.filters.toJSON().filters
      });
    }
    /**
     * Deserialize the render results from the worker in the client. Includes
     * hydrating of the React HTML string, and not hydrating the result if SVG is
     * being rendered
     *
     * @param results - the results of the render
     * @param args - the arguments passed to render
     */

  }, {
    key: "deserializeResultsInClient",
    value: function deserializeResultsInClient(results, args) {
      var html = results.html,
          rest = (0, _objectWithoutProperties2.default)(results, ["html"]); // if we are rendering svg, we skip hydration

      if (args.exportSVG) {
        // only return the results if the renderer explicitly has
        // this.supportsSVG support to avoid garbage being rendered in SVG
        // document
        return _objectSpread(_objectSpread({}, results), {}, {
          html: this.supportsSVG ? results.html : '<text y="12" fill="black">SVG export not supported for this track</text>'
        });
      } // hydrate results using ServerSideRenderedContent


      return _objectSpread(_objectSpread({}, rest), {}, {
        reactElement: /*#__PURE__*/_react.default.createElement(_ServerSideRenderedContent.default, (0, _extends2.default)({}, args, results, {
          RenderingComponent: this.ReactComponent
        }))
      });
    }
    /**
     * modifies the passed arguments object to inflate arguments as necessary.
     * called in the worker process.
     *
     * @param args - the converted arguments to modify
     */

  }, {
    key: "deserializeArgsInWorker",
    value: function deserializeArgsInWorker(args) {
      var deserialized = _objectSpread({}, args);

      var config = this.configSchema.create(args.config || {}, {
        pluginManager: this.pluginManager
      });
      deserialized.config = config;
      deserialized.filters = new _serializableFilterChain.default({
        filters: args.filters
      });
      return deserialized;
    }
    /**
     * Serialize results of the render to send them to the client. Includes
     * rendering React to an HTML string.
     *
     * @param results - object containing the results of calling the `render`
     * method
     * @param args - deserialized render args
     */

  }, {
    key: "serializeResultsInWorker",
    value: function serializeResultsInWorker(results, args) {
      var html = (0, _server.renderToString)( /*#__PURE__*/_react.default.createElement(_styles.ThemeProvider, {
        theme: (0, _ui.createJBrowseTheme)(args.theme)
      }, results.reactElement));
      delete results.reactElement;
      return _objectSpread(_objectSpread({}, results), {}, {
        html: html
      });
    }
    /**
     * Render method called on the client. Serializes args, then calls
     * "CoreRender" with the RPC manager.
     *
     * @param rpcManager - RPC mananger
     * @param args - render args
     */

  }, {
    key: "renderInClient",
    value: function () {
      var _renderInClient = (0, _asyncToGenerator2.default)( /*#__PURE__*/regeneratorRuntime.mark(function _callee(rpcManager, args) {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                return _context.abrupt("return", rpcManager.call(args.sessionId, 'CoreRender', args));

              case 1:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      function renderInClient(_x, _x2) {
        return _renderInClient.apply(this, arguments);
      }

      return renderInClient;
    }()
    /**
     * Render method called on the worker. `render` is called here in server-side
     * rendering
     *
     * @param args - serialized render args
     */

  }, {
    key: "renderInWorker",
    value: function () {
      var _renderInWorker = (0, _asyncToGenerator2.default)( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(args) {
        var _this = this;

        var signal, _args$statusCallback, statusCallback, deserializedArgs, results, serialized;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                signal = args.signal, _args$statusCallback = args.statusCallback, statusCallback = _args$statusCallback === void 0 ? function () {} : _args$statusCallback;
                (0, _util.checkAbortSignal)(signal);
                deserializedArgs = this.deserializeArgsInWorker(args);
                (0, _util.checkAbortSignal)(signal);
                _context2.next = 6;
                return (0, _util.updateStatus)('Rendering plot', statusCallback, function () {
                  return _this.render(deserializedArgs);
                });

              case 6:
                results = _context2.sent;
                (0, _util.checkAbortSignal)(signal); // serialize the results for passing back to the main thread.
                // these will be transmitted to the main process, and will come out
                // as the result of renderRegionWithWorker.

                _context2.next = 10;
                return (0, _util.updateStatus)('Serializing results', statusCallback, function () {
                  return _this.serializeResultsInWorker(results, deserializedArgs);
                });

              case 10:
                serialized = _context2.sent;
                return _context2.abrupt("return", serialized);

              case 12:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function renderInWorker(_x3) {
        return _renderInWorker.apply(this, arguments);
      }

      return renderInWorker;
    }()
  }, {
    key: "freeResourcesInClient",
    value: function () {
      var _freeResourcesInClient = (0, _asyncToGenerator2.default)( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(rpcManager, args) {
        var serializedArgs, freed, freedRpc;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                serializedArgs = this.serializeArgsInClient(args);
                freed = this.freeResources();
                _context3.next = 4;
                return rpcManager.call(args.sessionId, 'CoreFreeResources', serializedArgs);

              case 4:
                freedRpc = _context3.sent;
                return _context3.abrupt("return", freed + freedRpc);

              case 6:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function freeResourcesInClient(_x4, _x5) {
        return _freeResourcesInClient.apply(this, arguments);
      }

      return freeResourcesInClient;
    }()
  }]);
  return ServerSideRenderer;
}(_RendererType2.default);

exports.default = ServerSideRenderer;