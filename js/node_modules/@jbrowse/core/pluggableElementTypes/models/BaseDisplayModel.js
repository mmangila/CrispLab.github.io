"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BaseDisplay = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _mobxStateTree = require("mobx-state-tree");

var _configuration = require("../../configuration");

var _tracks = require("../../util/tracks");

var _mst = require("../../util/types/mst");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var BaseDisplay = _mobxStateTree.types.model('BaseDisplay', {
  id: _mst.ElementId,
  type: _mobxStateTree.types.string,
  rpcDriverName: _mobxStateTree.types.maybe(_mobxStateTree.types.string)
}).volatile(function () {
  return {
    rendererTypeName: '',
    error: undefined
  };
}).views(function (self) {
  return {
    get RenderingComponent() {
      var _getEnv = (0, _mobxStateTree.getEnv)(self),
          pluginManager = _getEnv.pluginManager;

      var displayType = pluginManager.getDisplayType(self.type);
      return displayType.ReactComponent;
    },

    get DisplayBlurb() {
      return null;
    },

    get adapterConfig() {
      return (0, _configuration.getConf)(this.parentTrack, 'adapter');
    },

    get parentTrack() {
      var track = (0, _mobxStateTree.getParent)(self);

      while (!(track.configuration && (0, _configuration.getConf)(track, 'trackId'))) {
        if ((0, _mobxStateTree.isRoot)(track)) {
          throw new Error("No parent track found for ".concat(self.type, " ").concat(self.id));
        }

        track = (0, _mobxStateTree.getParent)(track);
      }

      return track;
    },

    /**
     * the react props that are passed to the Renderer when data
     * is rendered in this display
     */
    get renderProps() {
      return _objectSpread(_objectSpread({}, (0, _tracks.getParentRenderProps)(self)), {}, {
        rpcDriverName: self.rpcDriverName,
        displayModel: self
      });
    },

    /**
     * the pluggable element type object for this display's
     * renderer
     */
    get rendererType() {
      var _getEnv2 = (0, _mobxStateTree.getEnv)(self),
          pluginManager = _getEnv2.pluginManager;

      var RendererType = pluginManager.getRendererType(self.rendererTypeName);

      if (!RendererType) {
        throw new Error("renderer \"".concat(self.rendererTypeName, "\" not found"));
      }

      if (!RendererType.ReactComponent) {
        throw new Error("renderer ".concat(self.rendererTypeName, " has no ReactComponent, it may not be completely implemented yet"));
      }

      return RendererType;
    },

    /**
     * if a display-level message should be displayed instead,
     * make this return a react component
     */
    get DisplayMessageComponent() {
      return undefined;
    },

    get trackMenuItems() {
      return [];
    },

    get viewMenuActions() {
      return [];
    },

    /**
     * @param region -
     * @returns falsy if the region is fine to try rendering. Otherwise,
     *  return a react node + string of text.
     *  string of text describes why it cannot be rendered
     *  react node allows user to force load at current setting
     */
    regionCannotBeRendered: function regionCannotBeRendered()
    /* region */
    {
      return undefined;
    }
  };
}).actions(function (self) {
  return {
    setError: function setError(error) {
      self.error = error;
    },
    setRpcDriverName: function setRpcDriverName(rpcDriverName) {
      self.rpcDriverName = rpcDriverName;
    },
    // base display reload does nothing, see specialized displays for details
    reload: function reload() {}
  };
});

exports.BaseDisplay = BaseDisplay;