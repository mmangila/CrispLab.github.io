"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createBaseTrackModel = createBaseTrackModel;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _mobx = require("mobx");

var _mobxStateTree = require("mobx-state-tree");

var _configuration = require("../../configuration");

var _configurationSchema = require("../../configuration/configurationSchema");

var _util = require("../../util");

var _types = require("../../util/types");

var _mst = require("../../util/types/mst");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// these MST models only exist for tracks that are *shown*.
// they should contain only UI state for the track, and have
// a reference to a track configuration (stored under
// session.configuration.assemblies.get(assemblyName).tracks).
// note that multiple displayed tracks could use the same configuration.
function createBaseTrackModel(pluginManager, trackType, baseTrackConfig) {
  return _mobxStateTree.types.model(trackType, {
    id: _mst.ElementId,
    type: _mobxStateTree.types.literal(trackType),
    configuration: (0, _configurationSchema.ConfigurationReference)(baseTrackConfig),
    displays: _mobxStateTree.types.array(pluginManager.pluggableMstType('display', 'stateModel'))
  }).views(function (self) {
    return {
      get rpcSessionId() {
        return self.configuration.trackId;
      },

      get name() {
        return (0, _configuration.getConf)(self, 'name');
      },

      get textSearchAdapter() {
        return (0, _configuration.getConf)(self, 'textSearchAdapter');
      },

      /**
       * the PluggableElementType for the currently defined adapter
       */
      get adapterType() {
        var adapterConfig = (0, _configuration.getConf)(self, 'adapter');

        var _getEnv = (0, _mobxStateTree.getEnv)(self),
            pm = _getEnv.pluginManager;

        if (!adapterConfig) {
          throw new Error("no adapter configuration provided for ".concat(self.type));
        }

        var adapterType = pm.getAdapterType(adapterConfig.type);

        if (!adapterType) {
          throw new Error("unknown adapter type ".concat(adapterConfig.type));
        }

        return adapterType;
      },

      get viewMenuActions() {
        var menuItems = [];
        self.displays.forEach(function (display) {
          menuItems.push.apply(menuItems, (0, _toConsumableArray2.default)(display.viewMenuActions));
        });
        return menuItems;
      },

      get canConfigure() {
        var session = (0, _util.getSession)(self);
        return (0, _types.isSessionModelWithConfigEditing)(session) && ( // @ts-ignore
        session.adminMode || // @ts-ignore
        session.sessionTracks.find(function (track) {
          return track.trackId === self.configuration.trackId;
        }));
      },

      // distinct set of track items that are particular to this track type.
      // for base, there are none
      //
      // note: this attribute is helpful when composing together multiple
      // subtracks
      get composedTrackMenuItems() {
        return [];
      }

    };
  }).actions(function (self) {
    return {
      activateConfigurationUI: function activateConfigurationUI() {
        var session = (0, _util.getSession)(self);
        var view = (0, _util.getContainingView)(self);

        if ((0, _types.isSessionModelWithConfigEditing)(session)) {
          // @ts-ignore
          var trackConf = session.editTrackConfiguration(self.configuration);

          if (trackConf && trackConf !== self.configuration) {
            // @ts-ignore
            view.hideTrack(self.configuration); // @ts-ignore

            view.showTrack(trackConf);
          }
        }
      },
      showDisplay: function showDisplay(displayId) {
        var initialSnapshot = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var displayTypeConfigSchema = pluginManager.pluggableConfigSchemaType('display');
        var configuration = (0, _mobxStateTree.resolveIdentifier)(displayTypeConfigSchema, (0, _mobxStateTree.getRoot)(self), displayId);
        var displayType = pluginManager.getDisplayType(configuration.type);

        if (!displayType) {
          throw new Error("unknown display type ".concat(configuration.type));
        }

        var display = displayType.stateModel.create(_objectSpread(_objectSpread({}, initialSnapshot), {}, {
          type: configuration.type,
          configuration: configuration
        }));
        self.displays.push(display);
      },
      hideDisplay: function hideDisplay(displayId) {
        var displayTypeConfigSchema = pluginManager.pluggableConfigSchemaType('display');
        var configuration = (0, _mobxStateTree.resolveIdentifier)(displayTypeConfigSchema, (0, _mobxStateTree.getRoot)(self), displayId); // if we have any displays with that configuration, turn them off

        var shownDisplays = self.displays.filter(function (d) {
          return d.configuration === configuration;
        });
        (0, _mobx.transaction)(function () {
          return shownDisplays.forEach(function (d) {
            return self.displays.remove(d);
          });
        });
        return shownDisplays.length;
      },
      replaceDisplay: function replaceDisplay(oldDisplayId, newDisplayId) {
        var initialSnapshot = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var displayIdx = self.displays.findIndex(function (d) {
          return d.configuration.displayId === oldDisplayId;
        });

        if (displayIdx === -1) {
          throw new Error("could not find display id ".concat(oldDisplayId, " to replace"));
        }

        var displayTypeConfigSchema = pluginManager.pluggableConfigSchemaType('display');
        var configuration = (0, _mobxStateTree.resolveIdentifier)(displayTypeConfigSchema, (0, _mobxStateTree.getRoot)(self), newDisplayId);
        var displayType = pluginManager.getDisplayType(configuration.type);

        if (!displayType) {
          throw new Error("unknown display type ".concat(configuration.type));
        }

        self.displays.splice(displayIdx, 1, _objectSpread(_objectSpread({}, initialSnapshot), {}, {
          type: configuration.type,
          configuration: configuration
        }));
      }
    };
  }).views(function (self) {
    return {
      get trackMenuItems() {
        var menuItems = [];
        self.displays.forEach(function (display) {
          menuItems.push.apply(menuItems, (0, _toConsumableArray2.default)(display.trackMenuItems));
        });
        var displayChoices = [];
        var view = (0, _util.getContainingView)(self);
        var viewType = pluginManager.getViewType(view.type);
        var compatibleDisplayTypes = viewType.displayTypes.map(function (displayType) {
          return displayType.name;
        });
        var compatibleDisplays = self.configuration.displays.filter(function (displayConf) {
          return compatibleDisplayTypes.includes(displayConf.type);
        });
        var shownId = self.displays[0].configuration.displayId;

        if (compatibleDisplays.length > 1) {
          displayChoices.push({
            type: 'divider'
          }, {
            type: 'subHeader',
            label: 'Display types'
          });
          compatibleDisplays.forEach(function (displayConf) {
            displayChoices.push({
              type: 'radio',
              label: "".concat(displayConf.type),
              onClick: function onClick() {
                self.replaceDisplay(shownId, displayConf.displayId);
              },
              checked: displayConf.displayId === shownId
            });
          });
        }

        return [].concat(menuItems, displayChoices);
      }

    };
  });
}