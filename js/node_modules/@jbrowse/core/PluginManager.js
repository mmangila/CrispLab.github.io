"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _mobxStateTree = require("mobx-state-tree");

var _RendererType = _interopRequireDefault(require("./pluggableElementTypes/renderers/RendererType"));

var _AdapterType = _interopRequireDefault(require("./pluggableElementTypes/AdapterType"));

var _TrackType = _interopRequireDefault(require("./pluggableElementTypes/TrackType"));

var _DisplayType = _interopRequireDefault(require("./pluggableElementTypes/DisplayType"));

var _ViewType = _interopRequireDefault(require("./pluggableElementTypes/ViewType"));

var _WidgetType = _interopRequireDefault(require("./pluggableElementTypes/WidgetType"));

var _ConnectionType = _interopRequireDefault(require("./pluggableElementTypes/ConnectionType"));

var _RpcMethodType = _interopRequireDefault(require("./pluggableElementTypes/RpcMethodType"));

var _TextSearchAdapterType = _interopRequireDefault(require("./pluggableElementTypes/TextSearchAdapterType"));

var _configuration = require("./configuration");

var _Plugin = _interopRequireDefault(require("./Plugin"));

var _ReExports = _interopRequireDefault(require("./ReExports"));

var _CorePlugin = _interopRequireDefault(require("./CorePlugin"));

var _jexl = _interopRequireDefault(require("./util/jexl"));

/** little helper class that keeps groups of callbacks that are
then run in a specified order by group */
var PhasedScheduler = /*#__PURE__*/function () {
  function PhasedScheduler() {
    (0, _classCallCheck2.default)(this, PhasedScheduler);
    (0, _defineProperty2.default)(this, "phaseCallbacks", new Map());
    (0, _defineProperty2.default)(this, "phaseOrder", []);

    for (var _len = arguments.length, phaseOrder = new Array(_len), _key = 0; _key < _len; _key++) {
      phaseOrder[_key] = arguments[_key];
    }

    this.phaseOrder = phaseOrder;
  }

  (0, _createClass2.default)(PhasedScheduler, [{
    key: "add",
    value: function add(phase, callback) {
      if (!this.phaseOrder.includes(phase)) {
        throw new Error("unknown phase ".concat(phase));
      }

      var phaseCallbacks = this.phaseCallbacks.get(phase);

      if (!phaseCallbacks) {
        phaseCallbacks = [];
        this.phaseCallbacks.set(phase, phaseCallbacks);
      }

      phaseCallbacks.push(callback);
    }
  }, {
    key: "run",
    value: function run() {
      var _this = this;

      this.phaseOrder.forEach(function (phaseName) {
        var phaseCallbacks = _this.phaseCallbacks.get(phaseName);

        if (phaseCallbacks) {
          phaseCallbacks.forEach(function (callback) {
            return callback();
          });
        }
      });
    }
  }]);
  return PhasedScheduler;
}();

/** internal class that holds the info for a certain element type */
var TypeRecord = /*#__PURE__*/function () {
  function TypeRecord(typeName, elementType) {
    (0, _classCallCheck2.default)(this, TypeRecord);
    (0, _defineProperty2.default)(this, "registeredTypes", {});
    (0, _defineProperty2.default)(this, "baseClass", void 0);
    (0, _defineProperty2.default)(this, "typeName", void 0);
    this.typeName = typeName;
    this.baseClass = elementType;
  }

  (0, _createClass2.default)(TypeRecord, [{
    key: "add",
    value: function add(name, t) {
      this.registeredTypes[name] = t;
    }
  }, {
    key: "has",
    value: function has(name) {
      return name in this.registeredTypes;
    }
  }, {
    key: "get",
    value: function get(name) {
      if (!this.has(name)) {
        throw new Error("".concat(this.typeName, " '").concat(name, "' not found, perhaps its plugin is not loaded or its plugin has not added it."));
      }

      return this.registeredTypes[name];
    }
  }, {
    key: "all",
    value: function all() {
      return Object.values(this.registeredTypes);
    }
  }]);
  return TypeRecord;
}(); // eslint-disable-next-line @typescript-eslint/no-explicit-any


var PluginManager = /*#__PURE__*/function () {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  function PluginManager() {
    var _this2 = this;

    var initialPlugins = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    (0, _classCallCheck2.default)(this, PluginManager);
    (0, _defineProperty2.default)(this, "plugins", []);
    (0, _defineProperty2.default)(this, "jexl", (0, _jexl.default)());
    (0, _defineProperty2.default)(this, "pluginMetadata", {});
    (0, _defineProperty2.default)(this, "runtimePluginDefinitions", []);
    (0, _defineProperty2.default)(this, "elementCreationSchedule", new PhasedScheduler('renderer', 'adapter', 'text search adapter', 'display', 'track', 'connection', 'view', 'widget', 'rpc method'));
    (0, _defineProperty2.default)(this, "rendererTypes", new TypeRecord('RendererType', _RendererType.default));
    (0, _defineProperty2.default)(this, "adapterTypes", new TypeRecord('AdapterType', _AdapterType.default));
    (0, _defineProperty2.default)(this, "textSearchAdapterTypes", new TypeRecord('TextSearchAdapterType', _TextSearchAdapterType.default));
    (0, _defineProperty2.default)(this, "trackTypes", new TypeRecord('TrackType', _TrackType.default));
    (0, _defineProperty2.default)(this, "displayTypes", new TypeRecord('DisplayType', _DisplayType.default));
    (0, _defineProperty2.default)(this, "connectionTypes", new TypeRecord('ConnectionType', _ConnectionType.default));
    (0, _defineProperty2.default)(this, "viewTypes", new TypeRecord('ViewType', _ViewType.default));
    (0, _defineProperty2.default)(this, "widgetTypes", new TypeRecord('WidgetType', _WidgetType.default));
    (0, _defineProperty2.default)(this, "rpcMethods", new TypeRecord('RpcMethodType', _RpcMethodType.default));
    (0, _defineProperty2.default)(this, "configured", false);
    (0, _defineProperty2.default)(this, "rootModel", void 0);
    (0, _defineProperty2.default)(this, "jbrequireCache", new Map());
    (0, _defineProperty2.default)(this, "lib", _ReExports.default);
    (0, _defineProperty2.default)(this, "load", function (lib) {
      if (!_this2.jbrequireCache.has(lib)) {
        _this2.jbrequireCache.set(lib, lib(_this2));
      }

      return _this2.jbrequireCache.get(lib);
    });
    (0, _defineProperty2.default)(this, "jbrequire", function (lib) {
      if (typeof lib === 'string') {
        var pack = _this2.lib[lib];

        if (!pack) {
          throw new TypeError("No jbrequire re-export defined for package '".concat(lib, "'. If this package must be shared between plugins, add it to ReExports.js. If it does not need to be shared, just import it normally."));
        }

        return pack;
      }

      if (typeof lib === 'function') {
        return _this2.load(lib);
      }

      if (lib.default) {
        return _this2.jbrequire(lib.default);
      }

      throw new TypeError('lib passed to jbrequire must be either a string or a function');
    });
    // add the core plugin
    this.addPlugin({
      plugin: new _CorePlugin.default(),
      metadata: {
        isCore: true
      }
    }); // add all the initial plugins

    initialPlugins.forEach(function (plugin) {
      _this2.addPlugin(plugin);
    });
  }

  (0, _createClass2.default)(PluginManager, [{
    key: "pluginConfigurationSchemas",
    value: function pluginConfigurationSchemas() {
      var configurationSchemas = {};
      this.plugins.forEach(function (plugin) {
        if (plugin.configurationSchema) {
          configurationSchemas[plugin.name] = plugin.configurationSchema;
        }
      });
      return configurationSchemas;
    }
  }, {
    key: "addPlugin",
    value: function addPlugin(load) {
      if (this.configured) {
        throw new Error('JBrowse already configured, cannot add plugins');
      }

      var _ref = load instanceof _Plugin.default ? [load, {}] : [load.plugin, load.metadata],
          _ref2 = (0, _slicedToArray2.default)(_ref, 2),
          plugin = _ref2[0],
          _ref2$ = _ref2[1],
          metadata = _ref2$ === void 0 ? {} : _ref2$;

      if (this.plugins.includes(plugin)) {
        throw new Error('plugin already installed');
      }

      this.pluginMetadata[plugin.name] = metadata;

      if ('definition' in load) {
        this.runtimePluginDefinitions.push(load.definition);
      }

      plugin.install(this);
      this.plugins.push(plugin);
      return this;
    }
  }, {
    key: "getPlugin",
    value: function getPlugin(name) {
      return this.plugins.find(function (p) {
        return p.name === name;
      });
    }
  }, {
    key: "hasPlugin",
    value: function hasPlugin(name) {
      return this.getPlugin(name) !== undefined;
    }
  }, {
    key: "createPluggableElements",
    value: function createPluggableElements() {
      // run the creation callbacks for each element type in order.
      // see elementCreationSchedule above for the creation order
      this.elementCreationSchedule.run();
      delete this.elementCreationSchedule;
      return this;
    }
  }, {
    key: "setRootModel",
    value: function setRootModel(rootModel) {
      this.rootModel = rootModel;
    }
  }, {
    key: "configure",
    value: function configure() {
      var _this3 = this;

      if (this.configured) {
        throw new Error('already configured');
      }

      this.plugins.forEach(function (plugin) {
        return plugin.configure(_this3);
      });
      this.configured = true; // console.log(JSON.stringify(getSnapshot(model)))

      return this;
    }
  }, {
    key: "getElementTypeRecord",
    value: function getElementTypeRecord(groupName) {
      switch (groupName) {
        case 'adapter':
          return this.adapterTypes;

        case 'text search adapter':
          return this.textSearchAdapterTypes;

        case 'connection':
          return this.connectionTypes;

        case 'widget':
          return this.widgetTypes;

        case 'renderer':
          return this.rendererTypes;

        case 'display':
          return this.displayTypes;

        case 'track':
          return this.trackTypes;

        case 'view':
          return this.viewTypes;

        case 'rpc method':
          return this.rpcMethods;

        default:
          throw new Error("invalid element type '".concat(groupName, "'"));
      }
    }
  }, {
    key: "addElementType",
    value: function addElementType(groupName, creationCallback) {
      var _this4 = this;

      if (typeof creationCallback !== 'function') {
        throw new Error('must provide a callback function that returns the new type object');
      }

      var typeRecord = this.getElementTypeRecord(groupName);
      this.elementCreationSchedule.add(groupName, function () {
        var newElement = creationCallback(_this4);

        if (!newElement.name) {
          throw new Error("cannot add a ".concat(groupName, " with no name"));
        }

        if (typeRecord.has(newElement.name)) {
          throw new Error("".concat(groupName, " ").concat(newElement.name, " already registered, cannot register it again"));
        }

        typeRecord.add(newElement.name, newElement);
      });
      return this;
    }
  }, {
    key: "getElementType",
    value: function getElementType(groupName, typeName) {
      var typeRecord = this.getElementTypeRecord(groupName);
      return typeRecord.get(typeName);
    }
  }, {
    key: "getElementTypesInGroup",
    value: function getElementTypesInGroup(groupName) {
      var typeRecord = this.getElementTypeRecord(groupName);
      return typeRecord.all();
    }
    /** get a MST type for the union of all specified pluggable MST types */

  }, {
    key: "pluggableMstType",
    value: function pluggableMstType(typeGroup, fieldName) {
      var fallback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _mobxStateTree.types.maybe(_mobxStateTree.types.null);
      var pluggableTypes = [];
      this.getElementTypeRecord(typeGroup).all().forEach(function (t) {
        var thing = t[fieldName];

        if ((0, _mobxStateTree.isType)(thing) && (0, _mobxStateTree.isModelType)(thing)) {
          pluggableTypes.push(thing);
        }
      }); // try to smooth over the case when no types are registered, mostly
      // encountered in tests

      if (pluggableTypes.length === 0) {
        console.warn("No JBrowse pluggable types found matching ('".concat(typeGroup, "','").concat(fieldName, "')"));
        return fallback;
      }

      return _mobxStateTree.types.union.apply(_mobxStateTree.types, pluggableTypes);
    }
    /** get a MST type for the union of all specified pluggable config schemas */

  }, {
    key: "pluggableConfigSchemaType",
    value: function pluggableConfigSchemaType(typeGroup) {
      var fieldName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'configSchema';
      var pluggableTypes = [];
      this.getElementTypeRecord(typeGroup).all().forEach(function (t) {
        var thing = t[fieldName];

        if ((0, _configuration.isBareConfigurationSchemaType)(thing)) {
          pluggableTypes.push(thing);
        }
      });

      if (pluggableTypes.length === 0) {
        pluggableTypes.push((0, _configuration.ConfigurationSchema)('Null', {}));
      }

      return _mobxStateTree.types.union.apply(_mobxStateTree.types, pluggableTypes);
    }
  }, {
    key: "getRendererType",
    value: function getRendererType(typeName) {
      return this.rendererTypes.get(typeName);
    }
  }, {
    key: "getRendererTypes",
    value: function getRendererTypes() {
      return this.rendererTypes.all();
    }
  }, {
    key: "getAdapterType",
    value: function getAdapterType(typeName) {
      return this.adapterTypes.get(typeName);
    }
  }, {
    key: "getTextSearchAdapterType",
    value: function getTextSearchAdapterType(typeName) {
      return this.textSearchAdapterTypes.get(typeName);
    }
  }, {
    key: "getTrackType",
    value: function getTrackType(typeName) {
      return this.trackTypes.get(typeName);
    }
  }, {
    key: "getDisplayType",
    value: function getDisplayType(typeName) {
      return this.displayTypes.get(typeName);
    }
  }, {
    key: "getViewType",
    value: function getViewType(typeName) {
      return this.viewTypes.get(typeName);
    }
  }, {
    key: "getWidgetType",
    value: function getWidgetType(typeName) {
      return this.widgetTypes.get(typeName);
    }
  }, {
    key: "getConnectionType",
    value: function getConnectionType(typeName) {
      return this.connectionTypes.get(typeName);
    }
  }, {
    key: "getRpcMethodType",
    value: function getRpcMethodType(methodName) {
      return this.rpcMethods.get(methodName);
    }
  }, {
    key: "addRendererType",
    value: function addRendererType(creationCallback) {
      return this.addElementType('renderer', creationCallback);
    }
  }, {
    key: "addAdapterType",
    value: function addAdapterType(creationCallback) {
      return this.addElementType('adapter', creationCallback);
    }
  }, {
    key: "addTextSearchAdapterType",
    value: function addTextSearchAdapterType(creationCallback) {
      return this.addElementType('text search adapter', creationCallback);
    }
  }, {
    key: "addTrackType",
    value: function addTrackType(creationCallback) {
      var _this5 = this;

      // Goes through the already-created displays and registers the ones that
      // specify this track type
      var callback = function callback() {
        var track = creationCallback(_this5);

        _this5.getElementTypesInGroup('display').forEach(function (display) {
          if (display.trackType === track.name && // track may have already added the displayType in its creationCallback
          !track.displayTypes.includes(display)) {
            track.addDisplayType(display);
          }
        });

        return track;
      };

      return this.addElementType('track', callback);
    }
  }, {
    key: "addDisplayType",
    value: function addDisplayType(creationCallback) {
      return this.addElementType('display', creationCallback);
    }
  }, {
    key: "addViewType",
    value: function addViewType(creationCallback) {
      var _this6 = this;

      var callback = function callback() {
        var newView = creationCallback(_this6);

        _this6.getElementTypesInGroup('display').forEach(function (display) {
          if (display.viewType === newView.name && // view may have already added the displayType in its creationCallback
          !newView.displayTypes.includes(display)) {
            newView.addDisplayType(display);
          }
        });

        return newView;
      };

      return this.addElementType('view', callback);
    }
  }, {
    key: "addWidgetType",
    value: function addWidgetType(creationCallback) {
      return this.addElementType('widget', creationCallback);
    }
  }, {
    key: "addConnectionType",
    value: function addConnectionType(creationCallback) {
      return this.addElementType('connection', creationCallback);
    }
  }, {
    key: "addRpcMethod",
    value: function addRpcMethod(creationCallback) {
      return this.addElementType('rpc method', creationCallback);
    }
  }]);
  return PluginManager;
}();

exports.default = PluginManager;