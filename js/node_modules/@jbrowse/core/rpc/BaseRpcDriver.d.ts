import PluginManager from '../PluginManager';
import { AnyConfigurationModel } from '../configuration/configurationSchema';
export interface WorkerHandle {
    status?: string;
    error?: Error;
    on?: (channel: string, callback: (message: string) => void) => void;
    off?: (channel: string, callback: (message: string) => void) => void;
    destroy(): void;
    call(functionName: string, args?: unknown, options?: {
        statusCallback?(message: string): void;
        timeout?: number;
        rpcDriverClassName: string;
    }): Promise<unknown>;
}
export interface RpcDriverConstructorArgs {
    config: AnyConfigurationModel;
}
export declare function watchWorker(worker: WorkerHandle, pingTime: number, rpcDriverClassName: string): Promise<unknown>;
declare class LazyWorker {
    worker?: WorkerHandle;
    driver: BaseRpcDriver;
    constructor(driver: BaseRpcDriver);
    getWorker(pluginManager: PluginManager, rpcDriverClassName: string): WorkerHandle;
}
export default abstract class BaseRpcDriver {
    abstract name: string;
    private lastWorkerAssignment;
    private workerAssignments;
    private workerCount;
    abstract makeWorker(pluginManager: PluginManager): WorkerHandle;
    private workerPool?;
    maxPingTime: number;
    workerCheckFrequency: number;
    config: AnyConfigurationModel;
    constructor(args: RpcDriverConstructorArgs);
    filterArgs<THING_TYPE>(thing: THING_TYPE, pluginManager: PluginManager, sessionId: string): THING_TYPE;
    remoteAbort(pluginManager: PluginManager, sessionId: string, functionName: string, signalId: number): void;
    createWorkerPool(): LazyWorker[];
    getWorkerPool(): LazyWorker[];
    getWorker(sessionId: string, pluginManager: PluginManager): WorkerHandle;
    call(pluginManager: PluginManager, sessionId: string, functionName: string, args: {
        statusCallback?: (message: string) => void;
    }, options?: {}): Promise<unknown>;
}
export {};
