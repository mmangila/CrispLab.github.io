"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.watchWorker = watchWorker;
exports.default = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _mobxStateTree = require("mobx-state-tree");

var _util = require("../util");

var _remoteAbortSignals = require("./remoteAbortSignals");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function isClonable(thing) {
  if (typeof thing === 'function') {
    return false;
  }

  if (thing instanceof Error) {
    return false;
  }

  return true;
} // watches the given worker object, returns a promise that will be rejected if
// the worker times out


function watchWorker(_x, _x2, _x3) {
  return _watchWorker.apply(this, arguments);
}

function _watchWorker() {
  _watchWorker = (0, _asyncToGenerator2.default)( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(worker, pingTime, rpcDriverClassName) {
    return regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _context3.next = 2;
            return worker.call('ping', [], {
              timeout: 100000000,
              rpcDriverClassName: rpcDriverClassName
            });

          case 2:
            return _context3.abrupt("return", new Promise(function (_resolve, reject) {
              function delay() {
                setTimeout( /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
                  return regeneratorRuntime.wrap(function _callee2$(_context2) {
                    while (1) {
                      switch (_context2.prev = _context2.next) {
                        case 0:
                          _context2.prev = 0;
                          _context2.next = 3;
                          return worker.call('ping', [], {
                            timeout: pingTime * 2,
                            rpcDriverClassName: rpcDriverClassName
                          });

                        case 3:
                          delay();
                          _context2.next = 9;
                          break;

                        case 6:
                          _context2.prev = 6;
                          _context2.t0 = _context2["catch"](0);
                          reject(_context2.t0);

                        case 9:
                        case "end":
                          return _context2.stop();
                      }
                    }
                  }, _callee2, null, [[0, 6]]);
                })), pingTime);
              }

              delay();
            }));

          case 3:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _watchWorker.apply(this, arguments);
}

function detectHardwareConcurrency() {
  var mainThread = typeof window !== 'undefined';
  var canDetect = mainThread && 'hardwareConcurrency' in window.navigator;

  if (mainThread && canDetect) {
    return window.navigator.hardwareConcurrency;
  }

  return 1;
}

var LazyWorker = /*#__PURE__*/function () {
  function LazyWorker(driver) {
    (0, _classCallCheck2.default)(this, LazyWorker);
    (0, _defineProperty2.default)(this, "worker", void 0);
    (0, _defineProperty2.default)(this, "driver", void 0);
    this.driver = driver;
  }

  (0, _createClass2.default)(LazyWorker, [{
    key: "getWorker",
    value: function getWorker(pluginManager, rpcDriverClassName) {
      var _this = this;

      if (!this.worker) {
        var worker = this.driver.makeWorker(pluginManager);
        watchWorker(worker, this.driver.maxPingTime, rpcDriverClassName).catch(function (error) {
          if (_this.worker) {
            console.warn("worker did not respond, killing and generating new one ".concat(error));

            _this.worker.destroy();

            _this.worker.status = 'killed';
            _this.worker.error = error;
            _this.worker = undefined;
          }
        });
        this.worker = worker;
      }

      return this.worker;
    }
  }]);
  return LazyWorker;
}();

var BaseRpcDriver = /*#__PURE__*/function () {
  function BaseRpcDriver(args) {
    (0, _classCallCheck2.default)(this, BaseRpcDriver);
    (0, _defineProperty2.default)(this, "name", void 0);
    (0, _defineProperty2.default)(this, "lastWorkerAssignment", -1);
    (0, _defineProperty2.default)(this, "workerAssignments", new Map());
    (0, _defineProperty2.default)(this, "workerCount", 0);
    (0, _defineProperty2.default)(this, "workerPool", void 0);
    (0, _defineProperty2.default)(this, "maxPingTime", 30000);
    (0, _defineProperty2.default)(this, "workerCheckFrequency", 5000);
    (0, _defineProperty2.default)(this, "config", void 0);
    this.config = args.config;
  } // filter the given object and just remove any non-clonable things from it


  (0, _createClass2.default)(BaseRpcDriver, [{
    key: "filterArgs",
    value: function filterArgs(thing, pluginManager, sessionId) {
      var _this2 = this;

      if (Array.isArray(thing)) {
        return thing.filter(isClonable).map(function (t) {
          return _this2.filterArgs(t, pluginManager, sessionId);
        });
      }

      if ((0, _typeof2.default)(thing) === 'object' && thing !== null) {
        // AbortSignals are specially handled
        if (thing instanceof AbortSignal) {
          return (0, _remoteAbortSignals.serializeAbortSignal)(thing, this.remoteAbort.bind(this, pluginManager, sessionId));
        }

        if ((0, _mobxStateTree.isStateTreeNode)(thing) && !(0, _mobxStateTree.isAlive)(thing)) {
          throw new Error('dead state tree node passed to RPC call');
        } // special case, don't try to iterate the file's subelements as the
        // object entries below would


        if (thing instanceof File) {
          return thing;
        }

        return (0, _util.objectFromEntries)(Object.entries(thing).filter(function (e) {
          return isClonable(e[1]);
        }).map(function (_ref) {
          var _ref2 = (0, _slicedToArray2.default)(_ref, 2),
              k = _ref2[0],
              v = _ref2[1];

          return [k, _this2.filterArgs(v, pluginManager, sessionId)];
        }));
      }

      return thing;
    }
  }, {
    key: "remoteAbort",
    value: function remoteAbort(pluginManager, sessionId, functionName, signalId) {
      var worker = this.getWorker(sessionId, pluginManager);
      worker.call(functionName, {
        signalId: signalId
      }, {
        timeout: 1000000,
        rpcDriverClassName: this.name
      });
    }
  }, {
    key: "createWorkerPool",
    value: function createWorkerPool() {
      var _this3 = this;

      var hardwareConcurrency = detectHardwareConcurrency();
      var workerCount = this.workerCount || Math.max(1, Math.ceil((hardwareConcurrency - 2) / 3));
      return (0, _toConsumableArray2.default)(new Array(workerCount)).map(function () {
        return new LazyWorker(_this3);
      });
    }
  }, {
    key: "getWorkerPool",
    value: function getWorkerPool() {
      if (!this.workerPool) {
        var res = this.createWorkerPool();
        this.workerPool = res;
        return res; // making this several steps makes TS happy
      }

      return this.workerPool;
    }
  }, {
    key: "getWorker",
    value: function getWorker(sessionId, pluginManager) {
      var workers = this.getWorkerPool();
      var workerNumber = this.workerAssignments.get(sessionId);

      if (workerNumber === undefined) {
        var workerAssignment = (this.lastWorkerAssignment + 1) % workers.length;
        this.workerAssignments.set(sessionId, workerAssignment);
        this.lastWorkerAssignment = workerAssignment;
        workerNumber = workerAssignment;
      } // console.log(`${sessionId} -> worker ${workerNumber}`)


      var worker = workers[workerNumber].getWorker(pluginManager, this.name);

      if (!worker) {
        throw new Error('no web workers registered for RPC');
      }

      return worker;
    }
  }, {
    key: "call",
    value: function () {
      var _call = (0, _asyncToGenerator2.default)( /*#__PURE__*/regeneratorRuntime.mark(function _callee(pluginManager, sessionId, functionName, args) {
        var _this4 = this;

        var options,
            worker,
            rpcMethod,
            serializedArgs,
            filteredAndSerializedArgs,
            callP,
            killedCheckInterval,
            killedP,
            resultP,
            _args = arguments;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                options = _args.length > 4 && _args[4] !== undefined ? _args[4] : {};

                if (sessionId) {
                  _context.next = 3;
                  break;
                }

                throw new TypeError('sessionId is required');

              case 3:
                worker = this.getWorker(sessionId, pluginManager);
                rpcMethod = pluginManager.getRpcMethodType(functionName);
                _context.next = 7;
                return rpcMethod.serializeArguments(args, this.name);

              case 7:
                serializedArgs = _context.sent;
                filteredAndSerializedArgs = this.filterArgs(serializedArgs, pluginManager, sessionId); // now actually call the worker

                callP = worker.call(functionName, filteredAndSerializedArgs, _objectSpread({
                  timeout: 5 * 60 * 1000,
                  // 5 minutes
                  statusCallback: args.statusCallback,
                  rpcDriverClassName: this.name
                }, options)); // check every 5 seconds to see if the worker has been killed, and
                // reject the killedP promise if it has

                killedP = new Promise(function (_resolve, reject) {
                  killedCheckInterval = setInterval(function () {
                    // must've been killed
                    if (worker.status === 'killed') {
                      reject(new Error("operation timed out, worker process stopped responding, ".concat(worker.error)));
                    }
                  }, _this4.workerCheckFrequency);
                }).finally(function () {
                  clearInterval(killedCheckInterval);
                }); // the result is a race between the actual result promise, and the "killed"
                // promise. the killed promise will only actually win if the worker was
                // killed before the call could return

                resultP = Promise.race([callP, killedP]);
                _context.t0 = rpcMethod;
                _context.next = 15;
                return resultP;

              case 15:
                _context.t1 = _context.sent;
                _context.t2 = args;
                _context.t3 = this.name;
                return _context.abrupt("return", _context.t0.deserializeReturn.call(_context.t0, _context.t1, _context.t2, _context.t3));

              case 19:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function call(_x4, _x5, _x6, _x7) {
        return _call.apply(this, arguments);
      }

      return call;
    }()
  }]);
  return BaseRpcDriver;
}();

exports.default = BaseRpcDriver;