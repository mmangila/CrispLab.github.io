"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = assemblyManagerFactory;

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _mobx = require("mobx");

var _mobxStateTree = require("mobx-state-tree");

var _util = require("../util");

var _configuration = require("../configuration");

var _assembly = _interopRequireDefault(require("./assembly"));

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function assemblyManagerFactory(assemblyConfigType, pluginManager) {
  var Assembly = (0, _assembly.default)(assemblyConfigType, pluginManager);
  return _mobxStateTree.types.model({
    assemblies: _mobxStateTree.types.array(Assembly)
  }).views(function (self) {
    return {
      get: function get(assemblyName) {
        return self.assemblies.find(function (assembly) {
          return assembly.hasName(assemblyName);
        });
      },

      get assemblyList() {
        // name is the explicit identifier and can be accessed without getConf,
        // hence the union with {name:string}
        var _getParent = (0, _mobxStateTree.getParent)(self),
            assemblies = _getParent.jbrowse.assemblies,
            _getParent$session$se = _getParent.session.sessionAssemblies,
            sessionAssemblies = _getParent$session$se === void 0 ? [] : _getParent$session$se;

        return [].concat((0, _toConsumableArray2.default)(assemblies), (0, _toConsumableArray2.default)(sessionAssemblies));
      },

      get rpcManager() {
        return (0, _mobxStateTree.getParent)(self).rpcManager;
      },

      get pluginManager() {
        return (0, _mobxStateTree.getParent)(self).pluginManager;
      },

      get allPossibleRefNames() {
        var refNames = [];

        var _iterator = _createForOfIteratorHelper(self.assemblies),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var assembly = _step.value;

            if (!assembly.allRefNames) {
              return undefined;
            }

            refNames = refNames.concat(assembly.allRefNames);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        return refNames;
      }

    };
  }).views(function (self) {
    return {
      // use this method instead of assemblyManager.get(assemblyName)
      // get an assembly with regions loaded
      waitForAssembly: function waitForAssembly(assemblyName) {
        return (0, _asyncToGenerator2.default)( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
          var assembly;
          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  if (assemblyName) {
                    _context.next = 2;
                    break;
                  }

                  throw new Error('no assembly name supplied to waitForAssembly');

                case 2:
                  assembly = self.get(assemblyName);

                  if (!assembly) {
                    _context.next = 7;
                    break;
                  }

                  _context.next = 6;
                  return (0, _util.when)(function () {
                    return Boolean(assembly.regions && assembly.refNameAliases);
                  });

                case 6:
                  return _context.abrupt("return", assembly);

                case 7:
                  return _context.abrupt("return", undefined);

                case 8:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }))();
      },
      getRefNameMapForAdapter: function getRefNameMapForAdapter(adapterConf, assemblyName, opts) {
        return (0, _asyncToGenerator2.default)( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
          var assembly;
          return regeneratorRuntime.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  _context2.next = 2;
                  return (0, _util.when)(function () {
                    return Boolean(self.get(assemblyName));
                  }, {
                    signal: opts.signal,
                    name: 'when assembly ready'
                  });

                case 2:
                  assembly = self.get(assemblyName);

                  if (!assembly) {
                    _context2.next = 5;
                    break;
                  }

                  return _context2.abrupt("return", assembly.getRefNameMapForAdapter(adapterConf, opts));

                case 5:
                  return _context2.abrupt("return", undefined);

                case 6:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2);
        }))();
      },
      getReverseRefNameMapForAdapter: function getReverseRefNameMapForAdapter(adapterConf, assemblyName, opts) {
        return (0, _asyncToGenerator2.default)( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
          var assembly;
          return regeneratorRuntime.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  _context3.next = 2;
                  return (0, _util.when)(function () {
                    return Boolean(self.get(assemblyName));
                  }, {
                    signal: opts.signal,
                    name: 'when assembly ready'
                  });

                case 2:
                  assembly = self.get(assemblyName);

                  if (!assembly) {
                    _context3.next = 5;
                    break;
                  }

                  return _context3.abrupt("return", assembly.getReverseRefNameMapForAdapter(adapterConf, opts));

                case 5:
                  return _context3.abrupt("return", undefined);

                case 6:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3);
        }))();
      },
      isValidRefName: function isValidRefName(refName, assemblyName) {
        if (assemblyName) {
          var assembly = self.get(assemblyName);

          if (assembly) {
            return assembly.isValidRefName(refName);
          }

          throw new Error("isValidRefName for ".concat(assemblyName, " failed, assembly does not exist"));
        }

        if (!self.allPossibleRefNames) {
          throw new Error("isValidRefName not available, assemblyManager has not yet finished loading. If you are looking for a refname in a specific assembly, pass assembly argument");
        }

        return self.allPossibleRefNames.includes(refName);
      }
    };
  }).actions(function (self) {
    return {
      removeAssembly: function removeAssembly(asm) {
        self.assemblies.remove(asm);
      },
      afterAttach: function afterAttach() {
        var _this = this;

        (0, _mobxStateTree.addDisposer)(self, (0, _mobx.reaction)( // have to slice it to be properly reacted to
        function () {
          return self.assemblyList;
        }, function (assemblyConfigs) {
          self.assemblies.forEach(function (asm) {
            if (!asm.configuration) {
              _this.removeAssembly(asm);
            }
          });
          assemblyConfigs.forEach(function (assemblyConfig) {
            var existingAssemblyIdx = self.assemblies.findIndex(function (assembly) {
              return assembly.name === (0, _configuration.readConfObject)(assemblyConfig, 'name');
            });

            if (existingAssemblyIdx === -1) {
              _this.addAssembly(assemblyConfig);
            }
          });
        }, {
          fireImmediately: true,
          name: 'assemblyManagerAfterAttach'
        }));
      },
      // this can take an active instance of an assembly, in which case it is
      // referred to, or it can take an identifier e.g. assembly name, which is
      // used as a reference. snapshots cannot be used
      addAssembly: function addAssembly(assemblyConfig) {
        self.assemblies.push({
          configuration: assemblyConfig
        });
      },
      replaceAssembly: function replaceAssembly(idx, assemblyConfig) {
        self.assemblies[idx] = (0, _mobxStateTree.cast)({
          configuration: assemblyConfig
        });
      }
    };
  });
}