"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = calculateDynamicBlocks;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _range = require("./range");

var _ = require(".");

var _blockTypes = require("./blockTypes");

/**
 * returns a BlockSet of which the `blocks` attribute is an array of 'dynamic
 * blocks', which are blocks representing only the regions that are visible in
 * the view right now. these are mostly used by tracks for which static blocks
 * are not feasible.
 *
 * each block is a plain JS object like:
 *   `{ refName, start, end, offsetPx, reversed? }`
 *
 * start and end are in bp, and start is always less than end, but if reversed
 * is true, startBp will be on the right side of the visible region.
 *
 * offsetPx is the number of pixels from the left edge of the view to the left
 * edge of the region
 *
 * NOTE: start, end, and offsetPx may all be fractional!
 *
 * @returns BlockSet of `{ refName, startBp, end, offset, reversed? }`
 */
function calculateDynamicBlocks(model) {
  var padding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  var elision = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  var offsetPx = model.offsetPx,
      displayedRegions = model.displayedRegions,
      bpPerPx = model.bpPerPx,
      width = model.width,
      minimumBlockWidth = model.minimumBlockWidth,
      interRegionPaddingWidth = model.interRegionPaddingWidth;

  if (!width) {
    throw new Error('view has no width, cannot calculate displayed blocks');
  }

  var blocks = new _blockTypes.BlockSet();
  var displayedRegionLeftPx = 0;
  var windowLeftPx = offsetPx;
  var windowRightPx = windowLeftPx + width;
  displayedRegions.forEach(function (region, regionNumber) {
    var assemblyName = region.assemblyName,
        refName = region.refName,
        regionStart = region.start,
        regionEnd = region.end,
        reversed = region.reversed;
    var displayedRegionRightPx = displayedRegionLeftPx + (regionEnd - regionStart) / bpPerPx;
    var regionWidthPx = (regionEnd - regionStart) / bpPerPx;

    if (displayedRegionLeftPx < windowRightPx && displayedRegionRightPx > windowLeftPx) {
      // this displayed region overlaps the view, so make a record for it
      var _intersection = (0, _range.intersection2)(windowLeftPx, windowRightPx, displayedRegionLeftPx, displayedRegionRightPx),
          _intersection2 = (0, _slicedToArray2.default)(_intersection, 2),
          leftPx = _intersection2[0],
          rightPx = _intersection2[1];

      var start;
      var end;
      var isLeftEndOfDisplayedRegion;
      var isRightEndOfDisplayedRegion;
      var blockOffsetPx;

      if (reversed) {
        start = Math.max(regionStart, regionEnd - (rightPx - displayedRegionLeftPx) * bpPerPx);
        end = regionEnd - (leftPx - displayedRegionLeftPx) * bpPerPx;
        isLeftEndOfDisplayedRegion = end === regionEnd;
        isRightEndOfDisplayedRegion = start === regionStart;
        blockOffsetPx = displayedRegionLeftPx + (regionEnd - end) / bpPerPx;
      } else {
        start = (leftPx - displayedRegionLeftPx) * bpPerPx + regionStart;
        end = Math.min(regionEnd, (rightPx - displayedRegionLeftPx) * bpPerPx + regionStart);
        isLeftEndOfDisplayedRegion = start === regionStart;
        isRightEndOfDisplayedRegion = end === regionEnd;
        blockOffsetPx = displayedRegionLeftPx + (start - regionStart) / bpPerPx;
      }

      var widthPx = (end - start) / bpPerPx;
      var blockData = {
        assemblyName: assemblyName,
        refName: refName,
        start: start,
        end: end,
        reversed: reversed,
        offsetPx: blockOffsetPx,
        parentRegion: region,
        regionNumber: regionNumber,
        widthPx: widthPx,
        isLeftEndOfDisplayedRegion: isLeftEndOfDisplayedRegion,
        isRightEndOfDisplayedRegion: isRightEndOfDisplayedRegion,
        key: ''
      };
      blockData.key = "".concat((0, _.assembleLocString)(blockData), "-").concat(regionNumber).concat(reversed ? '-reversed' : '');

      if (padding && blocks.length === 0 && isLeftEndOfDisplayedRegion) {
        blocks.push(new _blockTypes.InterRegionPaddingBlock({
          key: "".concat(blockData.key, "-beforeFirstRegion"),
          widthPx: -offsetPx,
          offsetPx: blockData.offsetPx + offsetPx,
          variant: 'boundary'
        }));
      }

      if (elision && regionWidthPx < minimumBlockWidth) {
        blocks.push(new _blockTypes.ElidedBlock(blockData));
      } else {
        blocks.push(new _blockTypes.ContentBlock(blockData));
      }

      if (padding) {
        // insert a inter-region padding block if we are crossing a displayed region
        if (regionWidthPx >= minimumBlockWidth && blockData.isRightEndOfDisplayedRegion && regionNumber < displayedRegions.length - 1) {
          blocks.push(new _blockTypes.InterRegionPaddingBlock({
            key: "".concat(blockData.key, "-rightpad"),
            widthPx: interRegionPaddingWidth,
            offsetPx: blockData.offsetPx + blockData.widthPx
          }));
          displayedRegionLeftPx += interRegionPaddingWidth;
        }

        if (regionNumber === displayedRegions.length - 1 && blockData.isRightEndOfDisplayedRegion) {
          blockOffsetPx = blockData.offsetPx + blockData.widthPx;
          blocks.push(new _blockTypes.InterRegionPaddingBlock({
            key: "".concat(blockData.key, "-afterLastRegion"),
            widthPx: width - blockOffsetPx + offsetPx,
            offsetPx: blockOffsetPx,
            variant: 'boundary'
          }));
        }
      }
    }

    displayedRegionLeftPx += (regionEnd - regionStart) / bpPerPx;
  });
  return blocks;
}