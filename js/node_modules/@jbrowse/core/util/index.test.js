"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _index = require("./index");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

describe('parseLocString', function () {
  var cases = [['chr1:1..200', {
    start: 0,
    end: 200,
    refName: 'chr1'
  }], ['chr1:1,000,000..2,000,000', {
    start: 999999,
    end: 2000000,
    refName: 'chr1'
  }], ['chr1:1-200', {
    start: 0,
    end: 200,
    refName: 'chr1'
  }], ['{hg19}chr1:1-200', {
    assemblyName: 'hg19',
    start: 0,
    end: 200,
    refName: 'chr1'
  }], ['{hg19}chr1:1..200', {
    assemblyName: 'hg19',
    start: 0,
    end: 200,
    refName: 'chr1'
  }], ['{hg19}chr1:1', {
    assemblyName: 'hg19',
    start: 0,
    end: 1,
    refName: 'chr1'
  }], ['chr1:1', {
    start: 0,
    end: 1,
    refName: 'chr1'
  }], ['chr1:-1', {
    start: -2,
    end: -1,
    refName: 'chr1'
  }], ['chr1:-100..-1', {
    start: -101,
    end: -1,
    refName: 'chr1'
  }], ['chr1:-100--1', // weird but valid
  {
    start: -101,
    end: -1,
    refName: 'chr1'
  }], ['chr2:1000-', {
    refName: 'chr2',
    start: 999
  }], ['chr2:1,000-', {
    refName: 'chr2',
    start: 999
  }], ['chr1', {
    refName: 'chr1'
  }], ['{hg19}chr1', {
    assemblyName: 'hg19',
    refName: 'chr1'
  }]];
  cases.forEach(function (_ref) {
    var _ref2 = (0, _slicedToArray2.default)(_ref, 2),
        input = _ref2[0],
        output = _ref2[1];

    test("".concat(input), function () {
      expect((0, _index.parseLocString)(input, function (refName) {
        return refName === 'chr1' || refName === 'chr2';
      })).toEqual(output);
    });
  });
});
describe('assembleLocString', function () {
  var cases = [[{
    refName: 'chr1'
  }, 'chr1'], [{
    refName: 'chr1',
    start: 0
  }, 'chr1:1..'], [{
    refName: 'chr1',
    start: 0,
    end: 1
  }, 'chr1:1'], [{
    refName: 'chr1',
    start: 0,
    end: 100
  }, 'chr1:1..100'], [{
    refName: 'chr1',
    start: 0,
    end: 200
  }, 'chr1:1..200'], [{
    refName: 'chr1',
    start: 1000000,
    end: 2000000
  }, 'chr1:1,000,001..2,000,000'], [{
    assemblyName: 'hg19',
    refName: 'chr1',
    start: 0,
    end: 100
  }, '{hg19}chr1:1..100'], [{
    refName: 'chr1',
    start: -2,
    end: -1
  }, 'chr1:-1'], [{
    start: -100,
    end: -1,
    refName: 'chr1'
  }, 'chr1:-99..-1']];
  cases.forEach(function (_ref3) {
    var _ref4 = (0, _slicedToArray2.default)(_ref3, 2),
        input = _ref4[0],
        output = _ref4[1];

    test("assemble ".concat(output), function () {
      expect((0, _index.assembleLocString)(input)).toEqual(output);
    });
    test("assemble and parse ".concat(output), function () {
      expect((0, _index.parseLocString)((0, _index.assembleLocString)(input), function (refName) {
        return refName === 'chr1' || refName === 'chr2';
      })).toEqual(input);
    });
  }); // Special case since undefined `start` will result in `start` being assumed
  // to be `0`

  var location = {
    refName: 'chr1',
    end: 100
  };
  test("assemble 'chr1:1..100'", function () {
    expect((0, _index.assembleLocString)(location)).toEqual('chr1:1..100');
  });
  test('test empty assemblyName', function () {
    var location = '{}chr1:1..100';
    expect(function () {
      (0, _index.parseLocString)(location, function (refName) {
        return refName === 'chr1' || refName === 'chr2';
      });
    }).toThrow("no assembly name was provided in location \"".concat(location, "\""));
  });
  test("assemble and parse 'chr1:1..100'", function () {
    expect((0, _index.parseLocString)((0, _index.assembleLocString)(location), function (refName) {
      return refName === 'chr1' || refName === 'chr2';
    })).toEqual(_objectSpread(_objectSpread({}, location), {}, {
      start: 0
    }));
  });
});
describe('compareLocStrings', function () {
  var cases = [['chr1:1..200', 'chr1:1-200', 0], ['chr1:1-200', '{hg19}chr1:1-200', -1], ['{hg19}chr1:1-200', 'chr1:1-200', 1], ['{hg19}chr1:1-200', '{hg19}chr1:2-200', -1]];
  cases.forEach(function (_ref5) {
    var _ref6 = (0, _slicedToArray2.default)(_ref5, 3),
        input1 = _ref6[0],
        input2 = _ref6[1],
        output = _ref6[2];

    test("".concat(input1, " ").concat(input2, " = ").concat(output), function () {
      expect((0, _index.compareLocStrings)(input1, input2, function (refName) {
        return refName === 'chr1' || refName === 'chr2';
      })).toEqual(output);
    });
  });
});
describe('test stringify', function () {
  var testStringify = {
    refName: 'ctgA',
    start: 5000,
    end: 20000,
    reversed: false,
    assemblyName: 'volvox',
    oob: false,
    offset: 0,
    coord: 5001,
    index: 0
  };
  test('stringify refName: bp', function () {
    expect((0, _index.stringify)({
      coord: testStringify.offset,
      refName: testStringify.refName
    })).toBe('ctgA:0');
  });
});