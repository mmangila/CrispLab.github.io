import { IAnyStateTreeNode } from 'mobx-state-tree';
import { IReactionPublic, IReactionOptions } from 'mobx';
import { Feature } from './simpleFeature';
import { TypeTestedByPredicate, Region, AssemblyManager } from './types';
export * from './types';
export * from './aborting';
export * from './when';
export * from './offscreenCanvasPonyfill';
export declare const inDevelopment: boolean;
export declare const inProduction: boolean;
/**
 * Compress and encode a string as url-safe base64
 * See {@link https://en.wikipedia.org/wiki/Base64#URL_applications}
 * @param str-  a string to compress and encode
 */
export declare function toUrlSafeB64(str: string): string;
/**
 * Decode and inflate a url-safe base64 to a string
 * See {@link https://en.wikipedia.org/wiki/Base64#URL_applications}
 * @param b64 - a base64 string to decode and inflate
 */
export declare function fromUrlSafeB64(b64: string): string;
export declare function useDebounce<T>(value: T, delay: number): T;
export declare function useDebouncedCallback<A extends any[]>(callback: (...args: A) => void, wait?: number): (...args: A) => void;
/** find the first node in the hierarchy that matches the given predicate */
export declare function findParentThat(node: IAnyStateTreeNode, predicate: (thing: IAnyStateTreeNode) => boolean): IAnyStateTreeNode;
export declare function springAnimate(fromValue: number, toValue: number, setValue: (value: number) => void, onFinish?: () => void, precision?: number, tension?: number, friction?: number): (() => void)[];
/** find the first node in the hierarchy that matches the given 'is' typescript type guard predicate */
export declare function findParentThatIs<PREDICATE extends (thing: IAnyStateTreeNode) => boolean>(node: IAnyStateTreeNode, predicate: PREDICATE): TypeTestedByPredicate<PREDICATE> & IAnyStateTreeNode;
/** get the current JBrowse session model, starting at any node in the state tree */
export declare function getSession(node: IAnyStateTreeNode): import("./types").AbstractSessionModel & IAnyStateTreeNode;
/** get the state model of the view in the state tree that contains the given node */
export declare function getContainingView(node: IAnyStateTreeNode): import("./types").AbstractViewModel & IAnyStateTreeNode;
/** get the state model of the view in the state tree that contains the given node */
export declare function getContainingTrack(node: IAnyStateTreeNode): IAnyStateTreeNode;
export declare function getContainingDisplay(node: IAnyStateTreeNode): import("./types").AbstractDisplayModel & IAnyStateTreeNode;
/**
 * Assemble a 1-based "locString" from an interbase genomic location
 * @param region - Region
 * @example
 * ```ts
 * assembleLocString({ refName: 'chr1', start: 0, end: 100 })
 * // ↳ 'chr1:1..100'
 * ```
 * @example
 * ```ts
 * assembleLocString({ assemblyName: 'hg19', refName: 'chr1', start: 0, end: 100 })
 * // ↳ '{hg19}chr1:1..100'
 * ```
 * @example
 * ```ts
 * assembleLocString({ refName: 'chr1' })
 * // ↳ 'chr1'
 * ```
 * @example
 * ```ts
 * assembleLocString({ refName: 'chr1', start: 0 })
 * // ↳ 'chr1:1..'
 * ```
 * @example
 * ```ts
 * assembleLocString({ refName: 'chr1', end: 100 })
 * // ↳ 'chr1:1..100'
 * ```
 * @example
 * ```ts
 * assembleLocString({ refName: 'chr1', start: 0, end: 1 })
 * // ↳ 'chr1:1'
 * ```
 */
export declare function assembleLocString(region: ParsedLocString): string;
export interface ParsedLocString {
    assemblyName?: string;
    refName: string;
    start?: number;
    end?: number;
}
export declare function parseLocStringOneBased(locString: string, isValidRefName: (refName: string, assemblyName?: string) => boolean): ParsedLocString;
/**
 * Parse a 1-based location string into an interbase genomic location
 * @param locString - Location string
 * @param isValidRefName - Function that checks if a refName exists in the set
 * of all known refNames, or in the set of refNames for an assembly if
 * assemblyName is given
 * @example
 * ```ts
 * parseLocString('chr1:1..100', isValidRefName)
 * // ↳ { refName: 'chr1', start: 0, end: 100 }
 * ```
 * @example
 * ```ts
 * parseLocString('chr1:1-100', isValidRefName)
 * // ↳ { refName: 'chr1', start: 0, end: 100 }
 * ```
 * @example
 * ```ts
 * parseLocString(`{hg19}chr1:1..100`, isValidRefName)
 * // ↳ { assemblyName: 'hg19', refName: 'chr1', start: 0, end: 100 }
 * ```
 * @example
 * ```ts
 * parseLocString('chr1', isValidRefName)
 * // ↳ { refName: 'chr1' }
 * ```
 * @example
 * ```ts
 * parseLocString('chr1:1', isValidRefName)
 * // ↳ { refName: 'chr1', start: 0, end: 1 }
 * ```
 * @example
 * ```ts
 * parseLocString('chr1:1..', isValidRefName)
 * // ↳ { refName: 'chr1', start: 0}
 * ```
 */
export declare function parseLocString(locString: string, isValidRefName: (refName: string, assemblyName?: string) => boolean): ParsedLocString;
export declare function compareLocs(locA: ParsedLocString, locB: ParsedLocString): number;
export declare function compareLocStrings(a: string, b: string, isValidRefName: (refName: string, assemblyName?: string) => boolean): number;
/**
 * Ensure that a number is at least min and at most max.
 *
 * @param num -
 * @param min -
 * @param  max -
 */
export declare function clamp(num: number, min: number, max: number): number;
/**
 * @param bp -
 * @param region -
 * @param bpPerPx -
 */
export declare function bpToPx(bp: number, region: {
    start: number;
    end: number;
    reversed?: boolean;
}, bpPerPx: number): number;
export declare function radToDeg(radians: number): number;
export declare function degToRad(degrees: number): number;
/**
 * @returns [x, y]
 */
export declare function polarToCartesian(rho: number, theta: number): [number, number];
/**
 * @param x - the x
 * @param y - the y
 * @returns [rho, theta]
 */
export declare function cartesianToPolar(x: number, y: number): [number, number];
export declare function featureSpanPx(feature: Feature, region: {
    start: number;
    end: number;
    reversed?: boolean;
}, bpPerPx: number): [number, number];
export declare function bpSpanPx(leftBp: number, rightBp: number, region: {
    start: number;
    end: number;
    reversed?: boolean;
}, bpPerPx: number): [number, number];
export declare const objectFromEntries: {
    <T = any>(entries: Iterable<readonly [string | number | symbol, T]>): {
        [k: string]: T;
    };
    (entries: Iterable<readonly any[]>): any;
};
export declare function iterMap<T, U>(iterable: Iterable<T>, func: (item: T) => U, sizeHint?: number): U[];
interface Assembly {
    name: string;
    [key: string]: any;
}
interface Track {
    trackId: string;
    [key: string]: any;
}
interface Config {
    savedSessions: unknown[];
    assemblies: Assembly[];
    tracks: Track[];
    defaultSession?: {};
}
export declare function mergeConfigs(A: Config, B: Config): {
    savedSessions: unknown[];
    assemblies: Assembly[];
    tracks: Track[];
    defaultSession: {};
};
/**
 * Returns the index of the last element in the array where predicate is true,
 * and -1 otherwise.
 * @param array - The source array to search in
 * @param predicate - find calls predicate once for each element of the array, in
 * descending order, until it finds one where predicate returns true. If such an
 * element is found, findLastIndex immediately returns that element index.
 * Otherwise, findLastIndex returns -1.
 */
export declare function findLastIndex<T>(array: Array<T>, predicate: (value: T, index: number, obj: T[]) => boolean): number;
/**
 * makes a mobx reaction with the given functions, that calls actions on the
 * model for each stage of execution, and to abort the reaction function when
 * the model is destroyed.
 *
 * Will call startedFunction(signal), successFunction(result), and
 * errorFunction(error) when the async reaction function starts, completes, and
 * errors respectively.
 *
 * @param self -
 * @param dataFunction -
 * @param asyncReactionFunction -
 * @param reactionOptions -
 * @param startedFunction -
 * @param successFunction -
 * @param errorFunction -
 */
export declare function makeAbortableReaction<T, U, V>(self: T, dataFunction: (arg: T) => U, asyncReactionFunction: (arg: U | undefined, signal: AbortSignal, model: T, handle: IReactionPublic) => Promise<V>, reactionOptions: IReactionOptions, startedFunction: (aborter: AbortController) => void, successFunction: (arg: V) => void, errorFunction: (err: Error) => void): void;
export declare function renameRegionIfNeeded(refNameMap: Record<string, string>, region: Region): Region & {
    originalRefName?: string;
};
export declare function renameRegionsIfNeeded<ARGTYPE extends {
    assemblyName?: string;
    regions?: Region[];
    signal?: AbortSignal;
    adapterConfig: unknown;
    sessionId: string;
    statusCallback?: Function;
}>(assemblyManager: AssemblyManager, args: ARGTYPE): Promise<ARGTYPE>;
export declare function minmax(a: number, b: number): number[];
export declare function stringify({ refName, coord, oob, }: {
    coord: number;
    refName: string;
    oob?: boolean;
}): string;
export declare const isElectron: boolean;
export declare function revcom(seqString: string): string;
export declare const complement: (seqString: string) => string;
export declare function blobToDataURL(blob: Blob): Promise<unknown>;
export declare const rIC: any;
export declare function measureText(str: unknown, fontSize?: number): number;
export declare const defaultStarts: string[];
export declare const defaultStops: string[];
export declare const defaultCodonTable: {
    TCA: string;
    TCC: string;
    TCG: string;
    TCT: string;
    TTC: string;
    TTT: string;
    TTA: string;
    TTG: string;
    TAC: string;
    TAT: string;
    TAA: string;
    TAG: string;
    TGC: string;
    TGT: string;
    TGA: string;
    TGG: string;
    CTA: string;
    CTC: string;
    CTG: string;
    CTT: string;
    CCA: string;
    CCC: string;
    CCG: string;
    CCT: string;
    CAC: string;
    CAT: string;
    CAA: string;
    CAG: string;
    CGA: string;
    CGC: string;
    CGG: string;
    CGT: string;
    ATA: string;
    ATC: string;
    ATT: string;
    ATG: string;
    ACA: string;
    ACC: string;
    ACG: string;
    ACT: string;
    AAC: string;
    AAT: string;
    AAA: string;
    AAG: string;
    AGC: string;
    AGT: string;
    AGA: string;
    AGG: string;
    GTA: string;
    GTC: string;
    GTG: string;
    GTT: string;
    GCA: string;
    GCC: string;
    GCG: string;
    GCT: string;
    GAC: string;
    GAT: string;
    GAA: string;
    GAG: string;
    GGA: string;
    GGC: string;
    GGG: string;
    GGT: string;
};
/**
 *  take CodonTable above and generate larger codon table that includes
 *  all permutations of upper and lower case nucleotides
 */
export declare function generateCodonTable(table: any): {
    [key: string]: string;
};
export declare function updateStatus(statusMsg: string, statusCallback: Function, fn: Function): Promise<any>;
export declare function hashCode(str: string): number;
export declare function objectHash(obj: Record<string, any>): string;
