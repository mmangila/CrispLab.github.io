"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.checkAbortSignal = checkAbortSignal;
exports.abortBreakPoint = abortBreakPoint;
exports.makeAbortError = makeAbortError;
exports.observeAbortSignal = observeAbortSignal;
exports.isAbortException = isAbortException;

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _wrapNativeSuper2 = _interopRequireDefault(require("@babel/runtime/helpers/wrapNativeSuper"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _rxjs = require("rxjs");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var AbortError = /*#__PURE__*/function (_Error) {
  (0, _inherits2.default)(AbortError, _Error);

  var _super = _createSuper(AbortError);

  function AbortError() {
    var _this;

    (0, _classCallCheck2.default)(this, AbortError);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "code", void 0);
    return _this;
  }

  return AbortError;
}( /*#__PURE__*/(0, _wrapNativeSuper2.default)(Error));
/**
 * properly check if the given AbortSignal is aborted.
 * per the standard, if the signal reads as aborted,
 * this function throws either a DOMException AbortError, or a regular error
 * with a `code` attribute set to `ERR_ABORTED`.
 *
 * for convenience, passing `undefined` is a no-op
 *
 * @param signal -
 * @returns nothing
 */


function checkAbortSignal(signal) {
  if (!signal) {
    return;
  }

  if (!(signal instanceof AbortSignal)) {
    throw new TypeError('must pass an AbortSignal');
  }

  if (signal.aborted) {
    throw makeAbortError();
  }
}

function timeout(ms) {
  return new Promise(function (resolve) {
    return setTimeout(resolve, ms);
  });
}
/**
 * Skips to the next tick, then runs `checkAbortSignal`.
 * Await this to inside an otherwise synchronous loop to
 * provide a place to break when an abort signal is received.
 */


function abortBreakPoint(_x) {
  return _abortBreakPoint.apply(this, arguments);
}

function _abortBreakPoint() {
  _abortBreakPoint = (0, _asyncToGenerator2.default)( /*#__PURE__*/regeneratorRuntime.mark(function _callee(signal) {
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return timeout(1);

          case 2:
            checkAbortSignal(signal);

          case 3:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _abortBreakPoint.apply(this, arguments);
}

function makeAbortError() {
  if (typeof DOMException !== 'undefined') {
    return new DOMException('aborted', 'AbortError');
  }

  var e = new AbortError('aborted');
  e.code = 'ERR_ABORTED';
  return e;
}

function observeAbortSignal(signal) {
  if (!signal) {
    return _rxjs.Observable.create();
  }

  return (0, _rxjs.fromEvent)(signal, 'abort');
}
/**
 * check if the given exception was caused by an operation being intentionally aborted
 * @param exception -
 */


function isAbortException(exception) {
  return (// DOMException
    exception.name === 'AbortError' || // standard-ish non-DOM abort exception
    exception.code === 'ERR_ABORTED' || // message contains aborted for bubbling through RPC
    // things we have seen that we want to catch here
    // Error: aborted
    // AbortError: aborted
    // AbortError: The user aborted a request.
    !!exception.message.match(/\b(aborted|AbortError)\b/i)
  );
}