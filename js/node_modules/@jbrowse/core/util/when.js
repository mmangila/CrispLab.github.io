"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.when = when;
exports.whenPresent = whenPresent;

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _mobx = require("mobx");

var _aborting = require("./aborting");

/**
 * Wrapper for mobx `when` that adds timeout and aborting support.
 */
function when(getter) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      timeout = _ref.timeout,
      signal = _ref.signal,
      name = _ref.name;

  return new Promise(function (resolve, reject) {
    var finished = false;
    var whenPromise = (0, _mobx.when)(getter); // set up timeout

    var timeoutId;

    var finishTimeout = function finishTimeout() {};

    if (timeout) {
      timeoutId = setTimeout(function () {
        if (!finished) {
          finished = true;
          whenPromise.cancel();
          reject(new Error("timed out waiting for ".concat(name || 'whenPresent')));
        }
      }, timeout);

      finishTimeout = function finishTimeout() {
        return timeoutId && clearTimeout(timeoutId);
      };
    } // set up aborting


    if (signal) {
      signal.addEventListener('abort', function () {
        if (!finished) {
          finished = true; // mobx when supports a cancel method

          whenPromise.cancel();
          finishTimeout();
          reject((0, _aborting.makeAbortError)());
        }
      });
    }

    whenPromise.then(function () {
      if (!finished) {
        finished = true;
        finishTimeout();
        resolve();
      }
    }).catch(function (err) {
      if (!finished) {
        finished = true;
        finishTimeout();
        reject(err);
      }
    });
  });
}
/**
 * Wrapper for mobx `when` that makes a promise for the return value
 * of the given function at the point in time when it becomes not
 * undefined and not null.
 */


function whenPresent(_x) {
  return _whenPresent.apply(this, arguments);
}

function _whenPresent() {
  _whenPresent = (0, _asyncToGenerator2.default)( /*#__PURE__*/regeneratorRuntime.mark(function _callee(getter) {
    var opts,
        _args = arguments;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            opts = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
            _context.next = 3;
            return when(function () {
              var val = getter();
              return val !== undefined && val !== null;
            }, opts);

          case 3:
            return _context.abrupt("return", getter());

          case 4:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _whenPresent.apply(this, arguments);
}