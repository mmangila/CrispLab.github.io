"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = calculateStaticBlocks;

var _ = require(".");

var _blockTypes = require("./blockTypes");

function calculateStaticBlocks(model) {
  var padding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  var elision = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  var extra = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
  var width = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : typeof window !== 'undefined' && window.innerWidth || model.width;
  var offsetPx = model.offsetPx,
      displayedRegions = model.displayedRegions,
      bpPerPx = model.bpPerPx,
      minimumBlockWidth = model.minimumBlockWidth,
      interRegionPaddingWidth = model.interRegionPaddingWidth;
  var windowLeftBp = offsetPx * bpPerPx;
  var windowRightBp = (offsetPx + width) * bpPerPx;
  var blockSizePx = width;
  var blockSizeBp = Math.ceil(blockSizePx * bpPerPx); // for each displayed region

  var regionBpOffset = 0;
  var blocks = new _blockTypes.BlockSet();
  displayedRegions.forEach(function (region, regionNumber) {
    // find the block numbers of the left and right window sides,
    // clamp those to the region range, and then make blocks for that range
    var assemblyName = region.assemblyName,
        refName = region.refName,
        regionStart = region.start,
        regionEnd = region.end,
        reversed = region.reversed;
    var regionBlockCount = Math.ceil((regionEnd - regionStart) / blockSizeBp);
    var windowRightBlockNum = Math.floor((windowRightBp - regionBpOffset) / blockSizeBp) + extra;

    if (windowRightBlockNum >= regionBlockCount) {
      windowRightBlockNum = regionBlockCount - 1;
    }

    var windowLeftBlockNum = Math.floor((windowLeftBp - regionBpOffset) / blockSizeBp) - extra;

    if (windowLeftBlockNum < 0) {
      windowLeftBlockNum = 0;
    }

    var regionWidthPx = (regionEnd - regionStart) / bpPerPx;

    for (var blockNum = windowLeftBlockNum; blockNum <= windowRightBlockNum; blockNum += 1) {
      var start = void 0;
      var end = void 0;
      var isLeftEndOfDisplayedRegion = void 0;
      var isRightEndOfDisplayedRegion = void 0;

      if (reversed) {
        start = Math.max(regionStart, regionEnd - (blockNum + 1) * blockSizeBp);
        end = regionEnd - blockNum * blockSizeBp;
        isLeftEndOfDisplayedRegion = end === regionEnd;
        isRightEndOfDisplayedRegion = start === regionStart;
      } else {
        start = regionStart + blockNum * blockSizeBp;
        end = Math.min(regionEnd, regionStart + (blockNum + 1) * blockSizeBp);
        isLeftEndOfDisplayedRegion = start === regionStart;
        isRightEndOfDisplayedRegion = end === regionEnd;
      }

      var widthPx = (end - start) / bpPerPx;
      var blockData = {
        assemblyName: assemblyName,
        refName: refName,
        start: start,
        end: end,
        reversed: reversed,
        offsetPx: (regionBpOffset + blockNum * blockSizeBp) / bpPerPx,
        parentRegion: region,
        regionNumber: regionNumber,
        widthPx: widthPx,
        isLeftEndOfDisplayedRegion: isLeftEndOfDisplayedRegion,
        isRightEndOfDisplayedRegion: isRightEndOfDisplayedRegion,
        key: ''
      };
      blockData.key = "".concat((0, _.assembleLocString)(blockData), "-").concat(regionNumber).concat(reversed ? '-reversed' : '');

      if (padding && regionNumber === 0 && blockNum === 0) {
        blocks.push(new _blockTypes.InterRegionPaddingBlock({
          key: "".concat(blockData.key, "-beforeFirstRegion"),
          widthPx: width,
          offsetPx: blockData.offsetPx - width,
          variant: 'boundary'
        }));
      }

      if (elision && regionWidthPx < minimumBlockWidth) {
        blocks.push(new _blockTypes.ElidedBlock(blockData));
      } else {
        blocks.push(new _blockTypes.ContentBlock(blockData));
      }

      if (padding) {
        // insert a inter-region padding block if we are crossing a displayed region
        if (regionWidthPx >= minimumBlockWidth && blockData.isRightEndOfDisplayedRegion && regionNumber < displayedRegions.length - 1) {
          regionBpOffset += interRegionPaddingWidth * bpPerPx;
          blocks.push(new _blockTypes.InterRegionPaddingBlock({
            key: "".concat(blockData.key, "-rightpad"),
            widthPx: interRegionPaddingWidth,
            offsetPx: blockData.offsetPx + blockData.widthPx
          }));
        }

        if (regionNumber === displayedRegions.length - 1 && blockData.isRightEndOfDisplayedRegion) {
          regionBpOffset += interRegionPaddingWidth * bpPerPx;
          blocks.push(new _blockTypes.InterRegionPaddingBlock({
            key: "".concat(blockData.key, "-afterLastRegion"),
            widthPx: width,
            offsetPx: blockData.offsetPx + blockData.widthPx,
            variant: 'boundary'
          }));
        }
      }
    }

    regionBpOffset += regionEnd - regionStart;
  });
  return blocks;
}