declare type Func<T> = (value: BaseBlock, index: number, array: BaseBlock[]) => T;
export declare class BlockSet {
    blocks: BaseBlock[];
    constructor(blocks?: BaseBlock[]);
    push(block: BaseBlock): void;
    getBlocks(): BaseBlock[];
    getRegions(): {
        refName: string;
        start: number;
        end: number;
        assemblyName: string;
        reversed: any;
    }[];
    map<T, U = this>(func: Func<T>, thisarg?: U): T[];
    forEach<T, U = this>(func: Func<T>, thisarg?: U): void;
    get length(): number;
    get totalWidthPx(): any;
    get totalWidthPxWithoutBorders(): any;
    get offsetPx(): number;
    get contentBlocks(): BaseBlock[];
    get totalBp(): number;
}
export declare class BaseBlock {
    [key: string]: any;
    refName: string;
    start: number;
    end: number;
    assemblyName: string;
    key: string;
    offsetPx: number;
    /**
     * a block that should be shown as filled with data
     */
    constructor(data: any);
    /**
     * rename the reference sequence of this block and return a new one
     *
     * @param refName -
     * @returns either a new block with a renamed reference sequence,
     * or the same block, if the ref name is not actually different
     */
    renameReference(refName: string): any;
    toRegion(): {
        refName: string;
        start: number;
        end: number;
        assemblyName: string;
        reversed: any;
    };
}
export declare class ContentBlock extends BaseBlock {
}
/**
 * marker block representing one or more blocks that are
 * too small to be shown at the current zoom level
 */
export declare class ElidedBlock extends BaseBlock {
    widthPx: number;
    constructor(data: Record<string, any>);
    push(otherBlock: BaseBlock): void;
}
/**
 * marker block that sits between two different displayed regions
 * and provides a thick border between them
 */
export declare class InterRegionPaddingBlock extends BaseBlock {
}
export {};
