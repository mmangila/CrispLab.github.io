"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _mobxStateTree = require("mobx-state-tree");

var _index = require("./index");

var _mst = require("./types/mst");

var _calculateDynamicBlocks = _interopRequireDefault(require("./calculateDynamicBlocks"));

var _calculateStaticBlocks = _interopRequireDefault(require("./calculateStaticBlocks"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var Base1DView = _mobxStateTree.types.model('Base1DView', {
  displayedRegions: _mobxStateTree.types.array(_mst.Region),
  bpPerPx: 0,
  offsetPx: 0,
  interRegionPaddingWidth: _mobxStateTree.types.optional(_mobxStateTree.types.number, 0),
  minimumBlockWidth: _mobxStateTree.types.optional(_mobxStateTree.types.number, 0)
}).volatile(function () {
  return {
    features: undefined,
    volatileWidth: 0
  };
}).actions(function (self) {
  return {
    setDisplayedRegions: function setDisplayedRegions(regions) {
      self.displayedRegions = (0, _mobxStateTree.cast)(regions);
    },
    setBpPerPx: function setBpPerPx(val) {
      self.bpPerPx = val;
    },
    setVolatileWidth: function setVolatileWidth(width) {
      self.volatileWidth = width;
    }
  };
}).views(function (self) {
  return {
    get width() {
      return self.volatileWidth;
    },

    get displayedRegionsTotalPx() {
      return this.totalBp / self.bpPerPx;
    },

    get maxOffset() {
      // objectively determined to keep the linear genome on the main screen
      var leftPadding = 10;
      return this.displayedRegionsTotalPx - leftPadding;
    },

    get minOffset() {
      // objectively determined to keep the linear genome on the main screen
      var rightPadding = 30;
      return -this.width + rightPadding;
    },

    get totalBp() {
      return self.displayedRegions.map(function (a) {
        return a.end - a.start;
      }).reduce(function (a, b) {
        return a + b;
      }, 0);
    },

    /**
     * calculates the Px at which coord is found.
     *
     * @param refName - string, refName of region
     * @param coord - number, bp to be translated to Px
     * @param regionNumber - number, index of displayedRegion in displayedRegions array
     */
    bpToPx: function bpToPx(_ref) {
      var _this = this;

      var refName = _ref.refName,
          coord = _ref.coord,
          regionNumber = _ref.regionNumber;
      var offsetBp = 0;
      var interRegionPaddingBp = self.interRegionPaddingWidth * self.bpPerPx;
      var minimumBlockBp = self.minimumBlockWidth * self.bpPerPx;
      var index = self.displayedRegions.findIndex(function (region, idx) {
        var len = region.end - region.start;

        if (refName === region.refName && coord >= region.start && coord <= region.end) {
          if (regionNumber ? regionNumber === idx : true) {
            offsetBp += region.reversed ? region.end - coord : coord - region.start;
            return true;
          }
        } // add the interRegionPaddingWidth if the boundary is in the screen
        // e.g. offset>0 && offset<width


        if (region.end - region.start > minimumBlockBp && offsetBp / self.bpPerPx > 0 && offsetBp / self.bpPerPx < _this.width) {
          offsetBp += len + interRegionPaddingBp;
        } else {
          offsetBp += len;
        }

        return false;
      });
      var foundRegion = self.displayedRegions[index];

      if (foundRegion) {
        return Math.round(offsetBp / self.bpPerPx);
      }

      return undefined;
    },
    pxToBp: function pxToBp(px) {
      var bpSoFar = 0;
      var bp = (self.offsetPx + px) * self.bpPerPx;
      var n = self.displayedRegions.length;

      if (bp < 0) {
        var region = self.displayedRegions[0];
        var offset = bp;
        return _objectSpread(_objectSpread({}, (0, _mobxStateTree.getSnapshot)(region)), {}, {
          oob: true,
          coord: region.reversed ? Math.floor(region.end - offset) + 1 : Math.floor(region.start + offset) + 1,
          offset: offset,
          index: 0
        });
      }

      var interRegionPaddingBp = self.interRegionPaddingWidth * self.bpPerPx;
      var minimumBlockBp = self.minimumBlockWidth * self.bpPerPx;

      for (var index = 0; index < self.displayedRegions.length; index += 1) {
        var _region = self.displayedRegions[index];
        var len = _region.end - _region.start;

        var _offset = bp - bpSoFar;

        if (len + bpSoFar > bp && bpSoFar <= bp) {
          return _objectSpread(_objectSpread({}, (0, _mobxStateTree.getSnapshot)(_region)), {}, {
            oob: false,
            offset: _offset,
            coord: _region.reversed ? Math.floor(_region.end - _offset) + 1 : Math.floor(_region.start + _offset) + 1,
            index: index
          });
        } // add the interRegionPaddingWidth if the boundary is in the screen
        // e.g. offset>0 && offset<width


        if (_region.end - _region.start > minimumBlockBp && _offset / self.bpPerPx > 0 && _offset / self.bpPerPx < this.width) {
          bpSoFar += len + interRegionPaddingBp;
        } else {
          bpSoFar += len;
        }
      }

      if (bp >= bpSoFar) {
        var _region2 = self.displayedRegions[n - 1];

        var _len = _region2.end - _region2.start;

        var _offset2 = bp - bpSoFar + _len;

        return _objectSpread(_objectSpread({}, (0, _mobxStateTree.getSnapshot)(_region2)), {}, {
          oob: true,
          offset: _offset2,
          coord: _region2.reversed ? Math.floor(_region2.end - _offset2) + 1 : Math.floor(_region2.start + _offset2) + 1,
          index: n - 1
        });
      }

      return {
        coord: 0,
        index: 0,
        start: 0,
        refName: '',
        oob: true,
        assemblyName: '',
        offset: 0,
        reversed: false
      };
    }
  };
}).views(function (self) {
  return {
    get dynamicBlocks() {
      return (0, _calculateDynamicBlocks.default)(self);
    },

    get staticBlocks() {
      return (0, _calculateStaticBlocks.default)(self);
    },

    get currBp() {
      return this.dynamicBlocks.map(function (a) {
        return a.end - a.start;
      }).reduce(function (a, b) {
        return a + b;
      }, 0);
    }

  };
}).actions(function (self) {
  return {
    setFeatures: function setFeatures(features) {
      self.features = features;
    },
    zoomToDisplayedRegions: function zoomToDisplayedRegions(leftPx, rightPx) {
      if (leftPx === undefined || rightPx === undefined) {
        return;
      }

      var singleRefSeq = leftPx.refName === rightPx.refName && leftPx.index === rightPx.index; // zooming into one displayed Region

      if (singleRefSeq && rightPx.offset < leftPx.offset || leftPx.index > rightPx.index) {
        ;
        var _ref2 = [rightPx, leftPx];
        leftPx = _ref2[0];
        rightPx = _ref2[1];
      }

      var startOffset = {
        start: leftPx.start,
        end: leftPx.end,
        index: leftPx.index,
        offset: leftPx.offset
      };
      var endOffset = {
        start: rightPx.start,
        end: rightPx.end,
        index: rightPx.index,
        offset: rightPx.offset
      };

      if (startOffset && endOffset) {
        this.moveTo(startOffset, endOffset);
      } else {
        throw new Error('regions not found');
      }
    },
    // this makes a zoomed out view that shows all displayedRegions
    // that makes the overview bar square with the scale bar
    showAllRegions: function showAllRegions() {
      self.bpPerPx = self.totalBp / self.width;
      self.offsetPx = 0;
    },

    /**
     * offset is the base-pair-offset in the displayed region, index is the index of the
     * displayed region in the linear genome view
     *
     * @param start - object as `{start, end, offset, index}`
     * @param end - object as `{start, end, offset, index}`
     */
    moveTo: function moveTo(start, end) {
      // find locations in the modellist
      var bpSoFar = 0;

      if (start.index === end.index) {
        bpSoFar += end.offset - start.offset;
      } else {
        var s = self.displayedRegions[start.index];
        bpSoFar += s.end - s.start - start.offset;

        if (end.index - start.index >= 2) {
          for (var i = start.index + 1; i < end.index; i += 1) {
            bpSoFar += self.displayedRegions[i].end - self.displayedRegions[i].start;
          }
        }

        bpSoFar += end.offset;
      }

      this.zoomTo(bpSoFar / (self.width - self.interRegionPaddingWidth * (end.index - start.index)));
      var bpToStart = 0;

      for (var _i = 0; _i < self.displayedRegions.length; _i += 1) {
        var region = self.displayedRegions[_i];

        if (start.index === _i) {
          bpToStart += start.offset;
          break;
        } else {
          bpToStart += region.end - region.start;
        }
      }

      self.offsetPx = Math.round(bpToStart / self.bpPerPx) + self.interRegionPaddingWidth * start.index;
    },
    zoomOut: function zoomOut() {
      this.zoomTo(self.bpPerPx * 2);
    },
    zoomIn: function zoomIn() {
      this.zoomTo(self.bpPerPx / 2);
    },
    zoomTo: function zoomTo(newBpPerPx) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : self.width / 2;
      var bpPerPx = newBpPerPx;

      if (bpPerPx === self.bpPerPx) {
        return;
      }

      var oldBpPerPx = self.bpPerPx;
      self.bpPerPx = bpPerPx; // tweak the offset so that the center of the view remains at the same coordinate

      self.offsetPx = (0, _index.clamp)(Math.round((self.offsetPx + offset) * oldBpPerPx / bpPerPx - offset), self.minOffset, self.maxOffset);
    },
    scroll: function scroll(distance) {
      var oldOffsetPx = self.offsetPx; // the scroll is clamped to keep the linear genome on the main screen

      var newOffsetPx = (0, _index.clamp)(self.offsetPx + distance, self.minOffset, self.maxOffset);
      self.offsetPx = newOffsetPx;
      return newOffsetPx - oldOffsetPx;
    }
  };
});

var _default = Base1DView;
exports.default = _default;