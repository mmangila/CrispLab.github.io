"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getTrackAssemblyNames = getTrackAssemblyNames;
exports.getRpcSessionId = getRpcSessionId;
exports.getParentRenderProps = getParentRenderProps;
exports.getBlob = getBlob;
exports.getBlobMap = getBlobMap;
exports.setBlobMap = setBlobMap;
exports.storeBlobLocation = storeBlobLocation;
exports.guessAdapter = guessAdapter;
exports.guessTrackType = guessTrackType;
exports.generateUnsupportedTrackConf = generateUnsupportedTrackConf;
exports.generateUnknownTrackConf = generateUnknownTrackConf;
exports.UNSUPPORTED = exports.UNKNOWN = void 0;

var _mobxStateTree = require("mobx-state-tree");

var _index = require("./index");

var _configuration = require("../configuration");

/* utility functions for use by track models and so forth */
function getTrackAssemblyNames(track) {
  var trackConf = track.configuration;
  var trackAssemblyNames = (0, _configuration.readConfObject)(trackConf, 'assemblyNames');

  if (!trackAssemblyNames) {
    // Check if it's an assembly sequence track
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    var parent = (0, _mobxStateTree.getParent)(track.configuration);

    if ('sequence' in parent) {
      return [(0, _configuration.readConfObject)(parent, 'name')];
    }
  }

  return trackAssemblyNames;
}
/** return the rpcSessionId of the highest parent node in the tree that has an rpcSessionId */


function getRpcSessionId(thisNode) {
  var highestRpcSessionId;

  for (var node = thisNode; !(0, _mobxStateTree.isRoot)(node); node = (0, _mobxStateTree.getParent)(node)) {
    if ('rpcSessionId' in node) {
      highestRpcSessionId = node.rpcSessionId;
    }
  }

  if (!highestRpcSessionId) {
    throw new Error('getRpcSessionId failed, no parent node in the state tree has an `rpcSessionId` attribute');
  }

  return highestRpcSessionId;
}
/**
 * given an MST node, get the renderprops of the first parent container that has
 * renderProps
 * @param node -
 * @returns renderprops, or empty object if none found
 */


function getParentRenderProps(node) {
  for (var currentNode = (0, _mobxStateTree.getParent)(node); !(0, _mobxStateTree.isRoot)(currentNode); currentNode = (0, _mobxStateTree.getParent)(currentNode)) {
    if ('renderProps' in currentNode) {
      return currentNode.renderProps;
    }
  }

  return {};
}

var UNKNOWN = 'UNKNOWN';
exports.UNKNOWN = UNKNOWN;
var UNSUPPORTED = 'UNSUPPORTED';
exports.UNSUPPORTED = UNSUPPORTED;
var blobMap = {}; // get a specific blob

function getBlob(id) {
  return blobMap[id];
} // used to export entire context to webworker


function getBlobMap() {
  return blobMap;
} // used in new contexts like webworkers


function setBlobMap(map) {
  blobMap = map;
} // blob files are stored in a global map


function storeBlobLocation(location) {
  if (location && 'blob' in location) {
    // possibly we should be more clear about when this is not undefined, and
    // also allow mix of blob and url for index and file
    // @ts-ignore
    var blobId = "b".concat(+Date.now());
    blobMap[blobId] = location.blob;
    return {
      name: location === null || location === void 0 ? void 0 : location.blob.name,
      blobId: blobId
    };
  }

  return location;
}

function guessAdapter(file, index, getFileName, adapterHint) {
  function makeIndex(location, suffix) {
    if ('uri' in location) {
      return {
        uri: location.uri + suffix
      };
    }

    if ('localPath' in location) {
      return {
        localPath: location.localPath + suffix
      };
    }

    return location;
  }

  var fileName = getFileName(file);
  var indexName = index && getFileName(index);

  function makeIndexType(name, typeA, typeB) {
    return name !== null && name !== void 0 && name.toUpperCase().endsWith(typeA) ? typeA : typeB;
  }

  if (/\.bam$/i.test(fileName) || adapterHint === 'BamAdapter') {
    return {
      type: 'BamAdapter',
      bamLocation: file,
      index: {
        location: index || makeIndex(file, '.bai'),
        indexType: makeIndexType(indexName, 'CSI', 'BAI')
      }
    };
  }

  if (/\.cram$/i.test(fileName) || adapterHint === 'CramAdapter') {
    return {
      type: 'CramAdapter',
      cramLocation: file,
      craiLocation: index || makeIndex(file, '.crai')
    };
  }

  if (/\.gff3?$/i.test(fileName)) {
    return {
      type: 'UNSUPPORTED'
    };
  }

  if (/\.gff3?\.b?gz$/i.test(fileName) || adapterHint === 'Gff3TabixAdapter') {
    return {
      type: 'Gff3TabixAdapter',
      gffGzLocation: file,
      index: {
        location: index || makeIndex(file, '.tbi'),
        indexType: makeIndexType(indexName, 'CSI', 'TBI')
      }
    };
  }

  if (/\.gtf?$/i.test(fileName)) {
    return {
      type: 'UNSUPPORTED'
    };
  }

  if (/\.vcf$/i.test(fileName)) {
    return {
      type: 'UNSUPPORTED'
    };
  }

  if (/\.vcf\.b?gz$/i.test(fileName) || adapterHint === 'VcfTabixAdapter') {
    return {
      type: 'VcfTabixAdapter',
      vcfGzLocation: file,
      index: {
        location: index || makeIndex(file, 'tbi'),
        indexType: makeIndexType(indexName, 'CSI', 'TBI')
      }
    };
  }

  if (/\.vcf\.idx$/i.test(fileName)) {
    return {
      type: 'UNSUPPORTED'
    };
  }

  if (/\.bed$/i.test(fileName)) {
    return {
      type: 'UNSUPPORTED'
    };
  }

  if (/\.bed\.b?gz$/i.test(fileName) || adapterHint === 'BedTabixAdapter') {
    return {
      type: 'BedTabixAdapter',
      bedGzLocation: file,
      index: {
        location: index || makeIndex(file, '.tbi'),
        indexType: makeIndexType(indexName, 'CSI', 'TBI')
      }
    };
  }

  if (/\.(bb|bigbed)$/i.test(fileName) || adapterHint === 'BigBedAdapter') {
    return {
      type: 'BigBedAdapter',
      bigBedLocation: file
    };
  }

  if (/\.(bw|bigwig)$/i.test(fileName) || adapterHint === 'BigWigAdapter') {
    return {
      type: 'BigWigAdapter',
      bigWigLocation: file
    };
  }

  if (/\.(fa|fasta|fas|fna|mfa)$/i.test(fileName) || adapterHint === 'IndexedFastaAdapter') {
    return {
      type: 'IndexedFastaAdapter',
      fastaLocation: file,
      faiLocation: index || makeIndex(file, '.fai')
    };
  }

  if (/\.(fa|fasta|fas|fna|mfa)\.b?gz$/i.test(fileName) || adapterHint === 'BgzipFastaAdapter') {
    return {
      type: 'BgzipFastaAdapter',
      fastaLocation: file,
      faiLocation: makeIndex(file, '.fai'),
      gziLocation: makeIndex(file, '.gzi')
    };
  }

  if (/\.2bit$/i.test(fileName) || adapterHint === 'TwoBitAdapter') {
    return {
      type: 'TwoBitAdapter',
      twoBitLocation: file
    };
  }

  if (/\.sizes$/i.test(fileName)) {
    return {
      type: 'UNSUPPORTED'
    };
  }

  if (/\/trackData.jsonz?$/i.test(fileName) || adapterHint === 'NCListAdapter') {
    return {
      type: 'NCListAdapter',
      rootUrlTemplate: file
    };
  }

  if (/\/sparql$/i.test(fileName) || adapterHint === 'SPARQLAdapter') {
    return {
      type: 'SPARQLAdapter',
      endpoint: file
    };
  }

  if (/\.hic/i.test(fileName) || adapterHint === 'HicAdapter') {
    return {
      type: 'HicAdapter',
      hicLocation: file
    };
  }

  if (/\.paf/i.test(fileName) || adapterHint === 'PAFAdapter') {
    return {
      type: 'PAFAdapter',
      pafLocation: file
    };
  }

  return {
    type: UNKNOWN
  };
}

function guessTrackType(adapterType) {
  var known = {
    BamAdapter: 'AlignmentsTrack',
    CramAdapter: 'AlignmentsTrack',
    BgzipFastaAdapter: 'ReferenceSequenceTrack',
    BigWigAdapter: 'QuantitativeTrack',
    IndexedFastaAdapter: 'ReferenceSequenceTrack',
    TwoBitAdapter: 'ReferenceSequenceTrack',
    VcfAdapter: 'VariantTrack',
    VcfTabixAdapter: 'VariantTrack',
    HicAdapter: 'HicTrack',
    PAFAdapter: 'SyntenyTrack'
  };
  return known[adapterType] || 'FeatureTrack';
}

function generateUnsupportedTrackConf(trackName, trackUrl, categories) {
  var conf = {
    type: 'FeatureTrack',
    name: "".concat(trackName, " (Unsupported)"),
    description: "Support not yet implemented for \"".concat(trackUrl, "\""),
    category: categories,
    trackId: ''
  };
  conf.trackId = (0, _index.objectHash)(conf);
  return conf;
}

function generateUnknownTrackConf(trackName, trackUrl, categories) {
  var conf = {
    type: 'FeatureTrack',
    name: "".concat(trackName, " (Unknown)"),
    description: "Could not determine track type for \"".concat(trackUrl, "\""),
    category: categories,
    trackId: ''
  };
  conf.trackId = (0, _index.objectHash)(conf);
  return conf;
}