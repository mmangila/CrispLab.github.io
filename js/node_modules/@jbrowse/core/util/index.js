"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  inDevelopment: true,
  inProduction: true,
  toUrlSafeB64: true,
  fromUrlSafeB64: true,
  useDebounce: true,
  useDebouncedCallback: true,
  findParentThat: true,
  springAnimate: true,
  findParentThatIs: true,
  getSession: true,
  getContainingView: true,
  getContainingTrack: true,
  getContainingDisplay: true,
  assembleLocString: true,
  parseLocStringOneBased: true,
  parseLocString: true,
  compareLocs: true,
  compareLocStrings: true,
  clamp: true,
  bpToPx: true,
  radToDeg: true,
  degToRad: true,
  polarToCartesian: true,
  cartesianToPolar: true,
  featureSpanPx: true,
  bpSpanPx: true,
  objectFromEntries: true,
  iterMap: true,
  mergeConfigs: true,
  findLastIndex: true,
  makeAbortableReaction: true,
  renameRegionIfNeeded: true,
  renameRegionsIfNeeded: true,
  minmax: true,
  stringify: true,
  isElectron: true,
  revcom: true,
  complement: true,
  blobToDataURL: true,
  rIC: true,
  measureText: true,
  defaultStarts: true,
  defaultStops: true,
  defaultCodonTable: true,
  generateCodonTable: true,
  updateStatus: true,
  hashCode: true,
  objectHash: true
};
exports.toUrlSafeB64 = toUrlSafeB64;
exports.fromUrlSafeB64 = fromUrlSafeB64;
exports.useDebounce = useDebounce;
exports.useDebouncedCallback = useDebouncedCallback;
exports.findParentThat = findParentThat;
exports.springAnimate = springAnimate;
exports.findParentThatIs = findParentThatIs;
exports.getSession = getSession;
exports.getContainingView = getContainingView;
exports.getContainingTrack = getContainingTrack;
exports.getContainingDisplay = getContainingDisplay;
exports.assembleLocString = assembleLocString;
exports.parseLocStringOneBased = parseLocStringOneBased;
exports.parseLocString = parseLocString;
exports.compareLocs = compareLocs;
exports.compareLocStrings = compareLocStrings;
exports.clamp = clamp;
exports.bpToPx = bpToPx;
exports.radToDeg = radToDeg;
exports.degToRad = degToRad;
exports.polarToCartesian = polarToCartesian;
exports.cartesianToPolar = cartesianToPolar;
exports.featureSpanPx = featureSpanPx;
exports.bpSpanPx = bpSpanPx;
exports.iterMap = iterMap;
exports.mergeConfigs = mergeConfigs;
exports.findLastIndex = findLastIndex;
exports.makeAbortableReaction = makeAbortableReaction;
exports.renameRegionIfNeeded = renameRegionIfNeeded;
exports.renameRegionsIfNeeded = renameRegionsIfNeeded;
exports.minmax = minmax;
exports.stringify = stringify;
exports.revcom = revcom;
exports.blobToDataURL = blobToDataURL;
exports.measureText = measureText;
exports.generateCodonTable = generateCodonTable;
exports.updateStatus = updateStatus;
exports.hashCode = hashCode;
exports.objectHash = objectHash;
exports.defaultCodonTable = exports.defaultStops = exports.defaultStarts = exports.rIC = exports.complement = exports.isElectron = exports.objectFromEntries = exports.inProduction = exports.inDevelopment = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _base64Js = require("base64-js");

var _mobxStateTree = require("mobx-state-tree");

var _mobx = require("mobx");

var _pako = require("pako");

var _object = _interopRequireDefault(require("object.fromentries"));

var _react = require("react");

var _deepmerge = _interopRequireDefault(require("deepmerge"));

var _types = require("./types");

Object.keys(_types).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _types[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _types[key];
    }
  });
});

var _aborting = require("./aborting");

Object.keys(_aborting).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _aborting[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _aborting[key];
    }
  });
});

var _when = require("./when");

Object.keys(_when).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _when[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _when[key];
    }
  });
});

var _offscreenCanvasPonyfill = require("./offscreenCanvasPonyfill");

Object.keys(_offscreenCanvasPonyfill).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _offscreenCanvasPonyfill[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _offscreenCanvasPonyfill[key];
    }
  });
});

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

if (!Object.fromEntries) {
  // @ts-ignore
  _object.default.shim();
}

var inDevelopment = (typeof process === "undefined" ? "undefined" : (0, _typeof2.default)(process)) === 'object' && process.env && process.env.NODE_ENV === 'development';
exports.inDevelopment = inDevelopment;
var inProduction = !inDevelopment;
/**
 * Compress and encode a string as url-safe base64
 * See {@link https://en.wikipedia.org/wiki/Base64#URL_applications}
 * @param str-  a string to compress and encode
 */

exports.inProduction = inProduction;

function toUrlSafeB64(str) {
  var bytes = new TextEncoder().encode(str);
  var deflated = (0, _pako.deflate)(bytes);
  var encoded = (0, _base64Js.fromByteArray)(deflated);
  var pos = encoded.indexOf('=');
  return pos > 0 ? encoded.slice(0, pos).replace(/\+/g, '-').replace(/\//g, '_') : encoded.replace(/\+/g, '-').replace(/\//g, '_');
}
/**
 * Decode and inflate a url-safe base64 to a string
 * See {@link https://en.wikipedia.org/wiki/Base64#URL_applications}
 * @param b64 - a base64 string to decode and inflate
 */


function fromUrlSafeB64(b64) {
  var originalB64 = b64PadSuffix(b64.replace(/-/g, '+').replace(/_/g, '/'));
  var bytes = (0, _base64Js.toByteArray)(originalB64);
  var inflated = (0, _pako.inflate)(bytes);
  return new TextDecoder().decode(inflated);
}
/**
 * Pad the end of a base64 string with "=" to make it valid
 * @param b64 - unpadded b64 string
 */


function b64PadSuffix(b64) {
  var num = 0;
  var mo = b64.length % 4;

  switch (mo) {
    case 3:
      num = 1;
      break;

    case 2:
      num = 2;
      break;

    case 0:
      num = 0;
      break;

    default:
      throw new Error('base64 not a valid length');
  }

  return b64 + '='.repeat(num);
}

function useDebounce(value, delay) {
  var _useState = (0, _react.useState)(value),
      _useState2 = (0, _slicedToArray2.default)(_useState, 2),
      debouncedValue = _useState2[0],
      setDebouncedValue = _useState2[1];

  (0, _react.useEffect)(function () {
    var handler = setTimeout(function () {
      setDebouncedValue(value);
    }, delay);
    return function () {
      clearTimeout(handler);
    };
  }, [value, delay]);
  return debouncedValue;
} // https://stackoverflow.com/questions/56283920/how-to-debounce-a-callback-in-functional-component-using-hooks
// eslint-disable-next-line @typescript-eslint/no-explicit-any


function useDebouncedCallback(callback) {
  var wait = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 400;
  // track args & timeout handle between calls
  var argsRef = (0, _react.useRef)();
  var timeout = (0, _react.useRef)();

  function cleanup() {
    if (timeout.current) {
      clearTimeout(timeout.current);
    }
  } // make sure our timeout gets cleared if our consuming component gets unmounted


  (0, _react.useEffect)(function () {
    return cleanup;
  }, []);
  return function debouncedCallback() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    // capture latest args
    argsRef.current = args; // clear debounce timer

    cleanup(); // start waiting again

    timeout.current = setTimeout(function () {
      if (argsRef.current) {
        callback.apply(void 0, (0, _toConsumableArray2.default)(argsRef.current));
      }
    }, wait);
  };
}
/** find the first node in the hierarchy that matches the given predicate */


function findParentThat(node, predicate) {
  var currentNode = node;

  while (currentNode && (0, _mobxStateTree.isAlive)(currentNode)) {
    if (predicate(currentNode)) {
      return currentNode;
    }

    if ((0, _mobxStateTree.hasParent)(currentNode)) {
      currentNode = (0, _mobxStateTree.getParent)(currentNode);
    } else {
      break;
    }
  }

  throw new Error('no matching node found');
}

// based on https://github.com/react-spring/react-spring/blob/cd5548a987383b8023efd620f3726a981f9e18ea/src/animated/FrameLoop.ts
function springAnimate(fromValue, toValue, setValue) {
  var onFinish = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : function () {};
  var precision = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
  var tension = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 170;
  var friction = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 26;
  var mass = 1;

  if (!precision) {
    precision = Math.abs(toValue - fromValue) / 1000;
  }

  var animationFrameId;

  function update(animation) {
    var time = Date.now();
    var position = animation.lastPosition;
    var lastTime = animation.lastTime || time;
    var velocity = animation.lastVelocity || 0; // If we lost a lot of frames just jump to the end.

    if (time > lastTime + 64) {
      lastTime = time;
    } // http://gafferongames.com/game-physics/fix-your-timestep/


    var numSteps = Math.floor(time - lastTime);

    for (var i = 0; i < numSteps; ++i) {
      var force = -tension * (position - toValue);
      var damping = -friction * velocity;
      var acceleration = (force + damping) / mass;
      velocity += acceleration * 1 / 1000;
      position += velocity * 1 / 1000;
    }

    var isVelocity = Math.abs(velocity) <= precision;
    var isDisplacement = tension !== 0 ? Math.abs(toValue - position) <= precision : true;
    var endOfAnimation = isVelocity && isDisplacement;

    if (endOfAnimation) {
      setValue(toValue);
      onFinish();
    } else {
      setValue(position);
      animationFrameId = requestAnimationFrame(function () {
        return update({
          lastPosition: position,
          lastTime: time,
          lastVelocity: velocity
        });
      });
    }
  }

  return [function () {
    return update({
      lastPosition: fromValue
    });
  }, function () {
    return cancelAnimationFrame(animationFrameId);
  }];
}
/** find the first node in the hierarchy that matches the given 'is' typescript type guard predicate */


function findParentThatIs(node, predicate) {
  return findParentThat(node, predicate);
}
/** get the current JBrowse session model, starting at any node in the state tree */


function getSession(node) {
  try {
    return findParentThatIs(node, _types.isSessionModel);
  } catch (e) {
    throw new Error('no session model found!');
  }
}
/** get the state model of the view in the state tree that contains the given node */


function getContainingView(node) {
  try {
    return findParentThatIs(node, _types.isViewModel);
  } catch (e) {
    throw new Error('no containing view found');
  }
}
/** get the state model of the view in the state tree that contains the given node */


function getContainingTrack(node) {
  try {
    return findParentThatIs(node, _types.isTrackModel);
  } catch (e) {
    throw new Error('no containing track found');
  }
}

function getContainingDisplay(node) {
  try {
    return findParentThatIs(node, _types.isDisplayModel);
  } catch (e) {
    throw new Error('no containing display found');
  }
}
/**
 * Assemble a 1-based "locString" from an interbase genomic location
 * @param region - Region
 * @example
 * ```ts
 * assembleLocString({ refName: 'chr1', start: 0, end: 100 })
 * // ↳ 'chr1:1..100'
 * ```
 * @example
 * ```ts
 * assembleLocString({ assemblyName: 'hg19', refName: 'chr1', start: 0, end: 100 })
 * // ↳ '{hg19}chr1:1..100'
 * ```
 * @example
 * ```ts
 * assembleLocString({ refName: 'chr1' })
 * // ↳ 'chr1'
 * ```
 * @example
 * ```ts
 * assembleLocString({ refName: 'chr1', start: 0 })
 * // ↳ 'chr1:1..'
 * ```
 * @example
 * ```ts
 * assembleLocString({ refName: 'chr1', end: 100 })
 * // ↳ 'chr1:1..100'
 * ```
 * @example
 * ```ts
 * assembleLocString({ refName: 'chr1', start: 0, end: 1 })
 * // ↳ 'chr1:1'
 * ```
 */


function assembleLocString(region) {
  var assemblyName = region.assemblyName,
      refName = region.refName,
      start = region.start,
      end = region.end;
  var assemblyNameString = assemblyName ? "{".concat(assemblyName, "}") : '';
  var startString;

  if (start !== undefined) {
    startString = ":".concat((start + 1).toLocaleString('en-US'));
  } else if (end !== undefined) {
    startString = ':1';
  } else {
    startString = '';
  }

  var endString;

  if (end !== undefined) {
    endString = start !== undefined && start + 1 === end ? '' : "..".concat(end.toLocaleString('en-US'));
  } else {
    endString = start !== undefined ? '..' : '';
  }

  return "".concat(assemblyNameString).concat(refName).concat(startString).concat(endString);
}

function parseLocStringOneBased(locString, isValidRefName) {
  if (!locString) {
    throw new Error('no location string provided, could not parse');
  } // remove any whitespace


  locString = locString.replace(/\s/, ''); // refNames can have colons :(
  // https://samtools.github.io/hts-specs/SAMv1.pdf Appendix A

  var assemblyMatch = locString.match(/(\{(.+)\})?(.+)/);

  if (!assemblyMatch) {
    throw new Error("invalid location string: \"".concat(locString, "\""));
  }

  var _assemblyMatch = (0, _slicedToArray2.default)(assemblyMatch, 4),
      assemblyName = _assemblyMatch[2],
      location = _assemblyMatch[3];

  if (!assemblyName && location.startsWith('{}')) {
    throw new Error("no assembly name was provided in location \"".concat(location, "\""));
  }

  var lastColonIdx = location.lastIndexOf(':');

  if (lastColonIdx === -1) {
    if (isValidRefName(location, assemblyName)) {
      return {
        assemblyName: assemblyName,
        refName: location
      };
    }

    throw new Error("Unknown reference sequence \"".concat(location, "\""));
  }

  var prefix = location.slice(0, lastColonIdx);
  var suffix = location.slice(lastColonIdx + 1);

  if (isValidRefName(prefix, assemblyName) && isValidRefName(location, assemblyName)) {
    throw new Error("ambiguous location string: \"".concat(locString, "\""));
  } else if (isValidRefName(prefix, assemblyName)) {
    if (suffix) {
      // see if it's a range
      var rangeMatch = suffix.match(/^(-?(\d+|\d{1,3}(,\d{3})*))(\.\.|-)(-?(\d+|\d{1,3}(,\d{3})*))$/); // see if it's a single point

      var singleMatch = suffix.match(/^(-?(\d+|\d{1,3}(,\d{3})*))(\.\.|-)?$/);

      if (rangeMatch) {
        var _rangeMatch = (0, _slicedToArray2.default)(rangeMatch, 6),
            start = _rangeMatch[1],
            end = _rangeMatch[5];

        if (start !== undefined && end !== undefined) {
          return {
            assemblyName: assemblyName,
            refName: prefix,
            start: +start.replace(/,/g, ''),
            end: +end.replace(/,/g, '')
          };
        }
      } else if (singleMatch) {
        var _singleMatch = (0, _slicedToArray2.default)(singleMatch, 5),
            _start = _singleMatch[1],
            separator = _singleMatch[4];

        if (_start !== undefined) {
          if (separator) {
            // indefinite end
            return {
              assemblyName: assemblyName,
              refName: prefix,
              start: +_start.replace(/,/g, '')
            };
          }

          return {
            assemblyName: assemblyName,
            refName: prefix,
            start: +_start.replace(/,/g, ''),
            end: +_start.replace(/,/g, '')
          };
        }
      } else {
        throw new Error("could not parse range \"".concat(suffix, "\" on location \"").concat(locString, "\""));
      }
    } else {
      return {
        assemblyName: assemblyName,
        refName: prefix
      };
    }
  } else if (isValidRefName(location, assemblyName)) {
    return {
      assemblyName: assemblyName,
      refName: location
    };
  }

  throw new Error("unknown reference sequence name in location \"".concat(locString, "\""));
}
/**
 * Parse a 1-based location string into an interbase genomic location
 * @param locString - Location string
 * @param isValidRefName - Function that checks if a refName exists in the set
 * of all known refNames, or in the set of refNames for an assembly if
 * assemblyName is given
 * @example
 * ```ts
 * parseLocString('chr1:1..100', isValidRefName)
 * // ↳ { refName: 'chr1', start: 0, end: 100 }
 * ```
 * @example
 * ```ts
 * parseLocString('chr1:1-100', isValidRefName)
 * // ↳ { refName: 'chr1', start: 0, end: 100 }
 * ```
 * @example
 * ```ts
 * parseLocString(`{hg19}chr1:1..100`, isValidRefName)
 * // ↳ { assemblyName: 'hg19', refName: 'chr1', start: 0, end: 100 }
 * ```
 * @example
 * ```ts
 * parseLocString('chr1', isValidRefName)
 * // ↳ { refName: 'chr1' }
 * ```
 * @example
 * ```ts
 * parseLocString('chr1:1', isValidRefName)
 * // ↳ { refName: 'chr1', start: 0, end: 1 }
 * ```
 * @example
 * ```ts
 * parseLocString('chr1:1..', isValidRefName)
 * // ↳ { refName: 'chr1', start: 0}
 * ```
 */


function parseLocString(locString, isValidRefName) {
  var parsed = parseLocStringOneBased(locString, isValidRefName);

  if (typeof parsed.start === 'number') {
    parsed.start -= 1;
  }

  return parsed;
}

function compareLocs(locA, locB) {
  var assemblyComp = locA.assemblyName || locB.assemblyName ? (locA.assemblyName || '').localeCompare(locB.assemblyName || '') : 0;

  if (assemblyComp) {
    return assemblyComp;
  }

  var refComp = locA.refName || locB.refName ? (locA.refName || '').localeCompare(locB.refName || '') : 0;

  if (refComp) {
    return refComp;
  }

  if (locA.start !== undefined && locB.start !== undefined) {
    var startComp = locA.start - locB.start;

    if (startComp) {
      return startComp;
    }
  }

  if (locA.end !== undefined && locB.end !== undefined) {
    var endComp = locA.end - locB.end;

    if (endComp) {
      return endComp;
    }
  }

  return 0;
}

function compareLocStrings(a, b, isValidRefName) {
  var locA = parseLocString(a, isValidRefName);
  var locB = parseLocString(b, isValidRefName);
  return compareLocs(locA, locB);
}
/**
 * Ensure that a number is at least min and at most max.
 *
 * @param num -
 * @param min -
 * @param  max -
 */


function clamp(num, min, max) {
  if (num < min) {
    return min;
  }

  if (num > max) {
    return max;
  }

  return num;
}

function roundToNearestPointOne(num) {
  return Math.round(num * 10) / 10;
}
/**
 * @param bp -
 * @param region -
 * @param bpPerPx -
 */


function bpToPx(bp, region, bpPerPx) {
  if (region.reversed) {
    return roundToNearestPointOne((region.end - bp) / bpPerPx);
  }

  return roundToNearestPointOne((bp - region.start) / bpPerPx);
}

var oneEightyOverPi = 180.0 / Math.PI;
var piOverOneEighty = Math.PI / 180.0;

function radToDeg(radians) {
  return radians * oneEightyOverPi % 360;
}

function degToRad(degrees) {
  return degrees * piOverOneEighty % (2 * Math.PI);
}
/**
 * @returns [x, y]
 */


function polarToCartesian(rho, theta) {
  return [rho * Math.cos(theta), rho * Math.sin(theta)];
}
/**
 * @param x - the x
 * @param y - the y
 * @returns [rho, theta]
 */


function cartesianToPolar(x, y) {
  var rho = Math.sqrt(x * x + y * y);
  var theta = Math.atan(y / x);
  return [rho, theta];
}

function featureSpanPx(feature, region, bpPerPx) {
  return bpSpanPx(feature.get('start'), feature.get('end'), region, bpPerPx);
}

function bpSpanPx(leftBp, rightBp, region, bpPerPx) {
  var start = bpToPx(leftBp, region, bpPerPx);
  var end = bpToPx(rightBp, region, bpPerPx);
  return region.reversed ? [end, start] : [start, end];
}

var objectFromEntries = Object.fromEntries.bind(Object); // do an array map of an iterable

exports.objectFromEntries = objectFromEntries;

function iterMap(iterable, func, sizeHint) {
  var results = sizeHint ? new Array(sizeHint) : [];
  var counter = 0;

  var _iterator = _createForOfIteratorHelper(iterable),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var _item = _step.value;
      results[counter] = func(_item);
      counter += 1;
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return results;
}

// similar to electron.js
function mergeConfigs(A, B) {
  var merged = (0, _deepmerge.default)(A, B);

  if (B.defaultSession) {
    merged.defaultSession = B.defaultSession;
  } else if (A.defaultSession) {
    merged.defaultSession = A.defaultSession;
  }

  return merged;
} // https://stackoverflow.com/a/53187807

/**
 * Returns the index of the last element in the array where predicate is true,
 * and -1 otherwise.
 * @param array - The source array to search in
 * @param predicate - find calls predicate once for each element of the array, in
 * descending order, until it finds one where predicate returns true. If such an
 * element is found, findLastIndex immediately returns that element index.
 * Otherwise, findLastIndex returns -1.
 */


function findLastIndex(array, predicate) {
  var l = array.length;

  while (l--) {
    if (predicate(array[l], l, array)) {
      return l;
    }
  }

  return -1;
}
/**
 * makes a mobx reaction with the given functions, that calls actions on the
 * model for each stage of execution, and to abort the reaction function when
 * the model is destroyed.
 *
 * Will call startedFunction(signal), successFunction(result), and
 * errorFunction(error) when the async reaction function starts, completes, and
 * errors respectively.
 *
 * @param self -
 * @param dataFunction -
 * @param asyncReactionFunction -
 * @param reactionOptions -
 * @param startedFunction -
 * @param successFunction -
 * @param errorFunction -
 */


function makeAbortableReaction(self, dataFunction, asyncReactionFunction, reactionOptions, startedFunction, successFunction, errorFunction) {
  var inProgress;

  function handleError(error) {
    if (!(0, _aborting.isAbortException)(error)) {
      if ((0, _mobxStateTree.isAlive)(self)) {
        errorFunction(error);
      } else {
        console.error(error);
      }
    }
  }

  var reactionDisposer = (0, _mobx.reaction)(function () {
    try {
      return dataFunction(self);
    } catch (error) {
      handleError(error);
      return undefined;
    }
  }, /*#__PURE__*/function () {
    var _ref = (0, _asyncToGenerator2.default)( /*#__PURE__*/regeneratorRuntime.mark(function _callee(data, mobxReactionHandle) {
      var thisInProgress, result;
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (inProgress && !inProgress.signal.aborted) {
                inProgress.abort();
              }

              if ((0, _mobxStateTree.isAlive)(self)) {
                _context.next = 3;
                break;
              }

              return _context.abrupt("return");

            case 3:
              inProgress = new AbortController();
              thisInProgress = inProgress;
              startedFunction(thisInProgress);
              _context.prev = 6;
              _context.next = 9;
              return asyncReactionFunction(data, thisInProgress.signal, self, mobxReactionHandle);

            case 9:
              result = _context.sent;
              (0, _aborting.checkAbortSignal)(thisInProgress.signal);

              if ((0, _mobxStateTree.isAlive)(self)) {
                successFunction(result);
              }

              _context.next = 18;
              break;

            case 14:
              _context.prev = 14;
              _context.t0 = _context["catch"](6);

              if (thisInProgress && !thisInProgress.signal.aborted) {
                thisInProgress.abort();
              }

              handleError(_context.t0);

            case 18:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, null, [[6, 14]]);
    }));

    return function (_x, _x2) {
      return _ref.apply(this, arguments);
    };
  }(), reactionOptions);
  (0, _mobxStateTree.addDisposer)(self, reactionDisposer);
  (0, _mobxStateTree.addDisposer)(self, function () {
    if (inProgress && !inProgress.signal.aborted) {
      inProgress.abort();
    }
  });
}

function renameRegionIfNeeded(refNameMap, region) {
  if ((0, _mobxStateTree.isStateTreeNode)(region) && !(0, _mobxStateTree.isAlive)(region)) {
    return region;
  }

  if (region && refNameMap && refNameMap[region.refName]) {
    // clone the region so we don't modify it
    if ((0, _mobxStateTree.isStateTreeNode)(region)) {
      region = _objectSpread({}, (0, _mobxStateTree.getSnapshot)(region));
    } else {
      region = _objectSpread({}, region);
    } // modify it directly in the container


    var newRef = refNameMap[region.refName];

    if (newRef) {
      return _objectSpread(_objectSpread({}, region), {}, {
        refName: newRef,
        originalRefName: region.refName
      });
    }
  }

  return region;
}

function renameRegionsIfNeeded(_x3, _x4) {
  return _renameRegionsIfNeeded.apply(this, arguments);
}

function _renameRegionsIfNeeded() {
  _renameRegionsIfNeeded = (0, _asyncToGenerator2.default)( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(assemblyManager, args) {
    var assemblyName, regions, adapterConfig, newArgs, refNameMap, i;
    return regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            assemblyName = args.assemblyName, regions = args.regions, adapterConfig = args.adapterConfig;

            if (args.sessionId) {
              _context2.next = 3;
              break;
            }

            throw new Error('sessionId is required');

          case 3:
            newArgs = _objectSpread(_objectSpread({}, args), {}, {
              regions: (0, _toConsumableArray2.default)(args.regions || [])
            });

            if (!assemblyName) {
              _context2.next = 9;
              break;
            }

            _context2.next = 7;
            return assemblyManager.getRefNameMapForAdapter(adapterConfig, assemblyName, newArgs);

          case 7:
            refNameMap = _context2.sent;

            if (refNameMap && regions && newArgs.regions) {
              for (i = 0; i < regions.length; i += 1) {
                newArgs.regions[i] = renameRegionIfNeeded(refNameMap, regions[i]);
              }
            }

          case 9:
            return _context2.abrupt("return", newArgs);

          case 10:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _renameRegionsIfNeeded.apply(this, arguments);
}

function minmax(a, b) {
  return [Math.min(a, b), Math.max(a, b)];
}

function stringify(_ref2) {
  var refName = _ref2.refName,
      coord = _ref2.coord,
      oob = _ref2.oob;
  return "".concat(refName, ":").concat(coord.toLocaleString('en-US')).concat(oob ? ' (out of bounds)' : '');
}

var isElectron = typeof window !== 'undefined' && Boolean(window.electron);
exports.isElectron = isElectron;

function revcom(seqString) {
  return complement(seqString).split('').reverse().join('');
}

var complement = function () {
  var complementRegex = /[ACGT]/gi; // from bioperl: tr/acgtrymkswhbvdnxACGTRYMKSWHBVDNX/tgcayrkmswdvbhnxTGCAYRKMSWDVBHNX/
  // generated with:
  // perl -MJSON -E '@l = split "","acgtrymkswhbvdnxACGTRYMKSWHBVDNX"; print to_json({ map { my $in = $_; tr/acgtrymkswhbvdnxACGTRYMKSWHBVDNX/tgcayrkmswdvbhnxTGCAYRKMSWDVBHNX/; $in => $_ } @l})'

  var complementTable = {
    S: 'S',
    w: 'w',
    T: 'A',
    r: 'y',
    a: 't',
    N: 'N',
    K: 'M',
    x: 'x',
    d: 'h',
    Y: 'R',
    V: 'B',
    y: 'r',
    M: 'K',
    h: 'd',
    k: 'm',
    C: 'G',
    g: 'c',
    t: 'a',
    A: 'T',
    n: 'n',
    W: 'W',
    X: 'X',
    m: 'k',
    v: 'b',
    B: 'V',
    s: 's',
    H: 'D',
    c: 'g',
    D: 'H',
    b: 'v',
    R: 'Y',
    G: 'C'
  };
  return function (seqString) {
    return seqString.replace(complementRegex, function (m) {
      return complementTable[m] || '';
    });
  };
}();

exports.complement = complement;

function blobToDataURL(blob) {
  var a = new FileReader();
  return new Promise(function (resolve, reject) {
    a.onload = function (e) {
      if (e.target) {
        resolve(e.target.result);
      } else {
        reject(new Error('unknown result reading blob from canvas'));
      }
    };

    a.readAsDataURL(blob);
  });
} // requires immediate execution in jest environment, because (hypothesis) it
// otherwise listens for prerendered_canvas but reads empty pixels, and doesn't
// get the contents of the canvas


var rIC = typeof jest === 'undefined' ? // @ts-ignore
typeof window !== 'undefined' && window.requestIdleCallback ? // @ts-ignore
window.requestIdleCallback : function (cb) {
  return setTimeout(function () {
    return cb();
  }, 1);
} : function (cb) {
  return cb();
}; // xref https://gist.github.com/tophtucker/62f93a4658387bb61e4510c37e2e97cf

exports.rIC = rIC;

function measureText(str) {
  var fontSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;
  // prettier-ignore
  var widths = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.2796875, 0.2765625, 0.3546875, 0.5546875, 0.5546875, 0.8890625, 0.665625, 0.190625, 0.3328125, 0.3328125, 0.3890625, 0.5828125, 0.2765625, 0.3328125, 0.2765625, 0.3015625, 0.5546875, 0.5546875, 0.5546875, 0.5546875, 0.5546875, 0.5546875, 0.5546875, 0.5546875, 0.5546875, 0.5546875, 0.2765625, 0.2765625, 0.584375, 0.5828125, 0.584375, 0.5546875, 1.0140625, 0.665625, 0.665625, 0.721875, 0.721875, 0.665625, 0.609375, 0.7765625, 0.721875, 0.2765625, 0.5, 0.665625, 0.5546875, 0.8328125, 0.721875, 0.7765625, 0.665625, 0.7765625, 0.721875, 0.665625, 0.609375, 0.721875, 0.665625, 0.94375, 0.665625, 0.665625, 0.609375, 0.2765625, 0.3546875, 0.2765625, 0.4765625, 0.5546875, 0.3328125, 0.5546875, 0.5546875, 0.5, 0.5546875, 0.5546875, 0.2765625, 0.5546875, 0.5546875, 0.221875, 0.240625, 0.5, 0.221875, 0.8328125, 0.5546875, 0.5546875, 0.5546875, 0.5546875, 0.3328125, 0.5, 0.2765625, 0.5546875, 0.5, 0.721875, 0.5, 0.5, 0.5, 0.3546875, 0.259375, 0.353125, 0.5890625];
  var avg = 0.5279276315789471;
  return String(str).split('').map(function (c) {
    return c.charCodeAt(0) < widths.length ? widths[c.charCodeAt(0)] : avg;
  }).reduce(function (cur, acc) {
    return acc + cur;
  }, 0) * fontSize;
}

var defaultStarts = ['ATG'];
exports.defaultStarts = defaultStarts;
var defaultStops = ['TAA', 'TAG', 'TGA'];
exports.defaultStops = defaultStops;
var defaultCodonTable = {
  TCA: 'S',
  TCC: 'S',
  TCG: 'S',
  TCT: 'S',
  TTC: 'F',
  TTT: 'F',
  TTA: 'L',
  TTG: 'L',
  TAC: 'Y',
  TAT: 'Y',
  TAA: '*',
  TAG: '*',
  TGC: 'C',
  TGT: 'C',
  TGA: '*',
  TGG: 'W',
  CTA: 'L',
  CTC: 'L',
  CTG: 'L',
  CTT: 'L',
  CCA: 'P',
  CCC: 'P',
  CCG: 'P',
  CCT: 'P',
  CAC: 'H',
  CAT: 'H',
  CAA: 'Q',
  CAG: 'Q',
  CGA: 'R',
  CGC: 'R',
  CGG: 'R',
  CGT: 'R',
  ATA: 'I',
  ATC: 'I',
  ATT: 'I',
  ATG: 'M',
  ACA: 'T',
  ACC: 'T',
  ACG: 'T',
  ACT: 'T',
  AAC: 'N',
  AAT: 'N',
  AAA: 'K',
  AAG: 'K',
  AGC: 'S',
  AGT: 'S',
  AGA: 'R',
  AGG: 'R',
  GTA: 'V',
  GTC: 'V',
  GTG: 'V',
  GTT: 'V',
  GCA: 'A',
  GCC: 'A',
  GCG: 'A',
  GCT: 'A',
  GAC: 'D',
  GAT: 'D',
  GAA: 'E',
  GAG: 'E',
  GGA: 'G',
  GGC: 'G',
  GGG: 'G',
  GGT: 'G'
};
/**
 *  take CodonTable above and generate larger codon table that includes
 *  all permutations of upper and lower case nucleotides
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any

exports.defaultCodonTable = defaultCodonTable;

function generateCodonTable(table) {
  var tempCodonTable = {};
  Object.keys(table).forEach(function (codon) {
    var aa = table[codon];
    var nucs = [];

    for (var i = 0; i < 3; i++) {
      var nuc = codon.charAt(i);
      nucs[i] = [];
      nucs[i][0] = nuc.toUpperCase();
      nucs[i][1] = nuc.toLowerCase();
    }

    for (var _i = 0; _i < 2; _i++) {
      var n0 = nucs[0][_i];

      for (var j = 0; j < 2; j++) {
        var n1 = nucs[1][j];

        for (var k = 0; k < 2; k++) {
          var n2 = nucs[2][k];
          var triplet = n0 + n1 + n2;
          tempCodonTable[triplet] = aa;
        }
      }
    }
  });
  return tempCodonTable;
} // call statusCallback with current status and clear when finished


function updateStatus(_x5, _x6, _x7) {
  return _updateStatus.apply(this, arguments);
}

function _updateStatus() {
  _updateStatus = (0, _asyncToGenerator2.default)( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(statusMsg, statusCallback, fn) {
    var result;
    return regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            statusCallback(statusMsg);
            _context3.next = 3;
            return fn();

          case 3:
            result = _context3.sent;
            statusCallback('');
            return _context3.abrupt("return", result);

          case 6:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _updateStatus.apply(this, arguments);
}

function hashCode(str) {
  var hash = 0;
  var i;
  var chr;

  if (str.length === 0) {
    return hash;
  }

  for (i = 0; i < str.length; i++) {
    chr = str.charCodeAt(i);
    hash = (hash << 5) - hash + chr;
    hash |= 0; // Convert to 32bit integer
  }

  return hash;
} // eslint-disable-next-line @typescript-eslint/no-explicit-any


function objectHash(obj) {
  return "".concat(hashCode(JSON.stringify(obj)));
}