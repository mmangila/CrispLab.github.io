"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getSubType = getSubType;
exports.getUnionSubTypes = getUnionSubTypes;
exports.getPropertyType = getPropertyType;
exports.getDefaultValue = getDefaultValue;
exports.getEnumerationValues = getEnumerationValues;
exports.resolveLateType = resolveLateType;

var _mobxStateTree = require("mobx-state-tree");

/* eslint-disable no-underscore-dangle */

/**
 * get the inner type of an MST optional, array, or late type object
 *
 * @param {IModelType} type
 * @returns {IModelType}
 */
function getSubType(type) {
  var t;

  if ((0, _mobxStateTree.isOptionalType)(type)) {
    t = type._subtype || type.type;
  } else if ((0, _mobxStateTree.isArrayType)(type) || (0, _mobxStateTree.isMapType)(type)) {
    t = type._subtype || type._subType || type.subType;
  } else if (typeof type.getSubType === 'function') {
    return type.getSubType();
  } else {
    throw new TypeError('unsupported mst type');
  }

  if (!t) {
    // debugger
    throw new Error('failed to get subtype');
  }

  return t;
}
/**
 * get the array of
 * @param {MST Union Type obj} unionType
 * @returns {Array<IModelType>}
 */


function getUnionSubTypes(unionType) {
  if (!(0, _mobxStateTree.isUnionType)(unionType)) {
    throw new TypeError('not an MST union type');
  }

  var t = unionType._types || unionType.types || getSubType(unionType)._types || getSubType(unionType).types;

  if (!t) {
    // debugger
    throw new Error('failed to extract subtypes from mst union');
  }

  return t;
}
/**
 * get the type of one of the properties of the given MST model type
 *
 * @param {IModelType} type
 * @param {string} propertyName
 * @returns {IModelType}
 */


function getPropertyType(type, propertyName) {
  var propertyType = type.properties[propertyName];
  return propertyType;
}
/**
 * get the base type from inside an MST optional type
 * @param {*} type
 */


function getDefaultValue(type) {
  if (!(0, _mobxStateTree.isOptionalType)(type)) {
    throw new TypeError('type must be an optional type');
  }

  return type._defaultValue || type.defaultValue;
}
/** get the string values of an MST enumeration type */


function getEnumerationValues(type) {
  var subtypes = getUnionSubTypes(type); // the subtypes should all be literals with a value member

  return subtypes.map(function (t) {
    return t.value;
  });
}

function resolveLateType(maybeLate) {
  if (!(0, _mobxStateTree.isUnionType)(maybeLate) && !(0, _mobxStateTree.isArrayType)(maybeLate) && (0, _mobxStateTree.isLateType)(maybeLate)) {
    return maybeLate.getSubType();
  }

  return maybeLate;
}