"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = ConfigSlot;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _mobxStateTree = require("mobx-state-tree");

var _jexlStrings = require("../util/jexlStrings");

var _mst = require("../util/types/mst");

/* eslint-disable @typescript-eslint/no-explicit-any */
function isValidColorString()
/* str */
{
  // TODO: check all the crazy cases for whether it's a valid HTML/CSS color string
  return true;
}

var typeModels = {
  stringArray: _mobxStateTree.types.array(_mobxStateTree.types.string),
  stringArrayMap: _mobxStateTree.types.map(_mobxStateTree.types.array(_mobxStateTree.types.string)),
  numberMap: _mobxStateTree.types.map(_mobxStateTree.types.number),
  boolean: _mobxStateTree.types.boolean,
  color: _mobxStateTree.types.refinement('Color', _mobxStateTree.types.string, isValidColorString),
  integer: _mobxStateTree.types.integer,
  number: _mobxStateTree.types.number,
  string: _mobxStateTree.types.string,
  text: _mobxStateTree.types.string,
  fileLocation: _mst.FileLocation,
  frozen: _mobxStateTree.types.frozen()
}; // default values we use if the defaultValue is malformed or does not work

var fallbackDefaults = {
  stringArray: [],
  stringArrayMap: {},
  numberMap: {},
  boolean: true,
  color: 'black',
  integer: 1,
  number: 1,
  string: '',
  text: '',
  fileLocation: {
    uri: '/path/to/resource.txt'
  },
  frozen: {}
};

var literalJSON = function literalJSON(self) {
  return {
    views: {
      get valueJSON() {
        return self.value;
      }

    }
  };
};

var objectJSON = function objectJSON(self) {
  return {
    views: {
      get valueJSON() {
        return JSON.stringify(self.value);
      }

    }
  };
}; // custom actions for modifying the value models


var typeModelExtensions = {
  fileLocation: objectJSON,
  number: literalJSON,
  integer: literalJSON,
  boolean: literalJSON,
  frozen: objectJSON,
  // special actions for working with stringArray slots
  stringArray: function stringArray(self) {
    return {
      views: {
        get valueJSON() {
          return JSON.stringify(self.value);
        }

      },
      actions: {
        add: function add(val) {
          self.value.push(val);
        },
        removeAtIndex: function removeAtIndex(idx) {
          self.value.splice(idx, 1);
        },
        setAtIndex: function setAtIndex(idx, val) {
          self.value[idx] = val;
        }
      }
    };
  },
  stringArrayMap: function stringArrayMap(self) {
    return {
      views: {
        get valueJSON() {
          return JSON.stringify(self.value);
        }

      },
      actions: {
        add: function add(key, val) {
          self.value.set(key, val);
        },
        remove: function remove(key) {
          self.value.delete(key);
        },
        addToKey: function addToKey(key, val) {
          var ar = self.value.get(key);

          if (!ar) {
            throw new Error("".concat(key, " not found"));
          }

          ar.push(val);
        },
        removeAtKeyIndex: function removeAtKeyIndex(key, idx) {
          var ar = self.value.get(key);

          if (!ar) {
            throw new Error("".concat(key, " not found"));
          }

          ar.splice(idx, 1);
        },
        setAtKeyIndex: function setAtKeyIndex(key, idx, val) {
          var ar = self.value.get(key);

          if (!ar) {
            throw new Error("".concat(key, " not found"));
          }

          ar[idx] = val;
        }
      }
    };
  },
  numberMap: function numberMap(self) {
    return {
      views: {
        get valueJSON() {
          return JSON.stringify(self.value);
        }

      },
      actions: {
        add: function add(key, val) {
          self.value.set(key, val);
        },
        remove: function remove(key) {
          self.value.delete(key);
        }
      }
    };
  }
}; // const FunctionStringType = types.refinement(
//   'FunctionString',
//   types.string,
//   str => functionRegexp.test(str),
// )

var JexlStringType = _mobxStateTree.types.refinement('JexlString', _mobxStateTree.types.string, function (str) {
  return str.startsWith('jexl:');
});

/**
 * builds a MST model for a configuration slot
 *
 * @param slotName -
 * @param  definition -
 */
function ConfigSlot(slotName, _ref) {
  var _ref$description = _ref.description,
      description = _ref$description === void 0 ? '' : _ref$description,
      model = _ref.model,
      type = _ref.type,
      defaultValue = _ref.defaultValue,
      _ref$contextVariable = _ref.contextVariable,
      contextVariable = _ref$contextVariable === void 0 ? [] : _ref$contextVariable;

  if (!type) {
    throw new Error('type name required');
  }

  if (!model) {
    model = typeModels[type];
  }

  if (!model) {
    throw new Error("no builtin config slot type \"".concat(type, "\", and no 'model' param provided"));
  }

  if (defaultValue === undefined) {
    throw new Error("no 'defaultValue' provided");
  } // if the `type` is something like `color`, then the model name
  // here will be `ColorConfigSlot`


  var configSlotModelName = "".concat(slotName.charAt(0).toUpperCase()).concat(slotName.slice(1), "ConfigSlot");

  var slot = _mobxStateTree.types.model(configSlotModelName, {
    name: _mobxStateTree.types.literal(slotName),
    description: _mobxStateTree.types.literal(description),
    type: _mobxStateTree.types.literal(type),
    value: _mobxStateTree.types.optional(_mobxStateTree.types.union(JexlStringType, model), defaultValue)
  }).volatile(function () {
    return {
      contextVariable: contextVariable
    };
  }).views(function (self) {
    return {
      get isCallback() {
        return String(self.value).startsWith('jexl:');
      }

    };
  }).views(function (self) {
    return {
      get expr() {
        if (self.isCallback) {
          // compile as jexl function
          var _getEnv = (0, _mobxStateTree.getEnv)(self),
              pluginManager = _getEnv.pluginManager;

          if (!pluginManager && typeof jest === 'undefined') {
            console.warn('no pluginManager detected on config env (if you dynamically instantiate a config, for example in renderProps for your display model, check that you add the env argument)');
          }

          return (0, _jexlStrings.stringToJexlExpression)(String(self.value), pluginManager === null || pluginManager === void 0 ? void 0 : pluginManager.jexl);
        }

        return {
          evalSync: function evalSync() {
            return self.value;
          }
        };
      },

      // JS representation of the value of this slot, suitable
      // for embedding in either JSON or a JS function string.
      // many of the data types override this in typeModelExtensions
      get valueJSON() {
        if (self.isCallback) {
          return undefined;
        }

        function json(value) {
          if (value && value.toJSON) {
            return value.toJSON();
          }

          return "\"".concat(value, "\"");
        }

        return json(self.value);
      }

    };
  }).preProcessSnapshot(function (val) {
    return (0, _typeof2.default)(val) === 'object' && val.name === slotName ? val : {
      name: slotName,
      description: description,
      type: type,
      value: val
    };
  }).postProcessSnapshot(function (snap) {
    if ((0, _typeof2.default)(snap.value) === 'object') {
      return JSON.stringify(snap.value) !== JSON.stringify(defaultValue) ? snap.value : undefined;
    }

    return snap.value !== defaultValue ? snap.value : undefined;
  }).actions(function (self) {
    return {
      set: function set(newVal) {
        self.value = newVal;
      },
      reset: function reset() {
        self.value = defaultValue;
      },
      convertToCallback: function convertToCallback() {
        if (self.isCallback) {
          return;
        }

        self.value = "jexl:".concat(self.valueJSON || "''");
      },
      convertToValue: function convertToValue() {
        if (!self.isCallback) {
          return;
        } // try calling it with no arguments


        try {
          var funcResult = self.expr.evalSync();

          if (funcResult !== undefined) {
            self.value = funcResult;
            return;
          }
        } catch (e) {
          /* ignore */
        }

        self.value = defaultValue; // if it is still a callback (happens if the defaultValue is a callback),
        // then use the last-resort fallback default
        // if defaultValue has jexl: string, run this part

        if (self.isCallback) {
          if (!(type in fallbackDefaults)) {
            throw new Error("no fallbackDefault defined for type ".concat(type));
          }

          self.value = fallbackDefaults[type];
        }
      }
    };
  }); // if there are any type-specific extensions (views or actions)
  //  to the slot, add those in


  if (typeModelExtensions[type]) {
    slot = slot.extend(typeModelExtensions[type]);
  }

  var completeModel = _mobxStateTree.types.optional(slot, {
    name: slotName,
    type: type,
    description: description,
    value: defaultValue
  });

  var m = completeModel;
  Object.defineProperty(m, 'isJBrowseConfigurationSlot', {
    value: true
  });
  return m;
}