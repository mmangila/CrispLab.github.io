"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.readConfObject = readConfObject;
exports.getConf = getConf;
exports.getTypeNamesFromExplicitlyTypedUnion = getTypeNamesFromExplicitlyTypedUnion;
exports.isBareConfigurationSchemaType = isBareConfigurationSchemaType;
exports.isConfigurationSchemaType = isConfigurationSchemaType;
exports.isConfigurationModel = isConfigurationModel;
exports.isConfigurationSlotType = isConfigurationSlotType;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _mobxStateTree = require("mobx-state-tree");

var _mstReflection = require("../util/mst-reflection");

/**
 * given a configuration model (an instance of a ConfigurationSchema),
 * read the configuration variable at the given path
 *
 * @param model - instance of ConfigurationSchema
 * @param slotPaths - array of paths to read
 * @param args - extra arguments e.g. for a feature callback,
 *  will be sent to each of the slotNames
 */
function readConfObject(confObject) {
  var slotPath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
  var args = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  if (!confObject) {
    throw new TypeError('must provide conf object to read');
  }

  if (!slotPath) {
    return (0, _mobxStateTree.getSnapshot)(confObject);
  }

  if (typeof slotPath === 'string') {
    var slot = confObject[slotPath]; // check for the subconf being a map if we don't find it immediately

    if (!slot && (0, _mobxStateTree.isStateTreeNode)(confObject) && (0, _mobxStateTree.isMapType)((0, _mobxStateTree.getType)(confObject))) {
      slot = confObject.get(slotPath);
    }

    if (!slot) {
      return undefined; // if we want to be very strict about config slots, we could uncomment the below
      // instead of returning undefine
      //
      // const modelType = getType(model)
      // const schemaType = model.configuration && getType(model.configuration)
      // throw new Error(
      //   `no slot "${slotName}" found in ${modelType.name} configuration (${
      //     schemaType.name
      //   })`,
      // )
    }

    if (slot.expr) {
      var appliedFunc = slot.expr.evalSync(args);

      if ((0, _mobxStateTree.isStateTreeNode)(appliedFunc)) {
        return (0, _mobxStateTree.getSnapshot)(appliedFunc);
      }

      return appliedFunc;
    }

    if ((0, _mobxStateTree.isStateTreeNode)(slot)) {
      return (0, _mobxStateTree.getSnapshot)(slot);
    }

    return slot;
  }

  var slotName = slotPath[0];

  if (slotPath.length > 1) {
    var newPath = slotPath.slice(1);
    var subConf = confObject[slotName]; // check for the subconf being a map if we don't find it immediately

    if (!subConf && (0, _mobxStateTree.isStateTreeNode)(confObject) && (0, _mobxStateTree.isMapType)((0, _mobxStateTree.getType)(confObject))) {
      subConf = confObject.get(slotName);
    }

    if (!subConf) {
      return undefined;
    }

    return readConfObject(subConf, newPath, args);
  }

  return readConfObject(confObject, slotName, args);
}
/**
 * helper method for readConfObject, reads the config from a mst model
 *
 * @param model - object containing a 'configuration' member
 * @param slotPaths - array of paths to read
 * @param args - extra arguments e.g. for a feature callback,
 *   will be sent to each of the slotNames
 */


function getConf(model) {
  var slotPath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
  var args = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  if (!model) {
    throw new TypeError('must provide a model object');
  }

  var _ref = model,
      configuration = _ref.configuration;

  if (isConfigurationModel(configuration)) {
    return readConfObject(configuration, slotPath, args);
  }

  throw new TypeError('cannot getConf on this model, it has no configuration');
}
/**
 * given a union of explicitly typed configuration schema types,
 * extract an array of the type names contained in the union
 *
 * @param unionType -
 * @returns Array of type names contained in the union
 */


function getTypeNamesFromExplicitlyTypedUnion(maybeUnionType) {
  if ((0, _mobxStateTree.isType)(maybeUnionType)) {
    maybeUnionType = (0, _mstReflection.resolveLateType)(maybeUnionType); // @ts-ignore

    if ((0, _mobxStateTree.isUnionType)(maybeUnionType)) {
      var typeNames = [];
      (0, _mstReflection.getUnionSubTypes)(maybeUnionType).forEach(function (type) {
        type = (0, _mstReflection.resolveLateType)(type);
        var typeName = getTypeNamesFromExplicitlyTypedUnion(type);

        if (!typeName.length) {
          var def = (0, _mstReflection.getDefaultValue)(type);
          typeName = [def.type];
        }

        if (!typeName[0]) {
          // debugger
          throw new Error("invalid config schema type ".concat(type));
        }

        typeNames.push.apply(typeNames, (0, _toConsumableArray2.default)(typeName));
      });
      return typeNames;
    }
  }

  return [];
}

function isBareConfigurationSchemaType(thing) {
  if ((0, _mobxStateTree.isType)(thing)) {
    if ((0, _mobxStateTree.isModelType)(thing) && ('isJBrowseConfigurationSchema' in thing || thing.name.includes('ConfigurationSchema'))) {
      return true;
    } // if it's a late type, assume its a config schema


    if ((0, _mobxStateTree.isLateType)(thing)) {
      return true;
    }
  }

  return false;
}

function isConfigurationSchemaType(thing) {
  if (!(0, _mobxStateTree.isType)(thing)) {
    return false;
  } // written as a series of if-statements instead of a big logical OR
  // because this construction gives much better debugging backtraces.
  // also, note that the order of these statements matters, because
  // for example some union types are also optional types


  if (isBareConfigurationSchemaType(thing)) {
    return true;
  }

  if ((0, _mobxStateTree.isUnionType)(thing)) {
    return (0, _mstReflection.getUnionSubTypes)(thing).every(function (t) {
      return isConfigurationSchemaType(t) || t.name === 'undefined';
    });
  }

  if ((0, _mobxStateTree.isOptionalType)(thing) && isConfigurationSchemaType((0, _mstReflection.getSubType)(thing))) {
    return true;
  }

  if ((0, _mobxStateTree.isArrayType)(thing) && isConfigurationSchemaType((0, _mstReflection.getSubType)(thing))) {
    return true;
  }

  if ((0, _mobxStateTree.isMapType)(thing) && isConfigurationSchemaType((0, _mstReflection.getSubType)(thing))) {
    return true;
  }

  return false;
}

function isConfigurationModel(thing) {
  return (0, _mobxStateTree.isStateTreeNode)(thing) && isConfigurationSchemaType((0, _mobxStateTree.getType)(thing));
}

function isConfigurationSlotType(thing) {
  return (0, _typeof2.default)(thing) === 'object' && thing !== null && 'isJBrowseConfigurationSlot' in thing;
}