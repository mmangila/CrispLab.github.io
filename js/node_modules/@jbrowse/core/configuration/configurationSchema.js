"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ConfigurationSchema = ConfigurationSchema;
exports.ConfigurationReference = ConfigurationReference;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _mobxStateTree = require("mobx-state-tree");

var _mst = require("../util/types/mst");

var _configurationSlot = _interopRequireDefault(require("./configurationSlot"));

var _util = require("./util");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function isEmptyObject(thing) {
  return (0, _typeof2.default)(thing) === 'object' && !Array.isArray(thing) && thing !== null && Object.keys(thing).length === 0;
}

function isEmptyArray(thing) {
  return Array.isArray(thing) && thing.length === 0;
}

function preprocessConfigurationSchemaArguments(modelName, inputSchemaDefinition) {
  var inputOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  if (typeof modelName !== 'string') {
    throw new Error('first arg must be string name of the model that this config schema goes with');
  } // if we have a base configuration schema that we are
  // extending, grab the slot definitions from that


  var schemaDefinition = inputSchemaDefinition;
  var options = inputOptions;

  if (inputOptions.baseConfiguration && inputOptions.baseConfiguration.jbrowseSchemaDefinition) {
    schemaDefinition = _objectSpread(_objectSpread({}, inputOptions.baseConfiguration.jbrowseSchemaDefinition), schemaDefinition);
    options = _objectSpread(_objectSpread({}, inputOptions.baseConfiguration.jbrowseSchemaOptions || {}), inputOptions);
    delete options.baseConfiguration;
  }

  return {
    schemaDefinition: schemaDefinition,
    options: options
  };
}

function makeConfigurationSchemaModel(modelName, schemaDefinition, options) {
  // now assemble the MST model of the configuration schema
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  var modelDefinition = {};
  var identifier;

  if (options.explicitlyTyped) {
    modelDefinition.type = _mobxStateTree.types.optional(_mobxStateTree.types.literal(modelName), modelName);
  }

  if (options.explicitIdentifier && options.implicitIdentifier) {
    throw new Error("Cannot have both explicit and implicit identifiers in ".concat(modelName));
  }

  if (options.explicitIdentifier) {
    if (typeof options.explicitIdentifier === 'string') {
      modelDefinition[options.explicitIdentifier] = _mobxStateTree.types.identifier;
      identifier = options.explicitIdentifier;
    } else {
      modelDefinition.id = _mobxStateTree.types.identifier;
      identifier = 'id';
    }
  } else if (options.implicitIdentifier) {
    if (typeof options.implicitIdentifier === 'string') {
      modelDefinition[options.implicitIdentifier] = _mst.ElementId;
      identifier = options.implicitIdentifier;
    } else {
      modelDefinition.id = _mst.ElementId;
      identifier = 'id';
    }
  } // eslint-disable-next-line @typescript-eslint/no-explicit-any


  var volatileConstants = {
    isJBrowseConfigurationSchema: true,
    jbrowseSchema: {
      modelName: modelName,
      definition: schemaDefinition,
      options: options
    }
  };
  Object.entries(schemaDefinition).forEach(function (_ref) {
    var _ref2 = (0, _slicedToArray2.default)(_ref, 2),
        slotName = _ref2[0],
        slotDefinition = _ref2[1];

    if ((0, _mobxStateTree.isType)(slotDefinition) && (0, _mobxStateTree.isLateType)(slotDefinition) || (0, _util.isConfigurationSchemaType)(slotDefinition)) {
      // this is either an MST late() type (which we assume to be a sub-configuration),
      // or an actual sub-configuration
      modelDefinition[slotName] = slotDefinition;
    } else if (typeof slotDefinition === 'string' || typeof slotDefinition === 'number') {
      volatileConstants[slotName] = slotDefinition;
    } else if ((0, _typeof2.default)(slotDefinition) === 'object') {
      // this is a slot definition
      if (!slotDefinition.type) {
        throw new Error("no type set for config slot ".concat(modelName, ".").concat(slotName));
      }

      try {
        modelDefinition[slotName] = (0, _configurationSlot.default)(slotName, slotDefinition);
      } catch (e) {
        throw new Error("invalid config slot definition for ".concat(modelName, ".").concat(slotName, ": ").concat(e.message));
      }
    } else {
      throw new Error("invalid configuration schema definition, \"".concat(slotName, "\" must be either a valid configuration slot definition, a constant, or a nested configuration schema"));
    }
  });

  var completeModel = _mobxStateTree.types.model("".concat(modelName, "ConfigurationSchema"), modelDefinition).actions(function (self) {
    return {
      setSubschema: function setSubschema(slotName, data) {
        if (!(0, _util.isConfigurationSchemaType)(modelDefinition[slotName])) {
          throw new Error("".concat(slotName, " is not a subschema, cannot replace"));
        }

        var newSchema = (0, _mobxStateTree.isStateTreeNode)(data) ? data : modelDefinition[slotName].create(data);
        self[slotName] = newSchema;
        return newSchema;
      }
    };
  });

  if (Object.keys(volatileConstants).length) {
    completeModel = completeModel.volatile(function () {
      return (
        /* self */
        volatileConstants
      );
    });
  }

  if (options.actions) {
    completeModel = completeModel.actions(options.actions);
  }

  if (options.views) {
    completeModel = completeModel.views(options.views);
  }

  if (options.extend) {
    completeModel = completeModel.extend(options.extend);
  }

  var identifierDefault = identifier ? (0, _defineProperty2.default)({}, identifier, 'placeholderId') : {};
  var modelDefault = options.explicitlyTyped ? _objectSpread({
    type: modelName
  }, identifierDefault) : identifierDefault;
  var defaultSnap = (0, _mobxStateTree.getSnapshot)(completeModel.create(modelDefault));
  completeModel = completeModel.postProcessSnapshot(function (snap) {
    var newSnap = {};
    var matchesDefault = true; // let keyCount = 0

    for (var _i = 0, _Object$entries = Object.entries(snap); _i < _Object$entries.length; _i++) {
      var _Object$entries$_i = (0, _slicedToArray2.default)(_Object$entries[_i], 2),
          key = _Object$entries$_i[0],
          value = _Object$entries$_i[1];

      if (matchesDefault) {
        if ((0, _typeof2.default)(defaultSnap[key]) === 'object' && (0, _typeof2.default)(value) === 'object') {
          if (JSON.stringify(defaultSnap[key]) !== JSON.stringify(value)) {
            matchesDefault = false;
          }
        } else if (defaultSnap[key] !== value) {
          matchesDefault = false;
        }
      }

      if (value !== undefined && volatileConstants[key] === undefined && !isEmptyObject(value) && !isEmptyArray(value)) {
        // keyCount += 1
        newSnap[key] = value;
      }
    }

    if (matchesDefault) {
      return {};
    }

    return newSnap;
  });

  if (options.preProcessSnapshot) {
    completeModel = completeModel.preProcessSnapshot(options.preProcessSnapshot);
  }

  var schemaType = _mobxStateTree.types.optional(completeModel, modelDefault);

  return schemaType;
}

function ConfigurationSchema(modelName, inputSchemaDefinition, inputOptions) {
  var _preprocessConfigurat = preprocessConfigurationSchemaArguments(modelName, inputSchemaDefinition, inputOptions),
      schemaDefinition = _preprocessConfigurat.schemaDefinition,
      options = _preprocessConfigurat.options;

  var schemaType = makeConfigurationSchemaModel(modelName, schemaDefinition, options); // saving a couple of jbrowse-specific things in the type object. hope nobody gets mad.

  schemaType.isJBrowseConfigurationSchema = true;
  schemaType.jbrowseSchemaDefinition = schemaDefinition;
  schemaType.jbrowseSchemaOptions = options;
  return schemaType;
}

function ConfigurationReference(schemaType) {
  return _mobxStateTree.types.union(_mobxStateTree.types.reference(schemaType), schemaType);
}