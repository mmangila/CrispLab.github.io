import { Observable } from 'rxjs';
import { Feature } from '../util/simpleFeature';
import { AnyConfigurationModel } from '../configuration/configurationSchema';
import { getSubAdapterType } from './dataAdapterCache';
import { Region, NoAssemblyRegion } from '../util/types';
import BaseResult from '../TextSearch/BaseResults';
export interface BaseOptions {
    signal?: AbortSignal;
    bpPerPx?: number;
    sessionId?: string;
    statusCallback?: (message: string) => void;
    headers?: Record<string, string>;
    [key: string]: unknown;
}
export declare type SearchType = 'full' | 'prefix' | 'exact';
export interface BaseArgs {
    searchType?: SearchType;
    queryString: string;
    signal?: AbortSignal;
    limit?: number;
    pageNumber?: number;
}
export interface AnyAdapter {
    new (config: AnyConfigurationModel, getSubAdapter?: getSubAdapterType): AnyDataAdapter;
}
export declare type AnyDataAdapter = BaseAdapter | BaseFeatureDataAdapter | BaseRefNameAliasAdapter | BaseTextSearchAdapter | RegionsAdapter | SequenceAdapter;
export declare abstract class BaseAdapter {
    id: string;
    static capabilities: string[];
    config: AnyConfigurationModel;
    getSubAdapter?: getSubAdapterType;
    constructor(config?: AnyConfigurationModel, getSubAdapter?: getSubAdapterType);
    /**
     * Called to provide a hint that data tied to a certain region will not be
     * needed for the forseeable future and can be purged from caches, etc
     * @param region - Region
     */
    abstract freeResources(region: Region): void;
}
/**
 * Base class for feature adapters to extend. Defines some methods that
 * subclasses must implement.
 */
export declare abstract class BaseFeatureDataAdapter extends BaseAdapter {
    /**
     * Get all reference sequence names used in the data source
     *
     * NOTE: If an adapter is unable to determine the reference sequence names,
     * the array will be empty
     * @param opts - Feature adapter options
     */
    abstract getRefNames(opts?: BaseOptions): Promise<string[]>;
    /**
     * Get features from the data source that overlap a region
     * @param region - Region
     * @param options - Feature adapter options
     * @returns Observable of Feature objects in the region
     */
    abstract getFeatures(region: Region, opts?: BaseOptions): Observable<Feature>;
    /**
     * Return "header info" that is fetched from the data file, or other info
     * that would not simply be in the config of the file. The return value can
     * be `{tag:string, data: any}[]` e.g. list of tags with their values which
     * is how VCF,BAM,CRAM return values for getInfo or it can be a nested JSON
     * object
     */
    getHeader(_opts?: BaseOptions): Promise<unknown>;
    /**
     * Return info that is primarily used for interpreting the data that is there,
     * primarily in reference to being used for augmenting feature details panels
     */
    getMetadata(_opts?: BaseOptions): Promise<unknown>;
    /**
     * Checks if the store has data for the given assembly and reference
     * sequence, and then gets the features in the region if it does.
     */
    getFeaturesInRegion(region: Region, opts?: BaseOptions): Observable<Feature>;
    /**
     * Checks if the store has data for the given assembly and reference
     * sequence, and then gets the features in the region if it does.
     *
     * Currently this just calls getFeatureInRegion for each region. Adapters
     * that are frequently called on multiple regions simultaneously may
     * want to implement a more efficient custom version of this method.
     *
     * Currently this just calls getFeatureInRegion for each region. Adapters that
     * are frequently called on multiple regions simultaneously may want to
     * implement a more efficient custom version of this method.
     * @param regions - Regions
     * @param opts - Feature adapter options
     * @returns Observable of Feature objects in the regions
     */
    getFeaturesInMultipleRegions(regions: Region[], opts?: BaseOptions): Observable<Feature>;
    /**
     * Check if the store has data for the given reference name.
     * @param refName - Name of the reference sequence
     * @returns Whether data source has data for the given reference name
     */
    hasDataForRefName(refName: string, opts?: BaseOptions): Promise<boolean>;
    getRegionStats(region: Region, opts?: BaseOptions): Promise<import("../util/stats").FeatureStats>;
    getMultiRegionStats(regions?: Region[], opts?: BaseOptions): Promise<import("../util/stats").FeatureStats>;
}
export interface RegionsAdapter extends BaseAdapter {
    getRegions(opts: BaseOptions): Promise<NoAssemblyRegion[]>;
}
export interface SequenceAdapter extends BaseFeatureDataAdapter, RegionsAdapter {
}
export declare function isSequenceAdapter(thing: AnyDataAdapter): thing is SequenceAdapter;
export declare function isRegionsAdapter(thing: AnyDataAdapter): thing is RegionsAdapter;
export declare function isFeatureAdapter(thing: AnyDataAdapter): thing is BaseFeatureDataAdapter;
export interface Alias {
    refName: string;
    aliases: string[];
}
export interface BaseRefNameAliasAdapter extends BaseAdapter {
    getRefNameAliases(opts: BaseOptions): Promise<Alias[]>;
}
export declare function isRefNameAliasAdapter(thing: object): thing is BaseRefNameAliasAdapter;
export interface BaseTextSearchAdapter extends BaseAdapter {
    searchIndex(args: BaseArgs): Promise<BaseResult[]>;
}
export declare function isTextSearchAdapter(thing: AnyDataAdapter): thing is BaseTextSearchAdapter;
