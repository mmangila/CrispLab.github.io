"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getAdapter = getAdapter;
exports.freeAdapterResources = freeAdapterResources;
exports.clearAdapterCache = clearAdapterCache;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _jsonStableStringify = _interopRequireDefault(require("json-stable-stringify"));

function adapterConfigCacheKey(adapterConfig) {
  return "".concat((0, _jsonStableStringify.default)(adapterConfig));
}

var adapterCache = {};
/**
 * instantiate a data adapter, or return an already-instantiated one if we have one with the same
 * configuration
 *
 * @param pluginManager -
 * @param sessionId - session ID of the associated worker session.
 *   used for reference counting
 * @param adapterConfigSnapshot - plain-JS configuration snapshot for the adapter
 */

function getAdapter(_x, _x2, _x3) {
  return _getAdapter.apply(this, arguments);
}
/**
 * this is a callback that is passed to adapters that
 * allows them to get any sub-adapters that they need
 * internally, staying with the same worker session ID
 */


function _getAdapter() {
  _getAdapter = (0, _asyncToGenerator2.default)( /*#__PURE__*/regeneratorRuntime.mark(function _callee(pluginManager, sessionId, adapterConfigSnapshot) {
    var cacheKey, adapterType, dataAdapterType, adapterConfig, getSubAdapter, AdapterClass, getAdapterClass, CLASS, dataAdapter, cacheEntry;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            // cache the adapter object
            cacheKey = adapterConfigCacheKey(adapterConfigSnapshot);

            if (adapterCache[cacheKey]) {
              _context.next = 21;
              break;
            }

            adapterType = (adapterConfigSnapshot || {}).type;

            if (adapterType) {
              _context.next = 5;
              break;
            }

            throw new Error('could not determine adapter type from adapter config snapshot');

          case 5:
            dataAdapterType = pluginManager.getAdapterType(adapterType);

            if (dataAdapterType) {
              _context.next = 8;
              break;
            }

            throw new Error("unknown data adapter type ".concat(adapterType));

          case 8:
            // instantiate the data adapter's config schema so it gets its defaults,
            // callbacks, etc
            adapterConfig = dataAdapterType.configSchema.create(adapterConfigSnapshot, {
              pluginManager: pluginManager
            });
            getSubAdapter = getAdapter.bind(null, pluginManager, sessionId); // instantiate the adapter itself with its config schema, and a bound
            // func that it can use to get any inner adapters
            // (such as sequence adapters or wrapped subadapters) that it needs
            //

            AdapterClass = dataAdapterType.AdapterClass, getAdapterClass = dataAdapterType.getAdapterClass; // @ts-ignore

            _context.t0 = AdapterClass;

            if (_context.t0) {
              _context.next = 16;
              break;
            }

            _context.next = 15;
            return getAdapterClass();

          case 15:
            _context.t0 = _context.sent;

          case 16:
            CLASS = _context.t0;

            if (CLASS) {
              _context.next = 19;
              break;
            }

            throw new Error('Failed to get adapter');

          case 19:
            dataAdapter = new CLASS(adapterConfig, getSubAdapter); // store it in our cache

            adapterCache[cacheKey] = {
              dataAdapter: dataAdapter,
              sessionIds: new Set([sessionId])
            };

          case 21:
            cacheEntry = adapterCache[cacheKey];
            cacheEntry.sessionIds.add(sessionId);
            return _context.abrupt("return", cacheEntry);

          case 24:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _getAdapter.apply(this, arguments);
}

// eslint-disable-next-line @typescript-eslint/no-explicit-any
function freeAdapterResources(specification) {
  var deleteCount = 0;
  var specKeys = Object.keys(specification); // if we don't specify a range, delete any adapters that are
  // only associated with that session

  if (specKeys.length === 1 && specKeys[0] === 'sessionId') {
    var sessionId = specification.sessionId;
    Object.entries(adapterCache).forEach(function (_ref) {
      var _ref2 = (0, _slicedToArray2.default)(_ref, 2),
          cacheKey = _ref2[0],
          cacheEntry = _ref2[1];

      cacheEntry.sessionIds.delete(sessionId);

      if (cacheEntry.sessionIds.size === 0) {
        deleteCount += 1;
        delete adapterCache[cacheKey];
      }
    });
  } else {
    // otherwise call freeResources on all the cached data adapters
    Object.values(adapterCache).forEach(function (cacheEntry) {
      if (!cacheEntry.dataAdapter.freeResources) {
        console.warn(cacheEntry.dataAdapter, 'does not implement freeResources');
      } else {
        var regions = specification.regions || (specification.region ? [specification.region] : []);
        regions.forEach(function (region) {
          if (region.refName !== undefined) {
            cacheEntry.dataAdapter.freeResources(region);
          }
        });
      }
    });
  }

  return deleteCount;
}

function clearAdapterCache() {
  adapterCache = {};
}