"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isSequenceAdapter = isSequenceAdapter;
exports.isRegionsAdapter = isRegionsAdapter;
exports.isFeatureAdapter = isFeatureAdapter;
exports.isRefNameAliasAdapter = isRefNameAliasAdapter;
exports.isTextSearchAdapter = isTextSearchAdapter;
exports.BaseFeatureDataAdapter = exports.BaseAdapter = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _rxjs = require("rxjs");

var _operators = require("rxjs/operators");

var _mobxStateTree = require("mobx-state-tree");

var _rxjs2 = require("../util/rxjs");

var _util = require("../util");

var _configurationSchema = require("../configuration/configurationSchema");

var _stats = require("../util/stats");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

// generates a short "id fingerprint" from the config passed to the base
// feature adapter by recursively enumerating props, but if config is too big
// does not process entire config (FromConfigAdapter for example can be large)
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function idMaker(args) {
  var id = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  var keys = Object.keys(args);

  for (var i = 0; i < keys.length; i++) {
    var _key = keys[i];

    if (id.length > 5000) {
      break;
    }

    if ((0, _typeof2.default)(args[_key]) === 'object' && args[_key]) {
      id += idMaker(args[_key], id);
    } else {
      id += "".concat(_key, "-").concat(args[_key], ";");
    }
  }

  return (0, _util.hashCode)(id);
}

var BaseAdapter = function BaseAdapter() {
  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : (0, _configurationSchema.ConfigurationSchema)('empty', {}).create();
  var getSubAdapter = arguments.length > 1 ? arguments[1] : undefined;
  (0, _classCallCheck2.default)(this, BaseAdapter);
  (0, _defineProperty2.default)(this, "id", void 0);
  (0, _defineProperty2.default)(this, "config", void 0);
  (0, _defineProperty2.default)(this, "getSubAdapter", void 0);
  this.config = config;
  this.getSubAdapter = getSubAdapter; // note: we use switch on jest here for more simple feature IDs
  // in test environment

  if (typeof jest === 'undefined') {
    var data = (0, _mobxStateTree.isStateTreeNode)(config) ? (0, _mobxStateTree.getSnapshot)(config) : config;
    this.id = "".concat(idMaker(data));
  } else {
    this.id = 'test';
  }
}
/**
 * Called to provide a hint that data tied to a certain region will not be
 * needed for the forseeable future and can be purged from caches, etc
 * @param region - Region
 */
;
/**
 * Base class for feature adapters to extend. Defines some methods that
 * subclasses must implement.
 */


exports.BaseAdapter = BaseAdapter;
(0, _defineProperty2.default)(BaseAdapter, "capabilities", []);

var BaseFeatureDataAdapter = /*#__PURE__*/function (_BaseAdapter) {
  (0, _inherits2.default)(BaseFeatureDataAdapter, _BaseAdapter);

  var _super = _createSuper(BaseFeatureDataAdapter);

  function BaseFeatureDataAdapter() {
    (0, _classCallCheck2.default)(this, BaseFeatureDataAdapter);
    return _super.apply(this, arguments);
  }

  (0, _createClass2.default)(BaseFeatureDataAdapter, [{
    key: "getHeader",
    value: // public abstract getFeatures(
    //   region: Region,
    //   opts: BaseOptions,
    // ): Observable<Feature> {
    //   return ObservableCreate(observer => {
    //     const records = getRecords(assembly, refName, start, end)
    //     records.forEach(record => {
    //       observer.next(this.recordToFeature(record))
    //     })
    //     observer.complete()
    //   })
    // }

    /**
     * Return "header info" that is fetched from the data file, or other info
     * that would not simply be in the config of the file. The return value can
     * be `{tag:string, data: any}[]` e.g. list of tags with their values which
     * is how VCF,BAM,CRAM return values for getInfo or it can be a nested JSON
     * object
     */
    function () {
      var _getHeader = (0, _asyncToGenerator2.default)( /*#__PURE__*/regeneratorRuntime.mark(function _callee(_opts) {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                return _context.abrupt("return", null);

              case 1:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      function getHeader(_x) {
        return _getHeader.apply(this, arguments);
      }

      return getHeader;
    }()
    /**
     * Return info that is primarily used for interpreting the data that is there,
     * primarily in reference to being used for augmenting feature details panels
     */

  }, {
    key: "getMetadata",
    value: function () {
      var _getMetadata = (0, _asyncToGenerator2.default)( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(_opts) {
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                return _context2.abrupt("return", null);

              case 1:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }));

      function getMetadata(_x2) {
        return _getMetadata.apply(this, arguments);
      }

      return getMetadata;
    }()
    /**
     * Checks if the store has data for the given assembly and reference
     * sequence, and then gets the features in the region if it does.
     */

  }, {
    key: "getFeaturesInRegion",
    value: function getFeaturesInRegion(region) {
      var _this = this;

      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return (0, _rxjs2.ObservableCreate)( /*#__PURE__*/function () {
        var _ref = (0, _asyncToGenerator2.default)( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(observer) {
          var hasData;
          return regeneratorRuntime.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  _context3.next = 2;
                  return _this.hasDataForRefName(region.refName, opts);

                case 2:
                  hasData = _context3.sent;
                  (0, _util.checkAbortSignal)(opts.signal);

                  if (!hasData) {
                    // console.warn(`no data for ${region.refName}`)
                    observer.complete();
                  } else {
                    _this.getFeatures(region, opts).pipe((0, _operators.takeUntil)((0, _util.observeAbortSignal)(opts.signal))).subscribe(observer);
                  }

                case 5:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3);
        }));

        return function (_x3) {
          return _ref.apply(this, arguments);
        };
      }());
    }
    /**
     * Checks if the store has data for the given assembly and reference
     * sequence, and then gets the features in the region if it does.
     *
     * Currently this just calls getFeatureInRegion for each region. Adapters
     * that are frequently called on multiple regions simultaneously may
     * want to implement a more efficient custom version of this method.
     *
     * Currently this just calls getFeatureInRegion for each region. Adapters that
     * are frequently called on multiple regions simultaneously may want to
     * implement a more efficient custom version of this method.
     * @param regions - Regions
     * @param opts - Feature adapter options
     * @returns Observable of Feature objects in the regions
     */

  }, {
    key: "getFeaturesInMultipleRegions",
    value: function getFeaturesInMultipleRegions(regions) {
      var _this2 = this;

      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var obs = _rxjs.merge.apply(void 0, (0, _toConsumableArray2.default)(regions.map(function (region) {
        return (0, _rxjs2.ObservableCreate)( /*#__PURE__*/function () {
          var _ref2 = (0, _asyncToGenerator2.default)( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(observer) {
            var hasData;
            return regeneratorRuntime.wrap(function _callee4$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    _context4.next = 2;
                    return _this2.hasDataForRefName(region.refName, opts);

                  case 2:
                    hasData = _context4.sent;
                    (0, _util.checkAbortSignal)(opts.signal);

                    if (!hasData) {
                      // console.warn(`no data for ${region.refName}`)
                      observer.complete();
                    } else {
                      _this2.getFeatures(region, opts).subscribe(observer);
                    }

                  case 5:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee4);
          }));

          return function (_x4) {
            return _ref2.apply(this, arguments);
          };
        }());
      })));

      if (opts.signal) {
        return obs.pipe((0, _operators.takeUntil)((0, _util.observeAbortSignal)(opts.signal)));
      }

      return obs;
    }
    /**
     * Check if the store has data for the given reference name.
     * @param refName - Name of the reference sequence
     * @returns Whether data source has data for the given reference name
     */

  }, {
    key: "hasDataForRefName",
    value: function () {
      var _hasDataForRefName = (0, _asyncToGenerator2.default)( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(refName) {
        var opts,
            refNames,
            _args5 = arguments;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                opts = _args5.length > 1 && _args5[1] !== undefined ? _args5[1] : {};
                _context5.next = 3;
                return this.getRefNames(opts);

              case 3:
                refNames = _context5.sent;
                return _context5.abrupt("return", refNames.includes(refName));

              case 5:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function hasDataForRefName(_x5) {
        return _hasDataForRefName.apply(this, arguments);
      }

      return hasDataForRefName;
    }()
  }, {
    key: "getRegionStats",
    value: function () {
      var _getRegionStats = (0, _asyncToGenerator2.default)( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(region, opts) {
        var feats;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                feats = this.getFeatures(region, opts);
                return _context6.abrupt("return", (0, _stats.scoresToStats)(region, feats));

              case 2:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function getRegionStats(_x6, _x7) {
        return _getRegionStats.apply(this, arguments);
      }

      return getRegionStats;
    }()
  }, {
    key: "getMultiRegionStats",
    value: function () {
      var _getMultiRegionStats = (0, _asyncToGenerator2.default)( /*#__PURE__*/regeneratorRuntime.mark(function _callee7() {
        var _this3 = this;

        var regions,
            opts,
            feats,
            scoreMax,
            scoreMin,
            scoreSum,
            scoreSumSquares,
            featureCount,
            basesCovered,
            _args7 = arguments;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                regions = _args7.length > 0 && _args7[0] !== undefined ? _args7[0] : [];
                opts = _args7.length > 1 ? _args7[1] : undefined;

                if (regions.length) {
                  _context7.next = 4;
                  break;
                }

                return _context7.abrupt("return", (0, _stats.blankStats)());

              case 4:
                _context7.next = 6;
                return Promise.all(regions.map(function (region) {
                  return _this3.getRegionStats(region, opts);
                }));

              case 6:
                feats = _context7.sent;
                scoreMax = feats.map(function (s) {
                  return s.scoreMax;
                }).reduce(function (acc, curr) {
                  return Math.max(acc, curr);
                });
                scoreMin = feats.map(function (s) {
                  return s.scoreMin;
                }).reduce(function (acc, curr) {
                  return Math.min(acc, curr);
                });
                scoreSum = feats.map(function (s) {
                  return s.scoreSum;
                }).reduce(function (a, b) {
                  return a + b;
                }, 0);
                scoreSumSquares = feats.map(function (s) {
                  return s.scoreSumSquares;
                }).reduce(function (a, b) {
                  return a + b;
                }, 0);
                featureCount = feats.map(function (s) {
                  return s.featureCount;
                }).reduce(function (a, b) {
                  return a + b;
                }, 0);
                basesCovered = feats.map(function (s) {
                  return s.basesCovered;
                }).reduce(function (a, b) {
                  return a + b;
                }, 0);
                return _context7.abrupt("return", (0, _stats.rectifyStats)({
                  scoreMin: scoreMin,
                  scoreMax: scoreMax,
                  featureCount: featureCount,
                  basesCovered: basesCovered,
                  scoreSumSquares: scoreSumSquares,
                  scoreSum: scoreSum
                }));

              case 14:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7);
      }));

      function getMultiRegionStats() {
        return _getMultiRegionStats.apply(this, arguments);
      }

      return getMultiRegionStats;
    }()
  }]);
  return BaseFeatureDataAdapter;
}(BaseAdapter);

exports.BaseFeatureDataAdapter = BaseFeatureDataAdapter;

function isSequenceAdapter(thing) {
  return 'getRegions' in thing && 'getFeatures' in thing;
}

function isRegionsAdapter(thing) {
  return 'getRegions' in thing;
}

function isFeatureAdapter(thing) {
  return 'getFeatures' in thing;
}

function isRefNameAliasAdapter(thing) {
  return 'getRefNameAliases' in thing;
}

function isTextSearchAdapter(thing) {
  return 'searchIndex' in thing;
}