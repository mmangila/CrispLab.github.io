"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = SequenceFeatureDetails;
exports.SequencePanel = void 0;

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _react = _interopRequireWildcard(require("react"));

var _core = require("@material-ui/core");

var _reactIntersectionObserver = require("react-intersection-observer");

var _copyToClipboard = _interopRequireDefault(require("copy-to-clipboard"));

var _util = require("../util");

var _configuration = require("../configuration");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function stitch(subfeats, sequence) {
  return subfeats.map(function (sub) {
    return sequence.slice(sub.start, sub.end);
  }).join('');
} // filter if they have the same ID


function filterId(feat) {
  return "".concat(feat.start, "-").concat(feat.end);
} // filters if successive elements share same start/end


function dedupe(list) {
  return list.filter(function (item, pos, ary) {
    return !pos || filterId(item) !== filterId(ary[pos - 1]);
  });
}

function revlist(list, seqlen) {
  return list.map(function (sub) {
    return _objectSpread(_objectSpread({}, sub), {}, {
      start: seqlen - sub.end,
      end: seqlen - sub.start
    });
  }).sort(function (a, b) {
    return a.start - b.start;
  });
} // note that these are currently put into the style section instead of being
// defined in classes to aid copy and paste to an external document e.g. word


var proteinColor = 'rgb(220,160,220)';
var intronColor = undefined;
var cdsColor = 'rgb(220,220,180)';
var updownstreamColor = 'rgba(250,200,200)';
var utrColor = 'rgb(200,240,240)';

function GeneCDS(props) {
  var cds = props.cds,
      sequence = props.sequence;
  return /*#__PURE__*/_react.default.createElement("span", {
    style: {
      background: cdsColor
    }
  }, stitch(cds, sequence));
}

function GeneProtein(props) {
  var cds = props.cds,
      sequence = props.sequence,
      codonTable = props.codonTable;
  var str = stitch(cds, sequence);
  var protein = '';

  for (var i = 0; i < str.length; i += 3) {
    // use & symbol for undefined codon, or partial slice
    protein += codonTable[str.slice(i, i + 3)] || '&';
  }

  return /*#__PURE__*/_react.default.createElement("span", {
    style: {
      background: proteinColor
    }
  }, protein);
}

function GenecDNA(props) {
  var utr = props.utr,
      cds = props.cds,
      exons = props.exons,
      sequence = props.sequence,
      upstream = props.upstream,
      downstream = props.downstream,
      includeIntrons = props.includeIntrons,
      collapseIntron = props.collapseIntron;
  var chunks = cds.length ? [].concat((0, _toConsumableArray2.default)(cds), (0, _toConsumableArray2.default)(utr)).sort(function (a, b) {
    return a.start - b.start;
  }) : exons;
  return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, upstream ? /*#__PURE__*/_react.default.createElement("span", {
    style: {
      background: updownstreamColor
    }
  }, upstream) : null, chunks.filter(function (f) {
    return f.start !== f.end;
  }).map(function (chunk, index) {
    var _chunks;

    var intron = sequence.slice(chunk.end, (_chunks = chunks[index + 1]) === null || _chunks === void 0 ? void 0 : _chunks.start);
    return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, {
      key: JSON.stringify(chunk)
    }, /*#__PURE__*/_react.default.createElement("span", {
      style: {
        background: chunk.type === 'CDS' ? cdsColor : utrColor
      }
    }, sequence.slice(chunk.start, chunk.end)), includeIntrons && index < chunks.length - 1 ? /*#__PURE__*/_react.default.createElement("span", {
      style: {
        background: intronColor
      }
    }, collapseIntron && intron.length > 20 ? "".concat(intron.slice(0, 10), "...").concat(intron.slice(-10)) : intron) : null);
  }), downstream ? /*#__PURE__*/_react.default.createElement("span", {
    style: {
      background: updownstreamColor
    }
  }, downstream) : null);
} // calculates UTRs using impliedUTRs logic


function calculateUTRs(cds, exons) {
  var firstCds = cds[0];
  var lastCds = cds[cds.length - 1];
  var firstCdsIdx = exons.findIndex(function (exon) {
    return exon.end >= firstCds.start && exon.start <= firstCds.start;
  });
  var lastCdsIdx = exons.findIndex(function (exon) {
    return exon.end >= lastCds.end && exon.start <= lastCds.end;
  });
  var lastCdsExon = exons[lastCdsIdx];
  var firstCdsExon = exons[firstCdsIdx];
  var fiveUTRs = [].concat((0, _toConsumableArray2.default)(exons.slice(0, firstCdsIdx)), [{
    start: firstCdsExon.start,
    end: firstCds.start
  }]).map(function (elt) {
    return _objectSpread(_objectSpread({}, elt), {}, {
      type: 'five_prime_UTR'
    });
  });
  var threeUTRs = [{
    start: lastCds.end,
    end: lastCdsExon.end
  }].concat((0, _toConsumableArray2.default)(exons.slice(lastCdsIdx + 1))).map(function (elt) {
    return _objectSpread(_objectSpread({}, elt), {}, {
      type: 'three_prime_UTR'
    });
  });
  return [].concat((0, _toConsumableArray2.default)(fiveUTRs), (0, _toConsumableArray2.default)(threeUTRs));
}

var SequencePanel = /*#__PURE__*/_react.default.forwardRef(function (props, ref) {
  var feature = props.feature,
      mode = props.mode;
  var _props$sequence = props.sequence,
      sequence = _props$sequence.seq,
      _props$sequence$upstr = _props$sequence.upstream,
      upstream = _props$sequence$upstr === void 0 ? '' : _props$sequence$upstr,
      _props$sequence$downs = _props$sequence.downstream,
      downstream = _props$sequence$downs === void 0 ? '' : _props$sequence$downs;
  var subfeatures = feature.subfeatures;
  var codonTable = (0, _util.generateCodonTable)(_util.defaultCodonTable);

  if (!subfeatures) {
    return null;
  }

  var children = subfeatures.sort(function (a, b) {
    return a.start - b.start;
  }).map(function (sub) {
    return _objectSpread(_objectSpread({}, sub), {}, {
      start: sub.start - feature.start,
      end: sub.end - feature.start
    });
  }); // we filter duplicate entries in cds and exon lists duplicate entries may be
  // rare but was seen in Gencode v36 track NCList, likely a bug on GFF3 or
  // probably worth ignoring here (produces broken protein translations if
  // included)
  //
  // position 1:224,800,006..225,203,064 gene ENSG00000185842.15 first
  // transcript ENST00000445597.6
  //
  // http://localhost:3000/?config=test_data%2Fconfig.json&session=share-FUl7G1isvF&password=HXh5Y

  var cds = dedupe(children.filter(function (sub) {
    return sub.type === 'CDS';
  }));
  var utr = dedupe(children.filter(function (sub) {
    return sub.type.match(/utr/i);
  }));
  var exons = dedupe(children.filter(function (sub) {
    return sub.type === 'exon';
  }));

  if (!utr.length && cds.length && exons.length) {
    utr = calculateUTRs(cds, exons);
  }

  if (feature.strand === -1) {
    // doing this in a single assignment is needed because downstream and
    // upstream are swapped so this avoids a temp variable
    ;
    var _ref = [(0, _util.revcom)(sequence), (0, _util.revcom)(downstream), (0, _util.revcom)(upstream)];
    sequence = _ref[0];
    upstream = _ref[1];
    downstream = _ref[2];
    cds = revlist(cds, sequence.length);
    exons = revlist(exons, sequence.length);
    utr = revlist(utr, sequence.length);
  }

  return /*#__PURE__*/_react.default.createElement("div", {
    ref: ref,
    "data-testid": "sequence_panel"
  }, mode === 'cds' ? /*#__PURE__*/_react.default.createElement(GeneCDS, {
    cds: cds,
    sequence: sequence
  }) : mode === 'cdna' ? /*#__PURE__*/_react.default.createElement(GenecDNA, {
    exons: exons,
    cds: cds,
    utr: utr,
    sequence: sequence
  }) : mode === 'protein' ? /*#__PURE__*/_react.default.createElement(GeneProtein, {
    cds: cds,
    codonTable: codonTable,
    sequence: sequence
  }) : mode === 'gene' ? /*#__PURE__*/_react.default.createElement(GenecDNA, {
    exons: exons,
    cds: cds,
    utr: utr,
    sequence: sequence,
    includeIntrons: true
  }) : mode === 'gene_collapsed_intron' ? /*#__PURE__*/_react.default.createElement(GenecDNA, {
    exons: exons,
    cds: cds,
    sequence: sequence,
    utr: utr,
    includeIntrons: true,
    collapseIntron: true
  }) : mode === 'gene_updownstream' ? /*#__PURE__*/_react.default.createElement(GenecDNA, {
    exons: exons,
    cds: cds,
    sequence: sequence,
    utr: utr,
    upstream: upstream,
    downstream: downstream,
    includeIntrons: true
  }) : mode === 'gene_updownstream_collapsed_intron' ? /*#__PURE__*/_react.default.createElement(GenecDNA, {
    exons: exons,
    cds: cds,
    sequence: sequence,
    utr: utr,
    upstream: upstream,
    downstream: downstream,
    includeIntrons: true,
    collapseIntron: true
  }) : /*#__PURE__*/_react.default.createElement("div", null, "Unknown type"));
}); // display the stitched-together sequence of a gene's CDS, cDNA, or protein
// sequence. this is a best effort and weird genomic phenomena could lead these
// to not be 100% accurate


exports.SequencePanel = SequencePanel;

function SequenceFeatureDetails(props) {
  var _parentFeature$subfea;

  var model = props.model,
      feature = props.feature;
  var parentFeature = feature;
  var hasCDS = (_parentFeature$subfea = parentFeature.subfeatures) === null || _parentFeature$subfea === void 0 ? void 0 : _parentFeature$subfea.find(function (sub) {
    return sub.type === 'CDS';
  });
  var seqPanelRef = (0, _react.useRef)(null);

  var _useInView = (0, _reactIntersectionObserver.useInView)(),
      ref = _useInView.ref,
      inView = _useInView.inView;

  var _useState = (0, _react.useState)(),
      _useState2 = (0, _slicedToArray2.default)(_useState, 2),
      sequence = _useState2[0],
      setSequence = _useState2[1];

  var _useState3 = (0, _react.useState)(),
      _useState4 = (0, _slicedToArray2.default)(_useState3, 2),
      error = _useState4[0],
      setError = _useState4[1];

  var _useState5 = (0, _react.useState)(hasCDS ? 'cds' : 'cdna'),
      _useState6 = (0, _slicedToArray2.default)(_useState5, 2),
      mode = _useState6[0],
      setMode = _useState6[1];

  var _useState7 = (0, _react.useState)(false),
      _useState8 = (0, _slicedToArray2.default)(_useState7, 2),
      copied = _useState8[0],
      setCopied = _useState8[1];

  (0, _react.useEffect)(function () {
    var _model$view;

    var finished = false;

    if (!model || !inView) {
      return function () {};
    }

    var _getSession = (0, _util.getSession)(model),
        assemblyManager = _getSession.assemblyManager,
        rpcManager = _getSession.rpcManager;

    var _ref2 = ((_model$view = model.view) === null || _model$view === void 0 ? void 0 : _model$view.assemblyNames) || [],
        _ref3 = (0, _slicedToArray2.default)(_ref2, 1),
        assemblyName = _ref3[0];

    function fetchSeq(_x, _x2, _x3) {
      return _fetchSeq.apply(this, arguments);
    }

    function _fetchSeq() {
      _fetchSeq = (0, _asyncToGenerator2.default)( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(start, end, refName) {
        var assembly, sessionId, feats, _ref6, _ref7, feat;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return assemblyManager.waitForAssembly(assemblyName);

              case 2:
                assembly = _context2.sent;

                if (assembly) {
                  _context2.next = 5;
                  break;
                }

                throw new Error('assembly not found');

              case 5:
                sessionId = 'getSequence';
                _context2.next = 8;
                return rpcManager.call(sessionId, 'CoreGetFeatures', {
                  adapterConfig: (0, _configuration.getConf)(assembly, ['sequence', 'adapter']),
                  sessionId: sessionId,
                  region: {
                    start: start,
                    end: end,
                    refName: assembly.getCanonicalRefName(refName)
                  }
                });

              case 8:
                feats = _context2.sent;
                _ref6 = feats, _ref7 = (0, _slicedToArray2.default)(_ref6, 1), feat = _ref7[0];

                if (feat) {
                  _context2.next = 12;
                  break;
                }

                throw new Error("sequence not found for feature with refName:".concat(refName));

              case 12:
                return _context2.abrupt("return", feat.get('seq'));

              case 13:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }));
      return _fetchSeq.apply(this, arguments);
    }

    ;
    (0, _asyncToGenerator2.default)( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
      var _ref5, s, e, refName, seq, upstream, downstream;

      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.prev = 0;
              _ref5 = feature, s = _ref5.start, e = _ref5.end, refName = _ref5.refName;
              _context.next = 4;
              return fetchSeq(s, e, refName);

            case 4:
              seq = _context.sent;
              _context.next = 7;
              return fetchSeq(Math.max(0, s - 500), s, refName);

            case 7:
              upstream = _context.sent;
              _context.next = 10;
              return fetchSeq(e, e + 500, refName);

            case 10:
              downstream = _context.sent;

              if (!finished) {
                setSequence({
                  seq: seq,
                  upstream: upstream,
                  downstream: downstream
                });
              }

              _context.next = 17;
              break;

            case 14:
              _context.prev = 14;
              _context.t0 = _context["catch"](0);
              setError(_context.t0);

            case 17:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, null, [[0, 14]]);
    }))();
    return function () {
      finished = true;
    };
  }, [feature, inView, model]);
  var loading = !sequence;
  return /*#__PURE__*/_react.default.createElement("div", {
    ref: ref
  }, /*#__PURE__*/_react.default.createElement(_core.Select, {
    value: mode,
    onChange: function onChange(event) {
      return setMode(event.target.value);
    }
  }, hasCDS ? /*#__PURE__*/_react.default.createElement(_core.MenuItem, {
    value: "cds"
  }, "CDS") : null, hasCDS ? /*#__PURE__*/_react.default.createElement(_core.MenuItem, {
    value: "protein"
  }, "Protein") : null, /*#__PURE__*/_react.default.createElement(_core.MenuItem, {
    value: "gene"
  }, "Gene w/ introns"), /*#__PURE__*/_react.default.createElement(_core.MenuItem, {
    value: "gene_collapsed_intron"
  }, "Gene w/ 10bp of intron"), /*#__PURE__*/_react.default.createElement(_core.MenuItem, {
    value: "gene_updownstream"
  }, "Gene w/ 500bp up+down stream"), /*#__PURE__*/_react.default.createElement(_core.MenuItem, {
    value: "gene_updownstream_collapsed_intron"
  }, "Gene w/ 500bp up+down stream w/ 10bp intron"), /*#__PURE__*/_react.default.createElement(_core.MenuItem, {
    value: "cdna"
  }, "cDNA")), /*#__PURE__*/_react.default.createElement(_core.Button, {
    type: "button",
    variant: "contained",
    onClick: function onClick() {
      if (seqPanelRef.current) {
        (0, _copyToClipboard.default)(seqPanelRef.current.innerHTML, {
          format: 'text/html'
        });
        setCopied(true);
        setTimeout(function () {
          setCopied(false);
        }, 1000);
      }
    }
  }, copied ? 'Copied to clipboard!' : 'Copy'), /*#__PURE__*/_react.default.createElement("div", {
    "data-testid": "feature_sequence"
  }, error ? /*#__PURE__*/_react.default.createElement(_core.Typography, {
    color: "error"
  }, "".concat(error)) : loading ? /*#__PURE__*/_react.default.createElement("div", null, "Loading gene sequence...") : sequence ? /*#__PURE__*/_react.default.createElement("div", {
    style: {
      fontFamily: 'monospace',
      wordWrap: 'break-word'
    }
  }, /*#__PURE__*/_react.default.createElement(SequencePanel, {
    ref: seqPanelRef,
    feature: parentFeature,
    mode: mode,
    sequence: sequence
  })) : /*#__PURE__*/_react.default.createElement("div", null, "No sequence found")));
}