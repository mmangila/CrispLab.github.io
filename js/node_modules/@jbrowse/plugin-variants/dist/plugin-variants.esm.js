import React, { lazy, useState } from 'react';
import { ConfigurationSchema, ConfigurationReference, getConf, readConfObject } from '@jbrowse/core/configuration';
import AdapterType from '@jbrowse/core/pluggableElementTypes/AdapterType';
import DisplayType from '@jbrowse/core/pluggableElementTypes/DisplayType';
import { createBaseTrackConfig, createBaseTrackModel } from '@jbrowse/core/pluggableElementTypes/models';
import TrackType from '@jbrowse/core/pluggableElementTypes/TrackType';
import WidgetType from '@jbrowse/core/pluggableElementTypes/WidgetType';
import Plugin from '@jbrowse/core/Plugin';
import { linearBasicDisplayConfigSchemaFactory, linearBasicDisplayModelFactory, BaseLinearDisplayComponent } from '@jbrowse/plugin-linear-genome-view';
import { baseChordDisplayConfig, BaseChordDisplayModel, BaseChordDisplayComponentFactory } from '@jbrowse/plugin-circular-view';
import { getRpcSessionId } from '@jbrowse/core/util/tracks';
import { getContainingView, getSession, isSessionModelWithWidgets, getContainingTrack } from '@jbrowse/core/util';
import { types, getSnapshot, getEnv } from 'mobx-state-tree';
import { ElementId } from '@jbrowse/core/util/types/mst';
import { BaseFeatureDataAdapter } from '@jbrowse/core/data_adapters/BaseAdapter';
import { openLocation } from '@jbrowse/core/util/io';
import { ObservableCreate } from '@jbrowse/core/util/rxjs';
import { TabixIndexedFile } from '@gmod/tabix';
import VcfParser from '@gmod/vcf';
import { unzip } from '@gmod/bgzf-filehandle';
import { Dialog, DialogTitle, IconButton, Divider, DialogContent, FormControlLabel, Checkbox, DialogActions, Button, Paper, Typography, TextField, Link } from '@material-ui/core';
import SimpleFeature from '@jbrowse/core/util/simpleFeature';
import { DataGrid } from '@material-ui/data-grid';
import { observer } from 'mobx-react';
import { FeatureDetails, BaseCard } from '@jbrowse/core/BaseFeatureWidget/BaseFeatureDetail';
import { makeStyles } from '@material-ui/core/styles';
import CloseIcon from '@material-ui/icons/Close';

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}

function _get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get;
  } else {
    _get = function _get(target, property, receiver) {
      var base = _superPropBase(target, property);

      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(receiver);
      }

      return desc.value;
    };
  }

  return _get(target, property, receiver || target);
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

function _iterableToArrayLimit(arr, i) {
  var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;

      var F = function () {};

      return {
        s: F,
        n: function () {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function (e) {
          throw e;
        },
        f: F
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var normalCompletion = true,
      didErr = false,
      err;
  return {
    s: function () {
      it = it.call(o);
    },
    n: function () {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function (e) {
      didErr = true;
      err = e;
    },
    f: function () {
      try {
        if (!normalCompletion && it.return != null) it.return();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}

var ChordVariantDisplayF = function ChordVariantDisplayF(pluginManager) {
  var jbrequire = pluginManager.jbrequire;

  var _jbrequire = jbrequire('mobx-state-tree'),
      types = _jbrequire.types;

  var _jbrequire2 = jbrequire('@jbrowse/core/configuration'),
      ConfigurationSchema = _jbrequire2.ConfigurationSchema,
      ConfigurationReference = _jbrequire2.ConfigurationReference;

  var _jbrequire3 = jbrequire('@jbrowse/core/util'),
      getContainingView = _jbrequire3.getContainingView;

  var _jbrequire4 = jbrequire('@jbrowse/core/util/tracks'),
      getParentRenderProps = _jbrequire4.getParentRenderProps;

  var configSchema = ConfigurationSchema('ChordVariantDisplay', {
    renderer: types.optional(pluginManager.pluggableConfigSchemaType('renderer'), {
      type: 'StructuralVariantChordRenderer'
    })
  }, {
    baseConfiguration: baseChordDisplayConfig,
    explicitlyTyped: true
  });
  var stateModel = types.compose('ChordVariantDisplay', BaseChordDisplayModel, types.model({
    type: types.literal('ChordVariantDisplay'),
    configuration: ConfigurationReference(configSchema)
  })).views(function (self) {
    return {
      get rendererTypeName() {
        return self.configuration.renderer.type;
      },

      get renderProps() {
        var view = getContainingView(self);
        return _objectSpread2(_objectSpread2({}, getParentRenderProps(self)), {}, {
          rpcDriverName: self.rpcDriverName,
          displayModel: self,
          bezierRadius: view.radiusPx * self.bezierRadiusRatio,
          radius: view.radiusPx,
          blockDefinitions: this.blockDefinitions,
          config: self.configuration.renderer,
          onChordClick: self.onChordClick
        });
      }

    };
  });
  return {
    stateModel: stateModel,
    configSchema: configSchema
  };
}; // http://localhost:3000/test_data/hs37d5.HG002-SequelII-CCS.sv.vcf.gz.tbi

var ChordVariantDisplay = (function (pluginManager) {
  var lib = pluginManager.lib,
      load = pluginManager.load;
  var DisplayType = lib['@jbrowse/core/pluggableElementTypes/DisplayType'];

  var _load = load(ChordVariantDisplayF),
      stateModel = _load.stateModel,
      configSchema = _load.configSchema;

  return new DisplayType({
    name: 'ChordVariantDisplay',
    configSchema: configSchema,
    stateModel: stateModel,
    trackType: 'VariantTrack',
    viewType: 'CircularView',
    ReactComponent: BaseChordDisplayComponentFactory(pluginManager)
  });
});

function LinearVariantDisplayConfigFactory(pluginManager) {
  var configSchema = linearBasicDisplayConfigSchemaFactory(pluginManager);
  return ConfigurationSchema('LinearVariantDisplay', {}, {
    baseConfiguration: configSchema,
    explicitlyTyped: true
  });
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var runtime_1 = /*#__PURE__*/createCommonjsModule(function (module) {
  /**
   * Copyright (c) 2014-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var runtime = function (exports) {

    var Op = Object.prototype;
    var hasOwn = Op.hasOwnProperty;
    var undefined$1; // More compressible than void 0.

    var $Symbol = typeof Symbol === "function" ? Symbol : {};
    var iteratorSymbol = $Symbol.iterator || "@@iterator";
    var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
    var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

    function define(obj, key, value) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
      return obj[key];
    }

    try {
      // IE 8 has a broken Object.defineProperty that only works on DOM objects.
      define({}, "");
    } catch (err) {
      define = function define(obj, key, value) {
        return obj[key] = value;
      };
    }

    function wrap(innerFn, outerFn, self, tryLocsList) {
      // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
      var generator = Object.create(protoGenerator.prototype);
      var context = new Context(tryLocsList || []); // The ._invoke method unifies the implementations of the .next,
      // .throw, and .return methods.

      generator._invoke = makeInvokeMethod(innerFn, self, context);
      return generator;
    }

    exports.wrap = wrap; // Try/catch helper to minimize deoptimizations. Returns a completion
    // record like context.tryEntries[i].completion. This interface could
    // have been (and was previously) designed to take a closure to be
    // invoked without arguments, but in all the cases we care about we
    // already have an existing method we want to call, so there's no need
    // to create a new function object. We can even get away with assuming
    // the method takes exactly one argument, since that happens to be true
    // in every case, so we don't have to touch the arguments object. The
    // only additional allocation required is the completion record, which
    // has a stable shape and so hopefully should be cheap to allocate.

    function tryCatch(fn, obj, arg) {
      try {
        return {
          type: "normal",
          arg: fn.call(obj, arg)
        };
      } catch (err) {
        return {
          type: "throw",
          arg: err
        };
      }
    }

    var GenStateSuspendedStart = "suspendedStart";
    var GenStateSuspendedYield = "suspendedYield";
    var GenStateExecuting = "executing";
    var GenStateCompleted = "completed"; // Returning this object from the innerFn has the same effect as
    // breaking out of the dispatch switch statement.

    var ContinueSentinel = {}; // Dummy constructor functions that we use as the .constructor and
    // .constructor.prototype properties for functions that return Generator
    // objects. For full spec compliance, you may wish to configure your
    // minifier not to mangle the names of these two functions.

    function Generator() {}

    function GeneratorFunction() {}

    function GeneratorFunctionPrototype() {} // This is a polyfill for %IteratorPrototype% for environments that
    // don't natively support it.


    var IteratorPrototype = {};

    IteratorPrototype[iteratorSymbol] = function () {
      return this;
    };

    var getProto = Object.getPrototypeOf;
    var NativeIteratorPrototype = getProto && getProto(getProto(values([])));

    if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
      // This environment has a native %IteratorPrototype%; use it instead
      // of the polyfill.
      IteratorPrototype = NativeIteratorPrototype;
    }

    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
    GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
    GeneratorFunctionPrototype.constructor = GeneratorFunction;
    GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"); // Helper for defining the .next, .throw, and .return methods of the
    // Iterator interface in terms of a single ._invoke method.

    function defineIteratorMethods(prototype) {
      ["next", "throw", "return"].forEach(function (method) {
        define(prototype, method, function (arg) {
          return this._invoke(method, arg);
        });
      });
    }

    exports.isGeneratorFunction = function (genFun) {
      var ctor = typeof genFun === "function" && genFun.constructor;
      return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can
      // do is to check its .name property.
      (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
    };

    exports.mark = function (genFun) {
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
      } else {
        genFun.__proto__ = GeneratorFunctionPrototype;
        define(genFun, toStringTagSymbol, "GeneratorFunction");
      }

      genFun.prototype = Object.create(Gp);
      return genFun;
    }; // Within the body of any async function, `await x` is transformed to
    // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
    // `hasOwn.call(value, "__await")` to determine if the yielded value is
    // meant to be awaited.


    exports.awrap = function (arg) {
      return {
        __await: arg
      };
    };

    function AsyncIterator(generator, PromiseImpl) {
      function invoke(method, arg, resolve, reject) {
        var record = tryCatch(generator[method], generator, arg);

        if (record.type === "throw") {
          reject(record.arg);
        } else {
          var result = record.arg;
          var value = result.value;

          if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
            return PromiseImpl.resolve(value.__await).then(function (value) {
              invoke("next", value, resolve, reject);
            }, function (err) {
              invoke("throw", err, resolve, reject);
            });
          }

          return PromiseImpl.resolve(value).then(function (unwrapped) {
            // When a yielded Promise is resolved, its final value becomes
            // the .value of the Promise<{value,done}> result for the
            // current iteration.
            result.value = unwrapped;
            resolve(result);
          }, function (error) {
            // If a rejected Promise was yielded, throw the rejection back
            // into the async generator function so it can be handled there.
            return invoke("throw", error, resolve, reject);
          });
        }
      }

      var previousPromise;

      function enqueue(method, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function (resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }

        return previousPromise = // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later
        // invocations of the iterator.
        callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      } // Define the unified helper method that is used to implement .next,
      // .throw, and .return (see defineIteratorMethods).


      this._invoke = enqueue;
    }

    defineIteratorMethods(AsyncIterator.prototype);

    AsyncIterator.prototype[asyncIteratorSymbol] = function () {
      return this;
    };

    exports.AsyncIterator = AsyncIterator; // Note that simple async functions are implemented on top of
    // AsyncIterator objects; they just return a Promise for the value of
    // the final result produced by the iterator.

    exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
      if (PromiseImpl === void 0) PromiseImpl = Promise;
      var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
      return exports.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function (result) {
        return result.done ? result.value : iter.next();
      });
    };

    function makeInvokeMethod(innerFn, self, context) {
      var state = GenStateSuspendedStart;
      return function invoke(method, arg) {
        if (state === GenStateExecuting) {
          throw new Error("Generator is already running");
        }

        if (state === GenStateCompleted) {
          if (method === "throw") {
            throw arg;
          } // Be forgiving, per 25.3.3.3.3 of the spec:
          // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume


          return doneResult();
        }

        context.method = method;
        context.arg = arg;

        while (true) {
          var delegate = context.delegate;

          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context);

            if (delegateResult) {
              if (delegateResult === ContinueSentinel) continue;
              return delegateResult;
            }
          }

          if (context.method === "next") {
            // Setting context._sent for legacy support of Babel's
            // function.sent implementation.
            context.sent = context._sent = context.arg;
          } else if (context.method === "throw") {
            if (state === GenStateSuspendedStart) {
              state = GenStateCompleted;
              throw context.arg;
            }

            context.dispatchException(context.arg);
          } else if (context.method === "return") {
            context.abrupt("return", context.arg);
          }

          state = GenStateExecuting;
          var record = tryCatch(innerFn, self, context);

          if (record.type === "normal") {
            // If an exception is thrown from innerFn, we leave state ===
            // GenStateExecuting and loop back for another invocation.
            state = context.done ? GenStateCompleted : GenStateSuspendedYield;

            if (record.arg === ContinueSentinel) {
              continue;
            }

            return {
              value: record.arg,
              done: context.done
            };
          } else if (record.type === "throw") {
            state = GenStateCompleted; // Dispatch the exception by looping back around to the
            // context.dispatchException(context.arg) call above.

            context.method = "throw";
            context.arg = record.arg;
          }
        }
      };
    } // Call delegate.iterator[context.method](context.arg) and handle the
    // result, either by returning a { value, done } result from the
    // delegate iterator, or by modifying context.method and context.arg,
    // setting context.delegate to null, and returning the ContinueSentinel.


    function maybeInvokeDelegate(delegate, context) {
      var method = delegate.iterator[context.method];

      if (method === undefined$1) {
        // A .throw or .return when the delegate iterator has no .throw
        // method always terminates the yield* loop.
        context.delegate = null;

        if (context.method === "throw") {
          // Note: ["return"] must be used for ES3 parsing compatibility.
          if (delegate.iterator["return"]) {
            // If the delegate iterator has a return method, give it a
            // chance to clean up.
            context.method = "return";
            context.arg = undefined$1;
            maybeInvokeDelegate(delegate, context);

            if (context.method === "throw") {
              // If maybeInvokeDelegate(context) changed context.method from
              // "return" to "throw", let that override the TypeError below.
              return ContinueSentinel;
            }
          }

          context.method = "throw";
          context.arg = new TypeError("The iterator does not provide a 'throw' method");
        }

        return ContinueSentinel;
      }

      var record = tryCatch(method, delegate.iterator, context.arg);

      if (record.type === "throw") {
        context.method = "throw";
        context.arg = record.arg;
        context.delegate = null;
        return ContinueSentinel;
      }

      var info = record.arg;

      if (!info) {
        context.method = "throw";
        context.arg = new TypeError("iterator result is not an object");
        context.delegate = null;
        return ContinueSentinel;
      }

      if (info.done) {
        // Assign the result of the finished delegate to the temporary
        // variable specified by delegate.resultName (see delegateYield).
        context[delegate.resultName] = info.value; // Resume execution at the desired location (see delegateYield).

        context.next = delegate.nextLoc; // If context.method was "throw" but the delegate handled the
        // exception, let the outer generator proceed normally. If
        // context.method was "next", forget context.arg since it has been
        // "consumed" by the delegate iterator. If context.method was
        // "return", allow the original .return call to continue in the
        // outer generator.

        if (context.method !== "return") {
          context.method = "next";
          context.arg = undefined$1;
        }
      } else {
        // Re-yield the result returned by the delegate method.
        return info;
      } // The delegate iterator is finished, so forget it and continue with
      // the outer generator.


      context.delegate = null;
      return ContinueSentinel;
    } // Define Generator.prototype.{next,throw,return} in terms of the
    // unified ._invoke helper method.


    defineIteratorMethods(Gp);
    define(Gp, toStringTagSymbol, "Generator"); // A Generator should always return itself as the iterator object when the
    // @@iterator function is called on it. Some browsers' implementations of the
    // iterator prototype chain incorrectly implement this, causing the Generator
    // object to not be returned from this call. This ensures that doesn't happen.
    // See https://github.com/facebook/regenerator/issues/274 for more details.

    Gp[iteratorSymbol] = function () {
      return this;
    };

    Gp.toString = function () {
      return "[object Generator]";
    };

    function pushTryEntry(locs) {
      var entry = {
        tryLoc: locs[0]
      };

      if (1 in locs) {
        entry.catchLoc = locs[1];
      }

      if (2 in locs) {
        entry.finallyLoc = locs[2];
        entry.afterLoc = locs[3];
      }

      this.tryEntries.push(entry);
    }

    function resetTryEntry(entry) {
      var record = entry.completion || {};
      record.type = "normal";
      delete record.arg;
      entry.completion = record;
    }

    function Context(tryLocsList) {
      // The root entry object (effectively a try statement without a catch
      // or a finally block) gives us a place to store values thrown from
      // locations where there is no enclosing try statement.
      this.tryEntries = [{
        tryLoc: "root"
      }];
      tryLocsList.forEach(pushTryEntry, this);
      this.reset(true);
    }

    exports.keys = function (object) {
      var keys = [];

      for (var key in object) {
        keys.push(key);
      }

      keys.reverse(); // Rather than returning an object with a next method, we keep
      // things simple and return the next function itself.

      return function next() {
        while (keys.length) {
          var key = keys.pop();

          if (key in object) {
            next.value = key;
            next.done = false;
            return next;
          }
        } // To avoid creating an additional object, we just hang the .value
        // and .done properties off the next function object itself. This
        // also ensures that the minifier will not anonymize the function.


        next.done = true;
        return next;
      };
    };

    function values(iterable) {
      if (iterable) {
        var iteratorMethod = iterable[iteratorSymbol];

        if (iteratorMethod) {
          return iteratorMethod.call(iterable);
        }

        if (typeof iterable.next === "function") {
          return iterable;
        }

        if (!isNaN(iterable.length)) {
          var i = -1,
              next = function next() {
            while (++i < iterable.length) {
              if (hasOwn.call(iterable, i)) {
                next.value = iterable[i];
                next.done = false;
                return next;
              }
            }

            next.value = undefined$1;
            next.done = true;
            return next;
          };

          return next.next = next;
        }
      } // Return an iterator with no values.


      return {
        next: doneResult
      };
    }

    exports.values = values;

    function doneResult() {
      return {
        value: undefined$1,
        done: true
      };
    }

    Context.prototype = {
      constructor: Context,
      reset: function reset(skipTempReset) {
        this.prev = 0;
        this.next = 0; // Resetting context._sent for legacy support of Babel's
        // function.sent implementation.

        this.sent = this._sent = undefined$1;
        this.done = false;
        this.delegate = null;
        this.method = "next";
        this.arg = undefined$1;
        this.tryEntries.forEach(resetTryEntry);

        if (!skipTempReset) {
          for (var name in this) {
            // Not sure about the optimal order of these conditions:
            if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
              this[name] = undefined$1;
            }
          }
        }
      },
      stop: function stop() {
        this.done = true;
        var rootEntry = this.tryEntries[0];
        var rootRecord = rootEntry.completion;

        if (rootRecord.type === "throw") {
          throw rootRecord.arg;
        }

        return this.rval;
      },
      dispatchException: function dispatchException(exception) {
        if (this.done) {
          throw exception;
        }

        var context = this;

        function handle(loc, caught) {
          record.type = "throw";
          record.arg = exception;
          context.next = loc;

          if (caught) {
            // If the dispatched exception was caught by a catch block,
            // then let that catch block handle the exception normally.
            context.method = "next";
            context.arg = undefined$1;
          }

          return !!caught;
        }

        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          var record = entry.completion;

          if (entry.tryLoc === "root") {
            // Exception thrown outside of any try block that could handle
            // it, so set the completion value of the entire function to
            // throw the exception.
            return handle("end");
          }

          if (entry.tryLoc <= this.prev) {
            var hasCatch = hasOwn.call(entry, "catchLoc");
            var hasFinally = hasOwn.call(entry, "finallyLoc");

            if (hasCatch && hasFinally) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              } else if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }
            } else if (hasCatch) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              }
            } else if (hasFinally) {
              if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }
            } else {
              throw new Error("try statement without catch or finally");
            }
          }
        }
      },
      abrupt: function abrupt(type, arg) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];

          if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
            var finallyEntry = entry;
            break;
          }
        }

        if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
          // Ignore the finally entry if control is not jumping to a
          // location outside the try/catch block.
          finallyEntry = null;
        }

        var record = finallyEntry ? finallyEntry.completion : {};
        record.type = type;
        record.arg = arg;

        if (finallyEntry) {
          this.method = "next";
          this.next = finallyEntry.finallyLoc;
          return ContinueSentinel;
        }

        return this.complete(record);
      },
      complete: function complete(record, afterLoc) {
        if (record.type === "throw") {
          throw record.arg;
        }

        if (record.type === "break" || record.type === "continue") {
          this.next = record.arg;
        } else if (record.type === "return") {
          this.rval = this.arg = record.arg;
          this.method = "return";
          this.next = "end";
        } else if (record.type === "normal" && afterLoc) {
          this.next = afterLoc;
        }

        return ContinueSentinel;
      },
      finish: function finish(finallyLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];

          if (entry.finallyLoc === finallyLoc) {
            this.complete(entry.completion, entry.afterLoc);
            resetTryEntry(entry);
            return ContinueSentinel;
          }
        }
      },
      "catch": function _catch(tryLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];

          if (entry.tryLoc === tryLoc) {
            var record = entry.completion;

            if (record.type === "throw") {
              var thrown = record.arg;
              resetTryEntry(entry);
            }

            return thrown;
          }
        } // The context.catch method must only be called with a location
        // argument that corresponds to a known catch block.


        throw new Error("illegal catch attempt");
      },
      delegateYield: function delegateYield(iterable, resultName, nextLoc) {
        this.delegate = {
          iterator: values(iterable),
          resultName: resultName,
          nextLoc: nextLoc
        };

        if (this.method === "next") {
          // Deliberately forget the last sent value so that we don't
          // accidentally pass it on to the delegate.
          this.arg = undefined$1;
        }

        return ContinueSentinel;
      }
    }; // Regardless of whether this script is executing as a CommonJS module
    // or not, return the runtime object so that we can declare the variable
    // regeneratorRuntime in the outer scope, which allows this module to be
    // injected easily by `bin/regenerator --include-runtime script.js`.

    return exports;
  }( // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
   module.exports );

  try {
    regeneratorRuntime = runtime;
  } catch (accidentalStrictMode) {
    // This module should not be running in strict mode, so the above
    // assignment should always work unless something is misconfigured. Just
    // in case runtime.js accidentally runs in strict mode, we can escape
    // strict mode using a global Function call. This could conceivably fail
    // if a Content Security Policy forbids using Function, but in that case
    // the proper solution is to fix the accidental strict mode problem. If
    // you've misconfigured your bundler to force strict mode and applied a
    // CSP to forbid Function, and you're not willing to fix either of those
    // problems, please detail your unique predicament in a GitHub issue.
    Function("r", "regeneratorRuntime = r")(runtime);
  }
});

function linearVariantDisplayModelFactory (configSchema) {
  return types.compose('LinearVariantDisplay', linearBasicDisplayModelFactory(configSchema), types.model({
    type: types.literal('LinearVariantDisplay'),
    configuration: ConfigurationReference(configSchema)
  })).actions(function (self) {
    return {
      selectFeature: function selectFeature(feature) {
        return _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee() {
          var session, rpcManager, sessionId, track, adapterConfig, header, featureWidget;
          return runtime_1.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  session = getSession(self);

                  if (!isSessionModelWithWidgets(session)) {
                    _context.next = 11;
                    break;
                  }

                  rpcManager = session.rpcManager;
                  sessionId = getRpcSessionId(self);
                  track = getContainingTrack(self);
                  adapterConfig = getConf(track, 'adapter');
                  _context.next = 8;
                  return rpcManager.call(sessionId, 'CoreGetMetadata', {
                    adapterConfig: adapterConfig
                  });

                case 8:
                  header = _context.sent;
                  featureWidget = session.addWidget('VariantFeatureWidget', 'variantFeature', {
                    featureData: feature.toJSON(),
                    view: getContainingView(self),
                    descriptions: header
                  });
                  session.showWidget(featureWidget);

                case 11:
                  session.setSelection(feature);

                case 12:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }))();
      }
    };
  });
}

var ChordRendererF = function ChordRendererF(_ref) {
  var jbrequire = _ref.jbrequire;
  var React = jbrequire('react');

  var _jbrequire = jbrequire('react'),
      useMemo = _jbrequire.useMemo;

  var _jbrequire2 = jbrequire('mobx-react'),
      observer = _jbrequire2.observer,
      MobxPropTypes = _jbrequire2.PropTypes;

  var _jbrequire3 = jbrequire('@jbrowse/core/util'),
      polarToCartesian = _jbrequire3.polarToCartesian;

  var _jbrequire4 = jbrequire('@jbrowse/core/configuration'),
      readConfObject = _jbrequire4.readConfObject;

  var _jbrequire5 = jbrequire('@jbrowse/core/util/types/mst'),
      CommonPropTypes = _jbrequire5.PropTypes;

  var PropTypes = jbrequire('prop-types');

  function bpToRadians(block, pos) {
    var blockStart = block.region.elided ? 0 : block.region.start;
    var blockEnd = block.region.elided ? 0 : block.region.end;
    var bpOffset = block.flipped ? blockEnd - pos : pos - blockStart;
    var radians = bpOffset / block.bpPerRadian + block.startRadians;
    return radians;
  }

  var Chord = observer(function Chord(_ref2) {
    var feature = _ref2.feature,
        blocksForRefs = _ref2.blocksForRefs,
        radius = _ref2.radius,
        config = _ref2.config,
        bezierRadius = _ref2.bezierRadius,
        selected = _ref2.selected,
        _onClick = _ref2.onClick;
    // find the blocks that our start and end points belong to
    var startBlock = blocksForRefs[feature.get('refName')];

    if (!startBlock) {
      return null;
    }

    var svType;

    if (feature.get('INFO')) {

      var _ref3 = feature.get('INFO').SVTYPE || [];

      var _ref4 = _slicedToArray(_ref3, 1);

      svType = _ref4[0];
    } else if (feature.get('mate')) {
      svType = 'mate';
    }

    var endPosition;
    var endBlock;

    if (svType === 'BND') {
      // VCF BND
      var breakendSpecification = (feature.get('ALT') || [])[0];
      var matePosition = breakendSpecification.MatePosition.split(':');
      endPosition = parseInt(matePosition[1], 10);
      endBlock = blocksForRefs[matePosition[0]];
    } else if (svType === 'TRA') {
      // VCF TRA
      var chr2 = ((feature.get('INFO') || {}).CHR2 || [])[0];
      var end = ((feature.get('INFO') || {}).END || [])[0];
      endPosition = parseInt(end, 10);
      endBlock = blocksForRefs[chr2];
    } else if (svType === 'mate') {
      // generic simplefeatures arcs
      var mate = feature.get('mate');
      var _chr = mate.refName;
      endPosition = mate.start;
      endBlock = blocksForRefs[_chr];
    }

    if (endBlock) {
      var startPos = feature.get('start');
      var startRadians = bpToRadians(startBlock, startPos);
      var endRadians = bpToRadians(endBlock, endPosition);
      var startXY = polarToCartesian(radius, startRadians);
      var endXY = polarToCartesian(radius, endRadians);
      var controlXY = polarToCartesian(bezierRadius, (endRadians + startRadians) / 2);
      var strokeColor;

      if (selected) {
        strokeColor = readConfObject(config, 'strokeColorSelected', {
          feature: feature
        });
      } else {
        strokeColor = readConfObject(config, 'strokeColor', {
          feature: feature
        });
      }

      var hoverStrokeColor = readConfObject(config, 'strokeColorHover', {
        feature: feature
      });
      return /*#__PURE__*/React.createElement("path", {
        "data-testid": "chord-".concat(feature.id()),
        d: ['M'].concat(_toConsumableArray(startXY), ['Q'], _toConsumableArray(controlXY), _toConsumableArray(endXY)).join(' '),
        style: {
          stroke: strokeColor
        },
        onClick: function onClick(evt) {
          return _onClick(feature, startBlock.region, endBlock.region, evt);
        },
        onMouseOver: function onMouseOver(evt) {
          if (!selected) {
            evt.target.style.stroke = hoverStrokeColor;
          }
        },
        onMouseOut: function onMouseOut(evt) {
          if (!selected) {
            evt.target.style.stroke = strokeColor;
          }
        }
      });
    }

    return null;
  });

  function StructuralVariantChords(props) {
    var features = props.features,
        config = props.config,
        displayModel = props.displayModel,
        blockDefinitions = props.blockDefinitions,
        radius = props.radius,
        bezierRadius = props.bezierRadius,
        selectedFeatureId = props.displayModel.selectedFeatureId,
        onChordClick = props.onChordClick; // make a map of refName -> blockDefinition

    var blocksForRefsMemo = useMemo(function () {
      var blocksForRefs = {};
      blockDefinitions.forEach(function (block) {
        var regions = block.region.elided ? block.region.regions : [block.region];
        regions.forEach(function (region) {
          blocksForRefs[region.refName] = block;
        });
      });
      return blocksForRefs;
    }, [blockDefinitions]); // console.log(blocksForRefs)

    var chords = [];

    var _iterator = _createForOfIteratorHelper(features),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var _step$value = _slicedToArray(_step.value, 2),
            id = _step$value[0],
            feature = _step$value[1];

        var selected = String(selectedFeatureId) === String(feature.id());
        chords.push( /*#__PURE__*/React.createElement(Chord, {
          key: id,
          feature: feature,
          config: config,
          displayModel: displayModel,
          radius: radius,
          bezierRadius: bezierRadius,
          blocksForRefs: blocksForRefsMemo,
          selected: selected,
          onClick: onChordClick
        }));
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    var trackStyleId = "chords-".concat(displayModel.id);
    return /*#__PURE__*/React.createElement("g", {
      id: trackStyleId,
      "data-testid": "structuralVariantChordRenderer"
    }, /*#__PURE__*/React.createElement("style", {
      // eslint-disable-next-line react/no-danger
      dangerouslySetInnerHTML: {
        __html: "\n          #".concat(trackStyleId, " > path {\n            cursor: crosshair;\n            fill: none;\n          }\n")
      }
    }), chords);
  }

  StructuralVariantChords.propTypes = {
    features: PropTypes.instanceOf(Map).isRequired,
    config: CommonPropTypes.ConfigSchema.isRequired,
    displayModel: MobxPropTypes.objectOrObservableObject,
    blockDefinitions: PropTypes.arrayOf(MobxPropTypes.objectOrObservableObject).isRequired,
    radius: PropTypes.number.isRequired,
    bezierRadius: PropTypes.number.isRequired,
    selectedFeatureId: PropTypes.string,
    onChordClick: PropTypes.oneOfType([PropTypes.func, PropTypes.string])
  };
  StructuralVariantChords.defaultProps = {
    displayModel: undefined,
    selectedFeatureId: '',
    onChordClick: undefined
  };
  return observer(StructuralVariantChords);
};

var ChordRendererConfigF = function ChordRendererConfigF(pluginManager) {
  var jbrequire = pluginManager.jbrequire;
  var ChordRendererType = jbrequire('@jbrowse/core/pluggableElementTypes/renderers/CircularChordRendererType');

  var _jbrequire = jbrequire('@jbrowse/core/configuration'),
      ConfigurationSchema = _jbrequire.ConfigurationSchema;

  var ReactComponent = jbrequire(ChordRendererF);
  var configSchema = ConfigurationSchema('StructuralVariantChordRenderer', {
    strokeColor: {
      type: 'color',
      description: 'the line color of each arc',
      defaultValue: 'rgba(255,133,0,0.32)',
      contextVariable: ['feature']
    },
    strokeColorSelected: {
      type: 'color',
      description: 'the line color of an arc that has been selected',
      defaultValue: 'black',
      contextVariable: ['feature']
    },
    strokeColorHover: {
      type: 'color',
      description: 'the line color of an arc that is being hovered over with the mouse',
      defaultValue: '#555',
      contextVariable: ['feature']
    }
  }, {
    explicitlyTyped: true
  });
  return new ChordRendererType({
    name: 'StructuralVariantChordRenderer',
    ReactComponent: ReactComponent,
    configSchema: configSchema,
    pluginManager: pluginManager
  });
};

var configSchema = /*#__PURE__*/ConfigurationSchema('VariantFeatureWidget', {});
function stateModelFactory(pluginManager) {
  return types.model('VariantFeatureWidget', {
    id: ElementId,
    type: types.literal('VariantFeatureWidget'),
    view: types.safeReference(pluginManager.pluggableMstType('view', 'stateModel')),
    featureData: types.frozen(),
    descriptions: types.frozen()
  }).actions(function (self) {
    return {
      setFeatureData: function setFeatureData(data) {
        self.featureData = data;
      },
      clearFeatureData: function clearFeatureData() {
        self.featureData = undefined;
      }
    };
  });
}

var vcfTabixAdapterConfigSchema = /*#__PURE__*/ConfigurationSchema('VcfTabixAdapter', {
  vcfGzLocation: {
    type: 'fileLocation',
    defaultValue: {
      uri: '/path/to/my.vcf.gz'
    }
  },
  index: /*#__PURE__*/ConfigurationSchema('VcfIndex', {
    indexType: {
      model: /*#__PURE__*/types.enumeration('IndexType', ['TBI', 'CSI']),
      type: 'stringEnum',
      defaultValue: 'TBI'
    },
    location: {
      type: 'fileLocation',
      defaultValue: {
        uri: '/path/to/my.vcf.gz.tbi'
      }
    }
  })
}, {
  explicitlyTyped: true
});

var vcfAdapterConfigSchema = /*#__PURE__*/ConfigurationSchema('VcfAdapter', {
  vcfLocation: {
    type: 'fileLocation',
    defaultValue: {
      uri: '/path/to/my.vcf'
    }
  }
}, {
  explicitlyTyped: true
});

var VCFFeature = /*#__PURE__*/function () {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  function VCFFeature(args) {
    _classCallCheck(this, VCFFeature);

    this.variant = args.variant;
    this.parser = args.parser;
    this.data = this.dataFromVariant(this.variant);
    this._id = args.id;
  } // eslint-disable-next-line @typescript-eslint/no-explicit-any


  _createClass(VCFFeature, [{
    key: "get",
    value: function get(field) {
      if (field === 'samples') {
        return this.variant.SAMPLES;
      }

      return this.data[field] || this.variant[field];
    }
  }, {
    key: "set",
    value: function set() {}
  }, {
    key: "parent",
    value: function parent() {
      return undefined;
    }
  }, {
    key: "children",
    value: function children() {
      return undefined;
    }
  }, {
    key: "tags",
    value: function tags() {
      var t = [].concat(_toConsumableArray(Object.keys(this.data)), _toConsumableArray(Object.keys(this.variant)), ['samples']);
      return t;
    }
  }, {
    key: "id",
    value: function id() {
      return this._id;
    }
  }, {
    key: "dataFromVariant",
    value: function dataFromVariant(variant) {
      var REF = variant.REF,
          ALT = variant.ALT,
          POS = variant.POS,
          CHROM = variant.CHROM,
          INFO = variant.INFO,
          ID = variant.ID;
      var start = POS - 1;

      var _this$_getSOTermAndDe = this._getSOTermAndDescription(REF, ALT),
          _this$_getSOTermAndDe2 = _slicedToArray(_this$_getSOTermAndDe, 2),
          SO_term = _this$_getSOTermAndDe2[0],
          description = _this$_getSOTermAndDe2[1];

      var isTRA = ALT === null || ALT === void 0 ? void 0 : ALT.some(function (f) {
        return f === '<TRA>';
      });
      var isSymbolic = ALT === null || ALT === void 0 ? void 0 : ALT.some(function (f) {
        return typeof f === 'string' && f.indexOf('<') !== -1;
      });
      return {
        refName: CHROM,
        start: start,
        end: isSymbolic && INFO.END && !isTRA ? +INFO.END[0] : start + REF.length,
        description: description,
        type: SO_term,
        name: ID ? ID[0] : undefined,
        aliases: ID && ID.length > 1 ? variant.ID.slice(1) : undefined
      };
    }
    /**
     * Get a sequence ontology (SO) term that describes the variant type
     */

  }, {
    key: "_getSOTermAndDescription",
    value: function _getSOTermAndDescription(ref, alt) {
      var _this = this;

      // it's just a remark if there are no alternate alleles
      if (!alt || alt === []) {
        return ['remark', 'no alternative alleles'];
      }

      var soTerms = new Set();
      var descriptions = new Set();
      alt.forEach(function (a) {
        var _this$_getSOAndDescFr = _this._getSOAndDescFromAltDefs(ref, a),
            _this$_getSOAndDescFr2 = _slicedToArray(_this$_getSOAndDescFr, 2),
            soTerm = _this$_getSOAndDescFr2[0],
            description = _this$_getSOAndDescFr2[1];

        if (!soTerm) {

          var _this$_getSOAndDescBy = _this._getSOAndDescByExamination(ref, a);

          var _this$_getSOAndDescBy2 = _slicedToArray(_this$_getSOAndDescBy, 2);

          soTerm = _this$_getSOAndDescBy2[0];
          description = _this$_getSOAndDescBy2[1];
        }

        if (soTerm && description) {
          soTerms.add(soTerm);
          descriptions.add(description);
        }
      }); // Combine descriptions like ["SNV G -> A", "SNV G -> T"] to ["SNV G -> A,T"]

      if (descriptions.size > 1) {
        var prefixes = new Set(_toConsumableArray(descriptions).map(function (desc) {
          var prefix = desc.split('->');
          return prefix[1] ? prefix[0] : desc;
        }));

        var new_descs = _toConsumableArray(prefixes).map(function (prefix) {
          var suffixes = _toConsumableArray(descriptions).map(function (desc) {
            var pref = desc.split('-> ');
            return pref[1] && pref[0] === prefix ? pref[1] : '';
          }).filter(function (f) {
            return !!f;
          });

          return suffixes.length ? prefix + '-> ' + suffixes.join(',') : _toConsumableArray(descriptions).join(',');
        });

        descriptions = new Set(new_descs);
      }

      if (soTerms.size) {
        return [_toConsumableArray(soTerms).join(','), _toConsumableArray(descriptions).join(',')];
      }

      return [undefined, undefined];
    }
  }, {
    key: "_getSOAndDescFromAltDefs",
    value: function _getSOAndDescFromAltDefs(ref, alt) {
      // not a symbolic ALT if doesn't begin with '<', so we'll have no definition
      if (_typeof(alt) === 'object') {
        return ['breakend', alt.toString()];
      }

      if (typeof alt === 'string' && !alt.startsWith('<')) {
        return [undefined, undefined];
      } // look for a definition with an SO type for this


      var soTerm = VCFFeature._altTypeToSO[alt]; // if no SO term but ALT is in metadata, assume sequence_variant

      if (!soTerm && this.parser.getMetadata('ALT', alt)) {
        soTerm = 'sequence_variant';
      }

      if (soTerm) {
        // const metaDescription = this.parser.getMetadata('ALT', alt, 'Description')
        // const description = metaDescription
        //   ? `${alt} - ${metaDescription}`
        //   : this._makeDescriptionString(soTerm, ref, alt)
        return [soTerm, alt];
      } // try to look for a definition for a parent term if we can


      var modAlt = alt.split(':');

      if (modAlt.length > 1) {
        return this._getSOAndDescFromAltDefs(ref, "<".concat(modAlt.slice(0, modAlt.length - 1).join(':'), ">"));
      } // no parent


      return [undefined, undefined];
    }
  }, {
    key: "_getSOAndDescByExamination",
    value: function _getSOAndDescByExamination(ref, alt) {
      if (_typeof(alt) === 'object') {
        return ['breakend', this._makeDescriptionString('breakend', ref, alt)];
      }

      if (ref.length === 1 && alt.length === 1) {
        // use SNV because SO definition of SNP says abundance must be at
        // least 1% in population, and can't be sure we meet that
        return ['SNV', this._makeDescriptionString('SNV', ref, alt)];
      }

      if (alt.includes('<')) {
        return ['sv', alt];
      }

      if (ref.length === alt.length) {
        if (ref.split('').reverse().join('') === alt) {
          return ['inversion', this._makeDescriptionString('inversion', ref, alt)];
        }

        return ['substitution', this._makeDescriptionString('substitution', ref, alt)];
      }

      if (ref.length <= alt.length) {
        return ['insertion', this._makeDescriptionString('insertion', ref, alt)];
      }

      if (ref.length > alt.length) {
        return ['deletion', this._makeDescriptionString('deletion', ref, alt)];
      }

      return ['indel', this._makeDescriptionString('indel', ref, alt)];
    }
  }, {
    key: "_makeDescriptionString",
    value: function _makeDescriptionString(soTerm, ref, alt) {
      return "".concat(soTerm, " ").concat(ref, " -> ").concat(alt);
    } // eslint-disable-next-line @typescript-eslint/no-explicit-any

  }, {
    key: "toJSON",
    value: function toJSON() {
      return _objectSpread2(_objectSpread2(_objectSpread2({
        uniqueId: this._id
      }, this.variant), this.data), {}, {
        samples: this.variant.SAMPLES
      });
    }
  }]);

  return VCFFeature;
}();
VCFFeature._altTypeToSO = {
  DEL: 'deletion',
  INS: 'insertion',
  DUP: 'duplication',
  INV: 'inversion',
  INVDUP: 'inverted duplication',
  CNV: 'copy_number_variation',
  TRA: 'translocation',
  'DUP:TANDEM': 'tandem_duplication',
  NON_REF: 'sequence_variant',
  '*': 'sequence_variant'
};

var VariantsPlugin = /*#__PURE__*/function (_Plugin) {
  _inherits(VariantsPlugin, _Plugin);

  var _super = /*#__PURE__*/_createSuper(VariantsPlugin);

  function VariantsPlugin() {
    var _this;

    _classCallCheck(this, VariantsPlugin);

    _this = _super.apply(this, arguments);
    _this.name = 'VariantsPlugin';
    return _this;
  }

  _createClass(VariantsPlugin, [{
    key: "install",
    value: function install(pluginManager) {
      pluginManager.addAdapterType(function () {
        return new AdapterType({
          name: 'VcfTabixAdapter',
          configSchema: vcfTabixAdapterConfigSchema,
          getAdapterClass: function getAdapterClass() {
            return Promise.resolve().then(function () { return VcfTabixAdapter; }).then(function (r) {
              return r["default"];
            });
          }
        });
      });
      pluginManager.addAdapterType(function () {
        return new AdapterType({
          name: 'VcfAdapter',
          configSchema: vcfAdapterConfigSchema,
          getAdapterClass: function getAdapterClass() {
            return Promise.resolve().then(function () { return VcfAdapter$1; }).then(function (r) {
              return r["default"];
            });
          }
        });
      });
      pluginManager.addRendererType(function () {
        return pluginManager.jbrequire(ChordRendererConfigF);
      });
      pluginManager.addTrackType(function () {
        var configSchema = ConfigurationSchema('VariantTrack', {}, {
          baseConfiguration: createBaseTrackConfig(pluginManager)
        });
        return new TrackType({
          name: 'VariantTrack',
          configSchema: configSchema,
          stateModel: createBaseTrackModel(pluginManager, 'VariantTrack', configSchema)
        });
      });
      pluginManager.addDisplayType(function () {
        return pluginManager.jbrequire(ChordVariantDisplay);
      });
      pluginManager.addDisplayType(function () {
        var configSchema = LinearVariantDisplayConfigFactory(pluginManager);
        return new DisplayType({
          name: 'LinearVariantDisplay',
          configSchema: configSchema,
          stateModel: linearVariantDisplayModelFactory(configSchema),
          trackType: 'VariantTrack',
          viewType: 'LinearGenomeView',
          ReactComponent: BaseLinearDisplayComponent
        });
      });
      pluginManager.addWidgetType(function () {
        return new WidgetType({
          name: 'VariantFeatureWidget',
          heading: 'Feature details',
          configSchema: configSchema,
          stateModel: stateModelFactory(pluginManager),
          ReactComponent: /*#__PURE__*/lazy(function () {
            return Promise.resolve().then(function () { return VariantFeatureWidget$1; });
          })
        });
      });
    }
  }]);

  return VariantsPlugin;
}(Plugin);

var _default = /*#__PURE__*/function (_BaseFeatureDataAdapt) {
  _inherits(_default, _BaseFeatureDataAdapt);

  var _super = /*#__PURE__*/_createSuper(_default);

  function _default() {
    _classCallCheck(this, _default);

    return _super.apply(this, arguments);
  }

  _createClass(_default, [{
    key: "configure",
    value: function () {
      var _configure = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee() {
        var _this = this;

        var vcfGzLocation, location, indexType, filehandle, isCSI, vcf;
        return runtime_1.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!this.configured) {
                  vcfGzLocation = readConfObject(this.config, 'vcfGzLocation');
                  location = readConfObject(this.config, ['index', 'location']);
                  indexType = readConfObject(this.config, ['index', 'indexType']);
                  filehandle = openLocation(vcfGzLocation);
                  isCSI = indexType === 'CSI';
                  vcf = new TabixIndexedFile({
                    filehandle: filehandle,
                    csiFilehandle: isCSI ? openLocation(location) : undefined,
                    tbiFilehandle: !isCSI ? openLocation(location) : undefined,
                    chunkCacheSize: 50 * Math.pow(2, 20),
                    chunkSizeLimit: 1000000000
                  });
                  this.configured = vcf.getHeader().then(function (header) {
                    return {
                      filehandle: filehandle,
                      vcf: vcf,
                      parser: new VcfParser({
                        header: header
                      })
                    };
                  })["catch"](function (e) {
                    _this.configured = undefined;
                    throw e;
                  });
                }

                return _context.abrupt("return", this.configured);

              case 2:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function configure() {
        return _configure.apply(this, arguments);
      }

      return configure;
    }()
  }, {
    key: "getRefNames",
    value: function () {
      var _getRefNames = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2() {
        var opts,
            _yield$this$configure,
            vcf,
            _args2 = arguments;

        return runtime_1.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                opts = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : {};
                _context2.next = 3;
                return this.configure();

              case 3:
                _yield$this$configure = _context2.sent;
                vcf = _yield$this$configure.vcf;
                return _context2.abrupt("return", vcf.getReferenceSequenceNames(opts));

              case 6:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getRefNames() {
        return _getRefNames.apply(this, arguments);
      }

      return getRefNames;
    }()
  }, {
    key: "getHeader",
    value: function () {
      var _getHeader = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3() {
        var _yield$this$configure2, vcf;

        return runtime_1.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this.configure();

              case 2:
                _yield$this$configure2 = _context3.sent;
                vcf = _yield$this$configure2.vcf;
                return _context3.abrupt("return", vcf.getHeader());

              case 5:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function getHeader() {
        return _getHeader.apply(this, arguments);
      }

      return getHeader;
    }()
  }, {
    key: "getMetadata",
    value: function () {
      var _getMetadata = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee4() {
        var _yield$this$configure3, parser;

        return runtime_1.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this.configure();

              case 2:
                _yield$this$configure3 = _context4.sent;
                parser = _yield$this$configure3.parser;
                return _context4.abrupt("return", parser.getMetadata());

              case 5:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function getMetadata() {
        return _getMetadata.apply(this, arguments);
      }

      return getMetadata;
    }()
  }, {
    key: "getFeatures",
    value: function getFeatures(query) {
      var _this2 = this;

      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return ObservableCreate( /*#__PURE__*/function () {
        var _ref = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee5(observer) {
          var refName, start, end, _yield$_this2$configu, vcf, parser;

          return runtime_1.wrap(function _callee5$(_context5) {
            while (1) {
              switch (_context5.prev = _context5.next) {
                case 0:
                  refName = query.refName, start = query.start, end = query.end;
                  _context5.next = 3;
                  return _this2.configure();

                case 3:
                  _yield$_this2$configu = _context5.sent;
                  vcf = _yield$_this2$configu.vcf;
                  parser = _yield$_this2$configu.parser;
                  _context5.next = 8;
                  return vcf.getLines(refName, start, end, _objectSpread2({
                    lineCallback: function lineCallback(line, fileOffset) {
                      observer.next(new VCFFeature({
                        variant: parser.parseLine(line),
                        parser: parser,
                        id: "".concat(_this2.id, "-vcf-").concat(fileOffset)
                      }));
                    }
                  }, opts));

                case 8:
                  observer.complete();

                case 9:
                case "end":
                  return _context5.stop();
              }
            }
          }, _callee5);
        }));

        return function (_x) {
          return _ref.apply(this, arguments);
        };
      }(), opts.signal);
    }
    /**
     * Checks if the data source has data for the given reference sequence,
     * and then gets the features in the region if it does
     *
     * Currently this just calls getFeatureInRegion for each region. Adapters that
     * are frequently called on multiple regions simultaneously may want to
     * implement a more efficient custom version of this method.
     *
     * Also includes a bit of extra logging to warn when fetching a large portion
     * of a VCF
     * @param regions - Regions
     * @param opts - Feature adapter options
     * @returns Observable of Feature objects in the regions
     */

  }, {
    key: "getFeaturesInMultipleRegions",
    value: function getFeaturesInMultipleRegions(regions) {
      var _this3 = this;

      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      // TODO: restore commented version below once TSDX supports Rollup v2
      // xref: https://github.com/rollup/rollup/blob/master/CHANGELOG.md#bug-fixes-45
      var superGetFeaturesInMultipleRegions = _get(_getPrototypeOf(_default.prototype), "getFeaturesInMultipleRegions", this);

      return ObservableCreate( /*#__PURE__*/function () {
        var _ref2 = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee6(observer) {
          var bytes, _yield$_this3$configu, filehandle, stat, pct;

          return runtime_1.wrap(function _callee6$(_context6) {
            while (1) {
              switch (_context6.prev = _context6.next) {
                case 0:
                  _context6.next = 2;
                  return _this3.bytesForRegions(regions);

                case 2:
                  bytes = _context6.sent;
                  _context6.next = 5;
                  return _this3.configure();

                case 5:
                  _yield$_this3$configu = _context6.sent;
                  filehandle = _yield$_this3$configu.filehandle;
                  _context6.next = 9;
                  return filehandle.stat();

                case 9:
                  stat = _context6.sent;
                  pct = Math.round(bytes / stat.size * 100);

                  if (pct > 100) {
                    // this is just a bad estimate, make 100% if it goes over
                    pct = 100;
                  }

                  if (pct > 60) {
                    console.warn("getFeaturesInMultipleRegions fetching ".concat(pct, "% of VCF file, but whole-file streaming not yet implemented"));
                  }

                  superGetFeaturesInMultipleRegions.call(_this3, regions, opts).subscribe(observer); // super.getFeaturesInMultipleRegions(regions, opts).subscribe(observer)

                case 14:
                case "end":
                  return _context6.stop();
              }
            }
          }, _callee6);
        }));

        return function (_x2) {
          return _ref2.apply(this, arguments);
        };
      }());
    }
    /**
     * get the approximate number of bytes queried from the file for the given
     * query regions
     * @param regions - list of query regions
     */

  }, {
    key: "bytesForRegions",
    value: function () {
      var _bytesForRegions = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee7(regions) {
        var _yield$this$configure4, vcf, blockResults, byteRanges;

        return runtime_1.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return this.configure();

              case 2:
                _yield$this$configure4 = _context7.sent;
                vcf = _yield$this$configure4.vcf;
                _context7.next = 6;
                return Promise.all(regions.map(function (region) {
                  return (// @ts-ignore
                    vcf.index.blocksForRange(region.refName, region.start, region.end)
                  );
                }));

              case 6:
                blockResults = _context7.sent;
                byteRanges = [];
                blockResults.forEach(function (blocks) {
                  blocks.forEach(function (block) {
                    var start = block.minv.blockPosition;
                    var end = block.maxv.blockPosition + 64000;

                    if (!byteRanges.find(function (range) {
                      if (range.start <= end && range.end >= start) {
                        range.start = Math.min(range.start, start);
                        range.end = Math.max(range.end, end);
                        return true;
                      }

                      return false;
                    })) {
                      byteRanges.push({
                        start: start,
                        end: end
                      });
                    }
                  });
                });
                return _context7.abrupt("return", byteRanges.reduce(function (a, b) {
                  return a + b.end - b.start + 1;
                }, 0));

              case 10:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function bytesForRegions(_x3) {
        return _bytesForRegions.apply(this, arguments);
      }

      return bytesForRegions;
    }()
  }, {
    key: "freeResources",
    value: function freeResources()
    /* { region } */
    {}
  }]);

  return _default;
}(BaseFeatureDataAdapter);

var VcfTabixAdapter = {
  __proto__: null,
  'default': _default
};

var readVcf = function readVcf(f) {
  var lines = f.split('\n');
  var header = [];
  var refNames = [];
  var rest = [];
  lines.forEach(function (line) {
    if (line.startsWith('##contig')) {
      refNames.push(line.split('##contig=<ID=')[1].split(',')[0]);
    } else if (line.startsWith('#')) {
      header.push(line);
    } else if (line) {
      rest.push(line);
    }
  });
  return {
    header: header.join('\n'),
    lines: rest,
    refNames: refNames
  };
};

var VcfAdapter = /*#__PURE__*/function (_BaseFeatureDataAdapt) {
  _inherits(VcfAdapter, _BaseFeatureDataAdapt);

  var _super = /*#__PURE__*/_createSuper(VcfAdapter);

  function VcfAdapter(config) {
    _classCallCheck(this, VcfAdapter);

    return _super.call(this, config);
  }

  _createClass(VcfAdapter, [{
    key: "decodeFileContents",
    value: function () {
      var _decodeFileContents = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee() {
        var vcfLocation, fileContents;
        return runtime_1.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                vcfLocation = readConfObject(this.config, 'vcfLocation');
                _context.next = 3;
                return openLocation(vcfLocation).readFile();

              case 3:
                fileContents = _context.sent;

                if (!(typeof fileContents[0] === 'number' && fileContents[0] === 31 && typeof fileContents[1] === 'number' && fileContents[1] === 139 && typeof fileContents[2] === 'number' && fileContents[2] === 8)) {
                  _context.next = 12;
                  break;
                }

                _context.t0 = new TextDecoder();
                _context.next = 8;
                return unzip(fileContents);

              case 8:
                _context.t1 = _context.sent;
                fileContents = _context.t0.decode.call(_context.t0, _context.t1);
                _context.next = 13;
                break;

              case 12:
                fileContents = fileContents.toString();

              case 13:
                return _context.abrupt("return", readVcf(fileContents));

              case 14:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function decodeFileContents() {
        return _decodeFileContents.apply(this, arguments);
      }

      return decodeFileContents;
    }()
  }, {
    key: "getLines",
    value: function () {
      var _getLines = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2() {
        var _this = this;

        var _yield$this$decodeFil, header, lines, parser;

        return runtime_1.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.decodeFileContents();

              case 2:
                _yield$this$decodeFil = _context2.sent;
                header = _yield$this$decodeFil.header;
                lines = _yield$this$decodeFil.lines;
                parser = new VcfParser({
                  header: header
                });
                return _context2.abrupt("return", lines.map(function (line, index) {
                  return new VCFFeature({
                    variant: parser.parseLine(line),
                    parser: parser,
                    id: "".concat(_this.id, "-vcf-").concat(index)
                  });
                }));

              case 7:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getLines() {
        return _getLines.apply(this, arguments);
      }

      return getLines;
    }()
  }, {
    key: "setup",
    value: function () {
      var _setup = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3() {
        return runtime_1.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (!this.setupP) {
                  this.setupP = this.getLines();
                }

                return _context3.abrupt("return", this.setupP);

              case 2:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function setup() {
        return _setup.apply(this, arguments);
      }

      return setup;
    }()
  }, {
    key: "getRefNames",
    value: function () {
      var _getRefNames = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee4() {
        var _yield$this$decodeFil2,
            refNames;

        return runtime_1.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 3;
                return this.decodeFileContents();

              case 3:
                _yield$this$decodeFil2 = _context4.sent;
                refNames = _yield$this$decodeFil2.refNames;
                return _context4.abrupt("return", refNames);

              case 6:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function getRefNames() {
        return _getRefNames.apply(this, arguments);
      }

      return getRefNames;
    }()
  }, {
    key: "getFeatures",
    value: function getFeatures(region) {
      var _this2 = this;

      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return ObservableCreate( /*#__PURE__*/function () {
        var _ref = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee5(observer) {
          var feats;
          return runtime_1.wrap(function _callee5$(_context5) {
            while (1) {
              switch (_context5.prev = _context5.next) {
                case 0:
                  _context5.next = 2;
                  return _this2.setup();

                case 2:
                  feats = _context5.sent;
                  feats.forEach(function (f) {
                    if (f.get('refName') === region.refName && f.get('end') > region.start && f.get('start') < region.end) {
                      observer.next(f);
                    }
                  });
                  observer.complete();

                case 5:
                case "end":
                  return _context5.stop();
              }
            }
          }, _callee5);
        }));

        return function (_x) {
          return _ref.apply(this, arguments);
        };
      }(), opts.signal);
    }
  }, {
    key: "freeResources",
    value: function freeResources() {}
  }]);

  return VcfAdapter;
}(BaseFeatureDataAdapter);
VcfAdapter.capabilities = ['getFeatures', 'getRefNames'];

var VcfAdapter$1 = {
  __proto__: null,
  'default': VcfAdapter
};

var useStyles = /*#__PURE__*/makeStyles(function (theme) {
  return {
    closeButton: {
      position: 'absolute',
      right: theme.spacing(1),
      top: theme.spacing(1),
      color: theme.palette.grey[500]
    },
    block: {
      display: 'block'
    }
  };
});

function BreakendOptionDialog(_ref) {
  var model = _ref.model,
      handleClose = _ref.handleClose,
      feature = _ref.feature,
      viewType = _ref.viewType;
  var classes = useStyles();

  var _useState = useState(true),
      _useState2 = _slicedToArray(_useState, 2),
      copyTracks = _useState2[0],
      setCopyTracks = _useState2[1];

  var _useState3 = useState(true),
      _useState4 = _slicedToArray(_useState3, 2),
      mirrorTracks = _useState4[0],
      setMirrorTracks = _useState4[1];

  return /*#__PURE__*/React.createElement(Dialog, {
    open: true,
    onClose: handleClose
  }, /*#__PURE__*/React.createElement(DialogTitle, null, "Breakpoint split view options", handleClose ? /*#__PURE__*/React.createElement(IconButton, {
    className: classes.closeButton,
    onClick: function onClick() {
      handleClose();
    }
  }, /*#__PURE__*/React.createElement(CloseIcon, null)) : null), /*#__PURE__*/React.createElement(Divider, null), /*#__PURE__*/React.createElement(DialogContent, null, /*#__PURE__*/React.createElement(FormControlLabel, {
    className: classes.block,
    control: /*#__PURE__*/React.createElement(Checkbox, {
      checked: copyTracks,
      onChange: function onChange() {
        return setCopyTracks(function (val) {
          return !val;
        });
      }
    }),
    label: "Copy tracks into the new view"
  }), /*#__PURE__*/React.createElement(FormControlLabel, {
    className: classes.block,
    control: /*#__PURE__*/React.createElement(Checkbox, {
      checked: mirrorTracks,
      onChange: function onChange() {
        return setMirrorTracks(function (val) {
          return !val;
        });
      }
    }),
    label: "Mirror tracks vertically in vertically stacked view"
  })), /*#__PURE__*/React.createElement(DialogActions, null, /*#__PURE__*/React.createElement(Button, {
    onClick: function onClick() {
      var view = model.view;
      var session = getSession(model);
      var viewSnapshot = viewType.snapshotFromBreakendFeature(feature, view);
      viewSnapshot.views[0].offsetPx -= view.width / 2 + 100;
      viewSnapshot.views[1].offsetPx -= view.width / 2 + 100;
      viewSnapshot.featureData = feature;
      var viewTracks = getSnapshot(view.tracks);
      viewSnapshot.views[0].tracks = viewTracks;
      viewSnapshot.views[1].tracks = mirrorTracks ? viewTracks.slice().reverse() : viewTracks;
      session.addView('BreakpointSplitView', viewSnapshot);
      handleClose();
    },
    variant: "contained",
    color: "primary",
    autoFocus: true
  }, "OK"), /*#__PURE__*/React.createElement(Button, {
    onClick: function onClick() {
      handleClose();
    },
    color: "secondary",
    variant: "contained",
    autoFocus: true
  }, "Cancel")));
}

var BreakendOptionDialog$1 = /*#__PURE__*/observer(BreakendOptionDialog);

function toString(feat) {
  if (typeof feat === 'string') {
    return feat;
  }

  var _char = feat.MateDirection === 'left' ? ']' : '[';

  if (feat.Join === 'left') {
    return "".concat(_char).concat(feat.MatePosition).concat(_char).concat(feat.Replacement);
  }

  return "".concat(feat.Replacement).concat(_char).concat(feat.MatePosition).concat(_char);
}

function VariantSamples(props) {
  var _useState = useState({}),
      _useState2 = _slicedToArray(_useState, 2),
      filter = _useState2[0],
      setFilter = _useState2[1];

  var _useState3 = useState(false),
      _useState4 = _slicedToArray(_useState3, 2),
      showFilters = _useState4[0],
      setShowFilters = _useState4[1];

  var feature = props.feature;
  var _feature$samples = feature.samples,
      samples = _feature$samples === void 0 ? {} : _feature$samples;
  var preFilteredRows = Object.entries(samples);

  if (!preFilteredRows.length) {
    return null;
  }

  var infoFields = ['sample'].concat(_toConsumableArray(Object.keys(preFilteredRows[0][1]))).map(function (field) {
    return {
      field: field
    };
  });
  var error;
  var rows = [];
  var filters = Object.keys(filter); // catch some error thrown from regex
  // note: maps all values into a string, if this is not done rows are not
  // sortable by the data-grid

  try {
    rows = preFilteredRows.map(function (row) {
      return _objectSpread2(_objectSpread2({}, Object.fromEntries(Object.entries(row[1]).map(function (entry) {
        return [entry[0], String(entry[1])];
      }))), {}, {
        sample: row[0],
        id: row[0]
      });
    }).filter(function (row) {
      return filters.length ? filters.every(function (key) {
        var val = row[key];
        var currFilter = filter[key];
        return currFilter ? val.match(new RegExp(currFilter, 'i')) : true;
      }) : true;
    });
  } catch (e) {
    error = e;
  } // disableSelectionOnClick helps avoid
  // https://github.com/mui-org/material-ui-x/issues/1197


  return /*#__PURE__*/React.createElement(BaseCard, Object.assign({}, props, {
    title: "Samples"
  }), error ? /*#__PURE__*/React.createElement(Typography, {
    color: "error"
  }, "".concat(error)) : null, /*#__PURE__*/React.createElement(FormControlLabel, {
    control: /*#__PURE__*/React.createElement(Checkbox, {
      checked: showFilters,
      onChange: function onChange() {
        return setShowFilters(function (f) {
          return !f;
        });
      }
    }),
    label: "Show sample filters"
  }), showFilters ? /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(Typography, null, "These filters can use a plain text search or regex style query, e.g. in the genotype field, entering 1 will query for all genotypes that include the first alternate allele e.g. 0|1 or 1|1, entering [1-9]\\d* will find any non-zero allele e.g. 0|2 or 2/33"), infoFields.map(function (_ref) {
    var field = _ref.field;
    return /*#__PURE__*/React.createElement(TextField, {
      key: "filter-".concat(field),
      placeholder: "Filter ".concat(field),
      value: filter[field] || '',
      onChange: function onChange(event) {
        return setFilter(_objectSpread2(_objectSpread2({}, filter), {}, _defineProperty({}, field, event.target.value)));
      }
    });
  })) : null, /*#__PURE__*/React.createElement("div", {
    style: {
      height: 600,
      width: '100%',
      overflow: 'auto'
    }
  }, /*#__PURE__*/React.createElement(DataGrid, {
    rows: rows,
    columns: infoFields,
    rowHeight: 20,
    headerHeight: 25,
    disableSelectionOnClick: true,
    disableColumnMenu: true
  })));
}

function BreakendPanel(props) {
  var model = props.model,
      locStrings = props.locStrings,
      feature = props.feature;
  var session = getSession(model);

  var _getEnv = getEnv(session),
      pluginManager = _getEnv.pluginManager;

  var _useState5 = useState(false),
      _useState6 = _slicedToArray(_useState5, 2),
      breakpointDialog = _useState6[0],
      setBreakpointDialog = _useState6[1];

  var viewType;

  try {
    viewType = pluginManager.getViewType('BreakpointSplitView');
  } catch (e) {// plugin not added
  }

  var simpleFeature = new SimpleFeature(feature);
  return /*#__PURE__*/React.createElement(BaseCard, Object.assign({}, props, {
    title: "Breakends"
  }), /*#__PURE__*/React.createElement(Typography, null, "Link to linear view of breakend endpoints"), /*#__PURE__*/React.createElement("ul", null, locStrings.map(function (locString, index) {
    return /*#__PURE__*/React.createElement("li", {
      key: "".concat(JSON.stringify(locString), "-").concat(index)
    }, /*#__PURE__*/React.createElement(Link, {
      href: "#",
      onClick: function onClick() {
        var view = model.view;

        if (view) {
          var _view$navToLocString;

          (_view$navToLocString = view.navToLocString) === null || _view$navToLocString === void 0 ? void 0 : _view$navToLocString.call(view, locString);
        } else {
          session.notify('No view associated with this feature detail panel anymore', 'warning');
        }
      }
    }, "LGV - ".concat(locString)));
  })), viewType ? /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(Typography, null, "Launch split views with breakend source and target"), /*#__PURE__*/React.createElement("ul", null, locStrings.map(function (locString, index) {
    return /*#__PURE__*/React.createElement("li", {
      key: "".concat(JSON.stringify(locString), "-").concat(index)
    }, /*#__PURE__*/React.createElement(Link, {
      href: "#",
      onClick: function onClick() {
        setBreakpointDialog(true);
      }
    }, "".concat(feature.refName, ":").concat(feature.start, " // ").concat(locString, " (split view)")));
  })), breakpointDialog ? /*#__PURE__*/React.createElement(BreakendOptionDialog$1, {
    model: model,
    feature: simpleFeature,
    viewType: viewType,
    handleClose: function handleClose() {
      setBreakpointDialog(false);
    }
  }) : null) : null);
}

function VariantFeatureDetails(props) {
  var _rest$ALT;

  var model = props.model;
  var featureData = model.featureData,
      descriptions = model.descriptions;
  var feat = JSON.parse(JSON.stringify(featureData));

  var rest = _objectWithoutProperties(feat, ["samples"]);

  var basicDescriptions = {
    CHROM: 'chromosome: An identifier from the reference genome',
    POS: 'position: The reference position, with the 1st base having position 1',
    ID: 'identifier: Semi-colon separated list of unique identifiers where available',
    REF: 'reference base(s): Each base must be one of A,C,G,T,N (case insensitive).',
    ALT: ' alternate base(s): Comma-separated list of alternate non-reference alleles',
    QUAL: 'quality: Phred-scaled quality score for the assertion made in ALT',
    FILTER: 'filter status: PASS if this position has passed all filters, otherwise a semicolon-separated list of codes for filters that fail'
  };
  return /*#__PURE__*/React.createElement(Paper, {
    "data-testid": "variant-side-drawer"
  }, /*#__PURE__*/React.createElement(FeatureDetails, Object.assign({
    feature: _objectSpread2(_objectSpread2({}, rest), {}, {
      ALT: (_rest$ALT = rest.ALT) === null || _rest$ALT === void 0 ? void 0 : _rest$ALT.map(function (alt) {
        return toString(alt);
      })
    }),
    descriptions: _objectSpread2(_objectSpread2({}, basicDescriptions), descriptions)
  }, props)), /*#__PURE__*/React.createElement(Divider, null), feat.type === 'breakend' ? /*#__PURE__*/React.createElement(BreakendPanel, {
    feature: feat,
    locStrings: feat.ALT.map(function (alt) {
      return alt.MatePosition;
    }),
    model: model
  }) : null, feat.type === 'translocation' ? /*#__PURE__*/React.createElement(BreakendPanel, {
    feature: feat,
    model: model,
    locStrings: ["".concat(feat.INFO.CHR2[0], ":").concat(feat.INFO.END)]
  }) : null, /*#__PURE__*/React.createElement(VariantSamples, Object.assign({
    feature: feat
  }, props)));
}

var VariantFeatureWidget = /*#__PURE__*/observer(VariantFeatureDetails);

var VariantFeatureWidget$1 = {
  __proto__: null,
  'default': VariantFeatureWidget
};

export default VariantsPlugin;
export { VCFFeature as VcfFeature };
//# sourceMappingURL=plugin-variants.esm.js.map
