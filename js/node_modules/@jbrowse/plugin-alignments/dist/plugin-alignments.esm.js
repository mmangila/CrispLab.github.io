import React, { lazy, useRef, useState, useEffect } from 'react';
import { ConfigurationSchema, ConfigurationReference, getConf, readConfObject } from '@jbrowse/core/configuration';
import AdapterType from '@jbrowse/core/pluggableElementTypes/AdapterType';
import DisplayType from '@jbrowse/core/pluggableElementTypes/DisplayType';
import { BaseDisplay, createBaseTrackConfig, createBaseTrackModel } from '@jbrowse/core/pluggableElementTypes/models';
import TrackType from '@jbrowse/core/pluggableElementTypes/TrackType';
import WidgetType from '@jbrowse/core/pluggableElementTypes/WidgetType';
import Plugin from '@jbrowse/core/Plugin';
import { baseLinearDisplayConfigSchema, linearBasicDisplayConfigSchemaFactory, BaseLinearDisplay, BaseLinearDisplayComponent } from '@jbrowse/plugin-linear-genome-view';
import { linearWiggleDisplayModelFactory, getScale, getOrigin, WiggleBaseRenderer, YSCALEBAR_LABEL_OFFSET, LinearWiggleDisplayReactComponent, WiggleRendering } from '@jbrowse/plugin-wiggle';
import { ElementId } from '@jbrowse/core/util/types/mst';
import { types, addDisposer, getSnapshot, cast, getEnv } from 'mobx-state-tree';
import deepEqual from 'fast-deep-equal';
import { autorun, when, observable } from 'mobx';
import { getContainingTrack, getSession, isSessionModelWithWidgets, getContainingView, bpSpanPx, iterMap, featureSpanPx, renameRegionsIfNeeded, checkAbortSignal } from '@jbrowse/core/util';
import { observer } from 'mobx-react';
import { ResizeHandle, PrerenderedCanvas, createJBrowseTheme } from '@jbrowse/core/ui';
import { getRpcSessionId, getParentRenderProps } from '@jbrowse/core/util/tracks';
import VisibilityIcon from '@material-ui/icons/Visibility';
import { ContentCopy } from '@jbrowse/core/ui/Icons';
import copy from 'copy-to-clipboard';
import MenuOpenIcon from '@material-ui/icons/MenuOpen';
import SortIcon from '@material-ui/icons/Sort';
import PaletteIcon from '@material-ui/icons/Palette';
import FilterListIcon from '@material-ui/icons/ClearAll';
import SerializableFilterChain from '@jbrowse/core/pluggableElementTypes/renderers/util/serializableFilterChain';
import Typography from '@material-ui/core/Typography';
import MUITooltip from '@material-ui/core/Tooltip';
import { makeStyles } from '@material-ui/core/styles';
import { toArray, filter, reduce } from 'rxjs/operators';
import BoxRendererType, { LayoutSession } from '@jbrowse/core/pluggableElementTypes/renderers/BoxRendererType';
import Color from 'color';
import { renderToAbstractCanvas } from '@jbrowse/core/util/offscreenCanvasUtils';
import { getAdapter } from '@jbrowse/core/data_adapters/dataAdapterCache';
import { doesIntersect2 } from '@jbrowse/core/util/range';
import { BaseFeatureDataAdapter } from '@jbrowse/core/data_adapters/BaseAdapter';
import SimpleFeature from '@jbrowse/core/util/simpleFeature';
import { ObservableCreate } from '@jbrowse/core/util/rxjs';
import RpcMethodType from '@jbrowse/core/pluggableElementTypes/RpcMethodType';
import { BamFile, HtsgetFile } from '@gmod/bam';
import { openLocation } from '@jbrowse/core/util/io';
import { IndexedCramFile, CraiIndex } from '@gmod/cram';
import { Dialog, DialogTitle, IconButton, DialogContent, Typography as Typography$1, TextField, Button, makeStyles as makeStyles$1, Link, Paper, FormControlLabel, Checkbox, CircularProgress, FormGroup } from '@material-ui/core';
import CloseIcon from '@material-ui/icons/Close';
import { FeatureDetails, BaseCard, SimpleValue } from '@jbrowse/core/BaseFeatureWidget/BaseFeatureDetail';

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}

function _get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get;
  } else {
    _get = function _get(target, property, receiver) {
      var base = _superPropBase(target, property);

      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(receiver);
      }

      return desc.value;
    };
  }

  return _get(target, property, receiver || target);
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

function _toArray(arr) {
  return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest();
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

function _iterableToArrayLimit(arr, i) {
  var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;

      var F = function () {};

      return {
        s: F,
        n: function () {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function (e) {
          throw e;
        },
        f: F
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var normalCompletion = true,
      didErr = false,
      err;
  return {
    s: function () {
      it = it.call(o);
    },
    n: function () {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function (e) {
      didErr = true;
      err = e;
    },
    f: function () {
      try {
        if (!normalCompletion && it.return != null) it.return();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}

var configSchema = /*#__PURE__*/ConfigurationSchema('AlignmentsFeatureWidget', {});
function stateModelFactory(pluginManager) {
  return types.model('AlignmentsFeatureWidget', {
    id: ElementId,
    type: types.literal('AlignmentsFeatureWidget'),
    featureData: types.frozen(),
    view: types.safeReference(pluginManager.pluggableMstType('view', 'stateModel'))
  }).actions(function (self) {
    return {
      setFeatureData: function setFeatureData(data) {
        self.featureData = data;
      },
      clearFeatureData: function clearFeatureData() {
        self.featureData = undefined;
      }
    };
  });
}

var configSchema$1 = /*#__PURE__*/types.late(function () {
  return ConfigurationSchema('BamAdapter', {
    bamLocation: {
      type: 'fileLocation',
      defaultValue: {
        uri: '/path/to/my.bam'
      }
    },
    index: ConfigurationSchema('BamIndex', {
      indexType: {
        model: types.enumeration('IndexType', ['BAI', 'CSI']),
        type: 'stringEnum',
        defaultValue: 'BAI'
      },
      location: {
        type: 'fileLocation',
        defaultValue: {
          uri: '/path/to/my.bam.bai'
        }
      }
    }),
    chunkSizeLimit: {
      type: 'number',
      defaultValue: 100000000
    },
    fetchSizeLimit: {
      type: 'number',
      defaultValue: 500000000
    },
    sequenceAdapter: {
      type: 'frozen',
      defaultValue: null
    }
  }, {
    explicitlyTyped: true
  });
});

var BamAdapterF = (function ()
/* pluginManager: PluginManager */
{
  return {
    configSchema: configSchema$1,
    getAdapterClass: function getAdapterClass() {
      return Promise.resolve().then(function () { return BamAdapter$1; }).then(function (r) {
        return r["default"];
      });
    }
  };
});

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var runtime_1 = /*#__PURE__*/createCommonjsModule(function (module) {
  /**
   * Copyright (c) 2014-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var runtime = function (exports) {

    var Op = Object.prototype;
    var hasOwn = Op.hasOwnProperty;
    var undefined$1; // More compressible than void 0.

    var $Symbol = typeof Symbol === "function" ? Symbol : {};
    var iteratorSymbol = $Symbol.iterator || "@@iterator";
    var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
    var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

    function define(obj, key, value) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
      return obj[key];
    }

    try {
      // IE 8 has a broken Object.defineProperty that only works on DOM objects.
      define({}, "");
    } catch (err) {
      define = function define(obj, key, value) {
        return obj[key] = value;
      };
    }

    function wrap(innerFn, outerFn, self, tryLocsList) {
      // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
      var generator = Object.create(protoGenerator.prototype);
      var context = new Context(tryLocsList || []); // The ._invoke method unifies the implementations of the .next,
      // .throw, and .return methods.

      generator._invoke = makeInvokeMethod(innerFn, self, context);
      return generator;
    }

    exports.wrap = wrap; // Try/catch helper to minimize deoptimizations. Returns a completion
    // record like context.tryEntries[i].completion. This interface could
    // have been (and was previously) designed to take a closure to be
    // invoked without arguments, but in all the cases we care about we
    // already have an existing method we want to call, so there's no need
    // to create a new function object. We can even get away with assuming
    // the method takes exactly one argument, since that happens to be true
    // in every case, so we don't have to touch the arguments object. The
    // only additional allocation required is the completion record, which
    // has a stable shape and so hopefully should be cheap to allocate.

    function tryCatch(fn, obj, arg) {
      try {
        return {
          type: "normal",
          arg: fn.call(obj, arg)
        };
      } catch (err) {
        return {
          type: "throw",
          arg: err
        };
      }
    }

    var GenStateSuspendedStart = "suspendedStart";
    var GenStateSuspendedYield = "suspendedYield";
    var GenStateExecuting = "executing";
    var GenStateCompleted = "completed"; // Returning this object from the innerFn has the same effect as
    // breaking out of the dispatch switch statement.

    var ContinueSentinel = {}; // Dummy constructor functions that we use as the .constructor and
    // .constructor.prototype properties for functions that return Generator
    // objects. For full spec compliance, you may wish to configure your
    // minifier not to mangle the names of these two functions.

    function Generator() {}

    function GeneratorFunction() {}

    function GeneratorFunctionPrototype() {} // This is a polyfill for %IteratorPrototype% for environments that
    // don't natively support it.


    var IteratorPrototype = {};

    IteratorPrototype[iteratorSymbol] = function () {
      return this;
    };

    var getProto = Object.getPrototypeOf;
    var NativeIteratorPrototype = getProto && getProto(getProto(values([])));

    if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
      // This environment has a native %IteratorPrototype%; use it instead
      // of the polyfill.
      IteratorPrototype = NativeIteratorPrototype;
    }

    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
    GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
    GeneratorFunctionPrototype.constructor = GeneratorFunction;
    GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"); // Helper for defining the .next, .throw, and .return methods of the
    // Iterator interface in terms of a single ._invoke method.

    function defineIteratorMethods(prototype) {
      ["next", "throw", "return"].forEach(function (method) {
        define(prototype, method, function (arg) {
          return this._invoke(method, arg);
        });
      });
    }

    exports.isGeneratorFunction = function (genFun) {
      var ctor = typeof genFun === "function" && genFun.constructor;
      return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can
      // do is to check its .name property.
      (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
    };

    exports.mark = function (genFun) {
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
      } else {
        genFun.__proto__ = GeneratorFunctionPrototype;
        define(genFun, toStringTagSymbol, "GeneratorFunction");
      }

      genFun.prototype = Object.create(Gp);
      return genFun;
    }; // Within the body of any async function, `await x` is transformed to
    // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
    // `hasOwn.call(value, "__await")` to determine if the yielded value is
    // meant to be awaited.


    exports.awrap = function (arg) {
      return {
        __await: arg
      };
    };

    function AsyncIterator(generator, PromiseImpl) {
      function invoke(method, arg, resolve, reject) {
        var record = tryCatch(generator[method], generator, arg);

        if (record.type === "throw") {
          reject(record.arg);
        } else {
          var result = record.arg;
          var value = result.value;

          if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
            return PromiseImpl.resolve(value.__await).then(function (value) {
              invoke("next", value, resolve, reject);
            }, function (err) {
              invoke("throw", err, resolve, reject);
            });
          }

          return PromiseImpl.resolve(value).then(function (unwrapped) {
            // When a yielded Promise is resolved, its final value becomes
            // the .value of the Promise<{value,done}> result for the
            // current iteration.
            result.value = unwrapped;
            resolve(result);
          }, function (error) {
            // If a rejected Promise was yielded, throw the rejection back
            // into the async generator function so it can be handled there.
            return invoke("throw", error, resolve, reject);
          });
        }
      }

      var previousPromise;

      function enqueue(method, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function (resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }

        return previousPromise = // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later
        // invocations of the iterator.
        callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      } // Define the unified helper method that is used to implement .next,
      // .throw, and .return (see defineIteratorMethods).


      this._invoke = enqueue;
    }

    defineIteratorMethods(AsyncIterator.prototype);

    AsyncIterator.prototype[asyncIteratorSymbol] = function () {
      return this;
    };

    exports.AsyncIterator = AsyncIterator; // Note that simple async functions are implemented on top of
    // AsyncIterator objects; they just return a Promise for the value of
    // the final result produced by the iterator.

    exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
      if (PromiseImpl === void 0) PromiseImpl = Promise;
      var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
      return exports.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function (result) {
        return result.done ? result.value : iter.next();
      });
    };

    function makeInvokeMethod(innerFn, self, context) {
      var state = GenStateSuspendedStart;
      return function invoke(method, arg) {
        if (state === GenStateExecuting) {
          throw new Error("Generator is already running");
        }

        if (state === GenStateCompleted) {
          if (method === "throw") {
            throw arg;
          } // Be forgiving, per 25.3.3.3.3 of the spec:
          // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume


          return doneResult();
        }

        context.method = method;
        context.arg = arg;

        while (true) {
          var delegate = context.delegate;

          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context);

            if (delegateResult) {
              if (delegateResult === ContinueSentinel) continue;
              return delegateResult;
            }
          }

          if (context.method === "next") {
            // Setting context._sent for legacy support of Babel's
            // function.sent implementation.
            context.sent = context._sent = context.arg;
          } else if (context.method === "throw") {
            if (state === GenStateSuspendedStart) {
              state = GenStateCompleted;
              throw context.arg;
            }

            context.dispatchException(context.arg);
          } else if (context.method === "return") {
            context.abrupt("return", context.arg);
          }

          state = GenStateExecuting;
          var record = tryCatch(innerFn, self, context);

          if (record.type === "normal") {
            // If an exception is thrown from innerFn, we leave state ===
            // GenStateExecuting and loop back for another invocation.
            state = context.done ? GenStateCompleted : GenStateSuspendedYield;

            if (record.arg === ContinueSentinel) {
              continue;
            }

            return {
              value: record.arg,
              done: context.done
            };
          } else if (record.type === "throw") {
            state = GenStateCompleted; // Dispatch the exception by looping back around to the
            // context.dispatchException(context.arg) call above.

            context.method = "throw";
            context.arg = record.arg;
          }
        }
      };
    } // Call delegate.iterator[context.method](context.arg) and handle the
    // result, either by returning a { value, done } result from the
    // delegate iterator, or by modifying context.method and context.arg,
    // setting context.delegate to null, and returning the ContinueSentinel.


    function maybeInvokeDelegate(delegate, context) {
      var method = delegate.iterator[context.method];

      if (method === undefined$1) {
        // A .throw or .return when the delegate iterator has no .throw
        // method always terminates the yield* loop.
        context.delegate = null;

        if (context.method === "throw") {
          // Note: ["return"] must be used for ES3 parsing compatibility.
          if (delegate.iterator["return"]) {
            // If the delegate iterator has a return method, give it a
            // chance to clean up.
            context.method = "return";
            context.arg = undefined$1;
            maybeInvokeDelegate(delegate, context);

            if (context.method === "throw") {
              // If maybeInvokeDelegate(context) changed context.method from
              // "return" to "throw", let that override the TypeError below.
              return ContinueSentinel;
            }
          }

          context.method = "throw";
          context.arg = new TypeError("The iterator does not provide a 'throw' method");
        }

        return ContinueSentinel;
      }

      var record = tryCatch(method, delegate.iterator, context.arg);

      if (record.type === "throw") {
        context.method = "throw";
        context.arg = record.arg;
        context.delegate = null;
        return ContinueSentinel;
      }

      var info = record.arg;

      if (!info) {
        context.method = "throw";
        context.arg = new TypeError("iterator result is not an object");
        context.delegate = null;
        return ContinueSentinel;
      }

      if (info.done) {
        // Assign the result of the finished delegate to the temporary
        // variable specified by delegate.resultName (see delegateYield).
        context[delegate.resultName] = info.value; // Resume execution at the desired location (see delegateYield).

        context.next = delegate.nextLoc; // If context.method was "throw" but the delegate handled the
        // exception, let the outer generator proceed normally. If
        // context.method was "next", forget context.arg since it has been
        // "consumed" by the delegate iterator. If context.method was
        // "return", allow the original .return call to continue in the
        // outer generator.

        if (context.method !== "return") {
          context.method = "next";
          context.arg = undefined$1;
        }
      } else {
        // Re-yield the result returned by the delegate method.
        return info;
      } // The delegate iterator is finished, so forget it and continue with
      // the outer generator.


      context.delegate = null;
      return ContinueSentinel;
    } // Define Generator.prototype.{next,throw,return} in terms of the
    // unified ._invoke helper method.


    defineIteratorMethods(Gp);
    define(Gp, toStringTagSymbol, "Generator"); // A Generator should always return itself as the iterator object when the
    // @@iterator function is called on it. Some browsers' implementations of the
    // iterator prototype chain incorrectly implement this, causing the Generator
    // object to not be returned from this call. This ensures that doesn't happen.
    // See https://github.com/facebook/regenerator/issues/274 for more details.

    Gp[iteratorSymbol] = function () {
      return this;
    };

    Gp.toString = function () {
      return "[object Generator]";
    };

    function pushTryEntry(locs) {
      var entry = {
        tryLoc: locs[0]
      };

      if (1 in locs) {
        entry.catchLoc = locs[1];
      }

      if (2 in locs) {
        entry.finallyLoc = locs[2];
        entry.afterLoc = locs[3];
      }

      this.tryEntries.push(entry);
    }

    function resetTryEntry(entry) {
      var record = entry.completion || {};
      record.type = "normal";
      delete record.arg;
      entry.completion = record;
    }

    function Context(tryLocsList) {
      // The root entry object (effectively a try statement without a catch
      // or a finally block) gives us a place to store values thrown from
      // locations where there is no enclosing try statement.
      this.tryEntries = [{
        tryLoc: "root"
      }];
      tryLocsList.forEach(pushTryEntry, this);
      this.reset(true);
    }

    exports.keys = function (object) {
      var keys = [];

      for (var key in object) {
        keys.push(key);
      }

      keys.reverse(); // Rather than returning an object with a next method, we keep
      // things simple and return the next function itself.

      return function next() {
        while (keys.length) {
          var key = keys.pop();

          if (key in object) {
            next.value = key;
            next.done = false;
            return next;
          }
        } // To avoid creating an additional object, we just hang the .value
        // and .done properties off the next function object itself. This
        // also ensures that the minifier will not anonymize the function.


        next.done = true;
        return next;
      };
    };

    function values(iterable) {
      if (iterable) {
        var iteratorMethod = iterable[iteratorSymbol];

        if (iteratorMethod) {
          return iteratorMethod.call(iterable);
        }

        if (typeof iterable.next === "function") {
          return iterable;
        }

        if (!isNaN(iterable.length)) {
          var i = -1,
              next = function next() {
            while (++i < iterable.length) {
              if (hasOwn.call(iterable, i)) {
                next.value = iterable[i];
                next.done = false;
                return next;
              }
            }

            next.value = undefined$1;
            next.done = true;
            return next;
          };

          return next.next = next;
        }
      } // Return an iterator with no values.


      return {
        next: doneResult
      };
    }

    exports.values = values;

    function doneResult() {
      return {
        value: undefined$1,
        done: true
      };
    }

    Context.prototype = {
      constructor: Context,
      reset: function reset(skipTempReset) {
        this.prev = 0;
        this.next = 0; // Resetting context._sent for legacy support of Babel's
        // function.sent implementation.

        this.sent = this._sent = undefined$1;
        this.done = false;
        this.delegate = null;
        this.method = "next";
        this.arg = undefined$1;
        this.tryEntries.forEach(resetTryEntry);

        if (!skipTempReset) {
          for (var name in this) {
            // Not sure about the optimal order of these conditions:
            if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
              this[name] = undefined$1;
            }
          }
        }
      },
      stop: function stop() {
        this.done = true;
        var rootEntry = this.tryEntries[0];
        var rootRecord = rootEntry.completion;

        if (rootRecord.type === "throw") {
          throw rootRecord.arg;
        }

        return this.rval;
      },
      dispatchException: function dispatchException(exception) {
        if (this.done) {
          throw exception;
        }

        var context = this;

        function handle(loc, caught) {
          record.type = "throw";
          record.arg = exception;
          context.next = loc;

          if (caught) {
            // If the dispatched exception was caught by a catch block,
            // then let that catch block handle the exception normally.
            context.method = "next";
            context.arg = undefined$1;
          }

          return !!caught;
        }

        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          var record = entry.completion;

          if (entry.tryLoc === "root") {
            // Exception thrown outside of any try block that could handle
            // it, so set the completion value of the entire function to
            // throw the exception.
            return handle("end");
          }

          if (entry.tryLoc <= this.prev) {
            var hasCatch = hasOwn.call(entry, "catchLoc");
            var hasFinally = hasOwn.call(entry, "finallyLoc");

            if (hasCatch && hasFinally) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              } else if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }
            } else if (hasCatch) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              }
            } else if (hasFinally) {
              if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }
            } else {
              throw new Error("try statement without catch or finally");
            }
          }
        }
      },
      abrupt: function abrupt(type, arg) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];

          if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
            var finallyEntry = entry;
            break;
          }
        }

        if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
          // Ignore the finally entry if control is not jumping to a
          // location outside the try/catch block.
          finallyEntry = null;
        }

        var record = finallyEntry ? finallyEntry.completion : {};
        record.type = type;
        record.arg = arg;

        if (finallyEntry) {
          this.method = "next";
          this.next = finallyEntry.finallyLoc;
          return ContinueSentinel;
        }

        return this.complete(record);
      },
      complete: function complete(record, afterLoc) {
        if (record.type === "throw") {
          throw record.arg;
        }

        if (record.type === "break" || record.type === "continue") {
          this.next = record.arg;
        } else if (record.type === "return") {
          this.rval = this.arg = record.arg;
          this.method = "return";
          this.next = "end";
        } else if (record.type === "normal" && afterLoc) {
          this.next = afterLoc;
        }

        return ContinueSentinel;
      },
      finish: function finish(finallyLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];

          if (entry.finallyLoc === finallyLoc) {
            this.complete(entry.completion, entry.afterLoc);
            resetTryEntry(entry);
            return ContinueSentinel;
          }
        }
      },
      "catch": function _catch(tryLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];

          if (entry.tryLoc === tryLoc) {
            var record = entry.completion;

            if (record.type === "throw") {
              var thrown = record.arg;
              resetTryEntry(entry);
            }

            return thrown;
          }
        } // The context.catch method must only be called with a location
        // argument that corresponds to a known catch block.


        throw new Error("illegal catch attempt");
      },
      delegateYield: function delegateYield(iterable, resultName, nextLoc) {
        this.delegate = {
          iterator: values(iterable),
          resultName: resultName,
          nextLoc: nextLoc
        };

        if (this.method === "next") {
          // Deliberately forget the last sent value so that we don't
          // accidentally pass it on to the delegate.
          this.arg = undefined$1;
        }

        return ContinueSentinel;
      }
    }; // Regardless of whether this script is executing as a CommonJS module
    // or not, return the runtime object so that we can declare the variable
    // regeneratorRuntime in the outer scope, which allows this module to be
    // injected easily by `bin/regenerator --include-runtime script.js`.

    return exports;
  }( // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
   module.exports );

  try {
    regeneratorRuntime = runtime;
  } catch (accidentalStrictMode) {
    // This module should not be running in strict mode, so the above
    // assignment should always work unless something is misconfigured. Just
    // in case runtime.js accidentally runs in strict mode, we can escape
    // strict mode using a global Function call. This could conceivably fail
    // if a Content Security Policy forbids using Function, but in that case
    // the proper solution is to fix the accidental strict mode problem. If
    // you've misconfigured your bundler to force strict mode and applied a
    // CSP to forbid Function, and you're not willing to fix either of those
    // problems, please detail your unique predicament in a GitHub issue.
    Function("r", "regeneratorRuntime = r")(runtime);
  }
});

var _marked = /*#__PURE__*/runtime_1.mark(getNextRefPos);

function parseCigar(cigar) {
  return (cigar || '').split(/([MIDNSHPX=])/);
}
function cigarToMismatches(ops, seq, qual) {
  var currOffset = 0;
  var seqOffset = 0;
  var mismatches = [];

  for (var i = 0; i < ops.length - 1; i += 2) {
    var len = +ops[i];
    var op = ops[i + 1];

    if (op === 'M' || op === '=' || op === 'E') {
      seqOffset += len;
    }

    if (op === 'I') {
      mismatches.push({
        start: currOffset,
        type: 'insertion',
        base: "".concat(len),
        length: 0
      });
      seqOffset += len;
    } else if (op === 'D') {
      mismatches.push({
        start: currOffset,
        type: 'deletion',
        base: '*',
        length: len
      });
    } else if (op === 'N') {
      mismatches.push({
        start: currOffset,
        type: 'skip',
        base: 'N',
        length: len
      });
    } else if (op === 'X') {
      var r = seq.slice(seqOffset, seqOffset + len);
      var q = (qual === null || qual === void 0 ? void 0 : qual.slice(seqOffset, seqOffset + len)) || [];

      for (var j = 0; j < len; j++) {
        mismatches.push({
          start: currOffset + j,
          type: 'mismatch',
          base: r[j],
          qual: q[j],
          length: 1
        });
      }

      seqOffset += len;
    } else if (op === 'H') {
      mismatches.push({
        start: currOffset,
        type: 'hardclip',
        base: "H".concat(len),
        cliplen: len,
        length: 1
      });
    } else if (op === 'S') {
      mismatches.push({
        start: currOffset,
        type: 'softclip',
        base: "S".concat(len),
        cliplen: len,
        length: 1
      });
      seqOffset += len;
    }

    if (op !== 'I' && op !== 'S' && op !== 'H') {
      currOffset += len;
    }
  }

  return mismatches;
}
/**
 * parse a SAM MD tag to find mismatching bases of the template versus the reference
 * @returns array of mismatches and their positions
 */

function mdToMismatches(mdstring, cigarOps, cigarMismatches, seq, qual) {
  var mismatchRecords = [];
  var curr = {
    start: 0,
    base: '',
    length: 0,
    type: 'mismatch'
  };
  var skips = cigarMismatches.filter(function (cigar) {
    return cigar.type === 'skip';
  });
  var lastCigar = 0;
  var lastTemplateOffset = 0;
  var lastRefOffset = 0;
  var lastSkipPos = 0; // convert a position on the reference sequence to a position
  // on the template sequence, taking into account hard and soft
  // clipping of reads

  function nextRecord() {
    mismatchRecords.push(curr); // get a new mismatch record ready

    curr = {
      start: curr.start + curr.length,
      length: 0,
      base: '',
      type: 'mismatch'
    };
  }

  function getTemplateCoordLocal(refCoord) {
    var templateOffset = lastTemplateOffset;
    var refOffset = lastRefOffset;

    for (var i = lastCigar; i < cigarOps.length && refOffset <= refCoord; i += 2, lastCigar = i) {
      var len = +cigarOps[i];
      var op = cigarOps[i + 1];

      if (op === 'S' || op === 'I') {
        templateOffset += len;
      } else if (op === 'D' || op === 'P' || op === 'N') {
        refOffset += len;
      } else if (op !== 'H') {
        templateOffset += len;
        refOffset += len;
      }
    }

    lastTemplateOffset = templateOffset;
    lastRefOffset = refOffset;
    return templateOffset - (refOffset - refCoord);
  } // now actually parse the MD string


  var md = mdstring.match(/(\d+|\^[a-z]+|[a-z])/gi) || [];

  for (var i = 0; i < md.length; i++) {
    var token = md[i];

    if (token.match(/^\d/)) {
      curr.start += parseInt(token, 10);
    } else if (token.match(/^\^/)) {
      curr.length = token.length - 1;
      curr.base = '*';
      curr.type = 'deletion';
      curr.seq = token.substring(1);
      nextRecord();
    } else if (token.match(/^[a-z]/i)) {
      // mismatch
      for (var j = 0; j < token.length; j += 1) {
        curr.length = 1;

        while (lastSkipPos < skips.length) {
          var mismatch = skips[lastSkipPos];

          if (curr.start >= mismatch.start) {
            curr.start += mismatch.length;
            lastSkipPos++;
          } else {
            break;
          }
        }

        var s = cigarOps ? getTemplateCoordLocal(curr.start) : curr.start;
        curr.base = seq ? seq.substr(s, 1) : 'X';
        var qualScore = qual === null || qual === void 0 ? void 0 : qual.slice(s, s + 1)[0];

        if (qualScore) {
          curr.qual = qualScore;
        }

        curr.altbase = token;
        nextRecord();
      }
    }
  }

  return mismatchRecords;
}
function getTemplateCoord(refCoord, cigarOps) {
  var templateOffset = 0;
  var refOffset = 0;

  for (var i = 0; i < cigarOps.length && refOffset <= refCoord; i += 2) {
    var len = +cigarOps[i];
    var op = cigarOps[i + 1];

    if (op === 'S' || op === 'I') {
      templateOffset += len;
    } else if (op === 'D' || op === 'P') {
      refOffset += len;
    } else if (op !== 'H') {
      templateOffset += len;
      refOffset += len;
    }
  }

  return templateOffset - (refOffset - refCoord);
}
function getMismatches(cigarString, mdString, seq, qual) {
  var mismatches = [];
  var cigarOps = []; // parse the CIGAR tag if it has one

  if (cigarString) {
    cigarOps = parseCigar(cigarString);
    mismatches = mismatches.concat(cigarToMismatches(cigarOps, seq, qual));
  } // now let's look for CRAM or MD mismatches


  if (mdString) {
    mismatches = mismatches.concat(mdToMismatches(mdString, cigarOps, mismatches, seq, qual));
  } // uniqify the mismatches


  var seen = {};
  return mismatches.filter(function (m) {
    var key = "".concat(m.type, ",").concat(m.start, ",").concat(m.length);
    var s = seen[key];
    seen[key] = true;
    return !s;
  });
} // adapted from minimap2 code static void write_MD_core function

function generateMD(target, query, cigar) {
  var queryOffset = 0;
  var targetOffset = 0;
  var lengthMD = 0;

  if (!target) {
    console.warn('no ref supplied to generateMD');
    return '';
  }

  var cigarOps = parseCigar(cigar);
  var str = '';

  for (var i = 0; i < cigarOps.length; i += 2) {
    var len = +cigarOps[i];
    var op = cigarOps[i + 1];

    if (op === 'M' || op === 'X' || op === '=') {
      for (var j = 0; j < len; j++) {
        if (query[queryOffset + j].toLowerCase() !== target[targetOffset + j].toLowerCase()) {
          str += "".concat(lengthMD).concat(target[targetOffset + j].toUpperCase());
          lengthMD = 0;
        } else {
          lengthMD++;
        }
      }

      queryOffset += len;
      targetOffset += len;
    } else if (op === 'I') {
      queryOffset += len;
    } else if (op === 'D') {
      var tmp = '';

      for (var _j = 0; _j < len; _j++) {
        tmp += target[targetOffset + _j].toUpperCase();
      }

      str += "".concat(lengthMD, "^").concat(tmp);
      lengthMD = 0;
      targetOffset += len;
    } else if (op === 'N') {
      targetOffset += len;
    } else if (op === 'S') {
      queryOffset += len;
    }
  }

  if (lengthMD > 0) {
    str += lengthMD;
  }

  return str;
} // get relative reference sequence positions for positions given relative to
// the read sequence

function getNextRefPos(cigarOps, positions) {
  var cigarIdx, readPos, refPos, i, pos, len, op;
  return runtime_1.wrap(function getNextRefPos$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          cigarIdx = 0;
          readPos = 0;
          refPos = 0;
          i = 0;

        case 4:
          if (!(i < positions.length)) {
            _context.next = 12;
            break;
          }

          pos = positions[i];

          for (; cigarIdx < cigarOps.length && readPos < pos; cigarIdx += 2) {
            len = +cigarOps[cigarIdx];
            op = cigarOps[cigarIdx + 1];

            if (op === 'S' || op === 'I') {
              readPos += len;
            } else if (op === 'D' || op === 'N') {
              refPos += len;
            } else if (op === 'M' || op === 'X' || op === '=') {
              readPos += len;
              refPos += len;
            }
          }

          _context.next = 9;
          return positions[i] - readPos + refPos;

        case 9:
          i++;
          _context.next = 4;
          break;

        case 12:
        case "end":
          return _context.stop();
      }
    }
  }, _marked);
}
function getModificationPositions(mm, seq) {
  var mods = mm.split(';');
  return mods.filter(function (mod) {
    return !!mod;
  }).map(function (mod) {
    var _mod$split = mod.split(','),
        _mod$split2 = _toArray(_mod$split),
        basemod = _mod$split2[0],
        rest = _mod$split2.slice(1); // regexes based on parse_mm.pl from hts-specs


    var matches = basemod.match(/([A-Z])([-+])([^,]+)/);

    if (!matches) {
      throw new Error('bad format for MM tag');
    }

    var _matches = _slicedToArray(matches, 4),
        base = _matches[1],
        strand = _matches[2],
        typestr = _matches[3]; // can be a multi e.g. C+mh for both meth (m) and hydroxymeth (h) so
    // split, and they can also be chemical codes (ChEBI) e.g. C+16061


    var types = typestr.split(/(\d+|.)/).filter(function (f) {
      return !!f;
    });

    if (strand === '-') {
      console.warn('unsupported negative strand modifications'); // make sure to return a somewhat matching type even in this case

      return {
        type: 'unsupported',
        positions: []
      };
    } // this logic also based on parse_mm.pl from hts-specs is that in the
    // sequence of the read, if we have a modification type e.g. C+m;2 and a
    // sequence ACGTACGTAC we skip the two instances of C and go to the last
    // C


    return types.map(function (type) {
      var i = 0;
      return {
        type: type,
        positions: rest.map(function (score) {
          return +score;
        }).map(function (delta) {
          i++;

          do {
            if (base === 'N' || base === seq[i]) {
              delta--;
            }

            i++;
          } while (delta >= 0 && i < seq.length);

          i--;
          return i;
        })
      };
    });
  }).flat();
}
function getModificationTypes(mm) {
  var mods = mm.split(';');
  return mods.filter(function (mod) {
    return !!mod;
  }).map(function (mod) {
    var _mod$split3 = mod.split(','),
        _mod$split4 = _slicedToArray(_mod$split3, 1),
        basemod = _mod$split4[0];

    var matches = basemod.match(/([A-Z])([-+])([^,]+)/);

    if (!matches) {
      throw new Error('bad format for MM tag');
    }

    var _matches2 = _slicedToArray(matches, 4),
        typestr = _matches2[3]; // can be a multi e.g. C+mh for both meth (m) and hydroxymeth (h) so
    // split, and they can also be chemical codes (ChEBI) e.g. C+16061


    return typestr.split(/(\d+|.)/).filter(function (f) {
      return !!f;
    });
  }).flat();
}

var MismatchParser = {
  __proto__: null,
  parseCigar: parseCigar,
  cigarToMismatches: cigarToMismatches,
  mdToMismatches: mdToMismatches,
  getTemplateCoord: getTemplateCoord,
  getMismatches: getMismatches,
  generateMD: generateMD,
  getNextRefPos: getNextRefPos,
  getModificationPositions: getModificationPositions,
  getModificationTypes: getModificationTypes
};

var configSchemaF = (function (pluginManager) {
  var types = pluginManager.lib['mobx-state-tree'].types;
  return types.late(function () {
    return ConfigurationSchema('CramAdapter', {
      cramLocation: {
        type: 'fileLocation',
        defaultValue: {
          uri: '/path/to/my.cram'
        }
      },
      craiLocation: {
        type: 'fileLocation',
        defaultValue: {
          uri: '/path/to/my.cram.crai'
        }
      },
      sequenceAdapter: pluginManager.pluggableConfigSchemaType('adapter')
    }, {
      explicitlyTyped: true
    });
  });
});

var CramAdapterF = (function (pluginManager) {
  return {
    configSchema: pluginManager.load(configSchemaF),
    getAdapterClass: function getAdapterClass() {
      return Promise.resolve().then(function () { return CramAdapter$1; }).then(function (r) {
        return r["default"];
      });
    }
  };
});

var configSchema$2 = /*#__PURE__*/types.late(function () {
  return ConfigurationSchema('HtsgetBamAdapter', {
    htsgetBase: {
      type: 'string',
      defaultValue: ''
    },
    htsgetTrackId: {
      type: 'string',
      defaultValue: ''
    },
    sequenceAdapter: {
      type: 'frozen',
      defaultValue: null
    }
  }, {
    explicitlyTyped: true
  });
});

var HtsgetBamAdapterF = (function ()
/* pluginManager: PluginManager */
{
  return {
    configSchema: configSchema$2,
    getAdapterClass: function getAdapterClass() {
      return Promise.resolve().then(function () { return HtsgetBamAdapter$1; }).then(function (r) {
        return r["default"];
      });
    }
  };
});

var configModelFactory = function configModelFactory(pluginManager) {
  var PileupDisplayConfigSchema = pluginManager.getDisplayType('LinearPileupDisplay').configSchema;
  var SNPCoverageDisplayConfigSchema = pluginManager.getDisplayType('LinearSNPCoverageDisplay').configSchema;
  return ConfigurationSchema('LinearAlignmentsDisplay', {
    pileupDisplay: PileupDisplayConfigSchema,
    snpCoverageDisplay: SNPCoverageDisplayConfigSchema
  }, {
    baseConfiguration: baseLinearDisplayConfigSchema,
    explicitlyTyped: true
  });
};

var minDisplayHeight = 20;

var stateModelFactory$1 = function stateModelFactory(pluginManager, configSchema) {
  return types.compose('LinearAlignmentsDisplay', BaseDisplay, types.model({
    PileupDisplay: types.maybe(pluginManager.getDisplayType('LinearPileupDisplay').stateModel),
    SNPCoverageDisplay: types.maybe(pluginManager.getDisplayType('LinearSNPCoverageDisplay').stateModel),
    snpCovHeight: 45,
    type: types.literal('LinearAlignmentsDisplay'),
    configuration: ConfigurationReference(configSchema),
    height: 250,
    showCoverage: true,
    showPileup: true
  }))["volatile"](function () {
    return {
      scrollTop: 0
    };
  }).actions(function (self) {
    return {
      toggleCoverage: function toggleCoverage() {
        self.showCoverage = !self.showCoverage;
      },
      togglePileup: function togglePileup() {
        self.showPileup = !self.showPileup;
      },
      setScrollTop: function setScrollTop(scrollTop) {
        self.scrollTop = scrollTop;
      },
      setSNPCoverageHeight: function setSNPCoverageHeight(n) {
        self.snpCovHeight = n;
      }
    };
  }).views(function (self) {
    var trackMenuItems = self.trackMenuItems;
    return {
      get pileupDisplayConfig() {
        var conf = getConf(self, 'pileupDisplay');
        var track = getContainingTrack(self);
        return _objectSpread2(_objectSpread2({}, conf), {}, {
          type: 'LinearPileupDisplay',
          name: "".concat(getConf(track, 'name'), " pileup"),
          displayId: "".concat(self.configuration.displayId, "_pileup_xyz")
        });
      },

      getFeatureByID: function getFeatureByID(id) {
        return self.PileupDisplay.getFeatureByID(id);
      },

      get features() {
        return self.PileupDisplay.features;
      },

      get DisplayBlurb() {
        var _self$PileupDisplay;

        return (_self$PileupDisplay = self.PileupDisplay) === null || _self$PileupDisplay === void 0 ? void 0 : _self$PileupDisplay.DisplayBlurb;
      },

      get sortedBy() {
        return self.PileupDisplay.sortedBy;
      },

      get sortedByPosition() {
        return self.PileupDisplay.sortedByPosition;
      },

      get sortedByRefName() {
        return self.PileupDisplay.sortedByRefName;
      },

      get snpCoverageDisplayConfig() {
        var conf = getConf(self, 'snpCoverageDisplay');
        var track = getContainingTrack(self);
        return _objectSpread2(_objectSpread2({}, conf), {}, {
          type: 'LinearSNPCoverageDisplay',
          name: "".concat(getConf(track, 'name'), " snp coverage"),
          displayId: "".concat(self.configuration.displayId, "_snpcoverage_xyz")
        });
      },

      get trackMenuItems() {
        return [].concat(_toConsumableArray(trackMenuItems), [{
          type: 'subMenu',
          label: 'Pileup settings',
          subMenu: self.PileupDisplay.composedTrackMenuItems
        }, {
          type: 'subMenu',
          label: 'SNPCoverage settings',
          subMenu: [].concat(_toConsumableArray(self.SNPCoverageDisplay.composedTrackMenuItems), _toConsumableArray(self.SNPCoverageDisplay.extraTrackMenuItems))
        }]);
      }

    };
  }).actions(function (self) {
    return {
      setSNPCoverageDisplay: function setSNPCoverageDisplay(displayConfig) {
        self.SNPCoverageDisplay = {
          type: 'LinearSNPCoverageDisplay',
          configuration: displayConfig,
          height: self.snpCovHeight
        };
      },
      setUserBpPerPxLimit: function setUserBpPerPxLimit(limit) {
        self.PileupDisplay.setUserBpPerPxLimit(limit);
        self.SNPCoverageDisplay.setUserBpPerPxLimit(limit);
      },
      setPileupDisplay: function setPileupDisplay(displayConfig) {
        self.PileupDisplay = {
          type: 'LinearPileupDisplay',
          configuration: displayConfig
        };
      },
      setHeight: function setHeight(displayHeight) {
        if (displayHeight > minDisplayHeight) {
          self.height = displayHeight;
        } else {
          self.height = minDisplayHeight;
        }

        return self.height;
      },
      resizeHeight: function resizeHeight(distance) {
        var oldHeight = self.height;
        var newHeight = this.setHeight(self.height + distance);
        return newHeight - oldHeight;
      }
    };
  }).actions(function (self) {
    return {
      afterAttach: function afterAttach() {
        addDisposer(self, autorun(function () {
          if (!self.SNPCoverageDisplay) {
            self.setSNPCoverageDisplay(self.snpCoverageDisplayConfig);
          } else if (!deepEqual(self.snpCoverageDisplayConfig, getSnapshot(self.SNPCoverageDisplay.configuration))) {
            self.SNPCoverageDisplay.setHeight(self.snpCovHeight);
            self.SNPCoverageDisplay.setConfig(self.snpCoverageDisplayConfig);
          }

          if (!self.PileupDisplay) {
            self.setPileupDisplay(self.pileupDisplayConfig);
          } else if (!deepEqual(self.pileupDisplayConfig, getSnapshot(self.PileupDisplay.configuration))) {
            self.PileupDisplay.setConfig(self.pileupDisplayConfig);
          } // propagate the filterBy setting from pileupdisplay to snpcoverage
          // note: the snpcoverage display is not able to control filterBy
          // itself


          if (self.PileupDisplay.filterBy && !deepEqual(getSnapshot(self.PileupDisplay.filterBy), getSnapshot(self.SNPCoverageDisplay.filterBy))) {
            self.SNPCoverageDisplay.setFilterBy(getSnapshot(self.PileupDisplay.filterBy));
          }

          if (self.PileupDisplay.colorBy && !deepEqual(getSnapshot(self.PileupDisplay.colorBy), self.SNPCoverageDisplay.colorBy ? getSnapshot(self.SNPCoverageDisplay.colorBy) : {})) {
            self.SNPCoverageDisplay.setColorBy(getSnapshot(self.PileupDisplay.colorBy));
          }
        }));
        addDisposer(self, autorun(function () {
          self.setSNPCoverageHeight(self.SNPCoverageDisplay.height);
        }));
      },
      renderSvg: function renderSvg(opts) {
        return _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee() {
          var pileupHeight;
          return runtime_1.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  pileupHeight = self.height - self.SNPCoverageDisplay.height;
                  _context.next = 3;
                  return when(function () {
                    return self.PileupDisplay.ready;
                  });

                case 3:
                  _context.t0 = React;
                  _context.t1 = React.Fragment;
                  _context.t2 = React;
                  _context.next = 8;
                  return self.SNPCoverageDisplay.renderSvg(opts);

                case 8:
                  _context.t3 = _context.sent;
                  _context.t4 = _context.t2.createElement.call(_context.t2, "g", null, _context.t3);
                  _context.t5 = React;
                  _context.t6 = {
                    transform: "translate(0 ".concat(self.SNPCoverageDisplay.height, ")")
                  };
                  _context.next = 14;
                  return self.PileupDisplay.renderSvg(_objectSpread2(_objectSpread2({}, opts), {}, {
                    overrideHeight: pileupHeight
                  }));

                case 14:
                  _context.t7 = _context.sent;
                  _context.t8 = _context.t5.createElement.call(_context.t5, "g", _context.t6, _context.t7);
                  return _context.abrupt("return", _context.t0.createElement.call(_context.t0, _context.t1, null, _context.t4, _context.t8));

                case 17:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }))();
      }
    };
  });
};

function AlignmentsDisplay(_ref) {
  var model = _ref.model;
  var PileupDisplay = model.PileupDisplay,
      SNPCoverageDisplay = model.SNPCoverageDisplay,
      showPileup = model.showPileup,
      showCoverage = model.showCoverage;
  return /*#__PURE__*/React.createElement("div", {
    "data-testid": "display-".concat(getConf(model, 'displayId')),
    style: {
      position: 'relative'
    }
  }, /*#__PURE__*/React.createElement("div", {
    "data-testid": "Blockset-snpcoverage"
  }, showCoverage ? /*#__PURE__*/React.createElement(SNPCoverageDisplay.RenderingComponent, {
    model: SNPCoverageDisplay
  }) : null), /*#__PURE__*/React.createElement(ResizeHandle, {
    onDrag: function onDrag(delta) {
      if (SNPCoverageDisplay) {
        SNPCoverageDisplay.setHeight(SNPCoverageDisplay.height + delta);
        return delta;
      }

      return 0;
    },
    style: {
      position: 'absolute',
      top: showCoverage ? SNPCoverageDisplay.height + 2 : 0,
      height: 3
    }
  }), /*#__PURE__*/React.createElement("div", {
    "data-testid": "Blockset-pileup",
    style: {
      position: 'absolute',
      top: showCoverage ? SNPCoverageDisplay.height + 5 : 0,
      height: 3
    }
  }, showPileup ? /*#__PURE__*/React.createElement(PileupDisplay.RenderingComponent, {
    model: PileupDisplay
  }) : null));
}

var LinearAlignmentsDisplayReactComponent = /*#__PURE__*/observer(AlignmentsDisplay);

function PileupConfigFactory(pluginManager) {
  var PileupRendererConfigSchema = pluginManager.getRendererType('PileupRenderer').configSchema;
  var SvgFeatureRendererConfigSchema = pluginManager.getRendererType('SvgFeatureRenderer').configSchema; // modify config schema to take in a sub coverage display

  return ConfigurationSchema('LinearPileupDisplay', {
    defaultRendering: {
      type: 'stringEnum',
      model: types.enumeration('Rendering', ['pileup', 'svg']),
      defaultValue: 'pileup'
    },
    renderers: ConfigurationSchema('RenderersConfiguration', {
      PileupRenderer: PileupRendererConfigSchema,
      SvgFeatureRenderer: SvgFeatureRendererConfigSchema
    }),
    renderer: '',
    maxDisplayedBpPerPx: {
      type: 'number',
      description: 'maximum bpPerPx that is displayed in the view',
      defaultValue: 100
    },
    colorScheme: {
      type: 'stringEnum',
      model: types.enumeration('colorScheme', ['strand', 'normal', 'insertSize', 'insertSizeAndOrientation', 'mappingQuality', 'tag']),
      description: 'color scheme to use',
      defaultValue: 'normal'
    }
  }, {
    baseConfiguration: linearBasicDisplayConfigSchemaFactory(pluginManager),
    explicitlyTyped: true
  });
}

function LinearPileupDisplayBlurb(props) {
  var model = props.model;
  var sortedBy = model.sortedBy;
  return sortedBy ? /*#__PURE__*/React.createElement("div", {
    "data-testid": "blurb-".concat(model.sortedBy),
    style: {
      backgroundColor: 'white'
    }
  }, /*#__PURE__*/React.createElement(Typography, {
    color: "secondary",
    variant: "caption"
  }, model.sortedBy ? "Sorted by ".concat(sortedBy.type.toLowerCase(), " at ").concat(sortedBy.refName, ":").concat(sortedBy.pos) : null)) : null;
}

var LinearPileupDisplayBlurb$1 = /*#__PURE__*/observer(LinearPileupDisplayBlurb);

function getUniqueTagValues(_x, _x2, _x3, _x4) {
  return _getUniqueTagValues.apply(this, arguments);
}

function _getUniqueTagValues() {
  _getUniqueTagValues = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(self, colorScheme, blocks, opts) {
    var _getSession, rpcManager, adapterConfig, sessionId, values;

    return runtime_1.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _getSession = getSession(self), rpcManager = _getSession.rpcManager;
            adapterConfig = self.adapterConfig;
            sessionId = getRpcSessionId(self);
            _context.next = 5;
            return rpcManager.call(getRpcSessionId(self), 'PileupGetGlobalValueForTag', _objectSpread2({
              adapterConfig: adapterConfig,
              tag: colorScheme.tag,
              sessionId: sessionId,
              regions: blocks.contentBlocks
            }, opts));

          case 5:
            values = _context.sent;
            return _context.abrupt("return", values);

          case 7:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _getUniqueTagValues.apply(this, arguments);
}

function getUniqueModificationValues(_x5, _x6, _x7, _x8, _x9) {
  return _getUniqueModificationValues.apply(this, arguments);
}

function _getUniqueModificationValues() {
  _getUniqueModificationValues = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(self, adapterConfig, colorScheme, blocks, opts) {
    var _getSession2, rpcManager, sessionId, values;

    return runtime_1.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _getSession2 = getSession(self), rpcManager = _getSession2.rpcManager;
            sessionId = getRpcSessionId(self);
            _context2.next = 4;
            return rpcManager.call(sessionId, 'PileupGetVisibleModifications', _objectSpread2({
              adapterConfig: adapterConfig,
              tag: colorScheme.tag,
              sessionId: sessionId,
              regions: blocks.contentBlocks
            }, opts));

          case 4:
            values = _context2.sent;
            return _context2.abrupt("return", values);

          case 6:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _getUniqueModificationValues.apply(this, arguments);
}

var ColorByTagDlg = /*#__PURE__*/lazy(function () {
  return Promise.resolve().then(function () { return ColorByTag$1; });
});
var FilterByTagDlg = /*#__PURE__*/lazy(function () {
  return Promise.resolve().then(function () { return FilterByTag$1; });
});
var SortByTagDlg = /*#__PURE__*/lazy(function () {
  return Promise.resolve().then(function () { return SortByTag$1; });
});
var SetFeatureHeightDlg = /*#__PURE__*/lazy(function () {
  return Promise.resolve().then(function () { return SetFeatureHeight$1; });
});
var SetMaxHeightDlg = /*#__PURE__*/lazy(function () {
  return Promise.resolve().then(function () { return SetMaxHeight$1; });
});
var ModificationsDlg = /*#__PURE__*/lazy(function () {
  return Promise.resolve().then(function () { return ColorByModifications$1; });
}); // using a map because it preserves order

var rendererTypes = /*#__PURE__*/new Map([['pileup', 'PileupRenderer'], ['svg', 'SvgFeatureRenderer']]);

var stateModelFactory$2 = function stateModelFactory(pluginManager, configSchema) {
  return types.compose('LinearPileupDisplay', BaseLinearDisplay, types.model({
    type: types.literal('LinearPileupDisplay'),
    configuration: ConfigurationReference(configSchema),
    showSoftClipping: false,
    featureHeight: types.maybe(types.number),
    noSpacing: types.maybe(types["boolean"]),
    fadeLikelihood: types.maybe(types["boolean"]),
    trackMaxHeight: types.maybe(types.number),
    mismatchAlpha: types.maybe(types["boolean"]),
    sortedBy: types.maybe(types.model({
      type: types.string,
      pos: types.number,
      tag: types.maybe(types.string),
      refName: types.string,
      assemblyName: types.string
    })),
    colorBy: types.maybe(types.model({
      type: types.string,
      tag: types.maybe(types.string),
      extra: types.frozen()
    })),
    filterBy: types.optional(types.model({
      flagInclude: types.optional(types.number, 0),
      flagExclude: types.optional(types.number, 1536),
      readName: types.maybe(types.string),
      tagFilter: types.maybe(types.model({
        tag: types.string,
        value: types.string
      }))
    }), {})
  }))["volatile"](function () {
    return {
      colorTagMap: observable.map({}),
      modificationTagMap: observable.map({}),
      ready: false,
      currBpPerPx: 0
    };
  }).actions(function (self) {
    return {
      setReady: function setReady(flag) {
        self.ready = flag;
      },
      setCurrBpPerPx: function setCurrBpPerPx(n) {
        self.currBpPerPx = n;
      },
      setMaxHeight: function setMaxHeight(n) {
        self.trackMaxHeight = n;
      },
      setFeatureHeight: function setFeatureHeight(n) {
        self.featureHeight = n;
      },
      setNoSpacing: function setNoSpacing(flag) {
        self.noSpacing = flag;
      },
      setColorScheme: function setColorScheme(colorScheme) {
        self.colorTagMap = observable.map({}); // clear existing mapping

        self.colorBy = cast(colorScheme);
        self.ready = false;
      },
      updateModificationColorMap: function updateModificationColorMap(uniqueModifications) {
        var colorPalette = ['red', 'blue', 'green', 'orange', 'purple'];
        uniqueModifications.forEach(function (value) {
          if (!self.modificationTagMap.has(value)) {
            var totalKeys = _toConsumableArray(self.modificationTagMap.keys()).length;

            var newColor = colorPalette[totalKeys];
            self.modificationTagMap.set(value, newColor);
          }
        });
      },
      updateColorTagMap: function updateColorTagMap(uniqueTag) {
        // pale color scheme https://cran.r-project.org/web/packages/khroma/vignettes/tol.html e.g. "tol_light"
        var colorPalette = ['#BBCCEE', 'pink', '#CCDDAA', '#EEEEBB', '#FFCCCC', 'lightblue', 'lightgreen', 'tan', '#CCEEFF', 'lightsalmon'];
        uniqueTag.forEach(function (value) {
          if (!self.colorTagMap.has(value)) {
            var totalKeys = _toConsumableArray(self.colorTagMap.keys()).length;

            var newColor = colorPalette[totalKeys];
            self.colorTagMap.set(value, newColor);
          }
        });
      }
    };
  }).actions(function (self) {
    return {
      afterAttach: function afterAttach() {
        addDisposer(self, autorun( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee() {
          var _getSession, rpcManager, sortedBy, colorBy, renderProps, view, uniqueTagSet, uniqueModificationsSet, pos, refName, assemblyName, region;

          return runtime_1.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _context.prev = 0;
                  _getSession = getSession(self), rpcManager = _getSession.rpcManager;
                  sortedBy = self.sortedBy, colorBy = self.colorBy, renderProps = self.renderProps;
                  view = getContainingView(self); // continually generate the vc pairing, set and rerender if any
                  // new values seen

                  if (!(colorBy !== null && colorBy !== void 0 && colorBy.tag)) {
                    _context.next = 9;
                    break;
                  }

                  _context.next = 7;
                  return getUniqueTagValues(self, colorBy, view.staticBlocks);

                case 7:
                  uniqueTagSet = _context.sent;
                  self.updateColorTagMap(uniqueTagSet);

                case 9:
                  if (!((colorBy === null || colorBy === void 0 ? void 0 : colorBy.type) === 'modifications')) {
                    _context.next = 14;
                    break;
                  }

                  _context.next = 12;
                  return getUniqueModificationValues(self, getConf(self.parentTrack, ['adapter']), colorBy, view.staticBlocks);

                case 12:
                  uniqueModificationsSet = _context.sent;
                  self.updateModificationColorMap(uniqueModificationsSet);

                case 14:
                  if (!sortedBy) {
                    _context.next = 23;
                    break;
                  }

                  pos = sortedBy.pos, refName = sortedBy.refName, assemblyName = sortedBy.assemblyName;
                  region = {
                    start: pos,
                    end: (pos || 0) + 1,
                    refName: refName,
                    assemblyName: assemblyName
                  }; // render just the sorted region first
                  // eslint-disable-next-line @typescript-eslint/no-explicit-any

                  _context.next = 19;
                  return self.rendererType.renderInClient(rpcManager, _objectSpread2({
                    assemblyName: assemblyName,
                    regions: [region],
                    adapterConfig: self.adapterConfig,
                    rendererType: self.rendererType.name,
                    sessionId: getRpcSessionId(self),
                    timeout: 1000000
                  }, renderProps));

                case 19:
                  self.setReady(true);
                  self.setCurrBpPerPx(view.bpPerPx);
                  _context.next = 24;
                  break;

                case 23:
                  self.setReady(true);

                case 24:
                  _context.next = 30;
                  break;

                case 26:
                  _context.prev = 26;
                  _context.t0 = _context["catch"](0);
                  console.error(_context.t0);
                  self.setError(_context.t0);

                case 30:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, null, [[0, 26]]);
        })), {
          delay: 1000
        }));
      },
      selectFeature: function selectFeature(feature) {
        var session = getSession(self);

        if (isSessionModelWithWidgets(session)) {
          var featureWidget = session.addWidget('AlignmentsFeatureWidget', 'alignmentFeature', {
            featureData: feature.toJSON(),
            view: getContainingView(self)
          });
          session.showWidget(featureWidget);
        }

        session.setSelection(feature);
      },
      clearSelected: function clearSelected() {
        self.sortedBy = undefined;
      },
      // uses copy-to-clipboard and generates notification
      copyFeatureToClipboard: function copyFeatureToClipboard(feature) {
        var copiedFeature = feature.toJSON();
        delete copiedFeature.uniqueId;
        var session = getSession(self);
        copy(JSON.stringify(copiedFeature, null, 4));
        session.notify('Copied to clipboard', 'success');
      },
      toggleSoftClipping: function toggleSoftClipping() {
        self.showSoftClipping = !self.showSoftClipping;
      },
      toggleMismatchAlpha: function toggleMismatchAlpha() {
        self.mismatchAlpha = !self.mismatchAlpha;
      },
      setConfig: function setConfig(configuration) {
        self.configuration = configuration;
      },
      setSortedBy: function setSortedBy(type, tag) {
        var _getContainingView = getContainingView(self),
            centerLineInfo = _getContainingView.centerLineInfo;

        if (!centerLineInfo) {
          return;
        }

        var refName = centerLineInfo.refName,
            assemblyName = centerLineInfo.assemblyName,
            offset = centerLineInfo.offset;
        var centerBp = Math.round(offset) + 1;
        var centerRefName = refName;

        if (centerBp < 0) {
          return;
        }

        self.sortedBy = {
          type: type,
          pos: centerBp,
          refName: centerRefName,
          assemblyName: assemblyName,
          tag: tag
        };
        self.ready = false;
      },
      setFilterBy: function setFilterBy(filter) {
        self.filterBy = cast(filter);
      }
    };
  }).actions(function (self) {
    // resets the sort object and refresh whole display on reload
    var superReload = self.reload;
    return {
      reload: function reload() {
        self.clearSelected();
        superReload();
      }
    };
  }).views(function (self) {
    return {
      get maxHeight() {
        var conf = getConf(self, ['renderers', self.rendererTypeName]) || {};
        return self.trackMaxHeight !== undefined ? self.trackMaxHeight : conf.maxHeight;
      },

      get rendererConfig() {
        var configBlob = getConf(self, ['renderers', self.rendererTypeName]) || {};
        return self.rendererType.configSchema.create(_objectSpread2(_objectSpread2({}, configBlob), {}, {
          height: self.featureHeight,
          noSpacing: self.noSpacing,
          maxHeight: this.maxHeight,
          mismatchAlpha: self.mismatchAlpha
        }), getEnv(self));
      },

      get featureHeightSetting() {
        return self.featureHeight || readConfObject(this.rendererConfig, 'height');
      },

      get mismatchAlphaSetting() {
        return self.mismatchAlpha !== undefined ? self.mismatchAlpha : readConfObject(this.rendererConfig, 'mismatchAlpha');
      }

    };
  }).views(function (self) {
    var trackMenuItems = self.trackMenuItems;
    return {
      get rendererTypeName() {
        var viewName = getConf(self, 'defaultRendering');
        var rendererType = rendererTypes.get(viewName);

        if (!rendererType) {
          throw new Error("unknown alignments view name ".concat(viewName));
        }

        return rendererType;
      },

      get contextMenuItems() {
        var feat = self.contextMenuFeature;
        var contextMenuItems = feat ? [{
          label: 'Open feature details',
          icon: MenuOpenIcon,
          onClick: function onClick() {
            self.clearFeatureSelection();

            if (feat) {
              self.selectFeature(feat);
            }
          }
        }, {
          label: 'Copy info to clipboard',
          icon: ContentCopy,
          onClick: function onClick() {
            if (feat) {
              self.copyFeatureToClipboard(feat);
            }
          }
        }] : [];
        self.additionalContextMenuItemCallbacks.forEach(function (callback) {
          var menuItems = callback(feat, self, pluginManager);
          contextMenuItems.push.apply(contextMenuItems, _toConsumableArray(menuItems));
        });
        return contextMenuItems;
      },

      get DisplayBlurb() {
        return LinearPileupDisplayBlurb$1;
      },

      get filters() {
        var filters = [];

        if (self.filterBy) {
          var _self$filterBy = self.filterBy,
              flagInclude = _self$filterBy.flagInclude,
              flagExclude = _self$filterBy.flagExclude;
          filters = ["jexl:((get(feature,'flags')&".concat(flagInclude, ")==").concat(flagInclude, ") && !(get(feature,'flags')&").concat(flagExclude, ")")];

          if (self.filterBy.tagFilter) {
            var _self$filterBy$tagFil = self.filterBy.tagFilter,
                tag = _self$filterBy$tagFil.tag,
                value = _self$filterBy$tagFil.value;
            filters.push("jexl:\"".concat(value, "\" =='*' ? getTag(feature,\"").concat(tag, "\") != undefined : getTag(feature,\"").concat(tag, "\") == \"").concat(value, "\""));
          }

          if (self.filterBy.readName) {
            var readName = self.filterBy.readName;
            filters.push("jexl:get(feature,'name') == \"".concat(readName, "\""));
          }
        }

        return new SerializableFilterChain({
          filters: filters
        });
      },

      get renderProps() {
        var view = getContainingView(self);
        return _objectSpread2(_objectSpread2(_objectSpread2({}, self.composedRenderProps), getParentRenderProps(self)), {}, {
          notReady: !self.ready || self.sortedBy && self.currBpPerPx !== view.bpPerPx,
          rpcDriverName: self.rpcDriverName,
          displayModel: self,
          sortedBy: self.sortedBy,
          colorBy: self.colorBy,
          colorTagMap: JSON.parse(JSON.stringify(self.colorTagMap)),
          modificationTagMap: JSON.parse(JSON.stringify(self.modificationTagMap)),
          filters: this.filters,
          showSoftClip: self.showSoftClipping,
          config: self.rendererConfig
        });
      },

      get composedTrackMenuItems() {
        return [{
          label: 'Show soft clipping',
          icon: VisibilityIcon,
          type: 'checkbox',
          checked: self.showSoftClipping,
          onClick: function onClick() {
            self.toggleSoftClipping(); // if toggling from off to on, will break sort for this track
            // so clear it

            if (self.showSoftClipping) {
              self.clearSelected();
            }
          }
        }, {
          label: 'Sort by',
          icon: SortIcon,
          disabled: self.showSoftClipping,
          subMenu: [].concat(_toConsumableArray(['Start location', 'Read strand', 'Base pair'].map(function (option) {
            return {
              label: option,
              onClick: function onClick() {
                return self.setSortedBy(option);
              }
            };
          })), [{
            label: 'Sort by tag...',
            onClick: function onClick() {
              return getSession(self).setDialogComponent(SortByTagDlg, {
                model: self
              });
            }
          }, {
            label: 'Clear sort',
            onClick: function onClick() {
              return self.clearSelected();
            }
          }])
        }, {
          label: 'Color scheme',
          icon: PaletteIcon,
          subMenu: [{
            label: 'Normal',
            onClick: function onClick() {
              self.setColorScheme({
                type: 'normal'
              });
            }
          }, {
            label: 'Mapping quality',
            onClick: function onClick() {
              self.setColorScheme({
                type: 'mappingQuality'
              });
            }
          }, {
            label: 'Strand',
            onClick: function onClick() {
              self.setColorScheme({
                type: 'strand'
              });
            }
          }, {
            label: 'Pair orientation',
            onClick: function onClick() {
              self.setColorScheme({
                type: 'pairOrientation'
              });
            }
          }, {
            label: 'Per-base quality',
            onClick: function onClick() {
              self.setColorScheme({
                type: 'perBaseQuality'
              });
            }
          }, {
            label: 'Modifications or methylation',
            onClick: function onClick() {
              getSession(self).setDialogComponent(ModificationsDlg, {
                model: self
              });
            }
          }, {
            label: 'Insert size',
            onClick: function onClick() {
              self.setColorScheme({
                type: 'insertSize'
              });
            }
          }, {
            label: 'Stranded paired-end',
            onClick: function onClick() {
              self.setColorScheme({
                type: 'reverseTemplate'
              });
            }
          }, {
            label: 'Color by tag...',
            onClick: function onClick() {
              getSession(self).setDialogComponent(ColorByTagDlg, {
                model: self
              });
            }
          }]
        }, {
          label: 'Filter by',
          icon: FilterListIcon,
          onClick: function onClick() {
            getSession(self).setDialogComponent(FilterByTagDlg, {
              model: self
            });
          }
        }, {
          label: 'Set feature height',
          onClick: function onClick() {
            getSession(self).setDialogComponent(SetFeatureHeightDlg, {
              model: self
            });
          }
        }, {
          label: 'Set max height',
          onClick: function onClick() {
            getSession(self).setDialogComponent(SetMaxHeightDlg, {
              model: self
            });
          }
        }, {
          label: 'Fade mismatches by quality',
          type: 'checkbox',
          checked: self.mismatchAlphaSetting,
          onClick: function onClick() {
            self.toggleMismatchAlpha();
          }
        }];
      },

      get trackMenuItems() {
        return [].concat(_toConsumableArray(trackMenuItems), _toConsumableArray(this.composedTrackMenuItems));
      }

    };
  });
};

function SNPCoverageConfigFactory(pluginManager) {
  var SNPCoverageRendererConfigSchema = pluginManager.getRendererType('SNPCoverageRenderer').configSchema;
  return ConfigurationSchema('LinearSNPCoverageDisplay', {
    autoscale: {
      type: 'stringEnum',
      defaultValue: 'local',
      model: types.enumeration('Autoscale type', ['local']),
      description: 'performs local autoscaling (no other options for SNP Coverage available)'
    },
    minScore: {
      type: 'number',
      defaultValue: Number.MIN_VALUE,
      description: 'minimum value for the y-scale'
    },
    maxScore: {
      type: 'number',
      description: 'maximum value for the y-scale',
      defaultValue: Number.MAX_VALUE
    },
    scaleType: {
      type: 'stringEnum',
      model: types.enumeration('Scale type', ['linear', 'log']),
      description: 'The type of scale to use',
      defaultValue: 'linear'
    },
    inverted: {
      type: 'boolean',
      description: 'draw upside down',
      defaultValue: false
    },
    maxDisplayedBpPerPx: {
      type: 'number',
      description: 'maximum bpPerPx that is displayed in the view',
      defaultValue: 100
    },
    headroom: {
      type: 'number',
      description: 'round the upper value of the domain scale to the nearest N',
      defaultValue: 0
    },
    renderers: ConfigurationSchema('RenderersConfiguration', {
      SNPCoverageRenderer: SNPCoverageRendererConfigSchema
    })
  }, {
    baseConfiguration: baseLinearDisplayConfigSchema,
    explicitlyTyped: true
  });
}

var useStyles = /*#__PURE__*/makeStyles(function (theme) {
  return {
    popper: {
      fontSize: '0.8em',
      zIndex: theme.zIndex.tooltip,
      pointerEvents: 'none'
    },
    hoverVertical: {
      background: '#333',
      border: 'none',
      width: 1,
      height: '100%',
      top: 0,
      cursor: 'default',
      position: 'absolute',
      pointerEvents: 'none'
    }
  };
});

function TooltipContents(_ref) {
  var feature = _ref.feature;
  var refName = feature.get('refName');
  var start = (feature.get('start') + 1).toLocaleString('en-US');
  var end = feature.get('end').toLocaleString('en-US');
  var loc = "".concat(refName ? "".concat(refName, ":") : '').concat(start === end ? start : "".concat(start, "..").concat(end));
  var info = feature.get('snpinfo');
  var total = info.total,
      ref = info.ref,
      cov = info.cov,
      noncov = info.noncov,
      lowqual = info.lowqual,
      delskips = info.delskips;
  return /*#__PURE__*/React.createElement("div", null, /*#__PURE__*/React.createElement("table", null, /*#__PURE__*/React.createElement("caption", null, loc), /*#__PURE__*/React.createElement("thead", null, /*#__PURE__*/React.createElement("tr", null, /*#__PURE__*/React.createElement("th", null, "Base"), /*#__PURE__*/React.createElement("th", null, "Count"), /*#__PURE__*/React.createElement("th", null, "% of Total"), /*#__PURE__*/React.createElement("th", null, "Strands"), /*#__PURE__*/React.createElement("th", null, "Source"))), /*#__PURE__*/React.createElement("tbody", null, /*#__PURE__*/React.createElement("tr", null, /*#__PURE__*/React.createElement("td", null, "Total"), /*#__PURE__*/React.createElement("td", null, total), /*#__PURE__*/React.createElement("td", null)), Object.entries({
    ref: ref,
    cov: cov,
    noncov: noncov,
    delskips: delskips,
    lowqual: lowqual
  }).map(function (_ref2) {
    var _ref3 = _slicedToArray(_ref2, 2),
        key = _ref3[0],
        entry = _ref3[1];

    return /*#__PURE__*/React.createElement(React.Fragment, {
      key: key
    }, Object.entries(entry).map(function (_ref4) {
      var _ref5 = _slicedToArray(_ref4, 2),
          base = _ref5[0],
          score = _ref5[1];

      var strands = score.strands;
      return /*#__PURE__*/React.createElement("tr", {
        key: base
      }, /*#__PURE__*/React.createElement("td", null, base.toUpperCase()), /*#__PURE__*/React.createElement("td", null, score.total), /*#__PURE__*/React.createElement("td", null, base === 'total' ? '---' : "".concat(Math.floor(score.total / total * 100), "%")), /*#__PURE__*/React.createElement("td", null, strands['-1'] ? "".concat(strands['-1'], "(-)") : '', strands['1'] ? "".concat(strands['1'], "(+)") : ''), /*#__PURE__*/React.createElement("td", null, key));
    }));
  }))));
}

var Tooltip = /*#__PURE__*/observer(function (_ref6) {
  var model = _ref6.model,
      height = _ref6.height,
      mouseCoord = _ref6.mouseCoord;
  var featureUnderMouse = model.featureUnderMouse;
  var classes = useStyles();
  return featureUnderMouse ? /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(MUITooltip, {
    placement: "right-start",
    className: classes.popper,
    open: true,
    title: /*#__PURE__*/React.createElement(TooltipContents, {
      feature: featureUnderMouse
    })
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      position: 'absolute',
      left: mouseCoord[0],
      top: 0
    }
  }, ' ')), /*#__PURE__*/React.createElement("div", {
    className: classes.hoverVertical,
    style: {
      left: mouseCoord[0],
      height: height
    }
  })) : null;
});

var rendererTypes$1 = /*#__PURE__*/new Map([['snpcoverage', 'SNPCoverageRenderer']]);

var stateModelFactory$3 = function stateModelFactory(pluginManager, configSchema) {
  return types.compose('LinearSNPCoverageDisplay', linearWiggleDisplayModelFactory(pluginManager, configSchema), types.model({
    type: types.literal('LinearSNPCoverageDisplay'),
    drawInterbaseCounts: types.maybe(types["boolean"]),
    drawIndicators: types.maybe(types["boolean"]),
    filterBy: types.optional(types.model({
      flagInclude: types.optional(types.number, 0),
      flagExclude: types.optional(types.number, 1536),
      readName: types.maybe(types.string),
      tagFilter: types.maybe(types.model({
        tag: types.string,
        value: types.string
      }))
    }), {}),
    colorBy: types.maybe(types.model({
      type: types.string,
      tag: types.maybe(types.string)
    }))
  }))["volatile"](function () {
    return {
      modificationTagMap: observable.map({})
    };
  }).actions(function (self) {
    return {
      setConfig: function setConfig(configuration) {
        self.configuration = configuration;
      },
      setFilterBy: function setFilterBy(filter) {
        self.filterBy = cast(filter);
      },
      setColorBy: function setColorBy(colorBy) {
        self.colorBy = cast(colorBy);
      },
      updateModificationColorMap: function updateModificationColorMap(uniqueModifications) {
        var colorPalette = ['red', 'blue', 'green', 'orange', 'purple'];
        var i = 0;
        uniqueModifications.forEach(function (value) {
          if (!self.modificationTagMap.has(value)) {
            var newColor = colorPalette[i++];
            self.modificationTagMap.set(value, newColor);
          }
        });
      }
    };
  }).views(function (self) {
    return {
      get rendererConfig() {
        var configBlob = getConf(self, ['renderers', self.rendererTypeName]) || {};
        return self.rendererType.configSchema.create(_objectSpread2(_objectSpread2({}, configBlob), {}, {
          drawInterbaseCounts: self.drawInterbaseCounts === undefined ? configBlob.drawInterbaseCounts : self.drawInterbaseCounts,
          drawIndicators: self.drawIndicators === undefined ? configBlob.drawIndicators : self.drawIndicators
        }), getEnv(self));
      },

      get drawInterbaseCountsSetting() {
        return self.drawInterbaseCounts !== undefined ? self.drawInterbaseCounts : readConfObject(this.rendererConfig, 'drawInterbaseCounts');
      },

      get drawIndicatorsSetting() {
        return self.drawIndicators !== undefined ? self.drawIndicators : readConfObject(this.rendererConfig, 'drawIndicators');
      },

      get modificationsReady() {
        var _self$colorBy;

        return ((_self$colorBy = self.colorBy) === null || _self$colorBy === void 0 ? void 0 : _self$colorBy.type) === 'modifications' ? Object.keys(JSON.parse(JSON.stringify(self.modificationTagMap))).length > 0 : true;
      },

      get renderProps() {
        return _objectSpread2(_objectSpread2(_objectSpread2({}, self.composedRenderProps), getParentRenderProps(self)), {}, {
          notReady: !self.ready || !this.modificationsReady,
          rpcDriverName: self.rpcDriverName,
          displayModel: self,
          config: self.rendererConfig,
          scaleOpts: self.scaleOpts,
          resolution: self.resolution,
          height: self.height,
          ticks: self.ticks,
          displayCrossHatches: self.displayCrossHatches,
          filters: self.filters,
          modificationTagMap: JSON.parse(JSON.stringify(self.modificationTagMap)),
          // must use getSnapshot because otherwise changes to e.g. just the
          // colorBy.type are not read
          colorBy: self.colorBy ? getSnapshot(self.colorBy) : undefined
        });
      }

    };
  }).actions(function (self) {
    return {
      toggleDrawIndicators: function toggleDrawIndicators() {
        self.drawIndicators = !self.drawIndicatorsSetting;
      },
      toggleDrawInterbaseCounts: function toggleDrawInterbaseCounts() {
        self.drawInterbaseCounts = !self.drawInterbaseCountsSetting;
      },
      afterAttach: function afterAttach() {
        addDisposer(self, autorun( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee() {
          var colorBy, _getContainingView, staticBlocks, vals;

          return runtime_1.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _context.prev = 0;
                  colorBy = self.colorBy;
                  _getContainingView = getContainingView(self), staticBlocks = _getContainingView.staticBlocks;

                  if (!((colorBy === null || colorBy === void 0 ? void 0 : colorBy.type) === 'modifications')) {
                    _context.next = 8;
                    break;
                  }

                  _context.next = 6;
                  return getUniqueModificationValues(self, getConf(self.parentTrack, 'adapter'), colorBy, staticBlocks);

                case 6:
                  vals = _context.sent;
                  self.updateModificationColorMap(vals);

                case 8:
                  _context.next = 14;
                  break;

                case 10:
                  _context.prev = 10;
                  _context.t0 = _context["catch"](0);
                  console.error(_context.t0);
                  self.setError(_context.t0);

                case 14:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, null, [[0, 10]]);
        })), {
          delay: 1000
        }));
      }
    };
  }).views(function (self) {
    var trackMenuItems = self.trackMenuItems;
    return {
      get TooltipComponent() {
        return Tooltip;
      },

      get adapterConfig() {
        var subadapter = getConf(self.parentTrack, 'adapter');
        return {
          type: 'SNPCoverageAdapter',
          subadapter: subadapter
        };
      },

      get rendererTypeName() {
        return rendererTypes$1.get('snpcoverage');
      },

      get needsScalebar() {
        return true;
      },

      get contextMenuItems() {
        return [];
      },

      get extraTrackMenuItems() {
        return [{
          label: 'Draw insertion/clipping indicators',
          type: 'checkbox',
          checked: self.drawIndicatorsSetting,
          onClick: function onClick() {
            self.toggleDrawIndicators();
          }
        }, {
          label: 'Draw insertion/clipping counts',
          type: 'checkbox',
          checked: self.drawInterbaseCountsSetting,
          onClick: function onClick() {
            self.toggleDrawInterbaseCounts();
          }
        }];
      },

      get trackMenuItems() {
        return [].concat(_toConsumableArray(trackMenuItems), _toConsumableArray(self.composedTrackMenuItems), _toConsumableArray(this.extraTrackMenuItems));
      },

      // The SNPCoverage filters are called twice because the BAM/CRAM features
      // pass filters and then the SNPCoverage score features pass through
      // here, and are already have 'snpinfo' are passed through
      get filters() {
        var filters = [];

        if (self.filterBy) {
          var _self$filterBy = self.filterBy,
              flagInclude = _self$filterBy.flagInclude,
              flagExclude = _self$filterBy.flagExclude;
          filters = ["jexl:get(feature,'snpinfo') != undefined ? true : " + "((get(feature,'flags')&".concat(flagInclude, ")==").concat(flagInclude, ") && ") + "!((get(feature,'flags')&".concat(flagExclude, "))")];

          if (self.filterBy.tagFilter) {
            var _self$filterBy$tagFil = self.filterBy.tagFilter,
                tag = _self$filterBy$tagFil.tag,
                value = _self$filterBy$tagFil.value;
            filters.push("jexl:get(feature,'snpinfo') != undefined ? true : " + "\"".concat(value, "\" =='*' ? getTag(feature,\"").concat(tag, "\") != undefined : ") + "getTag(feature,\"".concat(tag, "\") == \"").concat(value, "\""));
          }

          if (self.filterBy.readName) {
            var readName = self.filterBy.readName;
            filters.push("jexl:get(feature,'snpinfo') != undefined ? true : " + "get(feature,'name') == \"".concat(readName, "\""));
          }
        }

        return new SerializableFilterChain({
          filters: filters
        });
      }

    };
  });
};

function PileupRendering(props) {
  var onMouseMove = props.onMouseMove,
      blockKey = props.blockKey,
      displayModel = props.displayModel,
      width = props.width,
      height = props.height,
      regions = props.regions,
      bpPerPx = props.bpPerPx,
      sortedBy = props.sortedBy,
      colorBy = props.colorBy;

  var _ref = displayModel || {},
      selectedFeatureId = _ref.selectedFeatureId,
      featureIdUnderMouse = _ref.featureIdUnderMouse,
      contextMenuFeature = _ref.contextMenuFeature,
      blockLayoutFeatures = _ref.blockLayoutFeatures;

  var _regions = _slicedToArray(regions, 1),
      region = _regions[0];

  var highlightOverlayCanvas = useRef(null);

  var _useState = useState(false),
      _useState2 = _slicedToArray(_useState, 2),
      mouseIsDown = _useState2[0],
      setMouseIsDown = _useState2[1];

  var _useState3 = useState(false),
      _useState4 = _slicedToArray(_useState3, 2),
      movedDuringLastMouseDown = _useState4[0],
      setMovedDuringLastMouseDown = _useState4[1];

  useEffect(function () {
    var canvas = highlightOverlayCanvas.current;

    if (!canvas) {
      return;
    }

    var ctx = canvas.getContext('2d');

    if (!ctx) {
      return;
    }

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    var rect;
    var blockLayout;

    if (selectedFeatureId && (blockLayout = blockLayoutFeatures.get(blockKey)) && (rect = blockLayout.get(selectedFeatureId))) {
      var _rect = rect,
          _rect2 = _slicedToArray(_rect, 4),
          leftBp = _rect2[0],
          topPx = _rect2[1],
          rightBp = _rect2[2],
          bottomPx = _rect2[3];

      var _bpSpanPx = bpSpanPx(leftBp, rightBp, region, bpPerPx),
          _bpSpanPx2 = _slicedToArray(_bpSpanPx, 2),
          leftPx = _bpSpanPx2[0],
          rightPx = _bpSpanPx2[1];

      var rectTop = Math.round(topPx);
      var rectHeight = Math.round(bottomPx - topPx);
      ctx.shadowColor = '#222266';
      ctx.shadowBlur = 10;
      ctx.lineJoin = 'bevel';
      ctx.lineWidth = 2;
      ctx.strokeStyle = '#00b8ff';
      ctx.strokeRect(leftPx - 2, rectTop - 2, rightPx - leftPx + 4, rectHeight + 4);
      ctx.clearRect(leftPx, rectTop, rightPx - leftPx, rectHeight);
    }

    var highlightedFeature = featureIdUnderMouse || (contextMenuFeature === null || contextMenuFeature === void 0 ? void 0 : contextMenuFeature.id());

    if (highlightedFeature && (blockLayout = blockLayoutFeatures.get(blockKey)) && (rect = blockLayout.get(highlightedFeature))) {
      var _rect3 = rect,
          _rect4 = _slicedToArray(_rect3, 4),
          _leftBp = _rect4[0],
          _topPx = _rect4[1],
          _rightBp = _rect4[2],
          _bottomPx = _rect4[3];

      var _bpSpanPx3 = bpSpanPx(_leftBp, _rightBp, region, bpPerPx),
          _bpSpanPx4 = _slicedToArray(_bpSpanPx3, 2),
          _leftPx = _bpSpanPx4[0],
          _rightPx = _bpSpanPx4[1];

      var _rectTop = Math.round(_topPx);

      var _rectHeight = Math.round(_bottomPx - _topPx);

      ctx.fillStyle = '#0003';
      ctx.fillRect(_leftPx, _rectTop, _rightPx - _leftPx, _rectHeight);
    }
  }, [bpPerPx, region, selectedFeatureId, featureIdUnderMouse, contextMenuFeature, blockKey, blockLayoutFeatures]);

  function _onMouseDown(event) {
    setMouseIsDown(true);
    setMovedDuringLastMouseDown(false);
    callMouseHandler('MouseDown', event);
  }

  function _onMouseEnter(event) {
    callMouseHandler('MouseEnter', event);
  }

  function _onMouseOut(event) {
    callMouseHandler('MouseOut', event);
    callMouseHandler('MouseLeave', event);
  }

  function _onMouseOver(event) {
    callMouseHandler('MouseOver', event);
  }

  function _onMouseUp(event) {
    setMouseIsDown(false);
    callMouseHandler('MouseUp', event);
  }

  function _onClick(event) {
    if (!movedDuringLastMouseDown) {
      callMouseHandler('Click', event);
    }
  }

  function _onMouseLeave(event) {
    callMouseHandler('MouseOut', event);
    callMouseHandler('MouseLeave', event);
  }

  function _onContextMenu(event) {
    callMouseHandler('ContextMenu', event);
  }

  function mouseMove(event) {
    if (mouseIsDown) {
      setMovedDuringLastMouseDown(true);
    }

    var offsetX = 0;
    var offsetY = 0;

    if (highlightOverlayCanvas.current) {
      offsetX = highlightOverlayCanvas.current.getBoundingClientRect().left;
      offsetY = highlightOverlayCanvas.current.getBoundingClientRect().top;
    }

    offsetX = event.clientX - offsetX;
    offsetY = event.clientY - offsetY;
    var px = region.reversed ? width - offsetX : offsetX;
    var clientBp = region.start + bpPerPx * px;
    var featIdUnderMouse = displayModel.getFeatureOverlapping(blockKey, clientBp, offsetY);

    if (onMouseMove) {
      onMouseMove(event, featIdUnderMouse);
    }
  }

  function callMouseHandler(handlerName, event) {
    // @ts-ignore
    var featureHandler = props["onFeature".concat(handlerName)]; // @ts-ignore

    var canvasHandler = props["on".concat(handlerName)];

    if (featureHandler && featureIdUnderMouse) {
      featureHandler(event, featureIdUnderMouse);
    } else if (canvasHandler) {
      canvasHandler(event, featureIdUnderMouse);
    }
  }

  var canvasWidth = Math.ceil(width); // need to call this in render so we get the right observer behavior

  return /*#__PURE__*/React.createElement("div", {
    className: "PileupRendering",
    "data-testid": "pileup-".concat(sortedBy || colorBy ? "".concat((sortedBy === null || sortedBy === void 0 ? void 0 : sortedBy.type) || '').concat((colorBy === null || colorBy === void 0 ? void 0 : colorBy.type) || '').concat((colorBy === null || colorBy === void 0 ? void 0 : colorBy.tag) || '') : 'normal'),
    style: {
      position: 'relative',
      width: canvasWidth,
      height: height
    }
  }, /*#__PURE__*/React.createElement(PrerenderedCanvas, Object.assign({}, props, {
    style: {
      position: 'absolute',
      left: 0,
      top: 0
    }
  })), /*#__PURE__*/React.createElement("canvas", {
    "data-testid": "pileup_overlay_canvas",
    width: canvasWidth,
    height: height,
    style: {
      position: 'absolute',
      left: 0,
      top: 0
    },
    className: "highlightOverlayCanvas",
    ref: highlightOverlayCanvas,
    onMouseDown: function onMouseDown(event) {
      return _onMouseDown(event);
    },
    onMouseEnter: function onMouseEnter(event) {
      return _onMouseEnter(event);
    },
    onMouseOut: function onMouseOut(event) {
      return _onMouseOut(event);
    },
    onMouseOver: function onMouseOver(event) {
      return _onMouseOver(event);
    },
    onMouseUp: function onMouseUp(event) {
      return _onMouseUp(event);
    },
    onMouseLeave: function onMouseLeave(event) {
      return _onMouseLeave(event);
    },
    onMouseMove: function onMouseMove(event) {
      return mouseMove(event);
    },
    onClick: function onClick(event) {
      return _onClick(event);
    },
    onContextMenu: function onContextMenu(event) {
      return _onContextMenu(event);
    },
    onFocus: function onFocus() {},
    onBlur: function onBlur() {}
  }));
}

var PileupRendererReactComponent = /*#__PURE__*/observer(PileupRendering);

var pileupRendererConfigSchema = /*#__PURE__*/ConfigurationSchema('PileupRenderer', {
  color: {
    type: 'color',
    description: 'the color of each feature in a pileup alignment',
    defaultValue: "#c8c8c8",
    contextVariable: ['feature']
  },
  orientationType: {
    type: 'stringEnum',
    model: /*#__PURE__*/types.enumeration('orientationType', ['fr', 'rf', 'ff']),
    defaultValue: 'fr',
    description: 'read sequencer orienation. fr is normal "reads pointing at each other ---> <--- while some other sequencers can use other options'
  },
  displayMode: {
    type: 'stringEnum',
    model: /*#__PURE__*/types.enumeration('displayMode', ['normal', 'compact', 'collapse']),
    description: 'Alternative display modes',
    defaultValue: 'normal'
  },
  minSubfeatureWidth: {
    type: 'number',
    description: 'the minimum width in px for a pileup mismatch feature. use for increasing mismatch marker widths when zoomed out to e.g. 1px or 0.5px',
    defaultValue: 0
  },
  maxHeight: {
    type: 'integer',
    description: 'the maximum height to be used in a pileup rendering',
    defaultValue: 1200
  },
  maxClippingSize: {
    type: 'integer',
    description: 'the max clip size to be used in a pileup rendering',
    defaultValue: 10000
  },
  height: {
    type: 'number',
    description: 'the height of each feature in a pileup alignment',
    defaultValue: 7,
    contextVariable: ['feature']
  },
  noSpacing: {
    type: 'boolean',
    description: 'remove spacing between features',
    defaultValue: false
  },
  largeInsertionIndicatorScale: {
    type: 'number',
    description: 'scale at which to draw the large insertion indicators (bp/pixel)',
    defaultValue: 10
  },
  mismatchAlpha: {
    type: 'boolean',
    defaultValue: false,
    description: 'Fade low quality mismatches'
  }
}, {
  explicitlyTyped: true
});

var sortFeature = function sortFeature(features, sortedBy) {
  var featureArray = Array.from(features.values());
  var featuresInCenterLine = [];
  var featuresOutsideCenter = [];
  var pos = sortedBy.pos,
      type = sortedBy.type; // only sort on features that intersect center line, append those outside post-sort

  featureArray.forEach(function (innerArray) {
    var feature = innerArray;
    var start = feature.get('start');
    var end = feature.get('end');

    if (doesIntersect2(pos - 1, pos, start, end)) {
      featuresInCenterLine.push(innerArray);
    } else {
      featuresOutsideCenter.push(innerArray);
    }
  });
  var isCram = featureArray.length ? featureArray[0].get('tags') : false;

  switch (type) {
    case 'Start location':
      {
        featuresInCenterLine.sort(function (a, b) {
          return a.get('start') - b.get('start');
        });
        break;
      }

    case 'tag':
      {
        var tag = sortedBy.tag;

        var getTag = function getTag(f, t) {
          return isCram ? f.get('tags')[t] : f.get(t);
        };

        var isString = featuresInCenterLine[0] && typeof getTag(featuresInCenterLine[0], tag) === 'string';

        if (isString) {
          featuresInCenterLine.sort(function (a, b) {
            return getTag(b, tag).localeCompare(getTag(a, tag));
          });
        } else {
          featuresInCenterLine.sort(function (a, b) {
            return (getTag(b, tag) || 0) - (getTag(a, tag) || 0);
          });
        }

        break;
      }
    // first sort all mismatches, then all reference bases at the end

    case 'Base pair':
      {
        var baseSortArray = [];
        featuresInCenterLine.forEach(function (feature) {
          var mismatches = feature.get('mismatches');
          mismatches.forEach(function (mismatch) {
            var start = feature.get('start');
            var offset = start + mismatch.start + 1;
            var consuming = mismatch.type === 'insertion' || mismatch.type === 'softclip';
            var len = consuming ? 0 : mismatch.length;

            if (pos >= offset && pos < offset + len) {
              baseSortArray.push([feature.id(), mismatch]);
            }
          });
        });
        var baseMap = new Map(baseSortArray);
        featuresInCenterLine.sort(function (a, b) {
          var aMismatch = baseMap.get(a.id());
          var bMismatch = baseMap.get(b.id());
          var acode = bMismatch && bMismatch.base.toUpperCase();
          var bcode = aMismatch && aMismatch.base.toUpperCase();

          if (acode === bcode && acode === '*') {
            // @ts-ignore
            return aMismatch.length - bMismatch.length;
          }

          return (acode ? acode.charCodeAt(0) : 0) - (bcode ? bcode.charCodeAt(0) : 0);
        });
        break;
      }
    // sorts positive strands then negative strands

    case 'Read strand':
      {
        featuresInCenterLine.sort(function (a, b) {
          return a.get('strand') <= b.get('strand') ? 1 : -1;
        });
        break;
      }
  }

  var sortedMap = new Map(featuresInCenterLine.concat(featuresOutsideCenter).map(function (feature) {
    return [feature.id(), feature];
  }));
  return sortedMap;
};

// get tag from BAM or CRAM feature, where CRAM uses feature.get('tags') and
// BAM does not
function getTag(feature, tag) {
  var tags = feature.get('tags');
  return tags ? tags[tag] : feature.get(tag);
} // use fallback alt tag, used in situations where upper case/lower case tags
// exist e.g. Mm/MM for base modifications

function getTagAlt(feature, tag, alt) {
  return getTag(feature, tag) || getTag(feature, alt);
} // orientation definitions from igv.js, see also
// https://software.broadinstitute.org/software/igv/interpreting_pair_orientations

var orientationTypes = {
  fr: {
    F1R2: 'LR',
    F2R1: 'LR',
    F1F2: 'LL',
    F2F1: 'LL',
    R1R2: 'RR',
    R2R1: 'RR',
    R1F2: 'RL',
    R2F1: 'RL'
  },
  rf: {
    R1F2: 'LR',
    R2F1: 'LR',
    R1R2: 'LL',
    R2R1: 'LL',
    F1F2: 'RR',
    F2F1: 'RR',
    F1R2: 'RL',
    F2R1: 'RL'
  },
  ff: {
    F2F1: 'LR',
    R1R2: 'LR',
    F2R1: 'LL',
    R1F2: 'LL',
    R2F1: 'RR',
    F1R2: 'RR',
    R2R1: 'RL',
    F1F2: 'RL'
  }
};

// Adds extra conditions to see if cached layout is valid

var PileupLayoutSession = /*#__PURE__*/function (_LayoutSession) {
  _inherits(PileupLayoutSession, _LayoutSession);

  var _super = /*#__PURE__*/_createSuper(PileupLayoutSession);

  function PileupLayoutSession(args) {
    var _this;

    _classCallCheck(this, PileupLayoutSession);

    _this = _super.call(this, args);
    _this.showSoftClip = false;
    _this.config = args.config;
    return _this;
  }

  _createClass(PileupLayoutSession, [{
    key: "cachedLayoutIsValid",
    value: function cachedLayoutIsValid(cachedLayout) {
      return _get(_getPrototypeOf(PileupLayoutSession.prototype), "cachedLayoutIsValid", this).call(this, cachedLayout) && this.showSoftClip === cachedLayout.showSoftClip && deepEqual(this.sortedBy, cachedLayout.sortedBy);
    }
  }, {
    key: "layout",
    get: function get() {
      if (!this.cachedLayout || !this.cachedLayoutIsValid(this.cachedLayout)) {
        this.cachedLayout = {
          layout: this.makeLayout(),
          config: readConfObject(this.config),
          filters: this.filters,
          sortedBy: this.sortedBy,
          showSoftClip: this.showSoftClip
        };
      }

      return this.cachedLayout.layout;
    }
  }]);

  return PileupLayoutSession;
}(LayoutSession);

function getColorBaseMap(theme) {
  return {
    A: theme.palette.bases.A.main,
    C: theme.palette.bases.C.main,
    G: theme.palette.bases.G.main,
    T: theme.palette.bases.T.main,
    deletion: '#808080'
  };
}

var alignmentColoring = {
  color_fwd_strand_not_proper: '#ECC8C8',
  color_rev_strand_not_proper: '#BEBED8',
  color_fwd_strand: '#EC8B8B',
  color_rev_strand: '#8F8FD8',
  color_fwd_missing_mate: '#D11919',
  color_rev_missing_mate: '#1919D1',
  color_fwd_diff_chr: '#000',
  color_rev_diff_chr: '#969696',
  color_pair_lr: '#c8c8c8',
  color_pair_rr: 'navy',
  color_pair_rl: 'teal',
  color_pair_ll: 'green',
  color_nostrand: '#999',
  color_interchrom: 'orange',
  color_longinsert: 'red',
  color_shortinsert: 'pink'
};

function shouldDrawMismatches(type) {
  return !['methylation', 'modifications'].includes(type || '');
}

var PileupRenderer = /*#__PURE__*/function (_BoxRendererType) {
  _inherits(PileupRenderer, _BoxRendererType);

  var _super = /*#__PURE__*/_createSuper(PileupRenderer);

  function PileupRenderer() {
    var _this;

    _classCallCheck(this, PileupRenderer);

    _this = _super.apply(this, arguments);
    _this.supportsSVG = true;
    return _this;
  } // get width and height of chars the height is an approximation: width
  // letter M is approximately the height


  _createClass(PileupRenderer, [{
    key: "getCharWidthHeight",
    value: function getCharWidthHeight(ctx) {
      var charWidth = ctx.measureText('A').width;
      var charHeight = ctx.measureText('M').width;
      return {
        charWidth: charWidth,
        charHeight: charHeight
      };
    }
  }, {
    key: "layoutFeature",
    value: function layoutFeature(feature, layout, config, bpPerPx, region, showSoftClip) {
      var expansionBefore = 0;
      var expansionAfter = 0;
      var mismatches = feature.get('mismatches');
      var seq = feature.get('seq'); // Expand the start and end of feature when softclipping enabled

      if (showSoftClip && seq) {
        for (var i = 0; i < mismatches.length; i += 1) {
          var _mismatches$i = mismatches[i],
              type = _mismatches$i.type,
              start = _mismatches$i.start,
              _mismatches$i$cliplen = _mismatches$i.cliplen,
              cliplen = _mismatches$i$cliplen === void 0 ? 0 : _mismatches$i$cliplen;

          if (type === 'softclip') {
            start === 0 ? expansionBefore = cliplen : expansionAfter = cliplen;
          }
        }
      }

      var _bpSpanPx = bpSpanPx(feature.get('start') - expansionBefore, feature.get('end') + expansionAfter, region, bpPerPx),
          _bpSpanPx2 = _slicedToArray(_bpSpanPx, 2),
          leftPx = _bpSpanPx2[0],
          rightPx = _bpSpanPx2[1];

      var heightPx = readConfObject(config, 'height', {
        feature: feature
      });
      var displayMode = readConfObject(config, 'displayMode', {
        feature: feature
      });

      if (displayMode === 'compact') {
        heightPx /= 3;
      }

      if (feature.get('refName') !== region.refName) {
        throw new Error("feature ".concat(feature.id(), " is not on the current region's reference sequence ").concat(region.refName));
      }

      var topPx = layout.addRect(feature.id(), feature.get('start') - expansionBefore, feature.get('end') + expansionAfter, heightPx);

      if (topPx === null) {
        return null;
      }

      return {
        feature: feature,
        leftPx: leftPx,
        rightPx: rightPx,
        topPx: displayMode === 'collapse' ? 0 : topPx,
        heightPx: heightPx
      };
    } // expands region for clipping to use. possible improvement: use average read
    // size to set the heuristic maxClippingSize expansion (e.g. short reads
    // don't have to expand a softclipping size a lot, but long reads might)

  }, {
    key: "getExpandedRegion",
    value: function getExpandedRegion(region, renderArgs) {
      var config = renderArgs.config,
          showSoftClip = renderArgs.showSoftClip;
      var maxClippingSize = readConfObject(config, 'maxClippingSize');
      var start = region.start,
          end = region.end;
      var len = end - start;
      var bpExpansion = Math.max(len, showSoftClip ? Math.round(maxClippingSize) : 0);
      return _objectSpread2(_objectSpread2({}, region), {}, {
        start: Math.floor(Math.max(start - bpExpansion, 0)),
        end: Math.ceil(end + bpExpansion)
      });
    }
  }, {
    key: "colorByOrientation",
    value: function colorByOrientation(feature, config) {
      return alignmentColoring[this.getOrientation(feature, config) || 'color_nostrand'];
    }
  }, {
    key: "getOrientation",
    value: function getOrientation(feature, config) {
      var orientationType = readConfObject(config, 'orientationType');
      var type = orientationTypes[orientationType];
      var orientation = type[feature.get('pair_orientation')];
      var map = {
        LR: 'color_pair_lr',
        RR: 'color_pair_rr',
        RL: 'color_pair_rl',
        LL: 'color_pair_ll'
      };
      return map[orientation];
    }
  }, {
    key: "colorByInsertSize",
    value: function colorByInsertSize(feature, _config) {
      return feature.get('is_paired') && feature.get('seq_id') !== feature.get('next_seq_id') ? '#555' : "hsl(".concat(Math.abs(feature.get('template_length')) / 10, ",50%,50%)");
    }
  }, {
    key: "colorByStranded",
    value: function colorByStranded(feature, _config) {
      var flags = feature.get('flags');
      var strand = feature.get('strand'); // is paired

      if (flags & 1) {
        var revflag = flags & 64;
        var flipper = revflag ? -1 : 1; // proper pairing

        if (flags & 2) {
          return strand * flipper === 1 ? 'color_rev_strand' : 'color_fwd_strand';
        }

        if (feature.get('multi_segment_next_segment_unmapped')) {
          return strand * flipper === 1 ? 'color_rev_missing_mate' : 'color_fwd_missing_mate';
        }

        if (feature.get('seq_id') === feature.get('next_seq_id')) {
          return strand * flipper === 1 ? 'color_rev_strand_not_proper' : 'color_fwd_strand_not_proper';
        } // should only leave aberrant chr


        return strand === 1 ? 'color_fwd_diff_chr' : 'color_rev_diff_chr';
      }

      return strand === 1 ? 'color_fwd_strand' : 'color_rev_strand';
    }
  }, {
    key: "colorByPerBaseQuality",
    value: function colorByPerBaseQuality(ctx, feat, _config, region, bpPerPx) {
      var feature = feat.feature,
          topPx = feat.topPx,
          heightPx = feat.heightPx;
      var qual = feature.get('qual') || '';
      var scores = qual.split(' ').map(function (val) {
        return +val;
      });
      var cigarOps = parseCigar(feature.get('CIGAR'));
      var width = 1 / bpPerPx;
      var start = feature.get('start');

      for (var i = 0, j = 0, k = 0; k < scores.length; i += 2, k++) {
        var len = +cigarOps[i];
        var op = cigarOps[i + 1];

        if (op === 'S' || op === 'I') {
          k += len;
        } else if (op === 'D' || op === 'N') {
          j += len;
        } else if (op === 'M' || op === 'X' || op === '=') {
          for (var m = 0; m < len; m++) {
            var score = scores[k + m];
            ctx.fillStyle = "hsl(".concat(score === 255 ? 150 : score * 1.5, ",55%,50%)");

            var _bpSpanPx3 = bpSpanPx(start + j + m, start + j + m + 1, region, bpPerPx),
                _bpSpanPx4 = _slicedToArray(_bpSpanPx3, 1),
                leftPx = _bpSpanPx4[0];

            ctx.fillRect(leftPx, topPx, width + 0.5, heightPx);
          }

          j += len;
        }
      }
    } // ML stores probabilities as array of numerics and MP is scaled phred scores
    // https://github.com/samtools/hts-specs/pull/418/files#diff-e765c6479316309f56b636f88189cdde8c40b854c7bdcce9ee7fe87a4e76febcR596
    //
    // if we have ML or Ml, it is an 8bit probability, divide by 255
    //
    // if we have MP or Mp it is phred scaled ASCII, which can go up to 90 but
    // has very high likelihood basecalls at that point, we really only care
    // about low qual calls <20 approx
    //

  }, {
    key: "colorByModifications",
    value: function colorByModifications(ctx, layoutFeature, _config, region, bpPerPx, props) {
      var feature = layoutFeature.feature,
          topPx = layoutFeature.topPx,
          heightPx = layoutFeature.heightPx;
      var _props$modificationTa = props.modificationTagMap,
          modificationTagMap = _props$modificationTa === void 0 ? {} : _props$modificationTa;
      var mm = getTagAlt(feature, 'MM', 'Mm') || '';
      var ml = getTagAlt(feature, 'ML', 'Ml') || [];
      var probabilities = ml ? (typeof ml === 'string' ? ml.split(',').map(function (e) {
        return +e;
      }) : ml).map(function (e) {
        return e / 255;
      }) : getTagAlt(feature, 'MP', 'Mp').split('').map(function (s) {
        return s.charCodeAt(0) - 33;
      }).map(function (elt) {
        return Math.min(1, elt / 50);
      });
      var cigar = feature.get('CIGAR');
      var start = feature.get('start');
      var end = feature.get('end');
      var seq = feature.get('seq');
      var cigarOps = parseCigar(cigar);
      var modifications = getModificationPositions(mm, seq); // probIndex applies across multiple modifications e.g.

      var probIndex = 0;
      modifications.forEach(function (_ref) {
        var type = _ref.type,
            positions = _ref.positions;
        var col = modificationTagMap[type] || 'black';
        var base = Color(col);

        var _iterator = _createForOfIteratorHelper(getNextRefPos(cigarOps, positions)),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var readPos = _step.value;

            if (readPos >= 0 && start + readPos < end) {
              var _bpSpanPx5 = bpSpanPx(start + readPos, start + readPos + 1, region, bpPerPx),
                  _bpSpanPx6 = _slicedToArray(_bpSpanPx5, 2),
                  leftPx = _bpSpanPx6[0],
                  rightPx = _bpSpanPx6[1]; // give it a little boost of 0.1 to not make them fully
              // invisible to avoid confusion


              ctx.fillStyle = base.alpha(probabilities[probIndex] + 0.1).hsl().string();
              ctx.fillRect(leftPx, topPx, rightPx - leftPx + 0.5, heightPx);
            }

            probIndex++;
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      });
    } // Color by methylation is slightly modified version of color by
    // modifications
    //

  }, {
    key: "colorByMethylation",
    value: function colorByMethylation(ctx, layoutFeature, _config, region, bpPerPx, props) {
      var regionSequence = props.regionSequence;
      var feature = layoutFeature.feature,
          topPx = layoutFeature.topPx,
          heightPx = layoutFeature.heightPx;
      var mm = getTagAlt(feature, 'MM', 'Mm') || '';

      if (!regionSequence) {
        throw new Error('region sequence required for methylation');
      }

      var cigar = feature.get('CIGAR');
      var fstart = feature.get('start');
      var fend = feature.get('end');
      var seq = feature.get('seq');
      var cigarOps = parseCigar(cigar);
      var rstart = region.start,
          rend = region.end;
      var methBins = new Array(rend - rstart).fill(0);
      getModificationPositions(mm, seq).forEach(function (_ref2) {
        var type = _ref2.type,
            positions = _ref2.positions;

        if (type === 'm' && positions) {
          var _iterator2 = _createForOfIteratorHelper(getNextRefPos(cigarOps, positions)),
              _step2;

          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
              var pos = _step2.value;
              var epos = pos + fstart - rstart;

              if (epos >= 0 && epos < methBins.length) {
                methBins[epos] = 1;
              }
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
        }
      });

      for (var j = fstart; j < fend; j++) {
        var i = j - rstart;

        if (i >= 0 && i < methBins.length) {
          var l2 = regionSequence[i + 1];
          var l1 = regionSequence[i]; // color

          if (l1.toUpperCase() === 'C' && l2.toUpperCase() === 'G') {
            var _bpSpanPx7 = bpSpanPx(rstart + i, rstart + i + 1, region, bpPerPx),
                _bpSpanPx8 = _slicedToArray(_bpSpanPx7, 2),
                leftPx = _bpSpanPx8[0],
                rightPx = _bpSpanPx8[1];

            if (methBins[i]) {
              ctx.fillStyle = 'red';
            } else {
              ctx.fillStyle = 'blue';
            }

            ctx.fillRect(leftPx, topPx, rightPx - leftPx + 0.5, heightPx);
          }
        }
      }
    }
  }, {
    key: "drawRect",
    value: function drawRect(ctx, feat, props) {
      var regions = props.regions,
          bpPerPx = props.bpPerPx;
      var heightPx = feat.heightPx,
          topPx = feat.topPx,
          feature = feat.feature;

      var _regions = _slicedToArray(regions, 1),
          region = _regions[0];

      var _bpSpanPx9 = bpSpanPx(feature.get('start'), feature.get('end'), region, bpPerPx),
          _bpSpanPx10 = _slicedToArray(_bpSpanPx9, 2),
          leftPx = _bpSpanPx10[0],
          rightPx = _bpSpanPx10[1];

      var flip = region.reversed ? -1 : 1;
      var strand = feature.get('strand') * flip;

      if (bpPerPx < 10) {
        if (strand === -1) {
          ctx.beginPath();
          ctx.moveTo(leftPx - 5, topPx + heightPx / 2);
          ctx.lineTo(leftPx, topPx + heightPx);
          ctx.lineTo(rightPx, topPx + heightPx);
          ctx.lineTo(rightPx, topPx);
          ctx.lineTo(leftPx, topPx);
          ctx.closePath();
          ctx.fill();
        } else {
          ctx.beginPath();
          ctx.moveTo(leftPx, topPx);
          ctx.lineTo(leftPx, topPx + heightPx);
          ctx.lineTo(rightPx, topPx + heightPx);
          ctx.lineTo(rightPx + 5, topPx + heightPx / 2);
          ctx.lineTo(rightPx, topPx);
          ctx.closePath();
          ctx.fill();
        }
      } else {
        ctx.fillRect(leftPx, topPx, rightPx - leftPx, heightPx);
      }
    }
  }, {
    key: "drawAlignmentRect",
    value: function drawAlignmentRect(ctx, feat, props) {
      var config = props.config,
          bpPerPx = props.bpPerPx,
          regions = props.regions,
          colorBy = props.colorBy,
          _props$colorTagMap = props.colorTagMap,
          colorTagMap = _props$colorTagMap === void 0 ? {} : _props$colorTagMap;

      var _ref3 = colorBy || {},
          _ref3$tag = _ref3.tag,
          tag = _ref3$tag === void 0 ? '' : _ref3$tag,
          _ref3$type = _ref3.type,
          colorType = _ref3$type === void 0 ? '' : _ref3$type;

      var feature = feat.feature;
      var region = regions[0]; // first pass for simple color changes that change the color of the
      // alignment

      switch (colorType) {
        case 'insertSize':
          ctx.fillStyle = this.colorByInsertSize(feature, config);
          break;

        case 'strand':
          ctx.fillStyle = feature.get('strand') === -1 ? '#8F8FD8' : '#EC8B8B';
          break;

        case 'mappingQuality':
          ctx.fillStyle = "hsl(".concat(feature.get('mq'), ",50%,50%)");
          break;

        case 'pairOrientation':
          ctx.fillStyle = this.colorByOrientation(feature, config);
          break;

        case 'stranded':
          ctx.fillStyle = alignmentColoring[this.colorByStranded(feature, config)];
          break;

        case 'xs':
        case 'tag':
          {
            var tags = feature.get('tags');
            var val = tags ? tags[tag] : feature.get(tag); // special for for XS/TS tag

            if (tag === 'XS' || tag === 'TS') {
              var map = {
                '-': 'color_rev_strand',
                '+': 'color_fwd_strand'
              };
              ctx.fillStyle = alignmentColoring[map[val] || 'color_nostrand'];
            } // lower case 'ts' from minimap2 is flipped from xs


            if (tag === 'ts') {
              var _map = {
                '-': feature.get('strand') === -1 ? 'color_fwd_strand' : 'color_rev_strand',
                '+': feature.get('strand') === -1 ? 'color_rev_strand' : 'color_fwd_strand'
              };
              ctx.fillStyle = alignmentColoring[_map[val] || 'color_nostrand'];
            } // tag is not one of the autofilled tags, has color-value pairs from
            // fetchValues
            else {
                var foundValue = colorTagMap[val];
                ctx.fillStyle = foundValue || 'color_nostrand';
              }

            break;
          }

        case 'insertSizeAndPairOrientation':
          break;

        case 'normal':
        default:
          ctx.fillStyle = readConfObject(config, 'color', {
            feature: feature
          });
          break;
      }

      this.drawRect(ctx, feat, props); // second pass for color types that render per-base things that go over the
      // existing drawing

      switch (colorType) {
        case 'perBaseQuality':
          this.colorByPerBaseQuality(ctx, feat, config, region, bpPerPx);
          break;

        case 'modifications':
          this.colorByModifications(ctx, feat, config, region, bpPerPx, props);
          break;

        case 'methylation':
          this.colorByMethylation(ctx, feat, config, region, bpPerPx, props);
          break;
      }
    }
  }, {
    key: "drawMismatches",
    value: function drawMismatches(ctx, feat, props, theme, colorForBase, opts) {
      var mismatchAlpha = opts.mismatchAlpha,
          _opts$drawSNPs = opts.drawSNPs,
          drawSNPs = _opts$drawSNPs === void 0 ? true : _opts$drawSNPs,
          _opts$drawIndels = opts.drawIndels,
          drawIndels = _opts$drawIndels === void 0 ? true : _opts$drawIndels;
      var config = props.config,
          bpPerPx = props.bpPerPx,
          regions = props.regions;
      var heightPx = feat.heightPx,
          topPx = feat.topPx,
          feature = feat.feature;

      var _this$getCharWidthHei = this.getCharWidthHeight(ctx),
          charWidth = _this$getCharWidthHei.charWidth,
          charHeight = _this$getCharWidthHei.charHeight;

      var _regions2 = _slicedToArray(regions, 1),
          region = _regions2[0];

      var start = feature.get('start');
      var minFeatWidth = readConfObject(config, 'minSubfeatureWidth');
      var insertionScale = readConfObject(config, 'largeInsertionIndicatorScale');
      var pxPerBp = Math.min(1 / bpPerPx, 2);
      var w = Math.max(minFeatWidth, pxPerBp);
      var mismatches = feature.get('mismatches');
      var heightLim = charHeight - 2;

      function getAlphaColor(baseColor, mismatch) {
        var color = baseColor;

        if (mismatchAlpha && mismatch.qual !== undefined) {
          color = Color(baseColor).alpha(Math.min(1, mismatch.qual / 50)).hsl().string();
        }

        return color;
      } // two pass rendering: first pass, draw all the mismatches except wide
      // insertion markers


      for (var i = 0; i < mismatches.length; i += 1) {
        var mismatch = mismatches[i];

        var _bpSpanPx11 = bpSpanPx(start + mismatch.start, start + mismatch.start + mismatch.length, region, bpPerPx),
            _bpSpanPx12 = _slicedToArray(_bpSpanPx11, 2),
            mismatchLeftPx = _bpSpanPx12[0],
            mismatchRightPx = _bpSpanPx12[1];

        var mismatchWidthPx = Math.max(minFeatWidth, Math.abs(mismatchLeftPx - mismatchRightPx));

        if (mismatch.type === 'mismatch' && drawSNPs) {
          var baseColor = colorForBase[mismatch.base] || '#888';
          ctx.fillStyle = getAlphaColor(baseColor, mismatch);
          ctx.fillRect(mismatchLeftPx, topPx, mismatchWidthPx, heightPx);

          if (mismatchWidthPx >= charWidth && heightPx >= heightLim) {
            // normal SNP coloring
            ctx.fillStyle = getAlphaColor(theme.palette.getContrastText(baseColor), mismatch);
            ctx.fillText(mismatch.base, mismatchLeftPx + (mismatchWidthPx - charWidth) / 2 + 1, topPx + heightPx);
          }
        } else if (mismatch.type === 'deletion' && drawIndels) {
          var _baseColor = colorForBase.deletion;
          ctx.fillStyle = _baseColor;
          ctx.fillRect(mismatchLeftPx, topPx, mismatchWidthPx, heightPx);

          if (mismatchWidthPx >= charWidth && heightPx >= heightLim) {
            ctx.fillStyle = theme.palette.getContrastText(_baseColor);
            ctx.fillText(mismatch.base, mismatchLeftPx + (mismatchWidthPx - charWidth) / 2 + 1, topPx + heightPx);
          }
        } else if (mismatch.type === 'insertion' && drawIndels) {
          ctx.fillStyle = 'purple';
          var pos = mismatchLeftPx - 1;
          var len = +mismatch.base || mismatch.length;

          if (len < 10) {
            ctx.fillRect(pos, topPx, w, heightPx);

            if (1 / bpPerPx >= charWidth) {
              ctx.fillRect(pos - w, topPx, w * 3, 1);
              ctx.fillRect(pos - w, topPx + heightPx - 1, w * 3, 1);
            }

            if (1 / bpPerPx >= charWidth && heightPx >= heightLim) {
              ctx.fillText("(".concat(mismatch.base, ")"), mismatchLeftPx + 2, topPx + heightPx);
            }
          }
        } else if (mismatch.type === 'hardclip' || mismatch.type === 'softclip') {
          ctx.fillStyle = mismatch.type === 'hardclip' ? 'red' : 'blue';

          var _pos = mismatchLeftPx - 1;

          ctx.fillRect(_pos, topPx + 1, w, heightPx - 2);
          ctx.fillRect(_pos - w, topPx, w * 3, 1);
          ctx.fillRect(_pos - w, topPx + heightPx - 1, w * 3, 1);

          if (mismatchWidthPx >= charWidth && heightPx >= heightLim) {
            ctx.fillText("(".concat(mismatch.base, ")"), mismatchLeftPx + 2, topPx + heightPx);
          }
        } else if (mismatch.type === 'skip') {
          // fix to avoid bad rendering
          // note that this was also related to chrome bug https://bugs.chromium.org/p/chro>
          // ref #1236
          if (mismatchLeftPx + mismatchWidthPx > 0) {
            ctx.clearRect(mismatchLeftPx, topPx, // make small exons more visible when zoomed far out
            mismatchWidthPx - (bpPerPx > 10 ? 1.5 : 0), heightPx);
          }

          ctx.fillStyle = '#333';
          ctx.fillRect(mismatchLeftPx, topPx + heightPx / 2, mismatchWidthPx, 2);
        }
      } // second pass, draw wide insertion markers on top


      if (drawIndels) {
        for (var _i = 0; _i < mismatches.length; _i += 1) {
          var _mismatch = mismatches[_i];

          var _bpSpanPx13 = bpSpanPx(feature.get('start') + _mismatch.start, feature.get('start') + _mismatch.start + _mismatch.length, region, bpPerPx),
              _bpSpanPx14 = _slicedToArray(_bpSpanPx13, 1),
              _mismatchLeftPx = _bpSpanPx14[0];

          var _len = +_mismatch.base || _mismatch.length;

          var txt = "".concat(_len);

          if (_mismatch.type === 'insertion' && _len >= 10) {
            if (bpPerPx > insertionScale) {
              ctx.fillStyle = 'purple';
              ctx.fillRect(_mismatchLeftPx - 1, topPx, 2, heightPx);
            } else if (heightPx > charHeight) {
              var rect = ctx.measureText(txt);
              var padding = 5;
              ctx.fillStyle = 'purple';
              ctx.fillRect(_mismatchLeftPx - rect.width / 2 - padding, topPx, rect.width + 2 * padding, heightPx);
              ctx.fillStyle = 'white';
              ctx.fillText(txt, _mismatchLeftPx - rect.width / 2, topPx + heightPx);
            } else {
              var _padding = 2;
              ctx.fillStyle = 'purple';
              ctx.fillRect(_mismatchLeftPx - _padding, topPx, 2 * _padding, heightPx);
            }
          }
        }
      }
    }
  }, {
    key: "drawSoftClipping",
    value: function drawSoftClipping(ctx, feat, props, config, theme) {
      var feature = feat.feature,
          topPx = feat.topPx,
          heightPx = feat.heightPx;
      var regions = props.regions,
          bpPerPx = props.bpPerPx;

      var _regions3 = _slicedToArray(regions, 1),
          region = _regions3[0];

      var minFeatWidth = readConfObject(config, 'minSubfeatureWidth');
      var mismatches = feature.get('mismatches');
      var seq = feature.get('seq');

      var _this$getCharWidthHei2 = this.getCharWidthHeight(ctx),
          charWidth = _this$getCharWidthHei2.charWidth,
          charHeight = _this$getCharWidthHei2.charHeight;

      var colorForBase = {
        A: theme.palette.bases.A.main,
        C: theme.palette.bases.C.main,
        G: theme.palette.bases.G.main,
        T: theme.palette.bases.T.main,
        deletion: '#808080'
      }; // Display all bases softclipped off in lightened colors

      if (seq) {
        mismatches.filter(function (mismatch) {
          return mismatch.type === 'softclip';
        }).forEach(function (mismatch) {
          var softClipLength = mismatch.cliplen || 0;
          var softClipStart = mismatch.start === 0 ? feature.get('start') - softClipLength : feature.get('start') + mismatch.start;

          for (var k = 0; k < softClipLength; k += 1) {
            var base = seq.charAt(k + mismatch.start); // If softclip length+start is longer than sequence, no need to
            // continue showing base

            if (!base) {
              return;
            }

            var _bpSpanPx15 = bpSpanPx(softClipStart + k, softClipStart + k + 1, region, bpPerPx),
                _bpSpanPx16 = _slicedToArray(_bpSpanPx15, 2),
                softClipLeftPx = _bpSpanPx16[0],
                softClipRightPx = _bpSpanPx16[1];

            var softClipWidthPx = Math.max(minFeatWidth, Math.abs(softClipLeftPx - softClipRightPx)); // Black accounts for IUPAC ambiguity code bases such as N that
            // show in soft clipping

            var baseColor = colorForBase[base] || '#000000';
            ctx.fillStyle = baseColor;
            ctx.fillRect(softClipLeftPx, topPx, softClipWidthPx, heightPx);

            if (softClipWidthPx >= charWidth && heightPx >= charHeight - 5) {
              ctx.fillStyle = theme.palette.getContrastText(baseColor);
              ctx.fillText(base, softClipLeftPx + (softClipWidthPx - charWidth) / 2 + 1, topPx + heightPx);
            }
          }
        });
      }
    }
  }, {
    key: "makeImageData",
    value: function () {
      var _makeImageData = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(ctx, layoutRecords, // eslint-disable-line @typescript-eslint/no-explicit-any
      props) {
        var _this2 = this;

        var layout, config, showSoftClip, colorBy, configTheme, mismatchAlpha, theme, colorForBase;
        return runtime_1.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                layout = props.layout, config = props.config, showSoftClip = props.showSoftClip, colorBy = props.colorBy, configTheme = props.theme;
                mismatchAlpha = readConfObject(config, 'mismatchAlpha');
                theme = createJBrowseTheme(configTheme);
                colorForBase = getColorBaseMap(theme);

                if (layout) {
                  _context.next = 6;
                  break;
                }

                throw new Error("layout required");

              case 6:
                if (layout.addRect) {
                  _context.next = 8;
                  break;
                }

                throw new Error('invalid layout object');

              case 8:
                ctx.font = 'bold 10px Courier New,monospace'; // eslint-disable-next-line @typescript-eslint/no-explicit-any

                layoutRecords.forEach(function (feat) {
                  if (feat === null) {
                    return;
                  }

                  var feature = feat.feature,
                      topPx = feat.topPx,
                      heightPx = feat.heightPx;
                  ctx.fillStyle = readConfObject(config, 'color', {
                    feature: feature
                  });

                  _this2.drawAlignmentRect(ctx, {
                    feature: feature,
                    topPx: topPx,
                    heightPx: heightPx
                  }, props);

                  _this2.drawMismatches(ctx, feat, props, theme, colorForBase, {
                    mismatchAlpha: mismatchAlpha,
                    drawSNPs: shouldDrawMismatches(colorBy === null || colorBy === void 0 ? void 0 : colorBy.type),
                    drawIndels: shouldDrawMismatches(colorBy === null || colorBy === void 0 ? void 0 : colorBy.type)
                  });

                  if (showSoftClip) {
                    _this2.drawSoftClipping(ctx, feat, props, config, theme);
                  }
                });

              case 10:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      function makeImageData(_x, _x2, _x3) {
        return _makeImageData.apply(this, arguments);
      }

      return makeImageData;
    }() // we perform a full layout before render as a separate method because the
    // layout determines the height of the canvas that we use to render

  }, {
    key: "layoutFeats",
    value: function layoutFeats(props) {
      var _this3 = this;

      var layout = props.layout,
          features = props.features,
          sortedBy = props.sortedBy,
          config = props.config,
          bpPerPx = props.bpPerPx,
          showSoftClip = props.showSoftClip,
          regions = props.regions;

      var _regions4 = _slicedToArray(regions, 1),
          region = _regions4[0];

      if (!layout) {
        throw new Error("layout required");
      }

      if (!layout.addRect) {
        throw new Error('invalid layout object');
      }

      var sortedFeatures = sortedBy && sortedBy.type && region.start === sortedBy.pos ? sortFeature(features, sortedBy) : null;
      var featureMap = sortedFeatures || features;
      var layoutRecords = iterMap(featureMap.values(), function (feature) {
        return _this3.layoutFeature(feature, layout, config, bpPerPx, region, showSoftClip);
      }, featureMap.size);
      return layoutRecords;
    }
  }, {
    key: "render",
    value: function () {
      var _render = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(renderProps) {
        var _this4 = this;

        var bpPerPx, regions, features, layout, layoutRecords, _ref4, sequenceAdapter, _regions5, region, _ref5, _ref6, feat, regionSequence, width, height, res, results;

        return runtime_1.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                bpPerPx = renderProps.bpPerPx, regions = renderProps.regions;
                _context2.next = 3;
                return this.getFeatures(renderProps);

              case 3:
                features = _context2.sent;
                layout = this.createLayoutInWorker(renderProps);
                layoutRecords = this.layoutFeats(_objectSpread2(_objectSpread2({}, renderProps), {}, {
                  features: features,
                  layout: layout
                })); // @ts-ignore

                if (!renderProps.adapterConfig.sequenceAdapter) {
                  _context2.next = 12;
                  break;
                }

                _context2.next = 9;
                return getAdapter(this.pluginManager, renderProps.sessionId, // @ts-ignore
                renderProps.adapterConfig.sequenceAdapter);

              case 9:
                _context2.t0 = _context2.sent;
                _context2.next = 13;
                break;

              case 12:
                _context2.t0 = {};

              case 13:
                _ref4 = _context2.t0;
                sequenceAdapter = _ref4.dataAdapter;
                _regions5 = _slicedToArray(regions, 1), region = _regions5[0];

                if (!sequenceAdapter) {
                  _context2.next = 22;
                  break;
                }

                _context2.next = 19;
                return sequenceAdapter.getFeatures({
                  start: region.start,
                  end: region.end + 1,
                  refName: region.refName,
                  assemblyName: region.assemblyName
                }).pipe(toArray()).toPromise();

              case 19:
                _context2.t1 = _context2.sent;
                _context2.next = 23;
                break;

              case 22:
                _context2.t1 = [];

              case 23:
                _ref5 = _context2.t1;
                _ref6 = _slicedToArray(_ref5, 1);
                feat = _ref6[0];
                regionSequence = feat === null || feat === void 0 ? void 0 : feat.get('seq');
                width = (region.end - region.start) / bpPerPx;
                height = Math.max(layout.getTotalHeight(), 1);
                _context2.next = 31;
                return renderToAbstractCanvas(width, height, renderProps, function (ctx) {
                  return _this4.makeImageData(ctx, layoutRecords, _objectSpread2(_objectSpread2({}, renderProps), {}, {
                    layout: layout,
                    features: features,
                    regionSequence: regionSequence
                  }));
                });

              case 31:
                res = _context2.sent;
                _context2.next = 34;
                return _get(_getPrototypeOf(PileupRenderer.prototype), "render", this).call(this, _objectSpread2(_objectSpread2(_objectSpread2({}, renderProps), res), {}, {
                  features: features,
                  layout: layout,
                  height: height,
                  width: width
                }));

              case 34:
                results = _context2.sent;
                return _context2.abrupt("return", _objectSpread2(_objectSpread2(_objectSpread2({}, results), res), {}, {
                  features: features,
                  layout: layout,
                  height: height,
                  width: width,
                  maxHeightReached: layout.maxHeightReached
                }));

              case 36:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function render(_x4) {
        return _render.apply(this, arguments);
      }

      return render;
    }()
  }, {
    key: "createSession",
    value: function createSession(args) {
      return new PileupLayoutSession(args);
    }
  }]);

  return PileupRenderer;
}(BoxRendererType);

var configSchemaFactory = (function (pluginManager) {
  return types.late(function () {
    return ConfigurationSchema('SNPCoverageAdapter', {
      subadapter: pluginManager.pluggableConfigSchemaType('adapter')
    }, {
      explicitlyTyped: true
    });
  });
});

function mismatchLen(mismatch) {
  return !isInterbase(mismatch.type) ? mismatch.length : 1;
}

function isInterbase(type) {
  return type === 'softclip' || type === 'hardclip' || type === 'insertion';
} // eslint-disable-next-line @typescript-eslint/no-explicit-any


function inc(bin, strand, type, field) {
  if (!bin[type][field]) {
    bin[type][field] = {
      total: 0,
      strands: {
        '-1': 0,
        '0': 0,
        '1': 0
      }
    };
  }

  bin[type][field].total++;
  bin[type][field].strands[strand]++;
} // eslint-disable-next-line @typescript-eslint/no-explicit-any


function dec(bin, strand, type, field) {
  if (!bin[type][field]) {
    bin[type][field] = {
      total: 0,
      strands: {
        '-1': 0,
        '0': 0,
        '1': 0
      }
    };
  }

  bin[type][field].total--;
  bin[type][field].strands[strand]--;
}

var SNPCoverageAdapter = /*#__PURE__*/function (_BaseFeatureDataAdapt) {
  _inherits(SNPCoverageAdapter, _BaseFeatureDataAdapt);

  var _super = /*#__PURE__*/_createSuper(SNPCoverageAdapter);

  function SNPCoverageAdapter() {
    _classCallCheck(this, SNPCoverageAdapter);

    return _super.apply(this, arguments);
  }

  _createClass(SNPCoverageAdapter, [{
    key: "configure",
    value: function () {
      var _configure = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee() {
        var _this$getSubAdapter, _this$getSubAdapter2;

        var subadapterConfig, sequenceConf, dataAdapter, sequenceAdapter;
        return runtime_1.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                subadapterConfig = readConfObject(this.config, 'subadapter');
                sequenceConf = readConfObject(this.config, ['subadapter', 'sequenceAdapter']);
                _context.next = 4;
                return (_this$getSubAdapter = this.getSubAdapter) === null || _this$getSubAdapter === void 0 ? void 0 : _this$getSubAdapter.call(this, subadapterConfig);

              case 4:
                dataAdapter = _context.sent;

                if (!sequenceConf) {
                  _context.next = 11;
                  break;
                }

                _context.next = 8;
                return (_this$getSubAdapter2 = this.getSubAdapter) === null || _this$getSubAdapter2 === void 0 ? void 0 : _this$getSubAdapter2.call(this, sequenceConf);

              case 8:
                _context.t0 = _context.sent;
                _context.next = 12;
                break;

              case 11:
                _context.t0 = undefined;

              case 12:
                sequenceAdapter = _context.t0;

                if (dataAdapter) {
                  _context.next = 15;
                  break;
                }

                throw new Error('Failed to get subadapter');

              case 15:
                return _context.abrupt("return", {
                  subadapter: dataAdapter.dataAdapter,
                  sequenceAdapter: sequenceAdapter === null || sequenceAdapter === void 0 ? void 0 : sequenceAdapter.dataAdapter
                });

              case 16:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function configure() {
        return _configure.apply(this, arguments);
      }

      return configure;
    }()
  }, {
    key: "getFeatures",
    value: function getFeatures(region) {
      var _this = this;

      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return ObservableCreate( /*#__PURE__*/function () {
        var _ref = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(observer) {
          var _yield$_this$configur, subadapter, stream, filters, bins;

          return runtime_1.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  _context2.next = 2;
                  return _this.configure();

                case 2:
                  _yield$_this$configur = _context2.sent;
                  subadapter = _yield$_this$configur.subadapter;
                  stream = subadapter.getFeatures(region, opts);

                  if (opts.filters) {
                    filters = opts.filters;
                    stream = stream.pipe(filter(function (f) {
                      return filters.passes(f, opts);
                    }));
                  }

                  _context2.next = 8;
                  return _this.generateCoverageBins(stream, region, opts);

                case 8:
                  bins = _context2.sent;
                  bins.forEach(function (bin, index) {
                    if (bin.total) {
                      observer.next(new SimpleFeature({
                        id: "".concat(_this.id, "-").concat(region.start, "-").concat(index),
                        data: {
                          score: bin.total,
                          snpinfo: bin,
                          start: region.start + index,
                          end: region.start + index + 1,
                          refName: region.refName
                        }
                      }));
                    }
                  });
                  observer.complete();

                case 11:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2);
        }));

        return function (_x) {
          return _ref.apply(this, arguments);
        };
      }(), opts.signal);
    }
  }, {
    key: "getRefNames",
    value: function () {
      var _getRefNames = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3() {
        var opts,
            _yield$this$configure,
            subadapter,
            _args3 = arguments;

        return runtime_1.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                opts = _args3.length > 0 && _args3[0] !== undefined ? _args3[0] : {};
                _context3.next = 3;
                return this.configure();

              case 3:
                _yield$this$configure = _context3.sent;
                subadapter = _yield$this$configure.subadapter;
                return _context3.abrupt("return", subadapter.getRefNames(opts));

              case 6:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function getRefNames() {
        return _getRefNames.apply(this, arguments);
      }

      return getRefNames;
    }()
  }, {
    key: "freeResources",
    value: function freeResources()
    /* { region } */
    {}
    /**
     * Generates coverage bins from features which details
     * the reference, mismatches, strands, and coverage info
     * @param features - Features of region to be passed in
     * @param region - Region
     * @param bpPerPx - base pairs per pixel
     * @returns Array of nested frequency tables
     */

  }, {
    key: "generateCoverageBins",
    value: function () {
      var _generateCoverageBins = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee4(features, region, opts) {
        var colorBy, _yield$this$configure2, sequenceAdapter, refName, start, end, binMax, initBins, regionSeq, _yield$sequenceAdapte, _yield$sequenceAdapte2, feat;

        return runtime_1.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                colorBy = opts.colorBy;
                _context4.next = 3;
                return this.configure();

              case 3:
                _yield$this$configure2 = _context4.sent;
                sequenceAdapter = _yield$this$configure2.sequenceAdapter;
                refName = region.refName, start = region.start, end = region.end;
                binMax = Math.ceil(region.end - region.start);
                initBins = Array.from({
                  length: binMax
                }, function () {
                  return {
                    total: 0,
                    lowqual: {},
                    cov: {},
                    delskips: {},
                    noncov: {},
                    ref: {}
                  };
                }); // request an extra +1 on the end to get CpG crossing region boundary

                if (!sequenceAdapter) {
                  _context4.next = 15;
                  break;
                }

                _context4.next = 11;
                return sequenceAdapter.getFeatures({
                  refName: refName,
                  start: start,
                  end: end + 1,
                  assemblyName: 'na'
                }).pipe(toArray()).toPromise();

              case 11:
                _yield$sequenceAdapte = _context4.sent;
                _yield$sequenceAdapte2 = _slicedToArray(_yield$sequenceAdapte, 1);
                feat = _yield$sequenceAdapte2[0];
                regionSeq = feat === null || feat === void 0 ? void 0 : feat.get('seq');

              case 15:
                return _context4.abrupt("return", features.pipe(reduce(function (bins, feature) {
                  var cigar = feature.get('CIGAR');
                  var fstart = feature.get('start');
                  var fend = feature.get('end');
                  var fstrand = feature.get('strand');
                  var cigarOps = parseCigar(cigar);

                  for (var j = fstart; j < fend; j++) {
                    var i = j - region.start;

                    if (i >= 0 && i < bins.length) {
                      var bin = bins[i];
                      bin.total++;
                      inc(bin, fstrand, 'ref', 'ref');
                    }
                  }

                  if ((colorBy === null || colorBy === void 0 ? void 0 : colorBy.type) === 'modifications') {
                    var seq = feature.get('seq');
                    var mm = getTagAlt(feature, 'MM', 'Mm') || '';
                    var ml = getTagAlt(feature, 'ML', 'Ml') || [];
                    var probabilities = ml ? (typeof ml === 'string' ? ml.split(',').map(function (e) {
                      return +e;
                    }) : ml).map(function (e) {
                      return e / 255;
                    }) : getTagAlt(feature, 'MP', 'Mp').split('').map(function (s) {
                      return s.charCodeAt(0) - 33;
                    }).map(function (elt) {
                      return Math.min(1, elt / 50);
                    });
                    var probIndex = 0;
                    getModificationPositions(mm, seq).forEach(function (_ref2) {
                      var type = _ref2.type,
                          positions = _ref2.positions;
                      var mod = "mod_".concat(type);

                      var _iterator = _createForOfIteratorHelper(getNextRefPos(cigarOps, positions)),
                          _step;

                      try {
                        for (_iterator.s(); !(_step = _iterator.n()).done;) {
                          var pos = _step.value;
                          var epos = pos + fstart - region.start;

                          if (epos >= 0 && epos < bins.length && pos + fstart < fend) {
                            var _bin = bins[epos];

                            if (probabilities[probIndex] > 0.5) {
                              inc(_bin, fstrand, 'cov', mod);
                            } else {
                              inc(_bin, fstrand, 'lowqual', mod);
                            }
                          }

                          probIndex++;
                        }
                      } catch (err) {
                        _iterator.e(err);
                      } finally {
                        _iterator.f();
                      }
                    });
                  } // methylation based coloring takes into account both reference
                  // sequence CpG detection and reads
                  else // methylation based coloring takes into account both reference
                    // sequence CpG detection and reads
                    if ((colorBy === null || colorBy === void 0 ? void 0 : colorBy.type) === 'methylation') {
                      if (!regionSeq) {
                        throw new Error('no region sequence detected, need sequenceAdapter configuration');
                      }

                      var _seq = feature.get('seq');

                      var _mm = getTagAlt(feature, 'MM', 'Mm') || '';

                      var methBins = new Array(region.end - region.start).fill(0);
                      getModificationPositions(_mm, _seq).forEach(function (_ref3) {
                        var type = _ref3.type,
                            positions = _ref3.positions;

                        // we are processing methylation
                        if (type === 'm') {
                          var _iterator2 = _createForOfIteratorHelper(getNextRefPos(cigarOps, positions)),
                              _step2;

                          try {
                            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                              var pos = _step2.value;
                              var epos = pos + fstart - region.start;

                              if (epos >= 0 && epos < methBins.length) {
                                methBins[epos] = 1;
                              }
                            }
                          } catch (err) {
                            _iterator2.e(err);
                          } finally {
                            _iterator2.f();
                          }
                        }
                      });

                      for (var _j = fstart; _j < fend; _j++) {
                        var _i = _j - region.start;

                        if (_i >= 0 && _i < bins.length) {
                          var l2 = regionSeq[_i + 1];
                          var l1 = regionSeq[_i];
                          var _bin2 = bins[_i]; // color

                          // color
                          if (l1.toUpperCase() === 'C' && l2.toUpperCase() === 'G') {
                            if (methBins[_i]) {
                              inc(_bin2, fstrand, 'cov', 'meth');
                              dec(_bin2, fstrand, 'ref', 'ref');
                            } else {
                              inc(_bin2, fstrand, 'cov', 'unmeth');
                              dec(_bin2, fstrand, 'ref', 'ref');
                            }
                          }
                        }
                      }
                    } // normal SNP based coloring
                    else // normal SNP based coloring
                      {
                        var mismatches = feature.get('mismatches');

                        for (var _i2 = 0; _i2 < (mismatches === null || mismatches === void 0 ? void 0 : mismatches.length); _i2++) {
                          var mismatch = mismatches[_i2];
                          var mstart = fstart + mismatch.start;

                          for (var _j2 = mstart; _j2 < mstart + mismatchLen(mismatch); _j2++) {
                            var epos = _j2 - region.start;

                            if (epos >= 0 && epos < bins.length) {
                              var _bin3 = bins[epos];
                              var base = mismatch.base,
                                  type = mismatch.type;
                              var interbase = isInterbase(type);

                              if (!interbase) {
                                dec(_bin3, fstrand, 'ref', 'ref');
                              } else {
                                inc(_bin3, fstrand, 'noncov', type);
                              }

                              if (type === 'deletion' || type === 'skip') {
                                inc(_bin3, fstrand, 'delskips', type);
                                _bin3.total--;
                              } else if (!interbase) {
                                inc(_bin3, fstrand, 'cov', base);
                              }
                            }
                          }
                        }
                      }

                  return bins;
                }, initBins)).toPromise());

              case 16:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function generateCoverageBins(_x2, _x3, _x4) {
        return _generateCoverageBins.apply(this, arguments);
      }

      return generateCoverageBins;
    }()
  }]);

  return SNPCoverageAdapter;
}(BaseFeatureDataAdapter);
var capabilities = SNPCoverageAdapter.capabilities;

var SNPCoverageAdapter$1 = {
  __proto__: null,
  'default': SNPCoverageAdapter,
  capabilities: capabilities
};

var SNPCoverageAdapterF = (function (pluginManager) {
  return {
    getAdapterClass: function getAdapterClass() {
      return Promise.resolve().then(function () { return SNPCoverageAdapter$1; }).then(function (r) {
        return r["default"];
      });
    },
    configSchema: configSchemaFactory(pluginManager),
    adapterCapabilities: capabilities
  };
});

var ConfigSchema = /*#__PURE__*/ConfigurationSchema('SNPCoverageRenderer', {
  clipColor: {
    type: 'color',
    description: 'the color of the clipping marker',
    defaultValue: 'red'
  },
  indicatorThreshold: {
    type: 'number',
    description: 'the proportion of reads containing a insertion/clip indicator',
    defaultValue: 0.3
  },
  drawInterbaseCounts: {
    type: 'boolean',
    description: 'draw count "upsidedown histogram" of the interbase events that don\'t contribute to the coverage count so are not drawn in the normal histogram',
    defaultValue: true
  },
  drawIndicators: {
    type: 'boolean',
    description: 'draw a triangular indicator where an event has been detected',
    defaultValue: true
  }
}, {
  explicitlyTyped: true
});

var SNPCoverageRenderer = /*#__PURE__*/function (_WiggleBaseRenderer) {
  _inherits(SNPCoverageRenderer, _WiggleBaseRenderer);

  var _super = /*#__PURE__*/_createSuper(SNPCoverageRenderer);

  function SNPCoverageRenderer() {
    _classCallCheck(this, SNPCoverageRenderer);

    return _super.apply(this, arguments);
  }

  _createClass(SNPCoverageRenderer, [{
    key: "draw",
    value: // note: the snps are drawn on linear scale even if the data is drawn in log
    // scape hence the two different scales being used
    function draw(ctx, props) {
      var features = props.features,
          regions = props.regions,
          bpPerPx = props.bpPerPx,
          scaleOpts = props.scaleOpts,
          unadjustedHeight = props.height,
          configTheme = props.theme,
          cfg = props.config,
          displayCrossHatches = props.displayCrossHatches,
          values = props.ticks.values,
          modificationTagMap = props.modificationTagMap;
      var theme = createJBrowseTheme(configTheme);

      var _regions = _slicedToArray(regions, 1),
          region = _regions[0];

      var width = (region.end - region.start) / bpPerPx; // the adjusted height takes into account YSCALEBAR_LABEL_OFFSET from the
      // wiggle display, and makes the height of the actual drawn area add
      // "padding" to the top and bottom of the display

      var offset = YSCALEBAR_LABEL_OFFSET;
      var height = unadjustedHeight - offset * 2;

      var opts = _objectSpread2(_objectSpread2({}, scaleOpts), {}, {
        range: [0, height]
      });

      var viewScale = getScale(opts);
      var snpViewScale = getScale(_objectSpread2(_objectSpread2({}, opts), {}, {
        scaleType: 'linear'
      }));
      var originY = getOrigin(scaleOpts.scaleType);
      var snpOriginY = getOrigin('linear');
      var indicatorThreshold = readConfObject(cfg, 'indicatorThreshold');
      var drawInterbaseCounts = readConfObject(cfg, 'drawInterbaseCounts');
      var drawIndicators = readConfObject(cfg, 'drawIndicators'); // get the y coordinate that we are plotting at, this can be log scale

      var toY = function toY(n) {
        return height - viewScale(n) + offset;
      };

      var toHeight = function toHeight(n) {
        return toY(originY) - toY(n);
      }; // this is always linear scale, even when plotted on top of log scale


      var snpToY = function snpToY(n) {
        return height - snpViewScale(n) + offset;
      };

      var snpToHeight = function snpToHeight(n) {
        return snpToY(snpOriginY) - snpToY(n);
      };

      var colorForBase = {
        A: theme.palette.bases.A.main,
        C: theme.palette.bases.C.main,
        G: theme.palette.bases.G.main,
        T: theme.palette.bases.T.main,
        total: 'lightgrey',
        insertion: 'purple',
        softclip: 'blue',
        hardclip: 'red',
        meth: 'red',
        unmeth: 'blue',
        ref: 'lightgrey'
      }; // Use two pass rendering, which helps in visualizing the SNPs at higher
      // bpPerPx First pass: draw the gray background

      ctx.fillStyle = colorForBase.total;

      var _iterator = _createForOfIteratorHelper(features.values()),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var feature = _step.value;

          var _featureSpanPx = featureSpanPx(feature, region, bpPerPx),
              _featureSpanPx2 = _slicedToArray(_featureSpanPx, 2),
              leftPx = _featureSpanPx2[0],
              rightPx = _featureSpanPx2[1];

          var w = rightPx - leftPx + 0.3;
          var score = feature.get('score');
          ctx.fillRect(leftPx, toY(score), w, toHeight(score));
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      ctx.fillStyle = 'grey';
      ctx.beginPath();
      ctx.lineTo(0, 0);
      ctx.moveTo(0, width);
      ctx.stroke(); // Second pass: draw the SNP data, and add a minimum feature width of 1px
      // which can be wider than the actual bpPerPx This reduces overdrawing of
      // the grey background over the SNPs

      var _iterator2 = _createForOfIteratorHelper(features.values()),
          _step2;

      try {
        var _loop = function _loop() {
          var feature = _step2.value;

          var _featureSpanPx3 = featureSpanPx(feature, region, bpPerPx),
              _featureSpanPx4 = _slicedToArray(_featureSpanPx3, 2),
              leftPx = _featureSpanPx4[0],
              rightPx = _featureSpanPx4[1];

          var snpinfo = feature.get('snpinfo');
          var w = Math.max(rightPx - leftPx + 0.3, 1);
          var totalScore = snpinfo.total;
          Object.entries(snpinfo.cov).sort(function (_ref, _ref2) {
            var _ref3 = _slicedToArray(_ref, 1),
                a = _ref3[0];

            var _ref4 = _slicedToArray(_ref2, 1),
                b = _ref4[0];

            if (a < b) {
              return -1;
            }

            if (a > b) {
              return 1;
            }

            return 0;
          }).reduce(function (curr, _ref5) {
            var _ref6 = _slicedToArray(_ref5, 2),
                base = _ref6[0],
                total = _ref6[1].total;

            ctx.fillStyle = colorForBase[base] || modificationTagMap[base.replace('mod_', '')] || 'red';
            ctx.fillRect(leftPx, snpToY(total + curr), w, snpToHeight(total));
            return curr + total;
          }, 0);
          var interbaseEvents = Object.entries(snpinfo.noncov);
          var indicatorHeight = 4.5;

          if (drawInterbaseCounts) {
            interbaseEvents.reduce(function (curr, _ref7) {
              var _ref8 = _slicedToArray(_ref7, 2),
                  base = _ref8[0],
                  total = _ref8[1].total;

              ctx.fillStyle = colorForBase[base];
              ctx.fillRect(leftPx - 0.6, indicatorHeight + snpToHeight(curr), 1.2, snpToHeight(total));
              return curr + total;
            }, 0);
          }

          if (drawIndicators) {
            var accum = 0;
            var max = 0;
            var maxBase = '';
            interbaseEvents.forEach(function (_ref9) {
              var _ref10 = _slicedToArray(_ref9, 2),
                  base = _ref10[0],
                  total = _ref10[1].total;

              accum += total;

              if (total > max) {
                max = total;
                maxBase = base;
              }
            }); // avoid drawing a bunch of indicators if coverage is very low e.g.
            // less than 7

            if (accum > totalScore * indicatorThreshold && totalScore > 7) {
              ctx.fillStyle = colorForBase[maxBase];
              ctx.beginPath();
              ctx.moveTo(leftPx - 3, 0);
              ctx.lineTo(leftPx + 3, 0);
              ctx.lineTo(leftPx, indicatorHeight);
              ctx.fill();
            }
          }
        };

        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          _loop();
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      if (displayCrossHatches) {
        ctx.lineWidth = 1;
        ctx.strokeStyle = 'rgba(140,140,140,0.8)';
        values.forEach(function (tick) {
          ctx.beginPath();
          ctx.moveTo(0, Math.round(toY(tick)));
          ctx.lineTo(width, Math.round(toY(tick)));
          ctx.stroke();
        });
      }
    }
  }]);

  return SNPCoverageRenderer;
}(WiggleBaseRenderer);

var configSchema$3 = /*#__PURE__*/ConfigurationSchema('SNPCoverageRenderer', {}, {
  baseConfiguration: ConfigSchema,
  explicitlyTyped: true
});

var PileupGetGlobalValueForTag = /*#__PURE__*/function (_RpcMethodType) {
  _inherits(PileupGetGlobalValueForTag, _RpcMethodType);

  var _super = /*#__PURE__*/_createSuper(PileupGetGlobalValueForTag);

  function PileupGetGlobalValueForTag() {
    var _this;

    _classCallCheck(this, PileupGetGlobalValueForTag);

    _this = _super.apply(this, arguments);
    _this.name = 'PileupGetGlobalValueForTag';
    return _this;
  }

  _createClass(PileupGetGlobalValueForTag, [{
    key: "serializeArguments",
    value: function () {
      var _serializeArguments = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee(args) {
        var _rootModel$session;

        var rootModel, assemblyManager;
        return runtime_1.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                rootModel = this.pluginManager.rootModel;
                assemblyManager = rootModel === null || rootModel === void 0 ? void 0 : (_rootModel$session = rootModel.session) === null || _rootModel$session === void 0 ? void 0 : _rootModel$session.assemblyManager;

                if (assemblyManager) {
                  _context.next = 4;
                  break;
                }

                throw new Error('no assembly manager available');

              case 4:
                return _context.abrupt("return", renameRegionsIfNeeded(assemblyManager, args));

              case 5:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function serializeArguments(_x) {
        return _serializeArguments.apply(this, arguments);
      }

      return serializeArguments;
    }()
  }, {
    key: "execute",
    value: function () {
      var _execute = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(args, rpcDriverClassName) {
        var deserializedArgs, adapterConfig, sessionId, regions, tag, dataAdapter, features, featuresArray, uniqueValues;
        return runtime_1.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.deserializeArguments(args, rpcDriverClassName);

              case 2:
                deserializedArgs = _context2.sent;
                adapterConfig = deserializedArgs.adapterConfig, sessionId = deserializedArgs.sessionId, regions = deserializedArgs.regions, tag = deserializedArgs.tag;
                _context2.next = 6;
                return getAdapter(this.pluginManager, sessionId, adapterConfig);

              case 6:
                dataAdapter = _context2.sent.dataAdapter;
                features = dataAdapter.getFeaturesInMultipleRegions(regions);
                _context2.next = 10;
                return features.pipe(toArray()).toPromise();

              case 10:
                featuresArray = _context2.sent;
                uniqueValues = new Set();
                featuresArray.forEach(function (feature) {
                  var tags = feature.get('tags');
                  var val = tags ? tags[tag] : feature.get(tag);

                  if (val !== undefined) {
                    uniqueValues.add("".concat(val));
                  }
                });
                return _context2.abrupt("return", _toConsumableArray(uniqueValues));

              case 14:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function execute(_x2, _x3) {
        return _execute.apply(this, arguments);
      }

      return execute;
    }()
  }]);

  return PileupGetGlobalValueForTag;
}(RpcMethodType);
var PileupGetVisibleModifications = /*#__PURE__*/function (_RpcMethodType2) {
  _inherits(PileupGetVisibleModifications, _RpcMethodType2);

  var _super2 = /*#__PURE__*/_createSuper(PileupGetVisibleModifications);

  function PileupGetVisibleModifications() {
    var _this2;

    _classCallCheck(this, PileupGetVisibleModifications);

    _this2 = _super2.apply(this, arguments);
    _this2.name = 'PileupGetVisibleModifications';
    return _this2;
  }

  _createClass(PileupGetVisibleModifications, [{
    key: "serializeArguments",
    value: function () {
      var _serializeArguments2 = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3(args) {
        var _rootModel$session2;

        var rootModel, assemblyManager;
        return runtime_1.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                rootModel = this.pluginManager.rootModel;
                assemblyManager = rootModel === null || rootModel === void 0 ? void 0 : (_rootModel$session2 = rootModel.session) === null || _rootModel$session2 === void 0 ? void 0 : _rootModel$session2.assemblyManager;

                if (assemblyManager) {
                  _context3.next = 4;
                  break;
                }

                throw new Error('no assembly manager available');

              case 4:
                return _context3.abrupt("return", renameRegionsIfNeeded(assemblyManager, args));

              case 5:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function serializeArguments(_x4) {
        return _serializeArguments2.apply(this, arguments);
      }

      return serializeArguments;
    }()
  }, {
    key: "execute",
    value: function () {
      var _execute2 = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee4(args, rpcDriverClassName) {
        var deserializedArgs, adapterConfig, sessionId, regions, dataAdapter, features, featuresArray, uniqueValues;
        return runtime_1.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this.deserializeArguments(args, rpcDriverClassName);

              case 2:
                deserializedArgs = _context4.sent;
                adapterConfig = deserializedArgs.adapterConfig, sessionId = deserializedArgs.sessionId, regions = deserializedArgs.regions;
                _context4.next = 6;
                return getAdapter(this.pluginManager, sessionId, adapterConfig);

              case 6:
                dataAdapter = _context4.sent.dataAdapter;
                features = dataAdapter.getFeaturesInMultipleRegions(regions);
                _context4.next = 10;
                return features.pipe(toArray()).toPromise();

              case 10:
                featuresArray = _context4.sent;
                uniqueValues = new Set();
                featuresArray.forEach(function (feature) {
                  var val = getTagAlt(feature, 'MM', 'Mm') || '';

                  if (val !== undefined) {
                    getModificationTypes(val).forEach(function (t) {
                      return uniqueValues.add(t);
                    });
                  }
                });
                return _context4.abrupt("return", _toConsumableArray(uniqueValues));

              case 14:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function execute(_x5, _x6) {
        return _execute2.apply(this, arguments);
      }

      return execute;
    }()
  }]);

  return PileupGetVisibleModifications;
}(RpcMethodType);

var AlignmentsPlugin = /*#__PURE__*/function (_Plugin) {
  _inherits(AlignmentsPlugin, _Plugin);

  var _super = /*#__PURE__*/_createSuper(AlignmentsPlugin);

  function AlignmentsPlugin() {
    var _this;

    _classCallCheck(this, AlignmentsPlugin);

    _this = _super.apply(this, arguments);
    _this.name = 'AlignmentsPlugin';
    return _this;
  }

  _createClass(AlignmentsPlugin, [{
    key: "install",
    value: function install(pluginManager) {
      pluginManager.addTrackType(function () {
        var configSchema = ConfigurationSchema('AlignmentsTrack', {}, {
          baseConfiguration: createBaseTrackConfig(pluginManager)
        });
        var track = new TrackType({
          name: 'AlignmentsTrack',
          configSchema: configSchema,
          stateModel: createBaseTrackModel(pluginManager, 'AlignmentsTrack', configSchema)
        });
        var linearAlignmentsDisplay = pluginManager.getDisplayType('LinearAlignmentsDisplay'); // Add LinearAlignmentsDisplay here so that it has priority over the other
        // linear displays (defaults to order the displays are added, but we have
        // to add the Pileup and SNPCoverage displays first).

        track.addDisplayType(linearAlignmentsDisplay);
        return track;
      });
      pluginManager.addDisplayType(function () {
        var configSchema = PileupConfigFactory(pluginManager);
        return new DisplayType({
          name: 'LinearPileupDisplay',
          configSchema: configSchema,
          stateModel: stateModelFactory$2(pluginManager, configSchema),
          trackType: 'AlignmentsTrack',
          viewType: 'LinearGenomeView',
          ReactComponent: BaseLinearDisplayComponent
        });
      });
      pluginManager.addDisplayType(function () {
        var configSchema = SNPCoverageConfigFactory(pluginManager);
        return new DisplayType({
          name: 'LinearSNPCoverageDisplay',
          configSchema: configSchema,
          stateModel: stateModelFactory$3(pluginManager, configSchema),
          trackType: 'AlignmentsTrack',
          viewType: 'LinearGenomeView',
          ReactComponent: LinearWiggleDisplayReactComponent
        });
      });
      pluginManager.addDisplayType(function () {
        var configSchema = configModelFactory(pluginManager);
        return new DisplayType({
          name: 'LinearAlignmentsDisplay',
          configSchema: configSchema,
          stateModel: stateModelFactory$1(pluginManager, configSchema),
          trackType: 'AlignmentsTrack',
          viewType: 'LinearGenomeView',
          ReactComponent: LinearAlignmentsDisplayReactComponent
        });
      });
      pluginManager.addWidgetType(function () {
        return new WidgetType({
          name: 'AlignmentsFeatureWidget',
          heading: 'Feature details',
          configSchema: configSchema,
          stateModel: stateModelFactory(pluginManager),
          ReactComponent: /*#__PURE__*/lazy(function () {
            return Promise.resolve().then(function () { return AlignmentsFeatureDetail$1; });
          })
        });
      });
      pluginManager.addAdapterType(function () {
        return new AdapterType(_objectSpread2({
          name: 'BamAdapter'
        }, pluginManager.load(BamAdapterF)));
      });
      pluginManager.addAdapterType(function () {
        return new AdapterType(_objectSpread2({
          name: 'SNPCoverageAdapter'
        }, pluginManager.load(SNPCoverageAdapterF)));
      });
      pluginManager.addAdapterType(function () {
        return new AdapterType(_objectSpread2({
          name: 'CramAdapter'
        }, pluginManager.load(CramAdapterF)));
      });
      pluginManager.addAdapterType(function () {
        return new AdapterType(_objectSpread2({
          name: 'HtsgetBamAdapter'
        }, pluginManager.load(HtsgetBamAdapterF)));
      });
      pluginManager.addRendererType(function () {
        return new PileupRenderer({
          name: 'PileupRenderer',
          ReactComponent: PileupRendererReactComponent,
          configSchema: pileupRendererConfigSchema,
          pluginManager: pluginManager
        });
      });
      pluginManager.addRendererType(function () {
        return new SNPCoverageRenderer({
          name: 'SNPCoverageRenderer',
          ReactComponent: WiggleRendering,
          configSchema: configSchema$3,
          pluginManager: pluginManager
        });
      });
      pluginManager.addRpcMethod(function () {
        return new PileupGetGlobalValueForTag(pluginManager);
      });
      pluginManager.addRpcMethod(function () {
        return new PileupGetVisibleModifications(pluginManager);
      });
    }
  }]);

  return AlignmentsPlugin;
}(Plugin);

var BamSlightlyLazyFeature = /*#__PURE__*/function () {
  function BamSlightlyLazyFeature(record, adapter, ref) {
    _classCallCheck(this, BamSlightlyLazyFeature);

    this.record = record;
    this.adapter = adapter;
    this.ref = ref;
  }

  _createClass(BamSlightlyLazyFeature, [{
    key: "_get_name",
    value: function _get_name() {
      return this.record.get('name');
    }
  }, {
    key: "_get_type",
    value: function _get_type() {
      return 'match';
    }
  }, {
    key: "_get_score",
    value: function _get_score() {
      return this.record.get('mq');
    }
  }, {
    key: "_get_flags",
    value: function _get_flags() {
      // @ts-ignore
      return this.record.flags;
    }
  }, {
    key: "_get_strand",
    value: function _get_strand() {
      return this.record.isReverseComplemented() ? -1 : 1;
    }
  }, {
    key: "_get_read_group_id",
    value: function _get_read_group_id() {
      // @ts-ignore
      return this.record.readGroupId;
    }
  }, {
    key: "_get_pair_orientation",
    value: function _get_pair_orientation() {
      return this.record.isPaired() ? this.record.getPairOrientation() : undefined;
    }
  }, {
    key: "_get_next_seq_id",
    value: function _get_next_seq_id() {
      return this.record._next_refid();
    }
  }, {
    key: "_get_seq_id",
    value: function _get_seq_id() {
      // @ts-ignore
      return this.record._refID;
    }
  }, {
    key: "_get_next_refName",
    value: function _get_next_refName() {
      return this.adapter.refIdToName(this.record._next_refid());
    }
  }, {
    key: "_get_next_segment_position",
    value: function _get_next_segment_position() {
      return this.record.isPaired() ? "".concat(this.adapter.refIdToName(this.record._next_refid()), ":").concat(this.record._next_pos() + 1) : undefined;
    }
  }, {
    key: "_get_seq",
    value: function _get_seq() {
      return this.record.getReadBases();
    }
  }, {
    key: "_get_MD",
    value: function _get_MD() {
      var md = this.record.get('MD');
      var seq = this.get('seq');

      if (!md && seq && this.ref) {
        return generateMD(this.ref, this.record.getReadBases(), this.get('CIGAR'));
      }

      return md;
    }
  }, {
    key: "qualRaw",
    value: function qualRaw() {
      return this.record.qualRaw();
    }
  }, {
    key: "set",
    value: function set() {}
  }, {
    key: "tags",
    value: function tags() {
      var properties = Object.getOwnPropertyNames(BamSlightlyLazyFeature.prototype);
      return _toConsumableArray(new Set(properties.filter(function (prop) {
        return prop.startsWith('_get_') && prop !== '_get_mismatches' && prop !== '_get_skips_and_dels' && prop !== '_get_cram_read_features' && prop !== '_get_tags' && prop !== '_get_next_seq_id' && prop !== '_get_seq_id';
      }).map(function (methodName) {
        return methodName.replace('_get_', '');
      }).concat(this.record._tags())));
    }
  }, {
    key: "id",
    value: function id() {
      return "".concat(this.adapter.id, "-").concat(this.record.id());
    } // eslint-disable-next-line @typescript-eslint/no-explicit-any

  }, {
    key: "get",
    value: function get(field) {
      var methodName = "_get_".concat(field); // @ts-ignore

      if (this[methodName]) {
        // @ts-ignore
        return this[methodName]();
      }

      return this.record.get(field);
    }
  }, {
    key: "_get_refName",
    value: function _get_refName() {
      return this.adapter.refIdToName(this.record.seq_id());
    }
  }, {
    key: "parent",
    value: function parent() {
      return undefined;
    }
  }, {
    key: "children",
    value: function children() {
      return undefined;
    }
  }, {
    key: "pairedFeature",
    value: function pairedFeature() {
      return false;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var _this = this;

      var tags = Object.fromEntries(this.tags().map(function (t) {
        return [t, _this.get(t)];
      }).filter(function (elt) {
        return elt[1] !== undefined;
      }));
      return _objectSpread2(_objectSpread2({}, tags), {}, {
        uniqueId: this.id()
      });
    }
  }, {
    key: "_get_skips_and_dels",
    value: function _get_skips_and_dels() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
        cigarAttributeName: 'CIGAR'
      };
      var cigarAttributeName = opts.cigarAttributeName;
      var mismatches = [];
      var cigarOps = []; // parse the CIGAR tag if it has one

      var cigarString = this.get(cigarAttributeName);

      if (cigarString) {
        cigarOps = parseCigar(cigarString);
        mismatches = mismatches.concat(cigarToMismatches(cigarOps, this.get('seq'), this.qualRaw()));
      }

      return mismatches;
    }
  }, {
    key: "_get_mismatches",
    value: function _get_mismatches() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref$cigarAttributeNa = _ref.cigarAttributeName,
          cigarAttributeName = _ref$cigarAttributeNa === void 0 ? 'CIGAR' : _ref$cigarAttributeNa,
          _ref$mdAttributeName = _ref.mdAttributeName,
          mdAttributeName = _ref$mdAttributeName === void 0 ? 'MD' : _ref$mdAttributeName;

      var mismatches = [];
      var cigarOps = []; // parse the CIGAR tag if it has one

      var cigarString = this.get(cigarAttributeName);

      if (cigarString) {
        cigarOps = parseCigar(cigarString);
        mismatches = mismatches.concat(cigarToMismatches(cigarOps, this.get('seq'), this.qualRaw()));
      } // now let's look for CRAM or MD mismatches


      var mdString = this.get(mdAttributeName);

      if (mdString) {
        mismatches = mismatches.concat(mdToMismatches(mdString, cigarOps, mismatches, this.get('seq'), this.qualRaw()));
      } // uniqify the mismatches


      var seen = {};
      return mismatches.filter(function (m) {
        var key = "".concat(m.type, ",").concat(m.start, ",").concat(m.length);
        var s = seen[key];
        seen[key] = true;
        return !s;
      });
    }
  }, {
    key: "_get_clipPos",
    value: function _get_clipPos() {
      var cigar = this.get('CIGAR') || '';
      return this.get('strand') === -1 ? +(cigar.match(/(\d+)[SH]$/) || [])[1] || 0 : +(cigar.match(/^(\d+)([SH])/) || [])[1] || 0;
    }
  }]);

  return BamSlightlyLazyFeature;
}();

var BamAdapter = /*#__PURE__*/function (_BaseFeatureDataAdapt) {
  _inherits(BamAdapter, _BaseFeatureDataAdapt);

  var _super = /*#__PURE__*/_createSuper(BamAdapter);

  function BamAdapter() {
    _classCallCheck(this, BamAdapter);

    return _super.apply(this, arguments);
  }

  _createClass(BamAdapter, [{
    key: "configure",
    value: // derived classes may not use the same configuration so a custom
    // configure method allows derived classes to override this behavior
    function () {
      var _configure = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee() {
        var bamLocation, location, indexType, chunkSizeLimit, fetchSizeLimit, bam, adapterConfig;
        return runtime_1.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!this.configured) {
                  bamLocation = readConfObject(this.config, 'bamLocation');
                  location = readConfObject(this.config, ['index', 'location']);
                  indexType = readConfObject(this.config, ['index', 'indexType']);
                  chunkSizeLimit = readConfObject(this.config, 'chunkSizeLimit');
                  fetchSizeLimit = readConfObject(this.config, 'fetchSizeLimit');
                  bam = new BamFile({
                    bamFilehandle: openLocation(bamLocation),
                    csiFilehandle: indexType === 'CSI' ? openLocation(location) : undefined,
                    baiFilehandle: indexType !== 'CSI' ? openLocation(location) : undefined,
                    chunkSizeLimit: chunkSizeLimit,
                    fetchSizeLimit: fetchSizeLimit
                  });
                  adapterConfig = readConfObject(this.config, 'sequenceAdapter');

                  if (adapterConfig && this.getSubAdapter) {
                    this.configured = this.getSubAdapter(adapterConfig).then(function (_ref) {
                      var dataAdapter = _ref.dataAdapter;
                      return {
                        bam: bam,
                        sequenceAdapter: dataAdapter
                      };
                    });
                  } else {
                    this.configured = Promise.resolve({
                      bam: bam
                    });
                  }
                }

                return _context.abrupt("return", this.configured);

              case 2:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function configure() {
        return _configure.apply(this, arguments);
      }

      return configure;
    }()
  }, {
    key: "getHeader",
    value: function () {
      var _getHeader = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(opts) {
        var _yield$this$configure, bam;

        return runtime_1.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.configure();

              case 2:
                _yield$this$configure = _context2.sent;
                bam = _yield$this$configure.bam;
                return _context2.abrupt("return", bam.getHeaderText(opts));

              case 5:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getHeader(_x) {
        return _getHeader.apply(this, arguments);
      }

      return getHeader;
    }()
  }, {
    key: "setup",
    value: function () {
      var _setup = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee4(opts) {
        var _this = this;

        var _ref2, _ref2$statusCallback, statusCallback;

        return runtime_1.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                // note that derived classes may not provide a BAM directly so this is
                // conditional
                _ref2 = opts || {}, _ref2$statusCallback = _ref2.statusCallback, statusCallback = _ref2$statusCallback === void 0 ? function () {} : _ref2$statusCallback;

                if (!this.setupP) {
                  this.setupP = this.configure().then( /*#__PURE__*/function () {
                    var _ref4 = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3(_ref3) {
                      var bam, samHeader, idToName, nameToId;
                      return runtime_1.wrap(function _callee3$(_context3) {
                        while (1) {
                          switch (_context3.prev = _context3.next) {
                            case 0:
                              bam = _ref3.bam;
                              statusCallback('Downloading index');
                              _context3.next = 4;
                              return bam.getHeader(opts);

                            case 4:
                              samHeader = _context3.sent;
                              // use the @SQ lines in the header to figure out the
                              // mapping between ref ref ID numbers and names
                              idToName = [];
                              nameToId = {};
                              samHeader.filter(function (l) {
                                return l.tag === 'SQ';
                              }).forEach(function (sqLine, refId) {
                                sqLine.data.forEach(function (item) {
                                  if (item.tag === 'SN') {
                                    // this is the ref name
                                    var refName = item.value;
                                    nameToId[refName] = refId;
                                    idToName[refId] = refName;
                                  }
                                });
                              });
                              statusCallback('');
                              _this.samHeader = {
                                idToName: idToName,
                                nameToId: nameToId
                              };
                              return _context3.abrupt("return", _this.samHeader);

                            case 11:
                            case "end":
                              return _context3.stop();
                          }
                        }
                      }, _callee3);
                    }));

                    return function (_x3) {
                      return _ref4.apply(this, arguments);
                    };
                  }())["catch"](function (e) {
                    _this.setupP = undefined;
                    throw e;
                  });
                }

                return _context4.abrupt("return", this.setupP);

              case 3:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function setup(_x2) {
        return _setup.apply(this, arguments);
      }

      return setup;
    }()
  }, {
    key: "getRefNames",
    value: function () {
      var _getRefNames = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee5(opts) {
        var _yield$this$setup, idToName;

        return runtime_1.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return this.setup(opts);

              case 2:
                _yield$this$setup = _context5.sent;
                idToName = _yield$this$setup.idToName;
                return _context5.abrupt("return", idToName);

              case 5:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function getRefNames(_x4) {
        return _getRefNames.apply(this, arguments);
      }

      return getRefNames;
    }()
  }, {
    key: "seqFetch",
    value: function () {
      var _seqFetch = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee6(refName, start, end) {
        var _yield$this$configure2, sequenceAdapter, refSeqStore, features, seqChunks, trimmed, sequence;

        return runtime_1.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return this.configure();

              case 2:
                _yield$this$configure2 = _context6.sent;
                sequenceAdapter = _yield$this$configure2.sequenceAdapter;
                refSeqStore = sequenceAdapter;

                if (refSeqStore) {
                  _context6.next = 7;
                  break;
                }

                return _context6.abrupt("return", undefined);

              case 7:
                if (refName) {
                  _context6.next = 9;
                  break;
                }

                return _context6.abrupt("return", undefined);

              case 9:
                features = refSeqStore.getFeatures({
                  refName: refName,
                  start: start,
                  end: end,
                  assemblyName: ''
                });
                _context6.next = 12;
                return features.pipe(toArray()).toPromise();

              case 12:
                seqChunks = _context6.sent;
                trimmed = [];
                seqChunks.sort(function (a, b) {
                  return a.get('start') - b.get('start');
                }).forEach(function (chunk) {
                  var chunkStart = chunk.get('start');
                  var chunkEnd = chunk.get('end');
                  var trimStart = Math.max(start - chunkStart, 0);
                  var trimEnd = Math.min(end - chunkStart, chunkEnd - chunkStart);
                  var trimLength = trimEnd - trimStart;
                  var chunkSeq = chunk.get('seq') || chunk.get('residues');
                  trimmed.push(chunkSeq.substr(trimStart, trimLength));
                });
                sequence = trimmed.join('');

                if (!(sequence.length !== end - start)) {
                  _context6.next = 18;
                  break;
                }

                throw new Error("sequence fetch failed: fetching ".concat(refName, ":").concat((start - 1).toLocaleString(), "-").concat(end.toLocaleString(), " returned ").concat(sequence.length.toLocaleString(), " bases, but should have returned ").concat((end - start).toLocaleString()));

              case 18:
                return _context6.abrupt("return", sequence);

              case 19:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function seqFetch(_x5, _x6, _x7) {
        return _seqFetch.apply(this, arguments);
      }

      return seqFetch;
    }()
  }, {
    key: "getFeatures",
    value: function getFeatures(region, opts) {
      var _this2 = this;

      var refName = region.refName,
          start = region.start,
          end = region.end,
          originalRefName = region.originalRefName;

      var _ref5 = opts || {},
          signal = _ref5.signal,
          _ref5$statusCallback = _ref5.statusCallback,
          statusCallback = _ref5$statusCallback === void 0 ? function () {} : _ref5$statusCallback;

      return ObservableCreate( /*#__PURE__*/function () {
        var _ref6 = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee7(observer) {
          var _yield$_this2$configu, bam, records, _iterator, _step, record, ref;

          return runtime_1.wrap(function _callee7$(_context7) {
            while (1) {
              switch (_context7.prev = _context7.next) {
                case 0:
                  _context7.next = 2;
                  return _this2.configure();

                case 2:
                  _yield$_this2$configu = _context7.sent;
                  bam = _yield$_this2$configu.bam;
                  _context7.next = 6;
                  return _this2.setup(opts);

                case 6:
                  statusCallback('Downloading alignments');
                  _context7.next = 9;
                  return bam.getRecordsForRange(refName, start, end, opts);

                case 9:
                  records = _context7.sent;
                  checkAbortSignal(signal);
                  _iterator = _createForOfIteratorHelper(records);
                  _context7.prev = 12;

                  _iterator.s();

                case 14:
                  if ((_step = _iterator.n()).done) {
                    _context7.next = 24;
                    break;
                  }

                  record = _step.value;
                  ref = void 0;

                  if (record.get('md')) {
                    _context7.next = 21;
                    break;
                  }

                  _context7.next = 20;
                  return _this2.seqFetch(originalRefName || refName, record.get('start'), record.get('end'));

                case 20:
                  ref = _context7.sent;

                case 21:
                  observer.next(new BamSlightlyLazyFeature(record, _this2, ref));

                case 22:
                  _context7.next = 14;
                  break;

                case 24:
                  _context7.next = 29;
                  break;

                case 26:
                  _context7.prev = 26;
                  _context7.t0 = _context7["catch"](12);

                  _iterator.e(_context7.t0);

                case 29:
                  _context7.prev = 29;

                  _iterator.f();

                  return _context7.finish(29);

                case 32:
                  statusCallback('');
                  observer.complete();

                case 34:
                case "end":
                  return _context7.stop();
              }
            }
          }, _callee7, null, [[12, 26, 29, 32]]);
        }));

        return function (_x8) {
          return _ref6.apply(this, arguments);
        };
      }(), signal);
    }
  }, {
    key: "freeResources",
    value: function freeResources()
    /* { region } */
    {} // depends on setup being called before the BAM constructor

  }, {
    key: "refIdToName",
    value: function refIdToName(refId) {
      var _this$samHeader;

      return (_this$samHeader = this.samHeader) === null || _this$samHeader === void 0 ? void 0 : _this$samHeader.idToName[refId];
    }
  }]);

  return BamAdapter;
}(BaseFeatureDataAdapter);

var BamAdapter$1 = {
  __proto__: null,
  'default': BamAdapter
};

var CramSlightlyLazyFeature = /*#__PURE__*/function () {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  function CramSlightlyLazyFeature(record, store) {
    _classCallCheck(this, CramSlightlyLazyFeature);

    this.record = record;
    this._store = store;
  }

  _createClass(CramSlightlyLazyFeature, [{
    key: "_get_name",
    value: function _get_name() {
      return this.record.readName;
    }
  }, {
    key: "_get_start",
    value: function _get_start() {
      return this.record.alignmentStart - 1;
    }
  }, {
    key: "_get_end",
    value: function _get_end() {
      return this.record.alignmentStart + this.record.lengthOnRef - 1;
    }
  }, {
    key: "_get_cram_read_features",
    value: function _get_cram_read_features() {
      return this.record.readFeatures;
    }
  }, {
    key: "_get_type",
    value: function _get_type() {
      return 'match';
    }
  }, {
    key: "_get_score",
    value: function _get_score() {
      return this.record.mappingQuality;
    }
  }, {
    key: "_get_flags",
    value: function _get_flags() {
      return this.record.flags;
    }
  }, {
    key: "_get_strand",
    value: function _get_strand() {
      return this.record.isReverseComplemented() ? -1 : 1;
    }
  }, {
    key: "_read_group_id",
    value: function _read_group_id() {
      var rg = this._store.samHeader.readGroups;
      return rg ? rg[this.record.readGroupId] : undefined;
    }
  }, {
    key: "_get_qual",
    value: function _get_qual() {
      return (this.record.qualityScores || []).join(' ');
    }
  }, {
    key: "qualRaw",
    value: function qualRaw() {
      return this.record.qualityScores;
    }
  }, {
    key: "_get_seq_id",
    value: function _get_seq_id() {
      return this._store.refIdToName(this.record.sequenceId);
    }
  }, {
    key: "_get_refName",
    value: function _get_refName() {
      return this._get_seq_id();
    }
  }, {
    key: "_get_is_paired",
    value: function _get_is_paired() {
      return !!this.record.mate;
    }
  }, {
    key: "_get_pair_orientation",
    value: function _get_pair_orientation() {
      return this.record.isPaired() ? this.record.getPairOrientation() : undefined;
    }
  }, {
    key: "_get_template_length",
    value: function _get_template_length() {
      return this.record.templateLength || this.record.templateSize;
    }
  }, {
    key: "_get_next_seq_id",
    value: function _get_next_seq_id() {
      return this.record.mate ? this._store.refIdToName(this.record.mate.sequenceId) : undefined;
    }
  }, {
    key: "_get_next_pos",
    value: function _get_next_pos() {
      return this.record.mate ? this.record.mate.alignmentStart : undefined;
    }
  }, {
    key: "_get_next_segment_position",
    value: function _get_next_segment_position() {
      return this.record.mate ? "".concat(this._store.refIdToName(this.record.mate.sequenceId), ":").concat(this.record.mate.alignmentStart) : undefined;
    }
  }, {
    key: "_get_tags",
    value: function _get_tags() {
      var RG = this._read_group_id();

      var tags = this.record.tags; // avoids a tag copy if no RG, but just copy if there is one

      return RG !== undefined ? _objectSpread2(_objectSpread2({}, tags), {}, {
        RG: RG
      }) : tags;
    }
  }, {
    key: "_get_seq",
    value: function _get_seq() {
      return this.record.getReadBases();
    } // generate a CIGAR, based on code from jkbonfield

  }, {
    key: "_get_CIGAR",
    value: function _get_CIGAR() {
      var seq = '';
      var cigar = '';
      var op = 'M';
      var oplen = 0; // not sure I should access these, but...

      var ref = this.record._refRegion.seq;
      var refStart = this.record._refRegion.start;
      var last_pos = this.record.alignmentStart;
      var sublen = 0;

      if (typeof this.record.readFeatures !== 'undefined') {
        // @ts-ignore
        this.record.readFeatures.forEach(function (_ref) {
          var code = _ref.code,
              refPos = _ref.refPos,
              sub = _ref.sub,
              data = _ref.data;
          sublen = refPos - last_pos;
          seq += ref.substring(last_pos - refStart, refPos - refStart);
          last_pos = refPos;

          if (oplen && op !== 'M') {
            cigar += oplen + op;
            oplen = 0;
          }

          if (sublen) {
            op = 'M';
            oplen += sublen;
          }

          if (code === 'b') {
            // An array of bases stored verbatim
            var ret = data.split(',');
            var added = String.fromCharCode.apply(String, _toConsumableArray(ret));
            seq += added;
            last_pos += added.length;
            oplen += added.length;
          } else if (code === 'B') {
            // Single base (+ qual score)
            seq += sub;
            last_pos++;
            oplen++;
          } else if (code === 'X') {
            // Substitution
            seq += sub;
            last_pos++;
            oplen++;
          } else if (code === 'D' || code === 'N') {
            // Deletion or Ref Skip
            last_pos += data;

            if (oplen) {
              cigar += oplen + op;
            }

            cigar += data + code;
            oplen = 0;
          } else if (code === 'I' || code === 'S') {
            // Insertion or soft-clip
            seq += data;

            if (oplen) {
              cigar += oplen + op;
            }

            cigar += data.length + code;
            oplen = 0;
          } else if (code === 'i') {
            // Single base insertion
            seq += data;

            if (oplen) {
              cigar += oplen + op;
            }

            cigar += "".concat(1, "I");
            oplen = 0;
          } else if (code === 'P') {
            // Padding
            if (oplen) {
              cigar += oplen + op;
            }

            cigar += "".concat(data, "P");
          } else if (code === 'H') {
            // Hard clip
            if (oplen) {
              cigar += oplen + op;
            }

            cigar += "".concat(data, "H");
            oplen = 0;
          } // else q or Q

        });
      } else {
        sublen = this.record.readLength - seq.length;
      }

      if (seq.length !== this.record.readLength) {
        sublen = this.record.readLength - seq.length;
        seq += ref.substring(last_pos - refStart, last_pos - refStart + sublen);

        if (oplen && op !== 'M') {
          cigar += oplen + op;
          oplen = 0;
        }

        op = 'M';
        oplen += sublen;
      }

      if (oplen) {
        cigar += oplen + op;
      }

      return cigar;
    }
  }, {
    key: "tags",
    value: function tags() {
      var properties = Object.getOwnPropertyNames(CramSlightlyLazyFeature.prototype);
      return properties.filter(function (prop) {
        return prop.startsWith('_get_') && prop !== '_get_mismatches' && prop !== '_get_skips_and_dels' && prop !== '_get_cram_read_features';
      }).map(function (methodName) {
        return methodName.replace('_get_', '');
      });
    }
  }, {
    key: "id",
    value: function id() {
      return "".concat(this._store.id, "-").concat(this.record.uniqueId);
    }
  }, {
    key: "get",
    value: function get(field) {
      var methodName = "_get_".concat(field); // @ts-ignore

      if (this[methodName]) {
        // @ts-ignore
        return this[methodName]();
      }

      return undefined;
    }
  }, {
    key: "parent",
    value: function parent() {
      return undefined;
    }
  }, {
    key: "children",
    value: function children() {
      return undefined;
    }
  }, {
    key: "set",
    value: function set() {}
  }, {
    key: "pairedFeature",
    value: function pairedFeature() {
      return false;
    }
  }, {
    key: "_get_clipPos",
    value: function _get_clipPos() {
      var mismatches = this.get('mismatches');

      if (mismatches.length) {
        var record = this.get('strand') === -1 ? mismatches[mismatches.length - 1] : mismatches[0];
        var type = record.type,
            cliplen = record.cliplen;

        if (type === 'softclip' || type === 'hardclip') {
          return cliplen;
        }
      }

      return 0;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var _this = this;

      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      var tags = {};
      this.tags().forEach(function (t) {
        var val = _this.get(t);

        if (val !== undefined) {
          tags[t] = val;
        }
      });
      return _objectSpread2(_objectSpread2({}, tags), {}, {
        name: this.get('name'),
        type: this.get('type'),
        uniqueId: this.id()
      });
    }
  }, {
    key: "_get_mismatches",
    value: function _get_mismatches() {
      var readFeatures = this.get('cram_read_features');
      var qual = this.qualRaw();

      if (!readFeatures) {
        return [];
      }

      var start = this.get('start');
      var mismatches = [];
      readFeatures.forEach(function (args) {
        var code = args.code,
            pos = args.pos,
            data = args.data,
            sub = args.sub,
            ref = args.ref;
        var refPos = args.refPos - 1 - start;

        if (code === 'X') {
          // substitution
          mismatches.push({
            start: refPos,
            length: 1,
            base: sub,
            qual: qual === null || qual === void 0 ? void 0 : qual[pos],
            altbase: ref,
            type: 'mismatch'
          });
        } else if (code === 'I') {
          // insertion
          mismatches.push({
            start: refPos,
            type: 'insertion',
            base: "".concat(data.length),
            length: 0
          });
        } else if (code === 'N') {
          // reference skip
          mismatches.push({
            type: 'skip',
            length: data,
            start: refPos,
            base: 'N'
          });
        } else if (code === 'S') {
          // soft clip
          var len = data.length;
          mismatches.push({
            start: refPos,
            type: 'softclip',
            base: "S".concat(len),
            cliplen: len,
            length: 1
          });
        } else if (code === 'P') ; else if (code === 'H') {
          // hard clip
          var _len = data;
          mismatches.push({
            start: refPos,
            type: 'hardclip',
            base: "H".concat(_len),
            cliplen: _len,
            length: 1
          });
        } else if (code === 'D') {
          // deletion
          mismatches.push({
            type: 'deletion',
            length: data,
            start: refPos,
            base: '*'
          });
        } else if (code === 'b') ; else if (code === 'q') ; else if (code === 'B') ; else if (code === 'i') {
          // single-base insertion
          // insertion
          mismatches.push({
            start: refPos,
            type: 'insertion',
            base: data,
            length: 1
          });
        }
      });
      return mismatches;
    }
  }, {
    key: "_get_skips_and_dels",
    value: function _get_skips_and_dels() {
      return this._get_mismatches();
    }
  }]);

  return CramSlightlyLazyFeature;
}();

var CramAdapter = /*#__PURE__*/function (_BaseFeatureDataAdapt) {
  _inherits(CramAdapter, _BaseFeatureDataAdapt);

  var _super = /*#__PURE__*/_createSuper(CramAdapter);

  function CramAdapter() {
    var _this;

    _classCallCheck(this, CramAdapter);

    _this = _super.apply(this, arguments);
    _this.samHeader = {}; // maps a seqId to original refname, passed specially to render args, to a seqid

    _this.seqIdToOriginalRefName = [];
    return _this;
  }

  _createClass(CramAdapter, [{
    key: "configure",
    value: function () {
      var _configure = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee() {
        var cramLocation, craiLocation, sequenceAdapterType, _yield$this$getSubAda, dataAdapter;

        return runtime_1.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                cramLocation = readConfObject(this.config, 'cramLocation');
                craiLocation = readConfObject(this.config, 'craiLocation');

                if (cramLocation) {
                  _context.next = 4;
                  break;
                }

                throw new Error('missing cramLocation argument');

              case 4:
                if (craiLocation) {
                  _context.next = 6;
                  break;
                }

                throw new Error('missing craiLocation argument');

              case 6:
                this.cram = new IndexedCramFile({
                  cramFilehandle: openLocation(cramLocation),
                  index: new CraiIndex({
                    filehandle: openLocation(craiLocation)
                  }),
                  seqFetch: this.seqFetch.bind(this),
                  checkSequenceMD5: false,
                  fetchSizeLimit: this.config.fetchSizeLimit || 600000000
                }); // instantiate the sequence adapter

                sequenceAdapterType = readConfObject(this.config, ['sequenceAdapter', 'type']);

                if (this.getSubAdapter) {
                  _context.next = 10;
                  break;
                }

                throw new Error('Error getting subadapter');

              case 10:
                _context.next = 12;
                return this.getSubAdapter(readConfObject(this.config, 'sequenceAdapter'));

              case 12:
                _yield$this$getSubAda = _context.sent;
                dataAdapter = _yield$this$getSubAda.dataAdapter;

                if (!(dataAdapter instanceof BaseFeatureDataAdapter)) {
                  _context.next = 18;
                  break;
                }

                this.sequenceAdapter = dataAdapter;
                _context.next = 19;
                break;

              case 18:
                throw new Error("CRAM feature adapters cannot use sequence adapters of type '".concat(sequenceAdapterType, "'"));

              case 19:
                return _context.abrupt("return", {
                  sequenceAdapter: this.sequenceAdapter
                });

              case 20:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function configure() {
        return _configure.apply(this, arguments);
      }

      return configure;
    }()
  }, {
    key: "getHeader",
    value: function () {
      var _getHeader = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee2(opts) {
        return runtime_1.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.configure();

              case 2:
                return _context2.abrupt("return", this.cram.cram.getHeaderText(opts));

              case 3:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getHeader(_x) {
        return _getHeader.apply(this, arguments);
      }

      return getHeader;
    }()
  }, {
    key: "seqFetch",
    value: function () {
      var _seqFetch = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee3(seqId, start, end) {
        var refSeqStore, refName, features, seqChunks, trimmed, sequence;
        return runtime_1.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                start -= 1; // convert from 1-based closed to interbase

                refSeqStore = this.sequenceAdapter;

                if (refSeqStore) {
                  _context3.next = 4;
                  break;
                }

                return _context3.abrupt("return", undefined);

              case 4:
                refName = this.refIdToOriginalName(seqId) || this.refIdToName(seqId);

                if (refName) {
                  _context3.next = 7;
                  break;
                }

                return _context3.abrupt("return", undefined);

              case 7:
                features = refSeqStore.getFeatures({
                  refName: refName,
                  start: start,
                  end: end,
                  assemblyName: ''
                }, {});
                _context3.next = 10;
                return features.pipe(toArray()).toPromise();

              case 10:
                seqChunks = _context3.sent;
                trimmed = [];
                seqChunks.sort(function (a, b) {
                  return a.get('start') - b.get('start');
                }).forEach(function (chunk) {
                  var chunkStart = chunk.get('start');
                  var chunkEnd = chunk.get('end');
                  var trimStart = Math.max(start - chunkStart, 0);
                  var trimEnd = Math.min(end - chunkStart, chunkEnd - chunkStart);
                  var trimLength = trimEnd - trimStart;
                  var chunkSeq = chunk.get('seq') || chunk.get('residues');
                  trimmed.push(chunkSeq.substr(trimStart, trimLength));
                });
                sequence = trimmed.join('');

                if (!(sequence.length !== end - start)) {
                  _context3.next = 16;
                  break;
                }

                throw new Error("sequence fetch failed: fetching ".concat(refName, ":").concat((start - 1).toLocaleString(), "-").concat(end.toLocaleString(), " returned ").concat(sequence.length.toLocaleString(), " bases, but should have returned ").concat((end - start).toLocaleString()));

              case 16:
                return _context3.abrupt("return", sequence);

              case 17:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function seqFetch(_x2, _x3, _x4) {
        return _seqFetch.apply(this, arguments);
      }

      return seqFetch;
    }()
  }, {
    key: "setup",
    value: function () {
      var _setup = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee5(opts) {
        var _this2 = this;

        var _ref, _ref$statusCallback, statusCallback;

        return runtime_1.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _ref = opts || {}, _ref$statusCallback = _ref.statusCallback, statusCallback = _ref$statusCallback === void 0 ? function () {} : _ref$statusCallback;

                if (!this.setupP) {
                  this.setupP = this.configure().then( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee4() {
                    var samHeader, idToName, nameToId, readGroups;
                    return runtime_1.wrap(function _callee4$(_context4) {
                      while (1) {
                        switch (_context4.prev = _context4.next) {
                          case 0:
                            statusCallback('Downloading index');
                            _context4.next = 3;
                            return _this2.cram.cram.getSamHeader(opts === null || opts === void 0 ? void 0 : opts.signal);

                          case 3:
                            samHeader = _context4.sent;
                            // use the @SQ lines in the header to figure out the
                            // mapping between ref ID numbers and names
                            idToName = [];
                            nameToId = {};
                            samHeader.filter(function (l) {
                              return l.tag === 'SQ';
                            }).forEach(function (sqLine, refId) {
                              sqLine.data.forEach(function (item) {
                                if (item.tag === 'SN') {
                                  // this is the ref name
                                  var refName = item.value;
                                  nameToId[refName] = refId;
                                  idToName[refId] = refName;
                                }
                              });
                            });
                            readGroups = samHeader.filter(function (l) {
                              return l.tag === 'RG';
                            }).map(function (rgLine) {
                              var _rgLine$data$find;

                              return (_rgLine$data$find = rgLine.data.find(function (item) {
                                return item.tag === 'ID';
                              })) === null || _rgLine$data$find === void 0 ? void 0 : _rgLine$data$find.value;
                            });

                            if (idToName.length) {
                              _this2.samHeader = {
                                idToName: idToName,
                                nameToId: nameToId,
                                readGroups: readGroups
                              };
                            }

                            statusCallback('');
                            return _context4.abrupt("return", _this2.samHeader);

                          case 11:
                          case "end":
                            return _context4.stop();
                        }
                      }
                    }, _callee4);
                  })))["catch"](function (e) {
                    _this2.setupP = undefined;
                    throw e;
                  });
                }

                return _context5.abrupt("return", this.setupP);

              case 3:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function setup(_x5) {
        return _setup.apply(this, arguments);
      }

      return setup;
    }()
  }, {
    key: "getRefNames",
    value: function () {
      var _getRefNames = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee6(opts) {
        return runtime_1.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return this.setup(opts);

              case 2:
                if (!this.samHeader.idToName) {
                  _context6.next = 4;
                  break;
                }

                return _context6.abrupt("return", this.samHeader.idToName);

              case 4:
                if (!this.sequenceAdapter) {
                  _context6.next = 6;
                  break;
                }

                return _context6.abrupt("return", this.sequenceAdapter.getRefNames());

              case 6:
                throw new Error('unable to get refnames');

              case 7:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function getRefNames(_x6) {
        return _getRefNames.apply(this, arguments);
      }

      return getRefNames;
    }() // use info from the SAM header if possible, but fall back to using
    // the ref seq order from when the browser's refseqs were loaded

  }, {
    key: "refNameToId",
    value: function refNameToId(refName) {
      if (this.samHeader.nameToId) {
        return this.samHeader.nameToId[refName];
      }

      if (this.seqIdToRefName) {
        return this.seqIdToRefName.indexOf(refName);
      }

      return undefined;
    } // use info from the SAM header if possible, but fall back to using
    // the ref seq order from when the browser's refseqs were loaded

  }, {
    key: "refIdToName",
    value: function refIdToName(refId) {
      if (this.samHeader.idToName) {
        return this.samHeader.idToName[refId];
      }

      if (this.seqIdToRefName) {
        return this.seqIdToRefName[refId];
      }

      return undefined;
    }
  }, {
    key: "refIdToOriginalName",
    value: function refIdToOriginalName(refId) {
      return this.seqIdToOriginalRefName[refId];
    }
  }, {
    key: "getFeatures",
    value: function getFeatures(region, opts) {
      var _this3 = this;

      var _ref3 = opts || {},
          signal = _ref3.signal,
          _ref3$statusCallback = _ref3.statusCallback,
          statusCallback = _ref3$statusCallback === void 0 ? function () {} : _ref3$statusCallback;

      var refName = region.refName,
          start = region.start,
          end = region.end,
          originalRefName = region.originalRefName;
      return ObservableCreate( /*#__PURE__*/function () {
        var _ref4 = _asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee7(observer) {
          var refId, records;
          return runtime_1.wrap(function _callee7$(_context7) {
            while (1) {
              switch (_context7.prev = _context7.next) {
                case 0:
                  _context7.next = 2;
                  return _this3.setup(opts);

                case 2:
                  if (!(_this3.sequenceAdapter && !_this3.seqIdToRefName)) {
                    _context7.next = 6;
                    break;
                  }

                  _context7.next = 5;
                  return _this3.sequenceAdapter.getRefNames(opts);

                case 5:
                  _this3.seqIdToRefName = _context7.sent;

                case 6:
                  refId = _this3.refNameToId(refName);

                  if (!(refId !== undefined)) {
                    _context7.next = 15;
                    break;
                  }

                  if (originalRefName) {
                    _this3.seqIdToOriginalRefName[refId] = originalRefName;
                  }

                  statusCallback('Downloading alignments');
                  _context7.next = 12;
                  return _this3.cram.getRecordsForRange(refId, start, end, opts);

                case 12:
                  records = _context7.sent;
                  checkAbortSignal(signal); // eslint-disable-next-line @typescript-eslint/no-explicit-any

                  records.forEach(function (record) {
                    observer.next(_this3.cramRecordToFeature(record));
                  });

                case 15:
                  statusCallback('');
                  observer.complete();

                case 17:
                case "end":
                  return _context7.stop();
              }
            }
          }, _callee7);
        }));

        return function (_x7) {
          return _ref4.apply(this, arguments);
        };
      }(), signal);
    }
  }, {
    key: "freeResources",
    value: function freeResources()
    /* { region } */
    {} // eslint-disable-next-line @typescript-eslint/no-explicit-any

  }, {
    key: "cramRecordToFeature",
    value: function cramRecordToFeature(record) {
      return new CramSlightlyLazyFeature(record, this);
    }
  }]);

  return CramAdapter;
}(BaseFeatureDataAdapter);

var CramAdapter$1 = {
  __proto__: null,
  'default': CramAdapter
};

var HtsgetBamAdapter = /*#__PURE__*/function (_BamAdapter) {
  _inherits(HtsgetBamAdapter, _BamAdapter);

  var _super = /*#__PURE__*/_createSuper(HtsgetBamAdapter);

  function HtsgetBamAdapter() {
    _classCallCheck(this, HtsgetBamAdapter);

    return _super.apply(this, arguments);
  }

  _createClass(HtsgetBamAdapter, [{
    key: "configure",
    value: function () {
      var _configure = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/runtime_1.mark(function _callee() {
        var htsgetBase, htsgetTrackId, bam, adapterConfig;
        return runtime_1.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!this.configured) {
                  htsgetBase = readConfObject(this.config, 'htsgetBase');
                  htsgetTrackId = readConfObject(this.config, 'htsgetTrackId');
                  bam = new HtsgetFile({
                    baseUrl: htsgetBase,
                    trackId: htsgetTrackId
                  });
                  adapterConfig = readConfObject(this.config, 'sequenceAdapter');

                  if (adapterConfig && this.getSubAdapter) {
                    this.configured = this.getSubAdapter(adapterConfig).then(function (_ref) {
                      var dataAdapter = _ref.dataAdapter;
                      return {
                        bam: bam,
                        sequenceAdapter: dataAdapter
                      };
                    });
                  }

                  this.configured = Promise.resolve({
                    bam: bam
                  });
                }

                return _context.abrupt("return", this.configured);

              case 2:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function configure() {
        return _configure.apply(this, arguments);
      }

      return configure;
    }()
  }]);

  return HtsgetBamAdapter;
}(BamAdapter);

var HtsgetBamAdapter$1 = {
  __proto__: null,
  'default': HtsgetBamAdapter
};

var useStyles$1 = /*#__PURE__*/makeStyles$1(function (theme) {
  return {
    root: {
      width: 300
    },
    closeButton: {
      position: 'absolute',
      right: theme.spacing(1),
      top: theme.spacing(1),
      color: theme.palette.grey[500]
    }
  };
});

function ColorByTagDlg$1(props) {
  var classes = useStyles$1();
  var model = props.model,
      handleClose = props.handleClose;

  var _useState = useState(''),
      _useState2 = _slicedToArray(_useState, 2),
      tag = _useState2[0],
      setTag = _useState2[1];

  var validTag = tag.match(/^[A-Za-z][A-Za-z0-9]$/);
  return /*#__PURE__*/React.createElement(Dialog, {
    open: true,
    onClose: handleClose
  }, /*#__PURE__*/React.createElement(DialogTitle, null, "Color by tag", /*#__PURE__*/React.createElement(IconButton, {
    "aria-label": "close",
    className: classes.closeButton,
    onClick: handleClose
  }, /*#__PURE__*/React.createElement(CloseIcon, null))), /*#__PURE__*/React.createElement(DialogContent, {
    style: {
      overflowX: 'hidden'
    }
  }, /*#__PURE__*/React.createElement("div", {
    className: classes.root
  }, /*#__PURE__*/React.createElement(Typography$1, null, "Enter tag to color by: "), /*#__PURE__*/React.createElement(Typography$1, {
    color: "textSecondary"
  }, "Examples: XS or TS for RNA-seq inferred read strand, ts (lower-case) for minimap2 read strand, HP for haplotype, RG for read group, etc."), /*#__PURE__*/React.createElement(TextField, {
    value: tag,
    onChange: function onChange(event) {
      setTag(event.target.value);
    },
    placeholder: "Enter tag name",
    inputProps: {
      maxLength: 2,
      'data-testid': 'color-tag-name-input'
    },
    error: tag.length === 2 && !validTag,
    helperText: tag.length === 2 && !validTag ? 'Not a valid tag' : '',
    autoComplete: "off",
    "data-testid": "color-tag-name"
  }), /*#__PURE__*/React.createElement(Button, {
    variant: "contained",
    color: "primary",
    style: {
      marginLeft: 20
    },
    onClick: function onClick() {
      model.setColorScheme({
        type: 'tag',
        tag: tag
      });
      handleClose();
    },
    disabled: !validTag
  }, "Submit"))));
}

var ColorByTag = /*#__PURE__*/observer(ColorByTagDlg$1);

var ColorByTag$1 = {
  __proto__: null,
  'default': ColorByTag
};

var useStyles$2 = /*#__PURE__*/makeStyles$1(function (theme) {
  return {
    root: {
      width: 500
    },
    paper: {
      padding: theme.spacing(2),
      margin: theme.spacing(2)
    },
    closeButton: {
      position: 'absolute',
      right: theme.spacing(1),
      top: theme.spacing(1),
      color: theme.palette.grey[500]
    },
    field: {
      margin: theme.spacing(2)
    }
  };
});
var flagNames = ['read paired', 'read mapped in proper pair', 'read unmapped', 'mate unmapped', 'read reverse strand', 'mate reverse strand', 'first in pair', 'second in pair', 'not primary alignment', 'read fails platform/vendor quality checks', 'read is PCR or optical duplicate', 'supplementary alignment'];

function Bitmask(props) {
  var _props$flag = props.flag,
      flag = _props$flag === void 0 ? 0 : _props$flag,
      setFlag = props.setFlag;
  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(TextField, {
    type: "number",
    value: flag,
    onChange: function onChange(event) {
      return setFlag(+event.target.value);
    }
  }), flagNames.map(function (name, index) {
    var val = flag & 1 << index;
    var key = "".concat(name, "_").concat(val);
    return /*#__PURE__*/React.createElement("div", {
      key: key
    }, /*#__PURE__*/React.createElement("input", {
      type: "checkbox",
      checked: Boolean(val),
      onChange: function onChange(event) {
        if (event.target.checked) {
          setFlag(flag | 1 << index);
        } else {
          setFlag(flag & ~(1 << index));
        }
      }
    }), /*#__PURE__*/React.createElement("label", {
      htmlFor: key
    }, name));
  }));
}

function FilterByTagDlg$1(props) {
  var _filterBy$tagFilter, _filterBy$tagFilter2;

  var model = props.model,
      handleClose = props.handleClose;
  var classes = useStyles$2();
  var filterBy = model.filterBy;

  var _useState = useState(filterBy === null || filterBy === void 0 ? void 0 : filterBy.flagInclude),
      _useState2 = _slicedToArray(_useState, 2),
      flagInclude = _useState2[0],
      setFlagInclude = _useState2[1];

  var _useState3 = useState(filterBy === null || filterBy === void 0 ? void 0 : filterBy.flagExclude),
      _useState4 = _slicedToArray(_useState3, 2),
      flagExclude = _useState4[0],
      setFlagExclude = _useState4[1];

  var _useState5 = useState((filterBy === null || filterBy === void 0 ? void 0 : (_filterBy$tagFilter = filterBy.tagFilter) === null || _filterBy$tagFilter === void 0 ? void 0 : _filterBy$tagFilter.tag) || ''),
      _useState6 = _slicedToArray(_useState5, 2),
      tag = _useState6[0],
      setTag = _useState6[1];

  var _useState7 = useState((filterBy === null || filterBy === void 0 ? void 0 : (_filterBy$tagFilter2 = filterBy.tagFilter) === null || _filterBy$tagFilter2 === void 0 ? void 0 : _filterBy$tagFilter2.value) || ''),
      _useState8 = _slicedToArray(_useState7, 2),
      tagValue = _useState8[0],
      setTagValue = _useState8[1];

  var _useState9 = useState((filterBy === null || filterBy === void 0 ? void 0 : filterBy.readName) || ''),
      _useState10 = _slicedToArray(_useState9, 2),
      readName = _useState10[0],
      setReadName = _useState10[1];

  var validTag = tag.match(/^[A-Za-z][A-Za-z0-9]$/);
  var site = 'https://broadinstitute.github.io/picard/explain-flags.html';
  return /*#__PURE__*/React.createElement(Dialog, {
    open: true,
    onClose: handleClose
  }, /*#__PURE__*/React.createElement(DialogTitle, null, "Filter options", /*#__PURE__*/React.createElement(IconButton, {
    "aria-label": "close",
    className: classes.closeButton,
    onClick: handleClose
  }, /*#__PURE__*/React.createElement(CloseIcon, null))), /*#__PURE__*/React.createElement(DialogContent, null, /*#__PURE__*/React.createElement(Typography$1, null, "Set filter bitmask options. Refer to ", /*#__PURE__*/React.createElement(Link, {
    href: site
  }, site), ' ', "for details"), /*#__PURE__*/React.createElement("div", {
    className: classes.root
  }, /*#__PURE__*/React.createElement(Paper, {
    className: classes.paper,
    variant: "outlined"
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      display: 'flex'
    }
  }, /*#__PURE__*/React.createElement("div", null, /*#__PURE__*/React.createElement(Typography$1, null, "Read must have ALL these flags"), /*#__PURE__*/React.createElement(Bitmask, {
    flag: flagInclude,
    setFlag: setFlagInclude
  })), /*#__PURE__*/React.createElement("div", null, /*#__PURE__*/React.createElement(Typography$1, null, "Read must have NONE of these flags"), /*#__PURE__*/React.createElement(Bitmask, {
    flag: flagExclude,
    setFlag: setFlagExclude
  })))), /*#__PURE__*/React.createElement(Paper, {
    className: classes.paper,
    variant: "outlined"
  }, /*#__PURE__*/React.createElement(Typography$1, null, "Filter by tag name and value. Use * in the value field to get all reads containing any value for that tag. Example: filter tag name SA with value * to get all split/supplementary reads. Other examples include HP for haplotype, or RG for read group"), /*#__PURE__*/React.createElement(TextField, {
    className: classes.field,
    value: tag,
    onChange: function onChange(event) {
      setTag(event.target.value);
    },
    placeholder: "Enter tag name",
    inputProps: {
      maxLength: 2,
      'data-testid': 'color-tag-name-input'
    },
    error: tag.length === 2 && !validTag,
    helperText: tag.length === 2 && !validTag ? 'Not a valid tag' : '',
    "data-testid": "color-tag-name"
  }), /*#__PURE__*/React.createElement(TextField, {
    className: classes.field,
    value: tagValue,
    onChange: function onChange(event) {
      setTagValue(event.target.value);
    },
    placeholder: "Enter tag value",
    inputProps: {
      'data-testid': 'color-tag-name-input'
    },
    "data-testid": "color-tag-value"
  })), /*#__PURE__*/React.createElement(Paper, {
    className: classes.paper,
    variant: "outlined"
  }, /*#__PURE__*/React.createElement(Typography$1, null, "Filter by read name"), /*#__PURE__*/React.createElement(TextField, {
    className: classes.field,
    value: readName,
    onChange: function onChange(event) {
      setReadName(event.target.value);
    },
    placeholder: "Enter read name",
    inputProps: {
      'data-testid': 'color-tag-readname-input'
    },
    "data-testid": "color-tag-readname"
  })), /*#__PURE__*/React.createElement(Button, {
    variant: "contained",
    color: "primary",
    onClick: function onClick() {
      model.setFilterBy({
        flagInclude: flagInclude,
        flagExclude: flagExclude,
        readName: readName,
        tagFilter: tag !== '' ? {
          tag: tag,
          value: tagValue
        } : undefined
      });
      handleClose();
    }
  }, "Submit"))));
}

var FilterByTag = /*#__PURE__*/observer(FilterByTagDlg$1);

var FilterByTag$1 = {
  __proto__: null,
  'default': FilterByTag
};

var useStyles$3 = /*#__PURE__*/makeStyles$1(function (theme) {
  return {
    root: {
      margin: 0,
      padding: theme.spacing(2)
    },
    closeButton: {
      position: 'absolute',
      right: theme.spacing(1),
      top: theme.spacing(1),
      color: theme.palette.grey[500]
    }
  };
});

function SortByTagDlg$1(props) {
  var classes = useStyles$3();
  var model = props.model,
      handleClose = props.handleClose;

  var _useState = useState(''),
      _useState2 = _slicedToArray(_useState, 2),
      tag = _useState2[0],
      setTag = _useState2[1];

  var validTag = tag.match(/^[A-Za-z][A-Za-z0-9]$/);
  return /*#__PURE__*/React.createElement(Dialog, {
    open: true,
    onClose: handleClose
  }, /*#__PURE__*/React.createElement(DialogTitle, null, "Sort by tag", /*#__PURE__*/React.createElement(IconButton, {
    "aria-label": "close",
    className: classes.closeButton,
    onClick: handleClose
  }, /*#__PURE__*/React.createElement(CloseIcon, null))), /*#__PURE__*/React.createElement(DialogContent, null, /*#__PURE__*/React.createElement("div", null, /*#__PURE__*/React.createElement(Typography$1, null, "Set the tag to sort by"), /*#__PURE__*/React.createElement(Typography$1, {
    color: "textSecondary"
  }, "Examples: HP for haplotype, RG for read group, etc."), /*#__PURE__*/React.createElement(TextField, {
    value: tag,
    onChange: function onChange(event) {
      setTag(event.target.value);
    },
    placeholder: "Enter tag name",
    inputProps: {
      maxLength: 2,
      'data-testid': 'sort-tag-name-input'
    },
    error: tag.length === 2 && !validTag,
    helperText: tag.length === 2 && !validTag ? 'Not a valid tag' : '',
    autoComplete: "off",
    "data-testid": "sort-tag-name"
  }), /*#__PURE__*/React.createElement(Button, {
    variant: "contained",
    color: "primary",
    onClick: function onClick() {
      model.setSortedBy('tag', tag);
      handleClose();
    }
  }, "Submit"))));
}

var SortByTag = /*#__PURE__*/observer(SortByTagDlg$1);

var SortByTag$1 = {
  __proto__: null,
  'default': SortByTag
};

var useStyles$4 = /*#__PURE__*/makeStyles$1(function (theme) {
  return {
    root: {
      margin: theme.spacing(4)
    },
    closeButton: {
      position: 'absolute',
      right: theme.spacing(1),
      top: theme.spacing(1),
      color: theme.palette.grey[500]
    }
  };
});

function SetFeatureHeightDlg$1(props) {
  var classes = useStyles$4();
  var model = props.model,
      handleClose = props.handleClose;
  var featureHeightSetting = model.featureHeightSetting,
      noSpacingSetting = model.noSpacing;

  var _useState = useState("".concat(featureHeightSetting)),
      _useState2 = _slicedToArray(_useState, 2),
      height = _useState2[0],
      setHeight = _useState2[1];

  var _useState3 = useState(noSpacingSetting),
      _useState4 = _slicedToArray(_useState3, 2),
      noSpacing = _useState4[0],
      setNoSpacing = _useState4[1];

  var ok = height !== '' && !Number.isNaN(+height);
  return /*#__PURE__*/React.createElement(Dialog, {
    open: true,
    onClose: handleClose
  }, /*#__PURE__*/React.createElement(DialogTitle, null, "Set feature height", /*#__PURE__*/React.createElement(IconButton, {
    className: classes.closeButton,
    onClick: handleClose
  }, /*#__PURE__*/React.createElement(CloseIcon, null))), /*#__PURE__*/React.createElement(DialogContent, null, /*#__PURE__*/React.createElement(Typography$1, null, "Adjust the feature height and whether there is any spacing between features. Setting feature height to 1 and removing spacing makes the display very compact"), /*#__PURE__*/React.createElement("div", {
    className: classes.root
  }, /*#__PURE__*/React.createElement(Typography$1, null, "Enter feature height: "), /*#__PURE__*/React.createElement(TextField, {
    value: height,
    onChange: function onChange(event) {
      setHeight(event.target.value);
    }
  }), /*#__PURE__*/React.createElement(FormControlLabel, {
    control: /*#__PURE__*/React.createElement(Checkbox, {
      checked: !!noSpacing,
      onChange: function onChange() {
        return setNoSpacing(function (val) {
          return !val;
        });
      }
    }),
    label: "Remove spacing between features in y-direction?"
  }), /*#__PURE__*/React.createElement(Button, {
    variant: "contained",
    color: "primary",
    type: "submit",
    style: {
      marginLeft: 20
    },
    disabled: !ok,
    onClick: function onClick() {
      model.setFeatureHeight(height !== '' && !Number.isNaN(+height) ? +height : undefined);
      model.setNoSpacing(noSpacing);
      handleClose();
    }
  }, "Submit"))));
}

var SetFeatureHeight = /*#__PURE__*/observer(SetFeatureHeightDlg$1);

var SetFeatureHeight$1 = {
  __proto__: null,
  'default': SetFeatureHeight
};

var useStyles$5 = /*#__PURE__*/makeStyles$1(function (theme) {
  return {
    root: {
      width: 500
    },
    closeButton: {
      position: 'absolute',
      right: theme.spacing(1),
      top: theme.spacing(1),
      color: theme.palette.grey[500]
    },
    field: {
      margin: theme.spacing(2)
    }
  };
});

function SetMaxHeightDlg$1(props) {
  var model = props.model,
      handleClose = props.handleClose;
  var classes = useStyles$5();
  var _model$maxHeight = model.maxHeight,
      maxHeight = _model$maxHeight === void 0 ? '' : _model$maxHeight;

  var _useState = useState("".concat(maxHeight)),
      _useState2 = _slicedToArray(_useState, 2),
      max = _useState2[0],
      setMax = _useState2[1];

  return /*#__PURE__*/React.createElement(Dialog, {
    open: true,
    onClose: handleClose
  }, /*#__PURE__*/React.createElement(DialogTitle, {
    id: "alert-dialog-title"
  }, "Filter options", /*#__PURE__*/React.createElement(IconButton, {
    "aria-label": "close",
    className: classes.closeButton,
    onClick: handleClose
  }, /*#__PURE__*/React.createElement(CloseIcon, null))), /*#__PURE__*/React.createElement(DialogContent, null, /*#__PURE__*/React.createElement("div", {
    className: classes.root
  }, /*#__PURE__*/React.createElement(Typography$1, null, "Set max height for the track"), /*#__PURE__*/React.createElement(TextField, {
    value: max,
    onChange: function onChange(event) {
      setMax(event.target.value);
    },
    placeholder: "Enter max height for layout"
  }), /*#__PURE__*/React.createElement(Button, {
    variant: "contained",
    color: "primary",
    type: "submit",
    style: {
      marginLeft: 20
    },
    onClick: function onClick() {
      model.setMaxHeight(max !== '' && !Number.isNaN(+max) ? +max : undefined);
      handleClose();
    }
  }, "Submit"))));
}

var SetMaxHeight = /*#__PURE__*/observer(SetMaxHeightDlg$1);

var SetMaxHeight$1 = {
  __proto__: null,
  'default': SetMaxHeight
};

var useStyles$6 = /*#__PURE__*/makeStyles$1(function (theme) {
  return {
    root: {},
    closeButton: {
      position: 'absolute',
      right: theme.spacing(1),
      top: theme.spacing(1),
      color: theme.palette.grey[500]
    },
    table: {
      border: '1px solid #888',
      margin: theme.spacing(4),
      '& td': {
        padding: theme.spacing(1)
      }
    }
  };
});

function ModificationTable(_ref) {
  var modifications = _ref.modifications;
  var classes = useStyles$6();
  return /*#__PURE__*/React.createElement("table", {
    className: classes.table
  }, /*#__PURE__*/React.createElement("tbody", null, modifications.map(function (_ref2) {
    var _ref3 = _slicedToArray(_ref2, 2),
        key = _ref3[0],
        value = _ref3[1];

    return /*#__PURE__*/React.createElement("tr", {
      key: key
    }, /*#__PURE__*/React.createElement("td", null, key), /*#__PURE__*/React.createElement("td", null, value), /*#__PURE__*/React.createElement("td", {
      style: {
        width: '1em',
        background: value
      }
    }));
  })));
}

function ColorByTagDlg$2(props) {
  var classes = useStyles$6();
  var model = props.model,
      handleClose = props.handleClose;
  var colorBy = model.colorBy,
      modificationTagMap = model.modificationTagMap;

  var modifications = _toConsumableArray(modificationTagMap.entries());

  return /*#__PURE__*/React.createElement(Dialog, {
    open: true,
    onClose: handleClose
  }, /*#__PURE__*/React.createElement(DialogTitle, null, "Color by modifications", /*#__PURE__*/React.createElement(IconButton, {
    "aria-label": "close",
    className: classes.closeButton,
    onClick: handleClose
  }, /*#__PURE__*/React.createElement(CloseIcon, null))), /*#__PURE__*/React.createElement(DialogContent, null, /*#__PURE__*/React.createElement("div", {
    className: classes.root
  }, /*#__PURE__*/React.createElement(Typography$1, null, "You can choose to color the modifications in the BAM/CRAM MM/ML specification using this dialog. Choosing modifications colors the modified positions and can color multiple modification types. Choosing the methylation setting colors methylated and unmethylated CpG."), /*#__PURE__*/React.createElement(Typography$1, null, "Note: you can revisit this dialog to see the current mapping of colors to modification type for the modification coloring mode"), /*#__PURE__*/React.createElement("div", {
    style: {
      margin: 20
    }
  }, (colorBy === null || colorBy === void 0 ? void 0 : colorBy.type) === 'modifications' ? /*#__PURE__*/React.createElement("div", null, modifications.length ? /*#__PURE__*/React.createElement(React.Fragment, null, "Current modification-type-to-color mapping", /*#__PURE__*/React.createElement(ModificationTable, {
    modifications: _toConsumableArray(modificationTagMap.entries())
  })) : /*#__PURE__*/React.createElement("div", null, /*#__PURE__*/React.createElement(Typography$1, null, "Note: color by modifications is already enabled. Loading current modifications..."), /*#__PURE__*/React.createElement(CircularProgress, {
    size: 15
  }))) : null, (colorBy === null || colorBy === void 0 ? void 0 : colorBy.type) === 'methylation' ? /*#__PURE__*/React.createElement(ModificationTable, {
    modifications: [['methylated', 'red'], ['unmethylated', 'blue']]
  }) : null), /*#__PURE__*/React.createElement("div", {
    style: {
      display: 'flex'
    }
  }, /*#__PURE__*/React.createElement(Button, {
    variant: "contained",
    color: "primary",
    style: {
      margin: 5
    },
    onClick: function onClick() {
      model.setColorScheme({
        type: 'modifications'
      });
      handleClose();
    }
  }, "Modifications"), /*#__PURE__*/React.createElement(Button, {
    variant: "contained",
    color: "primary",
    style: {
      margin: 5
    },
    onClick: function onClick() {
      model.setColorScheme({
        type: 'methylation'
      });
      handleClose();
    }
  }, "Methylation"), /*#__PURE__*/React.createElement(Button, {
    variant: "contained",
    color: "secondary",
    style: {
      margin: 5
    },
    onClick: function onClick() {
      return handleClose();
    }
  }, "Cancel")))));
}

var ColorByModifications = /*#__PURE__*/observer(ColorByTagDlg$2);

var ColorByModifications$1 = {
  __proto__: null,
  'default': ColorByModifications
};

var useStyles$7 = /*#__PURE__*/makeStyles$1(function () {
  return {
    compact: {
      paddingRight: 0,
      paddingTop: 0,
      paddingBottom: 0
    }
  };
});
var omit = ['clipPos', 'flags']; // eslint-disable-next-line @typescript-eslint/no-explicit-any

function AlignmentFlags(props) {
  var classes = useStyles$7();
  var feature = props.feature;
  var flags = feature.flags;
  var flagNames = ['read paired', 'read mapped in proper pair', 'read unmapped', 'mate unmapped', 'read reverse strand', 'mate reverse strand', 'first in pair', 'second in pair', 'not primary alignment', 'read fails platform/vendor quality checks', 'read is PCR or optical duplicate', 'supplementary alignment'];
  return /*#__PURE__*/React.createElement(BaseCard, Object.assign({}, props, {
    title: "Flags"
  }), /*#__PURE__*/React.createElement(SimpleValue, {
    name: 'Flag',
    value: flags
  }), /*#__PURE__*/React.createElement(FormGroup, null, flagNames.map(function (name, index) {
    var val = flags & 1 << index;
    var key = "".concat(name, "_").concat(val);
    return /*#__PURE__*/React.createElement(FormControlLabel, {
      key: key,
      control: /*#__PURE__*/React.createElement(Checkbox, {
        className: classes.compact,
        checked: Boolean(val),
        name: name,
        readOnly: true
      }),
      label: name
    });
  })));
}

function Formatter(_ref) {
  var value = _ref.value;

  var _useState = useState(false),
      _useState2 = _slicedToArray(_useState, 2),
      show = _useState2[0],
      setShow = _useState2[1];

  var display = String(value);

  if (display.length > 100) {
    return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("button", {
      type: "button",
      onClick: function onClick() {
        return copy(display);
      }
    }, "Copy"), /*#__PURE__*/React.createElement("button", {
      type: "button",
      onClick: function onClick() {
        return setShow(function (val) {
          return !val;
        });
      }
    }, show ? 'Show less' : 'Show more'), /*#__PURE__*/React.createElement("div", null, show ? display : "".concat(display.slice(0, 100), "...")));
  }

  return /*#__PURE__*/React.createElement("div", null, display);
} // utility function to get length of alignment from cigar


function getLengthOnRef(cigar) {
  var cigarOps = parseCigar(cigar);
  var lengthOnRef = 0;

  for (var i = 0; i < cigarOps.length; i += 2) {
    var len = +cigarOps[i];
    var op = cigarOps[i + 1];

    if (op !== 'H' && op !== 'S' && op !== 'I') {
      lengthOnRef += len;
    }
  }

  return lengthOnRef;
} // eslint-disable-next-line @typescript-eslint/no-explicit-any


function SupplementaryAlignments(props) {
  var tag = props.tag,
      model = props.model;
  var session = getSession(model);
  return /*#__PURE__*/React.createElement(BaseCard, Object.assign({}, props, {
    title: "Supplementary alignments"
  }), /*#__PURE__*/React.createElement(Typography$1, null, "List of supplementary alignment locations"), /*#__PURE__*/React.createElement("ul", null, tag.split(';').filter(function (SA) {
    return !!SA;
  }).map(function (SA, index) {
    var _SA$split = SA.split(','),
        _SA$split2 = _slicedToArray(_SA$split, 4),
        saRef = _SA$split2[0],
        saStart = _SA$split2[1],
        saStrand = _SA$split2[2],
        saCigar = _SA$split2[3];

    var saLength = getLengthOnRef(saCigar);
    var extra = Math.floor(saLength / 5);
    var start = +saStart;
    var end = +saStart + saLength;
    var locString = "".concat(saRef, ":").concat(Math.max(1, start - extra), "-").concat(end + extra);
    var displayString = "".concat(saRef, ":").concat(start, "-").concat(end, " (").concat(saStrand, ")");
    return /*#__PURE__*/React.createElement("li", {
      key: "".concat(locString, "-").concat(index)
    }, /*#__PURE__*/React.createElement(Link, {
      onClick: function onClick() {
        var view = model.view;

        if (view) {
          view.navToLocString(locString);
        } else {
          session.notify('No view associated with this feature detail panel anymore', 'warning');
        }
      },
      href: "#"
    }, displayString));
  })));
} // eslint-disable-next-line @typescript-eslint/no-explicit-any


function PairLink(_ref2) {
  var locString = _ref2.locString,
      model = _ref2.model;
  var session = getSession(model);
  return /*#__PURE__*/React.createElement(Link, {
    onClick: function onClick() {
      var view = model.view;

      if (view) {
        view.navToLocString(locString);
      } else {
        session.notify('No view associated with this feature detail panel anymore', 'warning');
      }
    },
    href: "#"
  }, locString);
} // eslint-disable-next-line @typescript-eslint/no-explicit-any


function AlignmentFeatureDetails(props) {
  var model = props.model;
  var feat = JSON.parse(JSON.stringify(model.featureData));
  var SA = feat.tags && feat.tags.SA || feat.SA;
  return /*#__PURE__*/React.createElement(Paper, {
    "data-testid": "alignment-side-drawer"
  }, /*#__PURE__*/React.createElement(FeatureDetails, Object.assign({}, props, {
    omit: omit,
    feature: feat,
    formatter: function formatter(value, key) {
      return key === 'next_segment_position' ? /*#__PURE__*/React.createElement(PairLink, {
        model: model,
        locString: value
      }) : /*#__PURE__*/React.createElement(Formatter, {
        value: value
      });
    }
  })), SA ? /*#__PURE__*/React.createElement(SupplementaryAlignments, {
    model: model,
    tag: SA
  }) : null, /*#__PURE__*/React.createElement(AlignmentFlags, Object.assign({
    feature: feat
  }, props)));
}

var AlignmentsFeatureDetail = /*#__PURE__*/observer(AlignmentFeatureDetails);

var AlignmentsFeatureDetail$1 = {
  __proto__: null,
  'default': AlignmentsFeatureDetail
};

export default AlignmentsPlugin;
export { MismatchParser };
//# sourceMappingURL=plugin-alignments.esm.js.map
