export interface ScaleOpts {
    domain: number[];
    range: number[];
    scaleType: string;
    pivotValue?: number;
    inverted: boolean;
}
/**
 * produces a d3-scale from arguments. applies a "nice domain" adjustment
 *
 * @param object - containing attributes
 *   - domain [min,max]
 *   - range [min,max]
 *   - bounds [min,max]
 *   - scaleType (linear or log)
 *   - pivotValue (number)
 *   - inverted (boolean)
 */
export declare function getScale({ domain, range, scaleType, pivotValue, inverted, }: ScaleOpts): import("d3-scale").ScaleLinear<number, number> | import("d3-scale").ScaleQuantize<number>;
/**
 * gets the origin for drawing the graph. for linear this is 0, for log this is arbitrarily set to log(1)==0
 *
 * @param scaleType -
 */
export declare function getOrigin(scaleType: string): 1 | 0;
/**
 * produces a "nice" domain that actually rounds down to 0 for the min
 * or 0 to the max depending on if all values are positive or negative
 *
 * @param object - containing attributes
 *   - domain [min,max]
 *   - bounds [min,max]
 *   - mean
 *   - stddev
 *   - scaleType (linear or log)
 */
export declare function getNiceDomain({ scaleType, domain, bounds, }: {
    scaleType: string;
    domain: number[];
    bounds: number[];
}): [number, number];
