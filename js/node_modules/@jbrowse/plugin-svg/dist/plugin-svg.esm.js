import BoxRendererType from '@jbrowse/core/pluggableElementTypes/renderers/BoxRendererType';
import Plugin from '@jbrowse/core/Plugin';
import { readConfObject, ConfigurationSchema } from '@jbrowse/core/configuration';
import { PropTypes } from '@jbrowse/core/util/types/mst';
import { measureText, bpSpanPx, bpToPx } from '@jbrowse/core/util';
import SceneGraph from '@jbrowse/core/util/layouts/SceneGraph';
import { observer } from 'mobx-react';
import ReactPropTypes from 'prop-types';
import React, { useRef, useState, useCallback, useEffect } from 'react';
import { emphasize } from '@jbrowse/core/util/color';
import SimpleFeature from '@jbrowse/core/util/simpleFeature';
import { types } from 'mobx-state-tree';

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

function _iterableToArrayLimit(arr, i) {
  var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;

      var F = function () {};

      return {
        s: F,
        n: function () {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function (e) {
          throw e;
        },
        f: F
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var normalCompletion = true,
      didErr = false,
      err;
  return {
    s: function () {
      it = it.call(o);
    },
    n: function () {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function (e) {
      didErr = true;
      err = e;
    },
    f: function () {
      try {
        if (!normalCompletion && it.return != null) it.return();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}

function Label(props) {
  var text = props.text,
      x = props.x,
      y = props.y,
      _props$color = props.color,
      color = _props$color === void 0 ? 'black' : _props$color,
      _props$fontHeight = props.fontHeight,
      fontHeight = _props$fontHeight === void 0 ? 13 : _props$fontHeight,
      _props$featureWidth = props.featureWidth,
      featureWidth = _props$featureWidth === void 0 ? 0 : _props$featureWidth,
      reversed = props.reversed,
      allowedWidthExpansion = props.allowedWidthExpansion,
      _props$fontWidthScale = props.fontWidthScaleFactor,
      fontWidthScaleFactor = _props$fontWidthScale === void 0 ? 0.6 : _props$fontWidthScale;
  var fontWidth = fontHeight * fontWidthScaleFactor;
  var totalWidth = featureWidth && allowedWidthExpansion ? featureWidth + allowedWidthExpansion : Infinity;
  var measuredTextWidth = measureText(text, fontHeight);
  return /*#__PURE__*/React.createElement("text", {
    x: reversed ? x + featureWidth - measuredTextWidth : x,
    y: y + fontHeight,
    style: {
      fontSize: fontHeight,
      fill: color,
      cursor: 'default'
    }
  }, measuredTextWidth > totalWidth ? "".concat(text.slice(0, totalWidth / fontWidth), "...") : text);
}

function FeatureGlyph(props) {
  var feature = props.feature,
      rootLayout = props.rootLayout,
      selected = props.selected,
      config = props.config,
      name = props.name,
      shouldShowName = props.shouldShowName,
      description = props.description,
      shouldShowDescription = props.shouldShowDescription,
      fontHeight = props.fontHeight,
      allowedWidthExpansion = props.allowedWidthExpansion,
      reversed = props.reversed;
  var featureLayout = rootLayout.getSubRecord(String(feature.id()));
  var GlyphComponent = featureLayout.data.GlyphComponent;
  var glyphComponents = [/*#__PURE__*/React.createElement(GlyphComponent, _extends({
    key: "glyph-".concat(feature.id())
  }, props, {
    feature: feature,
    featureLayout: featureLayout,
    selected: selected
  }))];

  if (shouldShowName) {
    glyphComponents.push( /*#__PURE__*/React.createElement(Label, {
      key: "glyph-name-".concat(feature.id()),
      text: name,
      x: rootLayout.getSubRecord('nameLabel').absolute.left,
      y: rootLayout.getSubRecord('nameLabel').absolute.top,
      color: readConfObject(config, ['labels', 'nameColor'], {
        feature: feature
      }),
      fontHeight: fontHeight,
      reversed: reversed,
      featureWidth: featureLayout.width,
      allowedWidthExpansion: allowedWidthExpansion
    }));
  }

  if (shouldShowDescription) {
    glyphComponents.push( /*#__PURE__*/React.createElement(Label, {
      key: "glyph-description-".concat(feature.id()),
      text: description,
      x: rootLayout.getSubRecord('descriptionLabel').absolute.left,
      y: rootLayout.getSubRecord('descriptionLabel').absolute.top,
      color: readConfObject(config, ['labels', 'descriptionColor'], {
        feature: feature
      }),
      fontHeight: fontHeight,
      featureWidth: featureLayout.width,
      reversed: reversed,
      allowedWidthExpansion: allowedWidthExpansion
    }));
  }

  return /*#__PURE__*/React.createElement("g", null, glyphComponents);
}

FeatureGlyph.propTypes = {
  feature: /*#__PURE__*/ReactPropTypes.shape({
    id: ReactPropTypes.func.isRequired,
    get: ReactPropTypes.func.isRequired
  }).isRequired,
  layout: /*#__PURE__*/ReactPropTypes.shape({
    addRect: ReactPropTypes.func.isRequired,
    getTotalHeight: ReactPropTypes.func.isRequired
  }).isRequired,
  rootLayout: /*#__PURE__*/ReactPropTypes.shape({
    addChild: ReactPropTypes.func.isRequired,
    getSubRecord: ReactPropTypes.func.isRequired
  }).isRequired,
  region: PropTypes.Region.isRequired,
  bpPerPx: ReactPropTypes.number.isRequired,
  reversed: ReactPropTypes.bool,
  selected: ReactPropTypes.bool,
  config: PropTypes.ConfigSchema.isRequired,
  name: ReactPropTypes.string,
  shouldShowName: ReactPropTypes.bool,
  description: ReactPropTypes.string,
  shouldShowDescription: ReactPropTypes.bool,
  fontHeight: ReactPropTypes.number,
  allowedWidthExpansion: ReactPropTypes.number,
  movedDuringLastMouseDown: ReactPropTypes.bool.isRequired
};
FeatureGlyph.defaultProps = {
  reversed: false,
  selected: false,
  name: '',
  shouldShowName: false,
  description: '',
  shouldShowDescription: false,
  fontHeight: undefined,
  allowedWidthExpansion: undefined
};
var FeatureGlyph$1 = /*#__PURE__*/observer(FeatureGlyph);

function OverlayRect(_ref) {
  var rect = _ref.rect,
      region = _ref.region,
      bpPerPx = _ref.bpPerPx,
      rectProps = _objectWithoutProperties(_ref, ["rect", "region", "bpPerPx"]);

  if (!rect) {
    return null;
  }

  var _rect = _slicedToArray(rect, 4),
      leftBp = _rect[0],
      topPx = _rect[1],
      rightBp = _rect[2],
      bottomPx = _rect[3];

  var _bpSpanPx = bpSpanPx(leftBp, rightBp, region, bpPerPx),
      _bpSpanPx2 = _slicedToArray(_bpSpanPx, 2),
      leftPx = _bpSpanPx2[0],
      rightPx = _bpSpanPx2[1];

  var rectTop = Math.round(topPx);
  var screenWidth = (region.end - region.start) / bpPerPx;
  var rectHeight = Math.round(bottomPx - topPx);
  var width = rightPx - leftPx;

  if (leftPx + width < 0) {
    return null;
  }

  var leftWithinBlock = Math.max(leftPx, 0);
  var diff = leftWithinBlock - leftPx;
  var widthWithinBlock = Math.max(1, Math.min(width - diff, screenWidth));
  return /*#__PURE__*/React.createElement("rect", Object.assign({
    x: leftWithinBlock - 2,
    y: rectTop - 2,
    width: widthWithinBlock + 4,
    height: rectHeight + 4
  }, rectProps));
}

function SvgOverlay(_ref2) {
  var _ref2$displayModel = _ref2.displayModel,
      blockLayoutFeatures = _ref2$displayModel.blockLayoutFeatures,
      selectedFeatureId = _ref2$displayModel.selectedFeatureId,
      featureIdUnderMouse = _ref2$displayModel.featureIdUnderMouse,
      contextMenuFeature = _ref2$displayModel.contextMenuFeature,
      blockKey = _ref2.blockKey,
      region = _ref2.region,
      bpPerPx = _ref2.bpPerPx,
      movedDuringLastMouseDown = _ref2.movedDuringLastMouseDown,
      handlers = _objectWithoutProperties(_ref2, ["displayModel", "blockKey", "region", "bpPerPx", "movedDuringLastMouseDown"]);

  var blockLayout = blockLayoutFeatures === null || blockLayoutFeatures === void 0 ? void 0 : blockLayoutFeatures.get(blockKey);

  if (!blockLayout) {
    return null;
  }

  var mouseoverFeatureId = featureIdUnderMouse || (contextMenuFeature === null || contextMenuFeature === void 0 ? void 0 : contextMenuFeature.id());

  function onFeatureMouseDown(event) {
    var handler = handlers.onFeatureMouseDown;

    if (!(handler && mouseoverFeatureId)) {
      return undefined;
    }

    return handler(event, mouseoverFeatureId);
  }

  function onFeatureMouseEnter(event) {
    var handler = handlers.onFeatureMouseEnter;

    if (!(handler && mouseoverFeatureId)) {
      return undefined;
    }

    return handler(event, mouseoverFeatureId);
  }

  function onFeatureMouseOut(event) {
    var handler = handlers.onFeatureMouseOut;

    if (!(handler && mouseoverFeatureId)) {
      return undefined;
    }

    return handler(event, mouseoverFeatureId);
  }

  function onFeatureMouseOver(event) {
    var handler = handlers.onFeatureMouseOver;

    if (!(handler && mouseoverFeatureId)) {
      return undefined;
    }

    return handler(event, mouseoverFeatureId);
  }

  function onFeatureMouseUp(event) {
    var handler = handlers.onFeatureMouseUp;

    if (!(handler && mouseoverFeatureId)) {
      return undefined;
    }

    return handler(event, mouseoverFeatureId);
  }

  function onFeatureMouseLeave(event) {
    var handler = handlers.onFeatureMouseLeave;

    if (!(handler && mouseoverFeatureId)) {
      return undefined;
    }

    return handler(event, mouseoverFeatureId);
  }

  function onFeatureMouseMove(event) {
    var handler = handlers.onFeatureMouseMove;

    if (!(handler && mouseoverFeatureId)) {
      return undefined;
    }

    return handler(event, mouseoverFeatureId);
  }

  function onFeatureClick(event) {
    if (movedDuringLastMouseDown) {
      return undefined;
    }

    var handler = handlers.onFeatureClick;

    if (!(handler && mouseoverFeatureId)) {
      return undefined;
    }

    event.stopPropagation();
    return handler(event, mouseoverFeatureId);
  }

  function onFeatureContextMenu(event) {
    var handler = handlers.onFeatureContextMenu;

    if (!(handler && mouseoverFeatureId)) {
      return undefined;
    }

    return handler(event, mouseoverFeatureId);
  }

  return /*#__PURE__*/React.createElement(React.Fragment, null, mouseoverFeatureId ? /*#__PURE__*/React.createElement(OverlayRect, {
    rect: blockLayout.get(mouseoverFeatureId),
    region: region,
    bpPerPx: bpPerPx,
    fill: "#000",
    fillOpacity: "0.2",
    onMouseDown: onFeatureMouseDown,
    onMouseEnter: onFeatureMouseEnter,
    onMouseOut: onFeatureMouseOut,
    onMouseOver: onFeatureMouseOver,
    onMouseUp: onFeatureMouseUp,
    onMouseLeave: onFeatureMouseLeave,
    onMouseMove: onFeatureMouseMove,
    onClick: onFeatureClick,
    onContextMenu: onFeatureContextMenu,
    onFocus: onFeatureMouseOver,
    onBlur: onFeatureMouseOut,
    "data-testid": mouseoverFeatureId
  }) : null, selectedFeatureId ? /*#__PURE__*/React.createElement(OverlayRect, {
    rect: blockLayout.get(selectedFeatureId),
    region: region,
    bpPerPx: bpPerPx,
    stroke: "#00b8ff",
    fill: "none"
  }) : null);
}

var SvgOverlay$1 = /*#__PURE__*/observer(SvgOverlay);

function Box(props) {
  var feature = props.feature,
      region = props.region,
      config = props.config,
      featureLayout = props.featureLayout,
      selected = props.selected,
      bpPerPx = props.bpPerPx;
  var screenWidth = (region.end - region.start) / bpPerPx;
  var color1 = readConfObject(config, 'color1', {
    feature: feature
  });
  var emphasizedColor1;

  try {
    emphasizedColor1 = emphasize(color1, 0.3);
  } catch (error) {
    emphasizedColor1 = color1;
  }

  var color2 = readConfObject(config, 'color2', {
    feature: feature
  });
  var _featureLayout$absolu = featureLayout.absolute,
      left = _featureLayout$absolu.left,
      top = _featureLayout$absolu.top,
      width = _featureLayout$absolu.width,
      height = _featureLayout$absolu.height;

  if (left + width < 0) {
    return null;
  }

  var leftWithinBlock = Math.max(left, 0);
  var diff = leftWithinBlock - left;
  var widthWithinBlock = Math.max(1, Math.min(width - diff, screenWidth));
  return /*#__PURE__*/React.createElement("rect", {
    "data-testid": "box-".concat(feature.id()),
    x: leftWithinBlock,
    y: top,
    width: widthWithinBlock,
    height: height,
    fill: selected ? emphasizedColor1 : color1,
    stroke: selected ? color2 : undefined
  });
}

Box.propTypes = {
  feature: /*#__PURE__*/ReactPropTypes.shape({
    get: ReactPropTypes.func.isRequired,
    id: ReactPropTypes.func.isRequired
  }).isRequired,
  region: PropTypes.Region.isRequired,
  bpPerPx: ReactPropTypes.number.isRequired,
  featureLayout: /*#__PURE__*/ReactPropTypes.shape({
    absolute: /*#__PURE__*/ReactPropTypes.shape({
      top: ReactPropTypes.number.isRequired,
      left: ReactPropTypes.number.isRequired,
      width: ReactPropTypes.number.isRequired,
      height: ReactPropTypes.number.isRequired
    })
  }).isRequired,
  selected: ReactPropTypes.bool,
  config: PropTypes.ConfigSchema.isRequired
};
Box.defaultProps = {
  selected: false
};
var Box$1 = /*#__PURE__*/observer(Box);

var utrHeightFraction = 0.65;

function Chevron(props) {
  var feature = props.feature,
      bpPerPx = props.bpPerPx,
      region = props.region,
      config = props.config,
      featureLayout = props.featureLayout,
      selected = props.selected,
      reversed = props.reversed;
  var screenWidth = (region.end - region.start) / bpPerPx;
  var width = Math.max(featureLayout.absolute.width, 1);
  var left = featureLayout.absolute.left;
  var _featureLayout$absolu = featureLayout.absolute,
      top = _featureLayout$absolu.top,
      height = _featureLayout$absolu.height;

  if (isUTR$1(feature)) {
    top += (1 - utrHeightFraction) / 2 * height;
    height *= utrHeightFraction;
  }

  var strand = feature.get('strand');
  var direction = strand * (reversed ? -1 : 1);
  var color = isUTR$1(feature) ? readConfObject(config, 'color3', {
    feature: feature
  }) : readConfObject(config, 'color1', {
    feature: feature
  });
  var emphasizedColor;

  try {
    emphasizedColor = emphasize(color, 0.3);
  } catch (error) {
    emphasizedColor = color;
  }

  var color2 = readConfObject(config, 'color2', {
    feature: feature
  });

  if (left + width < 0) {
    return null;
  }

  var leftWithinBlock = Math.max(left, 0);
  var diff = leftWithinBlock - left;
  var widthWithinBlock = Math.max(1, Math.min(width - diff, screenWidth));
  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("rect", {
    "data-testid": feature.id(),
    stroke: selected ? color2 : undefined,
    fill: selected ? emphasizedColor : color,
    x: leftWithinBlock,
    y: top,
    width: widthWithinBlock,
    height: height
  }), direction < 0 && diff === 0 ? /*#__PURE__*/React.createElement("polygon", {
    stroke: selected ? color2 : undefined,
    fill: selected ? emphasizedColor : color,
    points: [[left, top], [left - height / 2, top + height / 2], [left, top + height]]
  }) : null, direction > 0 && leftWithinBlock + widthWithinBlock < screenWidth ? /*#__PURE__*/React.createElement("polygon", {
    stroke: selected ? color2 : undefined,
    fill: selected ? emphasizedColor : color,
    points: [[leftWithinBlock + widthWithinBlock, top], [leftWithinBlock + widthWithinBlock + height / 2, top + height / 2], [leftWithinBlock + widthWithinBlock, top + height]]
  }) : null);
}

Chevron.propTypes = {
  feature: /*#__PURE__*/ReactPropTypes.shape({
    id: ReactPropTypes.func.isRequired,
    get: ReactPropTypes.func.isRequired
  }).isRequired,
  region: PropTypes.Region.isRequired,
  bpPerPx: ReactPropTypes.number.isRequired,
  featureLayout: /*#__PURE__*/ReactPropTypes.shape({
    absolute: /*#__PURE__*/ReactPropTypes.shape({
      top: ReactPropTypes.number.isRequired,
      left: ReactPropTypes.number.isRequired,
      width: ReactPropTypes.number.isRequired,
      height: ReactPropTypes.number.isRequired
    })
  }).isRequired,
  selected: ReactPropTypes.bool,
  config: PropTypes.ConfigSchema.isRequired,
  reversed: ReactPropTypes.bool
};
Chevron.defaultProps = {
  selected: false,
  reversed: false
};
var Chevron$1 = /*#__PURE__*/observer(Chevron);

function Segments(props) {
  var feature = props.feature,
      featureLayout = props.featureLayout,
      selected = props.selected,
      config = props.config,
      reversed = props.reversed,
      subfeaturesProp = props.subfeatures;
  var subfeatures = subfeaturesProp || feature.get('subfeatures');
  var color2 = readConfObject(config, 'color2', {
    feature: feature
  });
  var emphasizedColor2;

  try {
    emphasizedColor2 = emphasize(color2, 0.3);
  } catch (error) {
    emphasizedColor2 = color2;
  }

  var _featureLayout$absolu = featureLayout.absolute,
      left = _featureLayout$absolu.left,
      top = _featureLayout$absolu.top,
      width = _featureLayout$absolu.width,
      height = _featureLayout$absolu.height;
  var points = [[left, top + height / 2], [left + width, top + height / 2]];
  var strand = feature.get('strand');

  if (strand) {
    points.push([left + width - height / 4, top + height / 4], [left + width - height / 4, top + 3 * (height / 4)], [left + width, top + height / 2]);
  }

  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("polyline", {
    "data-testid": feature.id(),
    transform: strand && (!reversed && strand < 0 || reversed && strand > 0) ? "rotate(180,".concat(left + width / 2, ",").concat(top + height / 2, ")") : undefined,
    points: points,
    stroke: selected ? emphasizedColor2 : color2
  }), // eslint-disable-next-line react/prop-types
  subfeatures.map(function (subfeature) {
    var subfeatureId = String(subfeature.id());
    var subfeatureLayout = featureLayout.getSubRecord(subfeatureId); // This subfeature got filtered out

    if (!subfeatureLayout) {
      return null;
    }

    var GlyphComponent = subfeatureLayout.data.GlyphComponent;
    return /*#__PURE__*/React.createElement(GlyphComponent, _extends({
      key: "glyph-".concat(subfeatureId)
    }, props, {
      feature: subfeature,
      featureLayout: subfeatureLayout,
      selected: selected
    }));
  }));
}

Segments.propTypes = {
  feature: /*#__PURE__*/ReactPropTypes.shape({
    id: ReactPropTypes.func.isRequired,
    get: ReactPropTypes.func.isRequired
  }).isRequired,
  featureLayout: /*#__PURE__*/ReactPropTypes.shape({
    absolute: /*#__PURE__*/ReactPropTypes.shape({
      top: ReactPropTypes.number.isRequired,
      left: ReactPropTypes.number.isRequired,
      width: ReactPropTypes.number.isRequired,
      height: ReactPropTypes.number.isRequired
    }),
    getSubRecord: ReactPropTypes.func.isRequired
  }).isRequired,
  selected: ReactPropTypes.bool,
  config: PropTypes.ConfigSchema.isRequired,
  reversed: ReactPropTypes.bool
};
Segments.defaultProps = {
  selected: false,
  reversed: false
};
var Segments$1 = /*#__PURE__*/observer(Segments);

function ProcessedTranscript(props) {
  // eslint-disable-next-line react/prop-types
  var feature = props.feature,
      config = props.config;
  var subfeatures = getSubparts(feature, config); // we manually compute some subfeatures, so pass these separately

  return /*#__PURE__*/React.createElement(Segments$1, _extends({}, props, {
    subfeatures: subfeatures
  }));
} // make a function that will filter features features according to the
// subParts conf var


function makeSubpartsFilter() {
  var confKey = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'subParts';
  var config = arguments.length > 1 ? arguments[1] : undefined;
  var filter = readConfObject(config, confKey);

  if (typeof filter == 'string') {
    // convert to array
    filter = filter.split(/\s*,\s*/);
  }

  if (Array.isArray(filter)) {
    var typeNames = filter.map(function (typeName) {
      return typeName.toLowerCase();
    });
    return function (feature) {
      return typeNames.includes(feature.get('type').toLowerCase());
    };
  }

  if (typeof filter === 'function') {
    return filter;
  }

  return function () {
    return true;
  };
}

function filterSubpart(feature, config) {
  return makeSubpartsFilter('subParts', config)(feature);
}

function isUTR(feature) {
  return /(\bUTR|_UTR|untranslated[_\s]region)\b/.test(feature.get('type') || '');
}

function makeUTRs(parent, subs) {
  // based on Lincoln's UTR-making code in Bio::Graphics::Glyph::processed_transcript
  var subparts = _toConsumableArray(subs);

  var codeStart = Infinity;
  var codeEnd = -Infinity;
  var haveLeftUTR;
  var haveRightUTR; // gather exons, find coding start and end, and look for UTRs

  var exons = [];

  for (var i = 0; i < subparts.length; i++) {
    var type = subparts[i].get('type');

    if (/^cds/i.test(type)) {
      if (codeStart > subparts[i].get('start')) {
        codeStart = subparts[i].get('start');
      }

      if (codeEnd < subparts[i].get('end')) {
        codeEnd = subparts[i].get('end');
      }
    } else if (/exon/i.test(type)) {
      exons.push(subparts[i]);
    } else if (isUTR(subparts[i])) {
      haveLeftUTR = subparts[i].get('start') === parent.get('start');
      haveRightUTR = subparts[i].get('end') === parent.get('end');
    }
  } // bail if we don't have exons and CDS


  if (!(exons.length && codeStart < Infinity && codeEnd > -Infinity)) {
    return subparts;
  } // make sure the exons are sorted by coord


  exons.sort(function (a, b) {
    return a.get('start') - b.get('start');
  });
  var strand = parent.get('strand'); // make the left-hand UTRs

  var start;
  var end;

  if (!haveLeftUTR) {
    for (var _i = 0; _i < exons.length; _i++) {
      start = exons[_i].get('start');

      if (start >= codeStart) {
        break;
      }

      end = codeStart > exons[_i].get('end') ? exons[_i].get('end') : codeStart;

      var _type = strand >= 0 ? 'five_prime_UTR' : 'three_prime_UTR';

      subparts.unshift(new SimpleFeature({
        parent: parent,
        id: "".concat(parent.id(), "_").concat(_type, "_").concat(_i),
        data: {
          start: start,
          end: end,
          strand: strand,
          type: _type
        }
      }));
    }
  } // make the right-hand UTRs


  if (!haveRightUTR) {
    for (var _i2 = exons.length - 1; _i2 >= 0; _i2--) {
      end = exons[_i2].get('end');

      if (end <= codeEnd) {
        break;
      }

      start = codeEnd < exons[_i2].get('start') ? exons[_i2].get('start') : codeEnd;

      var _type2 = strand >= 0 ? 'three_prime_UTR' : 'five_prime_UTR';

      subparts.push(new SimpleFeature({
        parent: parent,
        id: "".concat(parent.id(), "_").concat(_type2, "_").concat(_i2),
        data: {
          start: start,
          end: end,
          strand: strand,
          type: _type2
        }
      }));
    }
  }

  return subparts;
}

function getSubparts(f, config) {
  var c = f.get('subfeatures');

  if (!c || !c.length) {
    return [];
  }

  var hasUTRs = !!c.find(function (child) {
    return isUTR(child);
  });
  var isTranscript = ['mRNA', 'transcript'].includes(f.get('type'));
  var impliedUTRs = !hasUTRs && isTranscript; // if we think we should use impliedUTRs, or it is specifically in the
  // config, then makeUTRs

  if (impliedUTRs || readConfObject(config, 'impliedUTRs')) {
    c = makeUTRs(f, c);
  }

  return c.filter(function (element) {
    return filterSubpart(element, config);
  });
}

ProcessedTranscript.layOut = function (_ref) {
  var layout = _ref.layout,
      feature = _ref.feature,
      bpPerPx = _ref.bpPerPx,
      reversed = _ref.reversed,
      config = _ref.config;
  var subLayout = layOutFeature({
    layout: layout,
    feature: feature,
    bpPerPx: bpPerPx,
    reversed: reversed,
    config: config
  });
  var subfeatures = getSubparts(feature, config);
  layOutSubfeatures({
    layout: subLayout,
    subfeatures: subfeatures,
    bpPerPx: bpPerPx,
    reversed: reversed,
    config: config
  });
  return subLayout;
};

var ProcessedTranscript$1 = /*#__PURE__*/observer(ProcessedTranscript);

function Subfeatures(props) {
  var feature = props.feature,
      featureLayout = props.featureLayout,
      selected = props.selected;
  return /*#__PURE__*/React.createElement(React.Fragment, null, feature.get('subfeatures').map(function (subfeature) {
    var subfeatureId = String(subfeature.id());
    var subfeatureLayout = featureLayout.getSubRecord(subfeatureId);
    var GlyphComponent = subfeatureLayout.data.GlyphComponent;
    return /*#__PURE__*/React.createElement(GlyphComponent, _extends({
      key: "glyph-".concat(subfeatureId)
    }, props, {
      feature: subfeature,
      featureLayout: subfeatureLayout,
      selected: selected
    }));
  }));
}

Subfeatures.propTypes = {
  feature: /*#__PURE__*/ReactPropTypes.shape({
    get: ReactPropTypes.func.isRequired
  }).isRequired,
  featureLayout: /*#__PURE__*/ReactPropTypes.shape({
    getSubRecord: ReactPropTypes.func.isRequired
  }).isRequired,
  selected: ReactPropTypes.bool,
  reversed: ReactPropTypes.bool
};
Subfeatures.defaultProps = {
  selected: false,
  reversed: false
};

Subfeatures.layOut = function (_ref) {
  var layout = _ref.layout,
      feature = _ref.feature,
      bpPerPx = _ref.bpPerPx,
      reversed = _ref.reversed,
      config = _ref.config;
  var subLayout = layOutFeature({
    layout: layout,
    feature: feature,
    bpPerPx: bpPerPx,
    reversed: reversed,
    config: config
  });
  var displayMode = readConfObject(config, 'displayMode');

  if (displayMode !== 'reducedRepresentation') {
    var subfeatures = feature.get('subfeatures') || [];
    var topOffset = 0;
    subfeatures.forEach(function (subfeature) {
      var SubfeatureGlyphComponent = chooseGlyphComponent(subfeature);
      var subfeatureHeight = readConfObject(config, 'height', {
        feature: subfeature
      });
      var subSubLayout = (SubfeatureGlyphComponent.layOut || layOut)({
        layout: subLayout,
        feature: subfeature,
        bpPerPx: bpPerPx,
        reversed: reversed,
        config: config
      });
      subSubLayout.move(0, topOffset);
      topOffset += displayMode === 'collapse' ? 0 : (displayMode === 'compact' ? subfeatureHeight / 3 : subfeatureHeight) + 2;
    });
  }

  return subLayout;
};

var Subfeatures$1 = /*#__PURE__*/observer(Subfeatures);

function chooseGlyphComponent(feature) {
  var type = feature.get('type');
  var strand = feature.get('strand');
  var subfeatures = feature.get('subfeatures');

  if (subfeatures) {
    var hasSubSub = subfeatures.find(function (subfeature) {
      return !!subfeature.get('subfeatures');
    });

    if (hasSubSub) {
      return Subfeatures$1;
    }

    var transcriptTypes = ['mRNA', 'transcript'];

    if (transcriptTypes.includes(type) && subfeatures.find(function (f) {
      return f.get('type') === 'CDS';
    })) {
      return ProcessedTranscript$1;
    }

    return Segments$1;
  }

  return [1, -1].includes(strand) ? Chevron$1 : Box$1;
}
function layOut(_ref) {
  var layout = _ref.layout,
      feature = _ref.feature,
      bpPerPx = _ref.bpPerPx,
      reversed = _ref.reversed,
      config = _ref.config;
  var displayMode = readConfObject(config, 'displayMode');
  var subLayout = layOutFeature({
    layout: layout,
    feature: feature,
    bpPerPx: bpPerPx,
    reversed: reversed,
    config: config
  });

  if (displayMode !== 'reducedRepresentation') {
    layOutSubfeatures({
      layout: subLayout,
      subfeatures: feature.get('subfeatures') || [],
      bpPerPx: bpPerPx,
      reversed: reversed,
      config: config
    });
  }

  return subLayout;
}
function layOutFeature(args) {
  var layout = args.layout,
      feature = args.feature,
      bpPerPx = args.bpPerPx,
      reversed = args.reversed,
      config = args.config;
  var displayMode = readConfObject(config, 'displayMode');
  var GlyphComponent = displayMode === 'reducedRepresentation' ? Chevron$1 : chooseGlyphComponent(feature);
  var parentFeature = feature.parent();
  var x = 0;

  if (parentFeature) {
    x = reversed ? (parentFeature.get('end') - feature.get('end')) / bpPerPx : (feature.get('start') - parentFeature.get('start')) / bpPerPx;
  }

  var height = readConfObject(config, 'height', {
    feature: feature
  });
  var width = (feature.get('end') - feature.get('start')) / bpPerPx;
  var layoutParent = layout.parent;
  var top = layoutParent ? layoutParent.top : 0;
  var subLayout = layout.addChild(String(feature.id()), x, displayMode === 'collapse' ? 0 : top, width, displayMode === 'compact' ? height / 2 : height, {
    GlyphComponent: GlyphComponent
  });
  return subLayout;
}
function layOutSubfeatures(args) {
  var subLayout = args.layout,
      subfeatures = args.subfeatures,
      bpPerPx = args.bpPerPx,
      reversed = args.reversed,
      config = args.config;
  subfeatures.forEach(function (subfeature) {
    var SubfeatureGlyphComponent = chooseGlyphComponent(subfeature);
    (SubfeatureGlyphComponent.layOut || layOut)({
      layout: subLayout,
      feature: subfeature,
      bpPerPx: bpPerPx,
      reversed: reversed,
      config: config
    });
  });
}
function isUTR$1(feature) {
  return /(\bUTR|_UTR|untranslated[_\s]region)\b/.test(feature.get('type') || '');
}

var renderingStyle = {
  position: 'relative'
};
var padding = 2;

function RenderedFeatureGlyph(props) {
  var feature = props.feature,
      bpPerPx = props.bpPerPx,
      region = props.region,
      config = props.config,
      displayMode = props.displayMode,
      layout = props.layout;
  var reversed = region.reversed;
  var start = feature.get(reversed ? 'end' : 'start');
  var startPx = bpToPx(start, region, bpPerPx);
  var labelsAllowed = displayMode !== 'compact' && displayMode !== 'collapsed';
  var rootLayout = new SceneGraph('root', 0, 0, 0, 0);
  var GlyphComponent = chooseGlyphComponent(feature);
  var featureLayout = (GlyphComponent.layOut || layOut)({
    layout: rootLayout,
    feature: feature,
    bpPerPx: bpPerPx,
    reversed: reversed,
    config: config
  });
  var shouldShowName;
  var shouldShowDescription;
  var name;
  var description;
  var fontHeight;
  var expansion;

  if (labelsAllowed) {
    var showLabels = readConfObject(config, 'showLabels');
    fontHeight = readConfObject(config, ['labels', 'fontSize'], {
      feature: feature
    });
    expansion = readConfObject(config, 'maxFeatureGlyphExpansion') || 0;
    name = readConfObject(config, ['labels', 'name'], {
      feature: feature
    }) || '';
    shouldShowName = /\S/.test(name) && showLabels;
    description = readConfObject(config, ['labels', 'description'], {
      feature: feature
    }) || '';
    shouldShowDescription = /\S/.test(description) && showLabels;
    var textVerticalPadding = 2;
    var nameWidth = 0;

    if (shouldShowName) {
      nameWidth = Math.round(Math.min(measureText(name, fontHeight), rootLayout.width + expansion)) + padding;
      rootLayout.addChild('nameLabel', 0, featureLayout.bottom + textVerticalPadding, nameWidth, fontHeight);
    }

    var descriptionWidth = 0;

    if (shouldShowDescription) {
      var aboveLayout = shouldShowName ? rootLayout.getSubRecord('nameLabel') : featureLayout;
      descriptionWidth = Math.round(Math.min(measureText(description, fontHeight), rootLayout.width + expansion)) + padding;
      rootLayout.addChild('descriptionLabel', 0, aboveLayout.bottom + textVerticalPadding, descriptionWidth, fontHeight);
    }
  }

  var topPx = layout.addRect(feature.id(), feature.get('start'), feature.get('start') + rootLayout.width * bpPerPx, rootLayout.height);

  if (topPx === null) {
    return null;
  }

  rootLayout.move(startPx, topPx);
  return /*#__PURE__*/React.createElement(FeatureGlyph$1, _extends({
    key: "svg-feature-".concat(feature.id()),
    feature: feature,
    layout: layout,
    rootLayout: rootLayout,
    bpPerPx: bpPerPx,
    config: config,
    name: String(name),
    shouldShowName: shouldShowName,
    description: String(description),
    shouldShowDescription: shouldShowDescription,
    fontHeight: fontHeight,
    allowedWidthExpansion: expansion,
    reversed: region.reversed
  }, props));
}

RenderedFeatureGlyph.propTypes = {
  layout: /*#__PURE__*/ReactPropTypes.shape({
    addRect: ReactPropTypes.func.isRequired,
    getTotalHeight: ReactPropTypes.func.isRequired
  }).isRequired,
  displayMode: ReactPropTypes.string.isRequired,
  region: PropTypes.Region.isRequired,
  bpPerPx: ReactPropTypes.number.isRequired,
  feature: /*#__PURE__*/ReactPropTypes.shape({
    id: ReactPropTypes.func.isRequired,
    get: ReactPropTypes.func.isRequired
  }).isRequired,
  config: PropTypes.ConfigSchema.isRequired
};
var RenderedFeatures = /*#__PURE__*/observer(function (props) {
  var features = props.features;
  var featuresRendered = [];

  var _iterator = _createForOfIteratorHelper(features.values()),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var feature = _step.value;
      featuresRendered.push( /*#__PURE__*/React.createElement(RenderedFeatureGlyph, _extends({
        key: feature.id(),
        feature: feature
      }, props)));
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return /*#__PURE__*/React.createElement(React.Fragment, null, featuresRendered);
});
RenderedFeatures.propTypes = {
  features: /*#__PURE__*/ReactPropTypes.oneOfType([/*#__PURE__*/ReactPropTypes.instanceOf(Map), /*#__PURE__*/ReactPropTypes.arrayOf( /*#__PURE__*/ReactPropTypes.shape())]),
  layout: /*#__PURE__*/ReactPropTypes.shape({
    addRect: ReactPropTypes.func.isRequired,
    getTotalHeight: ReactPropTypes.func.isRequired
  }).isRequired
};
RenderedFeatures.defaultProps = {
  features: []
};

function SvgFeatureRendering(props) {
  var layout = props.layout,
      blockKey = props.blockKey,
      regions = props.regions,
      bpPerPx = props.bpPerPx,
      features = props.features,
      config = props.config,
      displayModel = props.displayModel,
      exportSVG = props.exportSVG;

  var _ref = regions || [],
      _ref2 = _slicedToArray(_ref, 1),
      region = _ref2[0];

  var width = (region.end - region.start) / bpPerPx;
  var displayMode = readConfObject(config, 'displayMode');
  var ref = useRef();

  var _useState = useState(false),
      _useState2 = _slicedToArray(_useState, 2),
      mouseIsDown = _useState2[0],
      setMouseIsDown = _useState2[1];

  var _useState3 = useState(false),
      _useState4 = _slicedToArray(_useState3, 2),
      movedDuringLastMouseDown = _useState4[0],
      setMovedDuringLastMouseDown = _useState4[1];

  var _useState5 = useState(0),
      _useState6 = _slicedToArray(_useState5, 2),
      height = _useState6[0],
      setHeight = _useState6[1];

  var onMouseOut = props.onMouseOut,
      onMouseDown = props.onMouseDown,
      onMouseLeave = props.onMouseLeave,
      onMouseEnter = props.onMouseEnter,
      onMouseOver = props.onMouseOver,
      onMouseMove = props.onMouseMove,
      onMouseUp = props.onMouseUp,
      onClick = props.onClick;
  var mouseDown = useCallback(function (event) {
    setMouseIsDown(true);
    setMovedDuringLastMouseDown(false);
    var handler = onMouseDown;

    if (!handler) {
      return undefined;
    }

    return handler(event);
  }, [onMouseDown]);
  var mouseUp = useCallback(function (event) {
    setMouseIsDown(false);
    var handler = onMouseUp;

    if (!handler) {
      return undefined;
    }

    return handler(event);
  }, [onMouseUp]);
  var mouseEnter = useCallback(function (event) {
    var handler = onMouseEnter;

    if (!handler) {
      return undefined;
    }

    return handler(event);
  }, [onMouseEnter]);
  var mouseLeave = useCallback(function (event) {
    var handler = onMouseLeave;

    if (!handler) {
      return undefined;
    }

    return handler(event);
  }, [onMouseLeave]);
  var mouseOver = useCallback(function (event) {
    var handler = onMouseOver;

    if (!handler) {
      return undefined;
    }

    return handler(event);
  }, [onMouseOver]);
  var mouseOut = useCallback(function (event) {
    var handler = onMouseOut;

    if (!handler) {
      return undefined;
    }

    return handler(event);
  }, [onMouseOut]);
  var mouseMove = useCallback(function (event) {
    if (mouseIsDown) {
      setMovedDuringLastMouseDown(true);
    }

    var offsetX = 0;
    var offsetY = 0;

    if (ref.current) {
      offsetX = ref.current.getBoundingClientRect().left;
      offsetY = ref.current.getBoundingClientRect().top;
    }

    offsetX = event.clientX - offsetX;
    offsetY = event.clientY - offsetY;
    var px = region.reversed ? width - offsetX : offsetX;
    var clientBp = region.start + bpPerPx * px;
    var featureIdCurrentlyUnderMouse = displayModel.getFeatureOverlapping(blockKey, clientBp, offsetY);

    if (onMouseMove) {
      onMouseMove(event, featureIdCurrentlyUnderMouse);
    }
  }, [blockKey, bpPerPx, mouseIsDown, onMouseMove, region.reversed, region.start, displayModel, width]);
  var click = useCallback(function (event) {
    // don't select a feature if we are clicking and dragging
    if (movedDuringLastMouseDown) {
      return;
    }

    if (onClick) {
      onClick(event);
    }
  }, [movedDuringLastMouseDown, onClick]);
  useEffect(function () {
    setHeight(layout.getTotalHeight());
  }, [layout]);

  if (exportSVG) {
    return /*#__PURE__*/React.createElement(RenderedFeatures, _extends({
      features: features,
      displayMode: displayMode
    }, props, {
      region: region
    }));
  }

  return /*#__PURE__*/React.createElement("div", {
    style: renderingStyle
  }, /*#__PURE__*/React.createElement("svg", {
    ref: ref,
    className: "SvgFeatureRendering",
    width: "".concat(width, "px"),
    height: "".concat(height, "px"),
    onMouseDown: mouseDown,
    onMouseUp: mouseUp,
    onMouseEnter: mouseEnter,
    onMouseLeave: mouseLeave,
    onMouseOver: mouseOver,
    onMouseOut: mouseOut,
    onMouseMove: mouseMove,
    onFocus: mouseEnter,
    onBlur: mouseLeave,
    onClick: click,
    style: {
      display: 'block'
    }
  }, /*#__PURE__*/React.createElement(RenderedFeatures, _extends({
    features: features,
    displayMode: displayMode
  }, props, {
    region: region,
    movedDuringLastMouseDown: movedDuringLastMouseDown
  })), /*#__PURE__*/React.createElement(SvgOverlay$1, _extends({}, props, {
    region: region
  }))));
}

SvgFeatureRendering.propTypes = {
  layout: /*#__PURE__*/ReactPropTypes.shape({
    addRect: ReactPropTypes.func.isRequired,
    getTotalHeight: ReactPropTypes.func.isRequired
  }).isRequired,
  regions: /*#__PURE__*/ReactPropTypes.arrayOf(PropTypes.Region).isRequired,
  bpPerPx: ReactPropTypes.number.isRequired,
  features: /*#__PURE__*/ReactPropTypes.oneOfType([/*#__PURE__*/ReactPropTypes.instanceOf(Map), /*#__PURE__*/ReactPropTypes.arrayOf( /*#__PURE__*/ReactPropTypes.shape())]),
  config: PropTypes.ConfigSchema.isRequired,
  displayModel: /*#__PURE__*/ReactPropTypes.shape({
    configuration: /*#__PURE__*/ReactPropTypes.shape({}),
    getFeatureOverlapping: ReactPropTypes.func,
    selectedFeatureId: ReactPropTypes.string,
    featureIdUnderMouse: ReactPropTypes.string
  }),
  onMouseDown: ReactPropTypes.func,
  onMouseUp: ReactPropTypes.func,
  onMouseEnter: ReactPropTypes.func,
  onMouseLeave: ReactPropTypes.func,
  onMouseOver: ReactPropTypes.func,
  onMouseOut: ReactPropTypes.func,
  onMouseMove: ReactPropTypes.func,
  onClick: ReactPropTypes.func,
  onContextMenu: ReactPropTypes.func,
  onFeatureClick: ReactPropTypes.func,
  onFeatureContextMenu: ReactPropTypes.func,
  blockKey: ReactPropTypes.string,
  exportSVG: /*#__PURE__*/ReactPropTypes.shape({})
};
SvgFeatureRendering.defaultProps = {
  displayModel: {},
  exportSVG: undefined,
  features: /*#__PURE__*/new Map(),
  blockKey: undefined,
  onMouseDown: undefined,
  onMouseUp: undefined,
  onMouseEnter: undefined,
  onMouseLeave: undefined,
  onMouseOver: undefined,
  onMouseOut: undefined,
  onMouseMove: undefined,
  onClick: undefined,
  onContextMenu: undefined,
  onFeatureClick: undefined,
  onFeatureContextMenu: undefined
};
var SvgFeatureRendererReactComponent = /*#__PURE__*/observer(SvgFeatureRendering);

var svgFeatureRendererConfigSchema = /*#__PURE__*/ConfigurationSchema('SvgFeatureRenderer', {
  color1: {
    type: 'color',
    description: 'the main color of each feature',
    defaultValue: 'goldenrod',
    contextVariable: ['feature']
  },
  color2: {
    type: 'color',
    description: 'the secondary color of each feature, used for connecting lines, etc',
    defaultValue: 'black',
    contextVariable: ['feature']
  },
  color3: {
    type: 'color',
    description: 'the tertiary color of each feature, often used for contrasting fills, like on UTRs',
    defaultValue: '#357089',
    contextVariable: ['feature']
  },
  height: {
    type: 'number',
    description: 'height in pixels of the main body of each feature',
    defaultValue: 10,
    contextVariable: ['feature']
  },
  showLabels: {
    type: 'boolean',
    defaultValue: true
  },
  labels: /*#__PURE__*/ConfigurationSchema('SvgFeatureLabels', {
    name: {
      type: 'string',
      description: 'the primary name of the feature to show, if space is available',
      defaultValue: "jexl:get(feature,'name') || get(feature,'id')",
      contextVariable: ['feature']
    },
    nameColor: {
      type: 'color',
      description: 'the color of the name label, if shown',
      defaultValue: 'black',
      contextVariable: ['feature']
    },
    description: {
      type: 'string',
      description: 'the text description to show, if space is available',
      defaultValue: "jexl:get(feature,'note') || get(feature,'description')",
      contextVariable: ['feature']
    },
    descriptionColor: {
      type: 'color',
      description: 'the color of the description, if shown',
      defaultValue: 'blue',
      contextVariable: ['feature']
    },
    fontSize: {
      type: 'number',
      description: 'height in pixels of the text to use for names and descriptions',
      defaultValue: 13,
      contextVariable: ['feature']
    }
  }),
  displayMode: {
    type: 'stringEnum',
    model: /*#__PURE__*/types.enumeration('displayMode', ['normal', 'compact', 'reducedRepresentation', 'collapse']),
    description: 'Alternative display modes',
    defaultValue: 'normal'
  },
  maxFeatureGlyphExpansion: {
    type: 'number',
    description: "maximum number of pixels on each side of a feature's bounding coordinates that a glyph is allowed to use",
    defaultValue: 500
  },
  maxHeight: {
    type: 'integer',
    description: 'the maximum height to be used in a svg rendering',
    defaultValue: 600
  },
  subParts: {
    type: 'string',
    description: 'subparts for a glyph',
    defaultValue: 'CDS,UTR,five_prime_UTR,three_prime_UTR'
  },
  impliedUTRs: {
    type: 'boolean',
    description: 'imply UTR from the exon and CDS differences',
    defaultValue: false
  }
}, {
  explicitlyTyped: true
});

var SvgFeatureRenderer = /*#__PURE__*/function (_BoxRendererType) {
  _inherits(SvgFeatureRenderer, _BoxRendererType);

  var _super = /*#__PURE__*/_createSuper(SvgFeatureRenderer);

  function SvgFeatureRenderer() {
    var _this;

    _classCallCheck(this, SvgFeatureRenderer);

    _this = _super.apply(this, arguments);
    _this.supportsSVG = true;
    return _this;
  }

  return SvgFeatureRenderer;
}(BoxRendererType);

var SVGPlugin = /*#__PURE__*/function (_Plugin) {
  _inherits(SVGPlugin, _Plugin);

  var _super2 = /*#__PURE__*/_createSuper(SVGPlugin);

  function SVGPlugin() {
    var _this2;

    _classCallCheck(this, SVGPlugin);

    _this2 = _super2.apply(this, arguments);
    _this2.name = 'SVGPlugin';
    return _this2;
  }

  _createClass(SVGPlugin, [{
    key: "install",
    value: function install(pluginManager) {
      pluginManager.addRendererType(function () {
        return new SvgFeatureRenderer({
          name: 'SvgFeatureRenderer',
          ReactComponent: SvgFeatureRendererReactComponent,
          configSchema: svgFeatureRendererConfigSchema,
          pluginManager: pluginManager
        });
      });
    }
  }]);

  return SVGPlugin;
}(Plugin);

export default SVGPlugin;
export { SvgFeatureRendererReactComponent, svgFeatureRendererConfigSchema };
//# sourceMappingURL=plugin-svg.esm.js.map
