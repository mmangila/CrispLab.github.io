"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _parseInt2 = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/parse-int"));

var _regenerator = _interopRequireDefault(require("@babel/runtime-corejs2/regenerator"));

var _now = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/date/now"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/defineProperty"));

var _promise = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/promise"));

var _abortablePromiseCache = _interopRequireDefault(require("abortable-promise-cache"));

var _quickLru = _interopRequireDefault(require("quick-lru"));

var _genericFilehandle = require("generic-filehandle");

var _bgzfFilehandle = require("@gmod/bgzf-filehandle");

var _util = require("./util");

var _tbi = _interopRequireDefault(require("./tbi"));

var _csi = _interopRequireDefault(require("./csi"));

function timeout(time) {
  return new _promise.default(function (resolve) {
    setTimeout(resolve, time);
  });
}

var TabixIndexedFile = /*#__PURE__*/function () {
  /**
   * @param {object} args
   * @param {string} [args.path]
   * @param {filehandle} [args.filehandle]
   * @param {string} [args.tbiPath]
   * @param {filehandle} [args.tbiFilehandle]
   * @param {string} [args.csiPath]
   * @param {filehandle} [args.csiFilehandle]
   * @param {chunkSizeLimit} default 50MiB
   * @param {function} [args.renameRefSeqs] optional function with sig `string => string` to transform
   * reference sequence names for the purpose of indexing and querying. note that the data that is returned is
   * not altered, just the names of the reference sequences that are used for querying.
   * @param {number} [args.chunkCacheSize] maximum size in bytes of the chunk cache. default 5MB
   * @param {number} [args.blockCacheSize] maximum size in bytes of the block cache. default 5MB
   */
  function TabixIndexedFile(_ref) {
    var path = _ref.path,
        filehandle = _ref.filehandle,
        tbiPath = _ref.tbiPath,
        tbiFilehandle = _ref.tbiFilehandle,
        csiPath = _ref.csiPath,
        csiFilehandle = _ref.csiFilehandle,
        _ref$chunkSizeLimit = _ref.chunkSizeLimit,
        chunkSizeLimit = _ref$chunkSizeLimit === void 0 ? 50000000 : _ref$chunkSizeLimit,
        _ref$renameRefSeqs = _ref.renameRefSeqs,
        renameRefSeqs = _ref$renameRefSeqs === void 0 ? function (n) {
      return n;
    } : _ref$renameRefSeqs,
        _ref$chunkCacheSize = _ref.chunkCacheSize,
        chunkCacheSize = _ref$chunkCacheSize === void 0 ? 5 * Math.pow(2, 20) : _ref$chunkCacheSize;
    (0, _classCallCheck2.default)(this, TabixIndexedFile);
    (0, _defineProperty2.default)(this, "filehandle", void 0);
    (0, _defineProperty2.default)(this, "index", void 0);
    (0, _defineProperty2.default)(this, "chunkSizeLimit", void 0);
    (0, _defineProperty2.default)(this, "renameRefSeq", void 0);
    (0, _defineProperty2.default)(this, "chunkCache", void 0);
    if (filehandle) this.filehandle = filehandle;else if (path) this.filehandle = new _genericFilehandle.LocalFile(path);else throw new TypeError('must provide either filehandle or path');
    if (tbiFilehandle) this.index = new _tbi.default({
      filehandle: tbiFilehandle,
      renameRefSeqs: renameRefSeqs
    });else if (csiFilehandle) this.index = new _csi.default({
      filehandle: csiFilehandle,
      renameRefSeqs: renameRefSeqs
    });else if (tbiPath) this.index = new _tbi.default({
      filehandle: new _genericFilehandle.LocalFile(tbiPath),
      renameRefSeqs: renameRefSeqs
    });else if (csiPath) this.index = new _csi.default({
      filehandle: new _genericFilehandle.LocalFile(csiPath),
      renameRefSeqs: renameRefSeqs
    });else if (path) {
      this.index = new _tbi.default({
        filehandle: new _genericFilehandle.LocalFile("".concat(path, ".tbi")),
        renameRefSeqs: renameRefSeqs
      });
    } else {
      throw new TypeError('must provide one of tbiFilehandle, tbiPath, csiFilehandle, or csiPath');
    }
    this.chunkSizeLimit = chunkSizeLimit;
    this.renameRefSeq = renameRefSeqs;
    this.chunkCache = new _abortablePromiseCache.default({
      cache: new _quickLru.default({
        maxSize: Math.floor(chunkCacheSize / (1 << 16))
      }),
      fill: this.readChunk.bind(this)
    });
  }
  /**
   * @param {string} refName name of the reference sequence
   * @param {number} start start of the region (in 0-based half-open coordinates)
   * @param {number} end end of the region (in 0-based half-open coordinates)
   * @param {function|object} lineCallback callback called for each line in the region. can also pass a object param containing obj.lineCallback, obj.signal, etc
   * @returns {Promise} resolved when the whole read is finished, rejected on error
   */


  (0, _createClass2.default)(TabixIndexedFile, [{
    key: "getLines",
    value: function () {
      var _getLines = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(refName, start, end, opts) {
        var signal, options, callback, metadata, chunks, i, size, last, chunkNum, previousStartCoordinate, c, _yield$this$chunkCach, buffer, cpositions, dpositions, lines, blockStart, pos, _i, line, _this$checkLine, startCoordinate, overlaps;

        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                options = {};

                if (!(typeof opts === 'undefined')) {
                  _context.next = 3;
                  break;
                }

                throw new TypeError('line callback must be provided');

              case 3:
                if (typeof opts === 'function') callback = opts;else {
                  options = opts;
                  callback = opts.lineCallback;
                }

                if (!(refName === undefined)) {
                  _context.next = 6;
                  break;
                }

                throw new TypeError('must provide a reference sequence name');

              case 6:
                if (callback) {
                  _context.next = 8;
                  break;
                }

                throw new TypeError('line callback must be provided');

              case 8:
                _context.next = 10;
                return this.index.getMetadata(options);

              case 10:
                metadata = _context.sent;
                (0, _util.checkAbortSignal)(signal);

                if (!start) {
                  start = 0;
                }

                if (!end) {
                  end = metadata.maxRefLength;
                }

                if (start <= end) {
                  _context.next = 16;
                  break;
                }

                throw new TypeError('invalid start and end coordinates. start must be less than or equal to end');

              case 16:
                if (!(start === end)) {
                  _context.next = 18;
                  break;
                }

                return _context.abrupt("return");

              case 18:
                _context.next = 20;
                return this.index.blocksForRange(refName, start, end, options);

              case 20:
                chunks = _context.sent;
                (0, _util.checkAbortSignal)(signal); // check the chunks for any that are over the size limit.  if
                // any are, don't fetch any of them

                i = 0;

              case 23:
                if (!(i < chunks.length)) {
                  _context.next = 30;
                  break;
                }

                size = chunks[i].fetchedSize();

                if (!(size > this.chunkSizeLimit)) {
                  _context.next = 27;
                  break;
                }

                throw new Error("Too much data. Chunk size ".concat(size.toLocaleString(), " bytes exceeds chunkSizeLimit of ").concat(this.chunkSizeLimit.toLocaleString(), "."));

              case 27:
                i += 1;
                _context.next = 23;
                break;

              case 30:
                // now go through each chunk and parse and filter the lines out of it
                last = (0, _now.default)();
                chunkNum = 0;

              case 32:
                if (!(chunkNum < chunks.length)) {
                  _context.next = 72;
                  break;
                }

                previousStartCoordinate = void 0;
                c = chunks[chunkNum];
                _context.next = 37;
                return this.chunkCache.get(c.toString(), c, signal);

              case 37:
                _yield$this$chunkCach = _context.sent;
                buffer = _yield$this$chunkCach.buffer;
                cpositions = _yield$this$chunkCach.cpositions;
                dpositions = _yield$this$chunkCach.dpositions;
                lines = (typeof TextDecoder !== 'undefined' ? new TextDecoder('utf-8').decode(buffer) : buffer.toString()).split('\n');
                lines.pop();
                (0, _util.checkAbortSignal)(signal);
                blockStart = c.minv.dataPosition;
                pos = void 0;
                _i = 0;

              case 47:
                if (!(_i < lines.length)) {
                  _context.next = 69;
                  break;
                }

                line = lines[_i];

                for (pos = 0; blockStart >= dpositions[pos]; pos += 1) {
                  ;
                } // filter the line for whether it is within the requested range


                _this$checkLine = this.checkLine(metadata, refName, start, end, line), startCoordinate = _this$checkLine.startCoordinate, overlaps = _this$checkLine.overlaps; // do a small check just to make sure that the lines are really sorted by start coordinate

                if (!(previousStartCoordinate !== undefined && startCoordinate !== undefined && previousStartCoordinate > startCoordinate)) {
                  _context.next = 53;
                  break;
                }

                throw new Error("Lines not sorted by start coordinate (".concat(previousStartCoordinate, " > ").concat(startCoordinate, "), this file is not usable with Tabix."));

              case 53:
                previousStartCoordinate = startCoordinate;

                if (!overlaps) {
                  _context.next = 58;
                  break;
                }

                callback(line.trim(), // cpositions[pos] refers to actual file offset of a bgzip block boundaries
                //
                // we multiply by (1 <<8) in order to make sure each block has a "unique"
                // address space so that data in that block could never overlap
                //
                // then the blockStart-dpositions is an uncompressed file offset from
                // that bgzip block boundary, and since the cpositions are multiplied by
                // (1 << 8) these uncompressed offsets get a unique space
                cpositions[pos] * (1 << 8) + (blockStart - dpositions[pos]));
                _context.next = 60;
                break;

              case 58:
                if (!(startCoordinate !== undefined && startCoordinate >= end)) {
                  _context.next = 60;
                  break;
                }

                return _context.abrupt("return");

              case 60:
                blockStart += line.length + 1; // yield if we have emitted beyond the yield limit

                if (!(last - (0, _now.default)() > 500)) {
                  _context.next = 66;
                  break;
                }

                last = (0, _now.default)();
                (0, _util.checkAbortSignal)(signal);
                _context.next = 66;
                return timeout(1);

              case 66:
                _i += 1;
                _context.next = 47;
                break;

              case 69:
                chunkNum += 1;
                _context.next = 32;
                break;

              case 72:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getLines(_x, _x2, _x3, _x4) {
        return _getLines.apply(this, arguments);
      }

      return getLines;
    }()
  }, {
    key: "getMetadata",
    value: function () {
      var _getMetadata = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2() {
        var opts,
            _args2 = arguments;
        return _regenerator.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                opts = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : {};
                return _context2.abrupt("return", this.index.getMetadata(opts));

              case 2:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getMetadata() {
        return _getMetadata.apply(this, arguments);
      }

      return getMetadata;
    }()
    /**
     * get a buffer containing the "header" region of
     * the file, which are the bytes up to the first
     * non-meta line
     *
     * @returns {Promise} for a buffer
     */

  }, {
    key: "getHeaderBuffer",
    value: function () {
      var _getHeaderBuffer = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee3() {
        var opts,
            _yield$this$getMetada,
            firstDataLine,
            metaChar,
            maxBlockSize,
            maxFetch,
            bytes,
            lastNewline,
            newlineByte,
            metaByte,
            i,
            _args3 = arguments;

        return _regenerator.default.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                opts = _args3.length > 0 && _args3[0] !== undefined ? _args3[0] : {};
                _context3.next = 3;
                return this.getMetadata(opts);

              case 3:
                _yield$this$getMetada = _context3.sent;
                firstDataLine = _yield$this$getMetada.firstDataLine;
                metaChar = _yield$this$getMetada.metaChar;
                maxBlockSize = _yield$this$getMetada.maxBlockSize;
                (0, _util.checkAbortSignal)(opts.signal);
                maxFetch = firstDataLine && firstDataLine.blockPosition ? firstDataLine.blockPosition + maxBlockSize : maxBlockSize; // TODO: what if we don't have a firstDataLine, and the header
                // actually takes up more than one block? this case is not covered here

                _context3.next = 11;
                return this._readRegion(0, maxFetch, opts);

              case 11:
                bytes = _context3.sent;
                (0, _util.checkAbortSignal)(opts.signal);
                _context3.prev = 13;
                _context3.next = 16;
                return (0, _bgzfFilehandle.unzip)(bytes);

              case 16:
                bytes = _context3.sent;
                _context3.next = 23;
                break;

              case 19:
                _context3.prev = 19;
                _context3.t0 = _context3["catch"](13);
                console.error(_context3.t0);
                throw new Error("error decompressing block ".concat(_context3.t0.code, " at 0 (length ").concat(maxFetch, ") ").concat(_context3.t0));

              case 23:
                if (!metaChar) {
                  _context3.next = 36;
                  break;
                }

                // trim backward from the end
                lastNewline = -1;
                newlineByte = '\n'.charCodeAt(0);
                metaByte = metaChar.charCodeAt(0);
                i = 0;

              case 28:
                if (!(i < bytes.length)) {
                  _context3.next = 35;
                  break;
                }

                if (!(i === lastNewline + 1 && bytes[i] !== metaByte)) {
                  _context3.next = 31;
                  break;
                }

                return _context3.abrupt("break", 35);

              case 31:
                if (bytes[i] === newlineByte) lastNewline = i;

              case 32:
                i += 1;
                _context3.next = 28;
                break;

              case 35:
                bytes = bytes.slice(0, lastNewline + 1);

              case 36:
                return _context3.abrupt("return", bytes);

              case 37:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this, [[13, 19]]);
      }));

      function getHeaderBuffer() {
        return _getHeaderBuffer.apply(this, arguments);
      }

      return getHeaderBuffer;
    }()
    /**
     * get a string containing the "header" region of the
     * file, is the portion up to the first non-meta line
     *
     * @returns {Promise} for a string
     */

  }, {
    key: "getHeader",
    value: function () {
      var _getHeader = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee4() {
        var opts,
            bytes,
            _args4 = arguments;
        return _regenerator.default.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                opts = _args4.length > 0 && _args4[0] !== undefined ? _args4[0] : {};
                _context4.next = 3;
                return this.getHeaderBuffer(opts);

              case 3:
                bytes = _context4.sent;
                (0, _util.checkAbortSignal)(opts.signal);
                return _context4.abrupt("return", bytes.toString('utf8'));

              case 6:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function getHeader() {
        return _getHeader.apply(this, arguments);
      }

      return getHeader;
    }()
    /**
     * get an array of reference sequence names, in the order in which
     * they occur in the file.
     *
     * reference sequence renaming is not applied to these names.
     *
     * @returns {Promise} for an array of string sequence names
     */

  }, {
    key: "getReferenceSequenceNames",
    value: function () {
      var _getReferenceSequenceNames = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee5() {
        var opts,
            metadata,
            _args5 = arguments;
        return _regenerator.default.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                opts = _args5.length > 0 && _args5[0] !== undefined ? _args5[0] : {};
                _context5.next = 3;
                return this.getMetadata(opts);

              case 3:
                metadata = _context5.sent;
                return _context5.abrupt("return", metadata.refIdToName);

              case 5:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function getReferenceSequenceNames() {
        return _getReferenceSequenceNames.apply(this, arguments);
      }

      return getReferenceSequenceNames;
    }()
    /**
     * @param {object} metadata metadata object from the parsed index,
     * containing columnNumbers, metaChar, and format
     * @param {string} regionRefName
     * @param {number} regionStart region start coordinate (0-based-half-open)
     * @param {number} regionEnd region end coordinate (0-based-half-open)
     * @param {array[string]} line
     * @returns {object} like `{startCoordinate, overlaps}`. overlaps is boolean,
     * true if line is a data line that overlaps the given region
     */

  }, {
    key: "checkLine",
    value: function checkLine(_ref2, regionRefName, regionStart, regionEnd, line) {
      var columnNumbers = _ref2.columnNumbers,
          metaChar = _ref2.metaChar,
          coordinateType = _ref2.coordinateType,
          format = _ref2.format;

      // skip meta lines
      if (line.charAt(0) === metaChar) {
        return {
          overlaps: false
        };
      } // check ref/start/end using column metadata from index


      var ref = columnNumbers.ref,
          start = columnNumbers.start,
          end = columnNumbers.end;
      if (!ref) ref = 0;
      if (!start) start = 0;
      if (!end) end = 0;
      if (format === 'VCF') end = 8;
      var maxColumn = Math.max(ref, start, end); // this code is kind of complex, but it is fairly fast.
      // basically, we want to avoid doing a split, because if the lines are really long
      // that could lead to us allocating a bunch of extra memory, which is slow

      var currentColumnNumber = 1; // cols are numbered starting at 1 in the index metadata

      var currentColumnStart = 0;
      var refSeq = '';
      var startCoordinate = -Infinity;

      for (var i = 0; i < line.length + 1; i += 1) {
        if (line[i] === '\t' || i === line.length) {
          if (currentColumnNumber === ref) {
            if (this.renameRefSeq(line.slice(currentColumnStart, i)) !== regionRefName) {
              return {
                overlaps: false
              };
            }
          } else if (currentColumnNumber === start) {
            startCoordinate = (0, _parseInt2.default)(line.slice(currentColumnStart, i), 10); // we convert to 0-based-half-open

            if (coordinateType === '1-based-closed') {
              startCoordinate -= 1;
            }

            if (startCoordinate >= regionEnd) {
              return {
                startCoordinate: startCoordinate,
                overlaps: false
              };
            }

            if (end === 0 || end === start) {
              // if we have no end, we assume the feature is 1 bp long
              if (startCoordinate + 1 <= regionStart) {
                return {
                  startCoordinate: startCoordinate,
                  overlaps: false
                };
              }
            }
          } else if (format === 'VCF' && currentColumnNumber === 4) {
            refSeq = line.slice(currentColumnStart, i);
          } else if (currentColumnNumber === end) {
            var endCoordinate = void 0; // this will never match if there is no end column

            if (format === 'VCF') {
              endCoordinate = this._getVcfEnd(startCoordinate, refSeq, line.slice(currentColumnStart, i));
            } else {
              endCoordinate = (0, _parseInt2.default)(line.slice(currentColumnStart, i), 10);
            }

            if (endCoordinate <= regionStart) {
              return {
                overlaps: false
              };
            }
          }

          currentColumnStart = i + 1;
          currentColumnNumber += 1;

          if (currentColumnNumber > maxColumn) {
            break;
          }
        }
      }

      return {
        startCoordinate: startCoordinate,
        overlaps: true
      };
    }
  }, {
    key: "_getVcfEnd",
    value: function _getVcfEnd(startCoordinate, refSeq, info) {
      var endCoordinate = startCoordinate + refSeq.length; // ignore TRA features as they specify CHR2 and END
      // as being on a different chromosome
      // if CHR2 is on the same chromosome, still ignore it
      // because there should be another pairwise feature
      // at the end of this one

      var isTRA = info.indexOf('SVTYPE=TRA') !== -1;

      if (info[0] !== '.' && !isTRA) {
        var prevChar = ';';

        for (var j = 0; j < info.length; j += 1) {
          if (prevChar === ';' && info.slice(j, j + 4) === 'END=') {
            var valueEnd = info.indexOf(';', j);
            if (valueEnd === -1) valueEnd = info.length;
            endCoordinate = (0, _parseInt2.default)(info.slice(j + 4, valueEnd), 10);
            break;
          }

          prevChar = info[j];
        }
      } else if (isTRA) {
        return startCoordinate + 1;
      }

      return endCoordinate;
    }
    /**
     * return the approximate number of data lines in the given reference sequence
     * @param {string} refSeq reference sequence name
     * @returns {Promise} for number of data lines present on that reference sequence
     */

  }, {
    key: "lineCount",
    value: function () {
      var _lineCount = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee6(refName) {
        var opts,
            _args6 = arguments;
        return _regenerator.default.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                opts = _args6.length > 1 && _args6[1] !== undefined ? _args6[1] : {};
                return _context6.abrupt("return", this.index.lineCount(refName, opts));

              case 2:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function lineCount(_x5) {
        return _lineCount.apply(this, arguments);
      }

      return lineCount;
    }()
  }, {
    key: "_readRegion",
    value: function () {
      var _readRegion2 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee7(position, compressedSize) {
        var opts,
            _yield$this$filehandl,
            bytesRead,
            buffer,
            _args7 = arguments;

        return _regenerator.default.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                opts = _args7.length > 2 && _args7[2] !== undefined ? _args7[2] : {};
                _context7.next = 3;
                return this.filehandle.read(Buffer.alloc(compressedSize), 0, compressedSize, position, opts);

              case 3:
                _yield$this$filehandl = _context7.sent;
                bytesRead = _yield$this$filehandl.bytesRead;
                buffer = _yield$this$filehandl.buffer;
                return _context7.abrupt("return", bytesRead < compressedSize ? buffer.slice(0, bytesRead) : buffer);

              case 7:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function _readRegion(_x6, _x7) {
        return _readRegion2.apply(this, arguments);
      }

      return _readRegion;
    }()
    /**
     * read and uncompress the data in a chunk (composed of one or more
     * contiguous bgzip blocks) of the file
     * @param {Chunk} chunk
     * @returns {Promise} for a string chunk of the file
     */

  }, {
    key: "readChunk",
    value: function () {
      var _readChunk = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee8(chunk) {
        var opts,
            compressedData,
            _args8 = arguments;
        return _regenerator.default.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                opts = _args8.length > 1 && _args8[1] !== undefined ? _args8[1] : {};
                _context8.next = 3;
                return this._readRegion(chunk.minv.blockPosition, chunk.fetchedSize(), opts);

              case 3:
                compressedData = _context8.sent;
                _context8.prev = 4;
                return _context8.abrupt("return", (0, _bgzfFilehandle.unzipChunkSlice)(compressedData, chunk));

              case 8:
                _context8.prev = 8;
                _context8.t0 = _context8["catch"](4);
                throw new Error("error decompressing chunk ".concat(chunk.toString(), " ").concat(_context8.t0));

              case 11:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this, [[4, 8]]);
      }));

      function readChunk(_x8) {
        return _readChunk.apply(this, arguments);
      }

      return readChunk;
    }()
  }]);
  return TabixIndexedFile;
}();

exports.default = TabixIndexedFile;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy90YWJpeEluZGV4ZWRGaWxlLnRzIl0sIm5hbWVzIjpbInRpbWVvdXQiLCJ0aW1lIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJUYWJpeEluZGV4ZWRGaWxlIiwicGF0aCIsImZpbGVoYW5kbGUiLCJ0YmlQYXRoIiwidGJpRmlsZWhhbmRsZSIsImNzaVBhdGgiLCJjc2lGaWxlaGFuZGxlIiwiY2h1bmtTaXplTGltaXQiLCJyZW5hbWVSZWZTZXFzIiwibiIsImNodW5rQ2FjaGVTaXplIiwiTG9jYWxGaWxlIiwiVHlwZUVycm9yIiwiaW5kZXgiLCJUQkkiLCJDU0kiLCJyZW5hbWVSZWZTZXEiLCJjaHVua0NhY2hlIiwiQWJvcnRhYmxlUHJvbWlzZUNhY2hlIiwiY2FjaGUiLCJMUlUiLCJtYXhTaXplIiwiTWF0aCIsImZsb29yIiwiZmlsbCIsInJlYWRDaHVuayIsImJpbmQiLCJyZWZOYW1lIiwic3RhcnQiLCJlbmQiLCJvcHRzIiwib3B0aW9ucyIsImNhbGxiYWNrIiwibGluZUNhbGxiYWNrIiwidW5kZWZpbmVkIiwiZ2V0TWV0YWRhdGEiLCJtZXRhZGF0YSIsInNpZ25hbCIsIm1heFJlZkxlbmd0aCIsImJsb2Nrc0ZvclJhbmdlIiwiY2h1bmtzIiwiaSIsImxlbmd0aCIsInNpemUiLCJmZXRjaGVkU2l6ZSIsIkVycm9yIiwidG9Mb2NhbGVTdHJpbmciLCJsYXN0IiwiY2h1bmtOdW0iLCJwcmV2aW91c1N0YXJ0Q29vcmRpbmF0ZSIsImMiLCJnZXQiLCJ0b1N0cmluZyIsImJ1ZmZlciIsImNwb3NpdGlvbnMiLCJkcG9zaXRpb25zIiwibGluZXMiLCJUZXh0RGVjb2RlciIsImRlY29kZSIsInNwbGl0IiwicG9wIiwiYmxvY2tTdGFydCIsIm1pbnYiLCJkYXRhUG9zaXRpb24iLCJwb3MiLCJsaW5lIiwiY2hlY2tMaW5lIiwic3RhcnRDb29yZGluYXRlIiwib3ZlcmxhcHMiLCJ0cmltIiwiZmlyc3REYXRhTGluZSIsIm1ldGFDaGFyIiwibWF4QmxvY2tTaXplIiwibWF4RmV0Y2giLCJibG9ja1Bvc2l0aW9uIiwiX3JlYWRSZWdpb24iLCJieXRlcyIsImNvbnNvbGUiLCJlcnJvciIsImNvZGUiLCJsYXN0TmV3bGluZSIsIm5ld2xpbmVCeXRlIiwiY2hhckNvZGVBdCIsIm1ldGFCeXRlIiwic2xpY2UiLCJnZXRIZWFkZXJCdWZmZXIiLCJyZWZJZFRvTmFtZSIsInJlZ2lvblJlZk5hbWUiLCJyZWdpb25TdGFydCIsInJlZ2lvbkVuZCIsImNvbHVtbk51bWJlcnMiLCJjb29yZGluYXRlVHlwZSIsImZvcm1hdCIsImNoYXJBdCIsInJlZiIsIm1heENvbHVtbiIsIm1heCIsImN1cnJlbnRDb2x1bW5OdW1iZXIiLCJjdXJyZW50Q29sdW1uU3RhcnQiLCJyZWZTZXEiLCJJbmZpbml0eSIsImVuZENvb3JkaW5hdGUiLCJfZ2V0VmNmRW5kIiwiaW5mbyIsImlzVFJBIiwiaW5kZXhPZiIsInByZXZDaGFyIiwiaiIsInZhbHVlRW5kIiwibGluZUNvdW50IiwicG9zaXRpb24iLCJjb21wcmVzc2VkU2l6ZSIsInJlYWQiLCJCdWZmZXIiLCJhbGxvYyIsImJ5dGVzUmVhZCIsImNodW5rIiwiY29tcHJlc3NlZERhdGEiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFJQTs7QUFDQTs7QUFFQSxTQUFTQSxPQUFULENBQWlCQyxJQUFqQixFQUErQjtBQUM3QixTQUFPLHFCQUFZLFVBQUFDLE9BQU8sRUFBSTtBQUM1QkMsSUFBQUEsVUFBVSxDQUFDRCxPQUFELEVBQVVELElBQVYsQ0FBVjtBQUNELEdBRk0sQ0FBUDtBQUdEOztJQUNvQkcsZ0I7QUFNbkI7Ozs7Ozs7Ozs7Ozs7OztBQWVBLGtDQW9CRztBQUFBLFFBbkJEQyxJQW1CQyxRQW5CREEsSUFtQkM7QUFBQSxRQWxCREMsVUFrQkMsUUFsQkRBLFVBa0JDO0FBQUEsUUFqQkRDLE9BaUJDLFFBakJEQSxPQWlCQztBQUFBLFFBaEJEQyxhQWdC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aXNlQ2FjaGUgZnJvbSAnYWJvcnRhYmxlLXByb21pc2UtY2FjaGUnXG5pbXBvcnQgTFJVIGZyb20gJ3F1aWNrLWxydSdcbmltcG9ydCB7IEdlbmVyaWNGaWxlaGFuZGxlLCBMb2NhbEZpbGUgfSBmcm9tICdnZW5lcmljLWZpbGVoYW5kbGUnXG5pbXBvcnQgeyB1bnppcCwgdW56aXBDaHVua1NsaWNlIH0gZnJvbSAnQGdtb2QvYmd6Zi1maWxlaGFuZGxlJ1xuaW1wb3J0IHsgY2hlY2tBYm9ydFNpZ25hbCB9IGZyb20gJy4vdXRpbCdcbmltcG9ydCBJbmRleEZpbGUsIHsgT3B0aW9ucyB9IGZyb20gJy4vaW5kZXhGaWxlJ1xuXG5pbXBvcnQgQ2h1bmsgZnJvbSAnLi9jaHVuaydcbmltcG9ydCBUQkkgZnJvbSAnLi90YmknXG5pbXBvcnQgQ1NJIGZyb20gJy4vY3NpJ1xuXG5mdW5jdGlvbiB0aW1lb3V0KHRpbWU6IG51bWJlcikge1xuICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgc2V0VGltZW91dChyZXNvbHZlLCB0aW1lKVxuICB9KVxufVxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGFiaXhJbmRleGVkRmlsZSB7XG4gIHByaXZhdGUgZmlsZWhhbmRsZTogR2VuZXJpY0ZpbGVoYW5kbGVcbiAgcHJpdmF0ZSBpbmRleDogSW5kZXhGaWxlXG4gIHByaXZhdGUgY2h1bmtTaXplTGltaXQ6IG51bWJlclxuICBwcml2YXRlIHJlbmFtZVJlZlNlcTogKG46IHN0cmluZykgPT4gc3RyaW5nXG4gIHByaXZhdGUgY2h1bmtDYWNoZTogYW55XG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gYXJnc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MucGF0aF1cbiAgICogQHBhcmFtIHtmaWxlaGFuZGxlfSBbYXJncy5maWxlaGFuZGxlXVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MudGJpUGF0aF1cbiAgICogQHBhcmFtIHtmaWxlaGFuZGxlfSBbYXJncy50YmlGaWxlaGFuZGxlXVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuY3NpUGF0aF1cbiAgICogQHBhcmFtIHtmaWxlaGFuZGxlfSBbYXJncy5jc2lGaWxlaGFuZGxlXVxuICAgKiBAcGFyYW0ge2NodW5rU2l6ZUxpbWl0fSBkZWZhdWx0IDUwTWlCXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IFthcmdzLnJlbmFtZVJlZlNlcXNdIG9wdGlvbmFsIGZ1bmN0aW9uIHdpdGggc2lnIGBzdHJpbmcgPT4gc3RyaW5nYCB0byB0cmFuc2Zvcm1cbiAgICogcmVmZXJlbmNlIHNlcXVlbmNlIG5hbWVzIGZvciB0aGUgcHVycG9zZSBvZiBpbmRleGluZyBhbmQgcXVlcnlpbmcuIG5vdGUgdGhhdCB0aGUgZGF0YSB0aGF0IGlzIHJldHVybmVkIGlzXG4gICAqIG5vdCBhbHRlcmVkLCBqdXN0IHRoZSBuYW1lcyBvZiB0aGUgcmVmZXJlbmNlIHNlcXVlbmNlcyB0aGF0IGFyZSB1c2VkIGZvciBxdWVyeWluZy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFthcmdzLmNodW5rQ2FjaGVTaXplXSBtYXhpbXVtIHNpemUgaW4gYnl0ZXMgb2YgdGhlIGNodW5rIGNhY2hlLiBkZWZhdWx0IDVNQlxuICAgKiBAcGFyYW0ge251bWJlcn0gW2FyZ3MuYmxvY2tDYWNoZVNpemVdIG1heGltdW0gc2l6ZSBpbiBieXRlcyBvZiB0aGUgYmxvY2sgY2FjaGUuIGRlZmF1bHQgNU1CXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgcGF0aCxcbiAgICBmaWxlaGFuZGxlLFxuICAgIHRiaVBhdGgsXG4gICAgdGJpRmlsZWhhbmRsZSxcbiAgICBjc2lQYXRoLFxuICAgIGNzaUZpbGVoYW5kbGUsXG4gICAgY2h1bmtTaXplTGltaXQgPSA1MDAwMDAwMCxcbiAgICByZW5hbWVSZWZTZXFzID0gbiA9PiBuLFxuICAgIGNodW5rQ2FjaGVTaXplID0gNSAqIDIgKiogMjAsXG4gIH06IHtcbiAgICBwYXRoPzogc3RyaW5nXG4gICAgZmlsZWhhbmRsZT86IEdlbmVyaWNGaWxlaGFuZGxlXG4gICAgdGJpUGF0aD86IHN0cmluZ1xuICAgIHRiaUZpbGVoYW5kbGU/OiBHZW5lcmljRmlsZWhhbmRsZVxuICAgIGNzaVBhdGg/OiBzdHJpbmdcbiAgICBjc2lGaWxlaGFuZGxlPzogR2VuZXJpY0ZpbGVoYW5kbGVcbiAgICBjaHVua1NpemVMaW1pdD86IG51bWJlclxuICAgIHJlbmFtZVJlZlNlcXM/OiAobjogc3RyaW5nKSA9PiBzdHJpbmdcbiAgICBjaHVua0NhY2hlU2l6ZT86IG51bWJlclxuICB9KSB7XG4gICAgaWYgKGZpbGVoYW5kbGUpIHRoaXMuZmlsZWhhbmRsZSA9IGZpbGVoYW5kbGVcbiAgICBlbHNlIGlmIChwYXRoKSB0aGlzLmZpbGVoYW5kbGUgPSBuZXcgTG9jYWxGaWxlKHBhdGgpXG4gICAgZWxzZSB0aHJvdyBuZXcgVHlwZUVycm9yKCdtdXN0IHByb3ZpZGUgZWl0aGVyIGZpbGVoYW5kbGUgb3IgcGF0aCcpXG5cbiAgICBpZiAodGJpRmlsZWhhbmRsZSlcbiAgICAgIHRoaXMuaW5kZXggPSBuZXcgVEJJKHtcbiAgICAgICAgZmlsZWhhbmRsZTogdGJpRmlsZWhhbmRsZSxcbiAgICAgICAgcmVuYW1lUmVmU2VxcyxcbiAgICAgIH0pXG4gICAgZWxzZSBpZiAoY3NpRmlsZWhhbmRsZSlcbiAgICAgIHRoaXMuaW5kZXggPSBuZXcgQ1NJKHtcbiAgICAgICAgZmlsZWhhbmRsZTogY3NpRmlsZWhhbmRsZSxcbiAgICAgICAgcmVuYW1lUmVmU2VxcyxcbiAgICAgIH0pXG4gICAgZWxzZSBpZiAodGJpUGF0aClcbiAgICAgIHRoaXMuaW5kZXggPSBuZXcgVEJJKHtcbiAgICAgICAgZmlsZWhhbmRsZTogbmV3IExvY2FsRmlsZSh0YmlQYXRoKSxcbiAgICAgICAgcmVuYW1lUmVmU2VxcyxcbiAgICAgIH0pXG4gICAgZWxzZSBpZiAoY3NpUGF0aClcbiAgICAgIHRoaXMuaW5kZXggPSBuZXcgQ1NJKHtcbiAgICAgICAgZmlsZWhhbmRsZTogbmV3IExvY2FsRmlsZShjc2lQYXRoKSxcbiAgICAgICAgcmVuYW1lUmVmU2VxcyxcbiAgICAgIH0pXG4gICAgZWxzZSBpZiAocGF0aCkge1xuICAgICAgdGhpcy5pbmRleCA9IG5ldyBUQkkoe1xuICAgICAgICBmaWxlaGFuZGxlOiBuZXcgTG9jYWxGaWxlKGAke3BhdGh9LnRiaWApLFxuICAgICAgICByZW5hbWVSZWZTZXFzLFxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ211c3QgcHJvdmlkZSBvbmUgb2YgdGJpRmlsZWhhbmRsZSwgdGJpUGF0aCwgY3NpRmlsZWhhbmRsZSwgb3IgY3NpUGF0aCcsXG4gICAgICApXG4gICAgfVxuXG4gICAgdGhpcy5jaHVua1NpemVMaW1pdCA9IGNodW5rU2l6ZUxpbWl0XG4gICAgdGhpcy5yZW5hbWVSZWZTZXEgPSByZW5hbWVSZWZTZXFzXG4gICAgdGhpcy5jaHVua0NhY2hlID0gbmV3IEFib3J0YWJsZVByb21pc2VDYWNoZSh7XG4gICAgICBjYWNoZTogbmV3IExSVSh7XG4gICAgICAgIG1heFNpemU6IE1hdGguZmxvb3IoY2h1bmtDYWNoZVNpemUgLyAoMSA8PCAxNikpLFxuICAgICAgfSksXG5cbiAgICAgIGZpbGw6IHRoaXMucmVhZENodW5rLmJpbmQodGhpcyksXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVmTmFtZSBuYW1lIG9mIHRoZSByZWZlcmVuY2Ugc2VxdWVuY2VcbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IHN0YXJ0IG9mIHRoZSByZWdpb24gKGluIDAtYmFzZWQgaGFsZi1vcGVuIGNvb3JkaW5hdGVzKVxuICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIGVuZCBvZiB0aGUgcmVnaW9uIChpbiAwLWJhc2VkIGhhbGYtb3BlbiBjb29yZGluYXRlcylcbiAgICogQHBhcmFtIHtmdW5jdGlvbnxvYmplY3R9IGxpbmVDYWxsYmFjayBjYWxsYmFjayBjYWxsZWQgZm9yIGVhY2ggbGluZSBpbiB0aGUgcmVnaW9uLiBjYW4gYWxzbyBwYXNzIGEgb2JqZWN0IHBhcmFtIGNvbnRhaW5pbmcgb2JqLmxpbmVDYWxsYmFjaywgb2JqLnNpZ25hbCwgZXRjXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSByZXNvbHZlZCB3aGVuIHRoZSB3aG9sZSByZWFkIGlzIGZpbmlzaGVkLCByZWplY3RlZCBvbiBlcnJvclxuICAgKi9cbiAgYXN5bmMgZ2V0TGluZXMoXG4gICAgcmVmTmFtZTogc3RyaW5nLFxuICAgIHN0YXJ0OiBudW1iZXIsXG4gICAgZW5kOiBudW1iZXIsXG4gICAgb3B0czogeyBzaWduYWw/OiBBYm9ydFNpZ25hbDsgbGluZUNhbGxiYWNrOiBGdW5jdGlvbiB9IHwgRnVuY3Rpb24sXG4gICkge1xuICAgIGxldCBzaWduYWw6IEFib3J0U2lnbmFsIHwgdW5kZWZpbmVkXG4gICAgbGV0IG9wdGlvbnM6IE9wdGlvbnMgPSB7fVxuICAgIGxldCBjYWxsYmFjazogRnVuY3Rpb25cbiAgICBpZiAodHlwZW9mIG9wdHMgPT09ICd1bmRlZmluZWQnKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbGluZSBjYWxsYmFjayBtdXN0IGJlIHByb3ZpZGVkJylcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIGNhbGxiYWNrID0gb3B0c1xuICAgIGVsc2Uge1xuICAgICAgb3B0aW9ucyA9IG9wdHNcbiAgICAgIGNhbGxiYWNrID0gb3B0cy5saW5lQ2FsbGJhY2tcbiAgICB9XG4gICAgaWYgKHJlZk5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbXVzdCBwcm92aWRlIGEgcmVmZXJlbmNlIHNlcXVlbmNlIG5hbWUnKVxuICAgIH1cbiAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdsaW5lIGNhbGxiYWNrIG11c3QgYmUgcHJvdmlkZWQnKVxuICAgIH1cblxuICAgIGNvbnN0IG1ldGFkYXRhID0gYXdhaXQgdGhpcy5pbmRleC5nZXRNZXRhZGF0YShvcHRpb25zKVxuICAgIGNoZWNrQWJvcnRTaWduYWwoc2lnbmFsKVxuICAgIGlmICghc3RhcnQpIHtcbiAgICAgIHN0YXJ0ID0gMFxuICAgIH1cbiAgICBpZiAoIWVuZCkge1xuICAgICAgZW5kID0gbWV0YWRhdGEubWF4UmVmTGVuZ3RoXG4gICAgfVxuICAgIGlmICghKHN0YXJ0IDw9IGVuZCkpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAnaW52YWxpZCBzdGFydCBhbmQgZW5kIGNvb3JkaW5hdGVzLiBzdGFydCBtdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byBlbmQnLFxuICAgICAgKVxuICAgIGlmIChzdGFydCA9PT0gZW5kKSByZXR1cm5cblxuICAgIGNvbnN0IGNodW5rcyA9IGF3YWl0IHRoaXMuaW5kZXguYmxvY2tzRm9yUmFuZ2UocmVmTmFtZSwgc3RhcnQsIGVuZCwgb3B0aW9ucylcbiAgICBjaGVja0Fib3J0U2lnbmFsKHNpZ25hbClcblxuICAgIC8vIGNoZWNrIHRoZSBjaHVua3MgZm9yIGFueSB0aGF0IGFyZSBvdmVyIHRoZSBzaXplIGxpbWl0LiAgaWZcbiAgICAvLyBhbnkgYXJlLCBkb24ndCBmZXRjaCBhbnkgb2YgdGhlbVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2h1bmtzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBjb25zdCBzaXplID0gY2h1bmtzW2ldLmZldGNoZWRTaXplKClcbiAgICAgIGlmIChzaXplID4gdGhpcy5jaHVua1NpemVMaW1pdCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYFRvbyBtdWNoIGRhdGEuIENodW5rIHNpemUgJHtzaXplLnRvTG9jYWxlU3RyaW5nKCl9IGJ5dGVzIGV4Y2VlZHMgY2h1bmtTaXplTGltaXQgb2YgJHt0aGlzLmNodW5rU2l6ZUxpbWl0LnRvTG9jYWxlU3RyaW5nKCl9LmAsXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBub3cgZ28gdGhyb3VnaCBlYWNoIGNodW5rIGFuZCBwYXJzZSBhbmQgZmlsdGVyIHRoZSBsaW5lcyBvdXQgb2YgaXRcbiAgICBsZXQgbGFzdCA9IERhdGUubm93KClcbiAgICBmb3IgKGxldCBjaHVua051bSA9IDA7IGNodW5rTnVtIDwgY2h1bmtzLmxlbmd0aDsgY2h1bmtOdW0gKz0gMSkge1xuICAgICAgbGV0IHByZXZpb3VzU3RhcnRDb29yZGluYXRlOiBudW1iZXIgfCB1bmRlZmluZWRcbiAgICAgIGNvbnN0IGMgPSBjaHVua3NbY2h1bmtOdW1dXG4gICAgICBjb25zdCB7IGJ1ZmZlciwgY3Bvc2l0aW9ucywgZHBvc2l0aW9ucyB9ID0gYXdhaXQgdGhpcy5jaHVua0NhY2hlLmdldChcbiAgICAgICAgYy50b1N0cmluZygpLFxuICAgICAgICBjLFxuICAgICAgICBzaWduYWwsXG4gICAgICApXG5cbiAgICAgIGNvbnN0IGxpbmVzID0gKHR5cGVvZiBUZXh0RGVjb2RlciAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgPyBuZXcgVGV4dERlY29kZXIoJ3V0Zi04JykuZGVjb2RlKGJ1ZmZlcilcbiAgICAgICAgOiBidWZmZXIudG9TdHJpbmcoKVxuICAgICAgKS5zcGxpdCgnXFxuJylcbiAgICAgIGxpbmVzLnBvcCgpXG5cbiAgICAgIGNoZWNrQWJvcnRTaWduYWwoc2lnbmFsKVxuICAgICAgbGV0IGJsb2NrU3RhcnQgPSBjLm1pbnYuZGF0YVBvc2l0aW9uXG4gICAgICBsZXQgcG9zXG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3QgbGluZSA9IGxpbmVzW2ldXG5cbiAgICAgICAgZm9yIChwb3MgPSAwOyBibG9ja1N0YXJ0ID49IGRwb3NpdGlvbnNbcG9zXTsgcG9zICs9IDEpO1xuXG4gICAgICAgIC8vIGZpbHRlciB0aGUgbGluZSBmb3Igd2hldGhlciBpdCBpcyB3aXRoaW4gdGhlIHJlcXVlc3RlZCByYW5nZVxuICAgICAgICBjb25zdCB7IHN0YXJ0Q29vcmRpbmF0ZSwgb3ZlcmxhcHMgfSA9IHRoaXMuY2hlY2tMaW5lKFxuICAgICAgICAgIG1ldGFkYXRhLFxuICAgICAgICAgIHJlZk5hbWUsXG4gICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgZW5kLFxuICAgICAgICAgIGxpbmUsXG4gICAgICAgIClcblxuICAgICAgICAvLyBkbyBhIHNtYWxsIGNoZWNrIGp1c3QgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIGxpbmVzIGFyZSByZWFsbHkgc29ydGVkIGJ5IHN0YXJ0IGNvb3JkaW5hdGVcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHByZXZpb3VzU3RhcnRDb29yZGluYXRlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICBzdGFydENvb3JkaW5hdGUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgIHByZXZpb3VzU3RhcnRDb29yZGluYXRlID4gc3RhcnRDb29yZGluYXRlXG4gICAgICAgIClcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgTGluZXMgbm90IHNvcnRlZCBieSBzdGFydCBjb29yZGluYXRlICgke3ByZXZpb3VzU3RhcnRDb29yZGluYXRlfSA+ICR7c3RhcnRDb29yZGluYXRlfSksIHRoaXMgZmlsZSBpcyBub3QgdXNhYmxlIHdpdGggVGFiaXguYCxcbiAgICAgICAgICApXG4gICAgICAgIHByZXZpb3VzU3RhcnRDb29yZGluYXRlID0gc3RhcnRDb29yZGluYXRlXG5cbiAgICAgICAgaWYgKG92ZXJsYXBzKSB7XG4gICAgICAgICAgY2FsbGJhY2soXG4gICAgICAgICAgICBsaW5lLnRyaW0oKSxcbiAgICAgICAgICAgIC8vIGNwb3NpdGlvbnNbcG9zXSByZWZlcnMgdG8gYWN0dWFsIGZpbGUgb2Zmc2V0IG9mIGEgYmd6aXAgYmxvY2sgYm91bmRhcmllc1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIHdlIG11bHRpcGx5IGJ5ICgxIDw8OCkgaW4gb3JkZXIgdG8gbWFrZSBzdXJlIGVhY2ggYmxvY2sgaGFzIGEgXCJ1bmlxdWVcIlxuICAgICAgICAgICAgLy8gYWRkcmVzcyBzcGFjZSBzbyB0aGF0IGRhdGEgaW4gdGhhdCBibG9jayBjb3VsZCBuZXZlciBvdmVybGFwXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gdGhlbiB0aGUgYmxvY2tTdGFydC1kcG9zaXRpb25zIGlzIGFuIHVuY29tcHJlc3NlZCBmaWxlIG9mZnNldCBmcm9tXG4gICAgICAgICAgICAvLyB0aGF0IGJnemlwIGJsb2NrIGJvdW5kYXJ5LCBhbmQgc2luY2UgdGhlIGNwb3NpdGlvbnMgYXJlIG11bHRpcGxpZWQgYnlcbiAgICAgICAgICAgIC8vICgxIDw8IDgpIHRoZXNlIHVuY29tcHJlc3NlZCBvZmZzZXRzIGdldCBhIHVuaXF1ZSBzcGFjZVxuICAgICAgICAgICAgY3Bvc2l0aW9uc1twb3NdICogKDEgPDwgOCkgKyAoYmxvY2tTdGFydCAtIGRwb3NpdGlvbnNbcG9zXSksXG4gICAgICAgICAgKVxuICAgICAgICB9IGVsc2UgaWYgKHN0YXJ0Q29vcmRpbmF0ZSAhPT0gdW5kZWZpbmVkICYmIHN0YXJ0Q29vcmRpbmF0ZSA+PSBlbmQpIHtcbiAgICAgICAgICAvLyB0aGUgbGluZXMgd2VyZSBvdmVybGFwcGluZyB0aGUgcmVnaW9uLCBidXQgbm93IGhhdmUgc3RvcHBlZCwgc29cbiAgICAgICAgICAvLyB3ZSBtdXN0IGJlIGF0IHRoZSBlbmQgb2YgdGhlIHJlbGV2YW50IGRhdGEgYW5kIHdlIGNhbiBzdG9wXG4gICAgICAgICAgLy8gcHJvY2Vzc2luZyBkYXRhIG5vd1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIGJsb2NrU3RhcnQgKz0gbGluZS5sZW5ndGggKyAxXG5cbiAgICAgICAgLy8geWllbGQgaWYgd2UgaGF2ZSBlbWl0dGVkIGJleW9uZCB0aGUgeWllbGQgbGltaXRcbiAgICAgICAgaWYgKGxhc3QgLSBEYXRlLm5vdygpID4gNTAwKSB7XG4gICAgICAgICAgbGFzdCA9IERhdGUubm93KClcbiAgICAgICAgICBjaGVja0Fib3J0U2lnbmFsKHNpZ25hbClcbiAgICAgICAgICBhd2FpdCB0aW1lb3V0KDEpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBhc3luYyBnZXRNZXRhZGF0YShvcHRzOiBPcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5pbmRleC5nZXRNZXRhZGF0YShvcHRzKVxuICB9XG5cbiAgLyoqXG4gICAqIGdldCBhIGJ1ZmZlciBjb250YWluaW5nIHRoZSBcImhlYWRlclwiIHJlZ2lvbiBvZlxuICAgKiB0aGUgZmlsZSwgd2hpY2ggYXJlIHRoZSBieXRlcyB1cCB0byB0aGUgZmlyc3RcbiAgICogbm9uLW1ldGEgbGluZVxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gZm9yIGEgYnVmZmVyXG4gICAqL1xuICBhc3luYyBnZXRIZWFkZXJCdWZmZXIob3B0czogT3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBmaXJzdERhdGFMaW5lLCBtZXRhQ2hhciwgbWF4QmxvY2tTaXplIH0gPSBhd2FpdCB0aGlzLmdldE1ldGFkYXRhKFxuICAgICAgb3B0cyxcbiAgICApXG4gICAgY2hlY2tBYm9ydFNpZ25hbChvcHRzLnNpZ25hbClcbiAgICBjb25zdCBtYXhGZXRjaCA9XG4gICAgICBmaXJzdERhdGFMaW5lICYmIGZpcnN0RGF0YUxpbmUuYmxvY2tQb3NpdGlvblxuICAgICAgICA/IGZpcnN0RGF0YUxpbmUuYmxvY2tQb3NpdGlvbiArIG1heEJsb2NrU2l6ZVxuICAgICAgICA6IG1heEJsb2NrU2l6ZVxuICAgIC8vIFRPRE86IHdoYXQgaWYgd2UgZG9uJ3QgaGF2ZSBhIGZpcnN0RGF0YUxpbmUsIGFuZCB0aGUgaGVhZGVyXG4gICAgLy8gYWN0dWFsbHkgdGFrZXMgdXAgbW9yZSB0aGFuIG9uZSBibG9jaz8gdGhpcyBjYXNlIGlzIG5vdCBjb3ZlcmVkIGhlcmVcblxuICAgIGxldCBieXRlcyA9IGF3YWl0IHRoaXMuX3JlYWRSZWdpb24oMCwgbWF4RmV0Y2gsIG9wdHMpXG4gICAgY2hlY2tBYm9ydFNpZ25hbChvcHRzLnNpZ25hbClcbiAgICB0cnkge1xuICAgICAgYnl0ZXMgPSBhd2FpdCB1bnppcChieXRlcylcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGUpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBlcnJvciBkZWNvbXByZXNzaW5nIGJsb2NrICR7ZS5jb2RlfSBhdCAwIChsZW5ndGggJHttYXhGZXRjaH0pICR7ZX1gLFxuICAgICAgKVxuICAgIH1cblxuICAgIC8vIHRyaW0gb2ZmIGxpbmVzIGFmdGVyIHRoZSBsYXN0IG5vbi1tZXRhIGxpbmVcbiAgICBpZiAobWV0YUNoYXIpIHtcbiAgICAgIC8vIHRyaW0gYmFja3dhcmQgZnJvbSB0aGUgZW5kXG4gICAgICBsZXQgbGFzdE5ld2xpbmUgPSAtMVxuICAgICAgY29uc3QgbmV3bGluZUJ5dGUgPSAnXFxuJy5jaGFyQ29kZUF0KDApXG4gICAgICBjb25zdCBtZXRhQnl0ZSA9IG1ldGFDaGFyLmNoYXJDb2RlQXQoMClcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKGkgPT09IGxhc3ROZXdsaW5lICsgMSAmJiBieXRlc1tpXSAhPT0gbWV0YUJ5dGUpIGJyZWFrXG4gICAgICAgIGlmIChieXRlc1tpXSA9PT0gbmV3bGluZUJ5dGUpIGxhc3ROZXdsaW5lID0gaVxuICAgICAgfVxuICAgICAgYnl0ZXMgPSBieXRlcy5zbGljZSgwLCBsYXN0TmV3bGluZSArIDEpXG4gICAgfVxuICAgIHJldHVybiBieXRlc1xuICB9XG5cbiAgLyoqXG4gICAqIGdldCBhIHN0cmluZyBjb250YWluaW5nIHRoZSBcImhlYWRlclwiIHJlZ2lvbiBvZiB0aGVcbiAgICogZmlsZSwgaXMgdGhlIHBvcnRpb24gdXAgdG8gdGhlIGZpcnN0IG5vbi1tZXRhIGxpbmVcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2V9IGZvciBhIHN0cmluZ1xuICAgKi9cbiAgYXN5bmMgZ2V0SGVhZGVyKG9wdHM6IE9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IGJ5dGVzID0gYXdhaXQgdGhpcy5nZXRIZWFkZXJCdWZmZXIob3B0cylcbiAgICBjaGVja0Fib3J0U2lnbmFsKG9wdHMuc2lnbmFsKVxuICAgIHJldHVybiBieXRlcy50b1N0cmluZygndXRmOCcpXG4gIH1cblxuICAvKipcbiAgICogZ2V0IGFuIGFycmF5IG9mIHJlZmVyZW5jZSBzZXF1ZW5jZSBuYW1lcywgaW4gdGhlIG9yZGVyIGluIHdoaWNoXG4gICAqIHRoZXkgb2NjdXIgaW4gdGhlIGZpbGUuXG4gICAqXG4gICAqIHJlZmVyZW5jZSBzZXF1ZW5jZSByZW5hbWluZyBpcyBub3QgYXBwbGllZCB0byB0aGVzZSBuYW1lcy5cbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2V9IGZvciBhbiBhcnJheSBvZiBzdHJpbmcgc2VxdWVuY2UgbmFtZXNcbiAgICovXG4gIGFzeW5jIGdldFJlZmVyZW5jZVNlcXVlbmNlTmFtZXMob3B0czogT3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgbWV0YWRhdGEgPSBhd2FpdCB0aGlzLmdldE1ldGFkYXRhKG9wdHMpXG4gICAgcmV0dXJuIG1ldGFkYXRhLnJlZklkVG9OYW1lXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IG1ldGFkYXRhIG1ldGFkYXRhIG9iamVjdCBmcm9tIHRoZSBwYXJzZWQgaW5kZXgsXG4gICAqIGNvbnRhaW5pbmcgY29sdW1uTnVtYmVycywgbWV0YUNoYXIsIGFuZCBmb3JtYXRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlZ2lvblJlZk5hbWVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHJlZ2lvblN0YXJ0IHJlZ2lvbiBzdGFydCBjb29yZGluYXRlICgwLWJhc2VkLWhhbGYtb3BlbilcbiAgICogQHBhcmFtIHtudW1iZXJ9IHJlZ2lvbkVuZCByZWdpb24gZW5kIGNvb3JkaW5hdGUgKDAtYmFzZWQtaGFsZi1vcGVuKVxuICAgKiBAcGFyYW0ge2FycmF5W3N0cmluZ119IGxpbmVcbiAgICogQHJldHVybnMge29iamVjdH0gbGlrZSBge3N0YXJ0Q29vcmRpbmF0ZSwgb3ZlcmxhcHN9YC4gb3ZlcmxhcHMgaXMgYm9vbGVhbixcbiAgICogdHJ1ZSBpZiBsaW5lIGlzIGEgZGF0YSBsaW5lIHRoYXQgb3ZlcmxhcHMgdGhlIGdpdmVuIHJlZ2lvblxuICAgKi9cbiAgY2hlY2tMaW5lKFxuICAgIHtcbiAgICAgIGNvbHVtbk51bWJlcnMsXG4gICAgICBtZXRhQ2hhcixcbiAgICAgIGNvb3JkaW5hdGVUeXBlLFxuICAgICAgZm9ybWF0LFxuICAgIH06IHtcbiAgICAgIGNvbHVtbk51bWJlcnM6IHsgcmVmOiBudW1iZXI7IHN0YXJ0OiBudW1iZXI7IGVuZDogbnVtYmVyIH1cbiAgICAgIG1ldGFDaGFyOiBzdHJpbmdcbiAgICAgIGNvb3JkaW5hdGVUeXBlOiBzdHJpbmdcbiAgICAgIGZvcm1hdDogc3RyaW5nXG4gICAgfSxcbiAgICByZWdpb25SZWZOYW1lOiBzdHJpbmcsXG4gICAgcmVnaW9uU3RhcnQ6IG51bWJlcixcbiAgICByZWdpb25FbmQ6IG51bWJlcixcbiAgICBsaW5lOiBzdHJpbmcsXG4gICkge1xuICAgIC8vIHNraXAgbWV0YSBsaW5lc1xuICAgIGlmIChsaW5lLmNoYXJBdCgwKSA9PT0gbWV0YUNoYXIpIHtcbiAgICAgIHJldHVybiB7IG92ZXJsYXBzOiBmYWxzZSB9XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgcmVmL3N0YXJ0L2VuZCB1c2luZyBjb2x1bW4gbWV0YWRhdGEgZnJvbSBpbmRleFxuICAgIGxldCB7IHJlZiwgc3RhcnQsIGVuZCB9ID0gY29sdW1uTnVtYmVyc1xuICAgIGlmICghcmVmKSByZWYgPSAwXG4gICAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gICAgaWYgKCFlbmQpIGVuZCA9IDBcbiAgICBpZiAoZm9ybWF0ID09PSAnVkNGJykgZW5kID0gOFxuICAgIGNvbnN0IG1heENvbHVtbiA9IE1hdGgubWF4KHJlZiwgc3RhcnQsIGVuZClcblxuICAgIC8vIHRoaXMgY29kZSBpcyBraW5kIG9mIGNvbXBsZXgsIGJ1dCBpdCBpcyBmYWlybHkgZmFzdC5cbiAgICAvLyBiYXNpY2FsbHksIHdlIHdhbnQgdG8gYXZvaWQgZG9pbmcgYSBzcGxpdCwgYmVjYXVzZSBpZiB0aGUgbGluZXMgYXJlIHJlYWxseSBsb25nXG4gICAgLy8gdGhhdCBjb3VsZCBsZWFkIHRvIHVzIGFsbG9jYXRpbmcgYSBidW5jaCBvZiBleHRyYSBtZW1vcnksIHdoaWNoIGlzIHNsb3dcblxuICAgIGxldCBjdXJyZW50Q29sdW1uTnVtYmVyID0gMSAvLyBjb2xzIGFyZSBudW1iZXJlZCBzdGFydGluZyBhdCAxIGluIHRoZSBpbmRleCBtZXRhZGF0YVxuICAgIGxldCBjdXJyZW50Q29sdW1uU3RhcnQgPSAwXG4gICAgbGV0IHJlZlNlcSA9ICcnXG4gICAgbGV0IHN0YXJ0Q29vcmRpbmF0ZSA9IC1JbmZpbml0eVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZS5sZW5ndGggKyAxOyBpICs9IDEpIHtcbiAgICAgIGlmIChsaW5lW2ldID09PSAnXFx0JyB8fCBpID09PSBsaW5lLmxlbmd0aCkge1xuICAgICAgICBpZiAoY3VycmVudENvbHVtbk51bWJlciA9PT0gcmVmKSB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgdGhpcy5yZW5hbWVSZWZTZXEobGluZS5zbGljZShjdXJyZW50Q29sdW1uU3RhcnQsIGkpKSAhPT1cbiAgICAgICAgICAgIHJlZ2lvblJlZk5hbWVcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiB7IG92ZXJsYXBzOiBmYWxzZSB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRDb2x1bW5OdW1iZXIgPT09IHN0YXJ0KSB7XG4gICAgICAgICAgc3RhcnRDb29yZGluYXRlID0gcGFyc2VJbnQobGluZS5zbGljZShjdXJyZW50Q29sdW1uU3RhcnQsIGkpLCAxMClcbiAgICAgICAgICAvLyB3ZSBjb252ZXJ0IHRvIDAtYmFzZWQtaGFsZi1vcGVuXG4gICAgICAgICAgaWYgKGNvb3JkaW5hdGVUeXBlID09PSAnMS1iYXNlZC1jbG9zZWQnKSB7XG4gICAgICAgICAgICBzdGFydENvb3JkaW5hdGUgLT0gMVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RhcnRDb29yZGluYXRlID49IHJlZ2lvbkVuZCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgc3RhcnRDb29yZGluYXRlLCBvdmVybGFwczogZmFsc2UgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZW5kID09PSAwIHx8IGVuZCA9PT0gc3RhcnQpIHtcbiAgICAgICAgICAgIC8vIGlmIHdlIGhhdmUgbm8gZW5kLCB3ZSBhc3N1bWUgdGhlIGZlYXR1cmUgaXMgMSBicCBsb25nXG4gICAgICAgICAgICBpZiAoc3RhcnRDb29yZGluYXRlICsgMSA8PSByZWdpb25TdGFydCkge1xuICAgICAgICAgICAgICByZXR1cm4geyBzdGFydENvb3JkaW5hdGUsIG92ZXJsYXBzOiBmYWxzZSB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gJ1ZDRicgJiYgY3VycmVudENvbHVtbk51bWJlciA9PT0gNCkge1xuICAgICAgICAgIHJlZlNlcSA9IGxpbmUuc2xpY2UoY3VycmVudENvbHVtblN0YXJ0LCBpKVxuICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRDb2x1bW5OdW1iZXIgPT09IGVuZCkge1xuICAgICAgICAgIGxldCBlbmRDb29yZGluYXRlXG4gICAgICAgICAgLy8gdGhpcyB3aWxsIG5ldmVyIG1hdGNoIGlmIHRoZXJlIGlzIG5vIGVuZCBjb2x1bW5cbiAgICAgICAgICBpZiAoZm9ybWF0ID09PSAnVkNGJykge1xuICAgICAgICAgICAgZW5kQ29vcmRpbmF0ZSA9IHRoaXMuX2dldFZjZkVuZChcbiAgICAgICAgICAgICAgc3RhcnRDb29yZGluYXRlLFxuICAgICAgICAgICAgICByZWZTZXEsXG4gICAgICAgICAgICAgIGxpbmUuc2xpY2UoY3VycmVudENvbHVtblN0YXJ0LCBpKSxcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZW5kQ29vcmRpbmF0ZSA9IHBhcnNlSW50KGxpbmUuc2xpY2UoY3VycmVudENvbHVtblN0YXJ0LCBpKSwgMTApXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChlbmRDb29yZGluYXRlIDw9IHJlZ2lvblN0YXJ0KSB7XG4gICAgICAgICAgICByZXR1cm4geyBvdmVybGFwczogZmFsc2UgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50Q29sdW1uU3RhcnQgPSBpICsgMVxuICAgICAgICBjdXJyZW50Q29sdW1uTnVtYmVyICs9IDFcbiAgICAgICAgaWYgKGN1cnJlbnRDb2x1bW5OdW1iZXIgPiBtYXhDb2x1bW4pIHtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IHN0YXJ0Q29vcmRpbmF0ZSwgb3ZlcmxhcHM6IHRydWUgfVxuICB9XG5cbiAgX2dldFZjZkVuZChzdGFydENvb3JkaW5hdGU6IG51bWJlciwgcmVmU2VxOiBzdHJpbmcsIGluZm86IGFueSkge1xuICAgIGxldCBlbmRDb29yZGluYXRlID0gc3RhcnRDb29yZGluYXRlICsgcmVmU2VxLmxlbmd0aFxuICAgIC8vIGlnbm9yZSBUUkEgZmVhdHVyZXMgYXMgdGhleSBzcGVjaWZ5IENIUjIgYW5kIEVORFxuICAgIC8vIGFzIGJlaW5nIG9uIGEgZGlmZmVyZW50IGNocm9tb3NvbWVcbiAgICAvLyBpZiBDSFIyIGlzIG9uIHRoZSBzYW1lIGNocm9tb3NvbWUsIHN0aWxsIGlnbm9yZSBpdFxuICAgIC8vIGJlY2F1c2UgdGhlcmUgc2hvdWxkIGJlIGFub3RoZXIgcGFpcndpc2UgZmVhdHVyZVxuICAgIC8vIGF0IHRoZSBlbmQgb2YgdGhpcyBvbmVcbiAgICBjb25zdCBpc1RSQSA9IGluZm8uaW5kZXhPZignU1ZUWVBFPVRSQScpICE9PSAtMVxuICAgIGlmIChpbmZvWzBdICE9PSAnLicgJiYgIWlzVFJBKSB7XG4gICAgICBsZXQgcHJldkNoYXIgPSAnOydcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgaW5mby5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICBpZiAocHJldkNoYXIgPT09ICc7JyAmJiBpbmZvLnNsaWNlKGosIGogKyA0KSA9PT0gJ0VORD0nKSB7XG4gICAgICAgICAgbGV0IHZhbHVlRW5kID0gaW5mby5pbmRleE9mKCc7JywgailcbiAgICAgICAgICBpZiAodmFsdWVFbmQgPT09IC0xKSB2YWx1ZUVuZCA9IGluZm8ubGVuZ3RoXG4gICAgICAgICAgZW5kQ29vcmRpbmF0ZSA9IHBhcnNlSW50KGluZm8uc2xpY2UoaiArIDQsIHZhbHVlRW5kKSwgMTApXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBwcmV2Q2hhciA9IGluZm9bal1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzVFJBKSB7XG4gICAgICByZXR1cm4gc3RhcnRDb29yZGluYXRlICsgMVxuICAgIH1cbiAgICByZXR1cm4gZW5kQ29vcmRpbmF0ZVxuICB9XG5cbiAgLyoqXG4gICAqIHJldHVybiB0aGUgYXBwcm94aW1hdGUgbnVtYmVyIG9mIGRhdGEgbGluZXMgaW4gdGhlIGdpdmVuIHJlZmVyZW5jZSBzZXF1ZW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVmU2VxIHJlZmVyZW5jZSBzZXF1ZW5jZSBuYW1lXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBmb3IgbnVtYmVyIG9mIGRhdGEgbGluZXMgcHJlc2VudCBvbiB0aGF0IHJlZmVyZW5jZSBzZXF1ZW5jZVxuICAgKi9cbiAgYXN5bmMgbGluZUNvdW50KHJlZk5hbWU6IHN0cmluZywgb3B0czogT3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuaW5kZXgubGluZUNvdW50KHJlZk5hbWUsIG9wdHMpXG4gIH1cblxuICBhc3luYyBfcmVhZFJlZ2lvbihcbiAgICBwb3NpdGlvbjogbnVtYmVyLFxuICAgIGNvbXByZXNzZWRTaXplOiBudW1iZXIsXG4gICAgb3B0czogT3B0aW9ucyA9IHt9LFxuICApIHtcbiAgICBjb25zdCB7IGJ5dGVzUmVhZCwgYnVmZmVyIH0gPSBhd2FpdCB0aGlzLmZpbGVoYW5kbGUucmVhZChcbiAgICAgIEJ1ZmZlci5hbGxvYyhjb21wcmVzc2VkU2l6ZSksXG4gICAgICAwLFxuICAgICAgY29tcHJlc3NlZFNpemUsXG4gICAgICBwb3NpdGlvbixcbiAgICAgIG9wdHMsXG4gICAgKVxuXG4gICAgcmV0dXJuIGJ5dGVzUmVhZCA8IGNvbXByZXNzZWRTaXplID8gYnVmZmVyLnNsaWNlKDAsIGJ5dGVzUmVhZCkgOiBidWZmZXJcbiAgfVxuXG4gIC8qKlxuICAgKiByZWFkIGFuZCB1bmNvbXByZXNzIHRoZSBkYXRhIGluIGEgY2h1bmsgKGNvbXBvc2VkIG9mIG9uZSBvciBtb3JlXG4gICAqIGNvbnRpZ3VvdXMgYmd6aXAgYmxvY2tzKSBvZiB0aGUgZmlsZVxuICAgKiBAcGFyYW0ge0NodW5rfSBjaHVua1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gZm9yIGEgc3RyaW5nIGNodW5rIG9mIHRoZSBmaWxlXG4gICAqL1xuICBhc3luYyByZWFkQ2h1bmsoY2h1bms6IENodW5rLCBvcHRzOiBPcHRpb25zID0ge30pIHtcbiAgICAvLyBmZXRjaCB0aGUgdW5jb21wcmVzc2VkIGRhdGEsIHVuY29tcHJlc3MgY2FyZWZ1bGx5IGEgYmxvY2sgYXQgYSB0aW1lLFxuICAgIC8vIGFuZCBzdG9wIHdoZW4gZG9uZVxuXG4gICAgY29uc3QgY29tcHJlc3NlZERhdGEgPSBhd2FpdCB0aGlzLl9yZWFkUmVnaW9uKFxuICAgICAgY2h1bmsubWludi5ibG9ja1Bvc2l0aW9uLFxuICAgICAgY2h1bmsuZmV0Y2hlZFNpemUoKSxcbiAgICAgIG9wdHMsXG4gICAgKVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gdW56aXBDaHVua1NsaWNlKGNvbXByZXNzZWREYXRhLCBjaHVuaylcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGVycm9yIGRlY29tcHJlc3NpbmcgY2h1bmsgJHtjaHVuay50b1N0cmluZygpfSAke2V9YClcbiAgICB9XG4gIH1cbn1cbiJdfQ==