"use strict";

var _interopRequireWildcard = require("@babel/runtime-corejs2/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

var _Object$defineProperty2 = require("@babel/runtime-corejs2/core-js/object/define-property");

_Object$defineProperty2(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _getIterator2 = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/get-iterator"));

var _isArray = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/array/is-array"));

var _iterator2 = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/symbol/iterator"));

var _symbol = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/symbol"));

var _from = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/array/from"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/define-property"));

var _defineProperties = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/define-properties"));

var _getOwnPropertyDescriptors = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptors"));

var _getOwnPropertyDescriptor = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptor"));

var _getOwnPropertySymbols = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/get-own-property-symbols"));

var _keys = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/keys"));

var _construct = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/reflect/construct"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/slicedToArray"));

var _regenerator = _interopRequireDefault(require("@babel/runtime-corejs2/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/createClass"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/assertThisInitialized"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/inherits"));

var _defineProperty3 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/defineProperty"));

var _long = _interopRequireDefault(require("long"));

var _bgzfFilehandle = require("@gmod/bgzf-filehandle");

var _virtualOffset = _interopRequireWildcard(require("./virtualOffset"));

var _chunk = _interopRequireDefault(require("./chunk"));

var _util = require("./util");

var _indexFile = _interopRequireDefault(require("./indexFile"));

function _createForOfIteratorHelper(o) { if (typeof _symbol.default === "undefined" || o[_iterator2.default] == null) { if ((0, _isArray.default)(o) || (o = _unsupportedIterableToArray(o))) { var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var it, normalCompletion = true, didErr = false, err; return { s: function s() { it = (0, _getIterator2.default)(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return (0, _from.default)(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys(object, enumerableOnly) { var keys = (0, _keys.default)(object); if (_getOwnPropertySymbols.default) { var symbols = (0, _getOwnPropertySymbols.default)(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return (0, _getOwnPropertyDescriptor.default)(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty3.default)(target, key, source[key]); }); } else if (_getOwnPropertyDescriptors.default) { (0, _defineProperties.default)(target, (0, _getOwnPropertyDescriptors.default)(source)); } else { ownKeys(Object(source)).forEach(function (key) { (0, _defineProperty2.default)(target, key, (0, _getOwnPropertyDescriptor.default)(source, key)); }); } } return target; }

function _createSuper(Derived) { return function () { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = (0, _construct.default)(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !_construct.default) return false; if (_construct.default.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call((0, _construct.default)(Date, [], function () {})); return true; } catch (e) { return false; } }

var CSI1_MAGIC = 21582659; // CSI\1

var CSI2_MAGIC = 38359875; // CSI\2

function lshift(num, bits) {
  return num * Math.pow(2, bits);
}

function rshift(num, bits) {
  return Math.floor(num / Math.pow(2, bits));
}

var CSI = /*#__PURE__*/function (_IndexFile) {
  (0, _inherits2.default)(CSI, _IndexFile);

  var _super = _createSuper(CSI);

  function CSI(args) {
    var _this;

    (0, _classCallCheck2.default)(this, CSI);
    _this = _super.call(this, args);
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "maxBinNumber", void 0);
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "depth", void 0);
    (0, _defineProperty3.default)((0, _assertThisInitialized2.default)(_this), "minShift", void 0);
    _this.maxBinNumber = 0;
    _this.depth = 0;
    _this.minShift = 0;
    return _this;
  }

  (0, _createClass2.default)(CSI, [{
    key: "lineCount",
    value: function () {
      var _lineCount = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(refName) {
        var opts,
            indexData,
            refId,
            idx,
            stats,
            _args = arguments;
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                opts = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
                _context.next = 3;
                return this.parse(opts);

              case 3:
                indexData = _context.sent;

                if (indexData) {
                  _context.next = 6;
                  break;
                }

                return _context.abrupt("return", -1);

              case 6:
                refId = indexData.refNameToId[refName];
                idx = indexData.indices[refId];

                if (idx) {
                  _context.next = 10;
                  break;
                }

                return _context.abrupt("return", -1);

              case 10:
                stats = indexData.indices[refId].stats;

                if (!stats) {
                  _context.next = 13;
                  break;
                }

                return _context.abrupt("return", stats.lineCount);

              case 13:
                return _context.abrupt("return", -1);

              case 14:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function lineCount(_x) {
        return _lineCount.apply(this, arguments);
      }

      return lineCount;
    }()
  }, {
    key: "indexCov",
    value: function () {
      var _indexCov = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2() {
        return _regenerator.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                throw new Error('CSI indexes do not support indexcov');

              case 2:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }));

      function indexCov() {
        return _indexCov.apply(this, arguments);
      }

      return indexCov;
    }()
  }, {
    key: "parseAuxData",
    value: function parseAuxData(bytes, offset, auxLength) {
      if (auxLength < 30) {
        return {
          refIdToName: [],
          refNameToId: {}
        };
      }

      var formatFlags = bytes.readInt32LE(offset);
      var coordinateType = formatFlags & 0x10000 ? 'zero-based-half-open' : '1-based-closed';
      var format = {
        0: 'generic',
        1: 'SAM',
        2: 'VCF'
      }[formatFlags & 0xf];
      if (!format) throw new Error("invalid Tabix preset format flags ".concat(formatFlags));
      var columnNumbers = {
        ref: bytes.readInt32LE(offset + 4),
        start: bytes.readInt32LE(offset + 8),
        end: bytes.readInt32LE(offset + 12)
      };
      var metaValue = bytes.readInt32LE(offset + 16);
      var metaChar = metaValue ? String.fromCharCode(metaValue) : '';
      var skipLines = bytes.readInt32LE(offset + 20);
      var nameSectionLength = bytes.readInt32LE(offset + 24);

      var _this$_parseNameBytes = this._parseNameBytes(bytes.slice(offset + 28, offset + 28 + nameSectionLength)),
          refIdToName = _this$_parseNameBytes.refIdToName,
          refNameToId = _this$_parseNameBytes.refNameToId;

      return {
        refIdToName: refIdToName,
        refNameToId: refNameToId,
        skipLines: skipLines,
        metaChar: metaChar,
        columnNumbers: columnNumbers,
        format: format,
        coordinateType: coordinateType
      };
    }
  }, {
    key: "_parseNameBytes",
    value: function _parseNameBytes(namesBytes) {
      var currRefId = 0;
      var currNameStart = 0;
      var refIdToName = [];
      var refNameToId = {};

      for (var i = 0; i < namesBytes.length; i += 1) {
        if (!namesBytes[i]) {
          if (currNameStart < i) {
            var refName = namesBytes.toString('utf8', currNameStart, i);
            refName = this.renameRefSeq(refName);
            refIdToName[currRefId] = refName;
            refNameToId[refName] = currRefId;
          }

          currNameStart = i + 1;
          currRefId += 1;
        }
      }

      return {
        refNameToId: refNameToId,
        refIdToName: refIdToName
      };
    } // fetch and parse the index

  }, {
    key: "_parse",
    value: function () {
      var _parse2 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee3() {
        var _this2 = this;

        var opts,
            bytes,
            csiVersion,
            maxRefLength,
            auxLength,
            aux,
            refCount,
            firstDataLine,
            currOffset,
            indices,
            _args3 = arguments;
        return _regenerator.default.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                opts = _args3.length > 0 && _args3[0] !== undefined ? _args3[0] : {};
                _context3.t0 = _bgzfFilehandle.unzip;
                _context3.next = 4;
                return this.filehandle.readFile(opts);

              case 4:
                _context3.t1 = _context3.sent;
                _context3.next = 7;
                return (0, _context3.t0)(_context3.t1);

              case 7:
                bytes = _context3.sent;

                if (!(bytes.readUInt32LE(0) === CSI1_MAGIC)) {
                  _context3.next = 12;
                  break;
                }

                csiVersion = 1;
                _context3.next = 17;
                break;

              case 12:
                if (!(bytes.readUInt32LE(0) === CSI2_MAGIC)) {
                  _context3.next = 16;
                  break;
                }

                csiVersion = 2;
                _context3.next = 17;
                break;

              case 16:
                throw new Error('Not a CSI file');

              case 17:
                this.minShift = bytes.readInt32LE(4);
                this.depth = bytes.readInt32LE(8);
                this.maxBinNumber = ((1 << (this.depth + 1) * 3) - 1) / 7;
                maxRefLength = Math.pow(2, this.minShift + this.depth * 3);
                auxLength = bytes.readInt32LE(12);
                aux = {
                  refIdToName: [],
                  refNameToId: {}
                };

                if (auxLength) {
                  aux = this.parseAuxData(bytes, 16, auxLength);
                }

                refCount = bytes.readInt32LE(16 + auxLength); // read the indexes for each reference sequence

                currOffset = 16 + auxLength + 4;
                indices = new Array(refCount).fill(0).map(function () {
                  // the binning index
                  var binCount = bytes.readInt32LE(currOffset);
                  currOffset += 4;
                  var binIndex = {};
                  var stats; // < provided by parsing a pseudo-bin, if present

                  for (var j = 0; j < binCount; j += 1) {
                    var bin = bytes.readUInt32LE(currOffset);

                    if (bin > _this2.maxBinNumber) {
                      // this is a fake bin that actually has stats information
                      // about the reference sequence in it
                      stats = _this2.parsePseudoBin(bytes, currOffset + 4);
                      currOffset += 4 + 8 + 4 + 16 + 16;
                    } else {
                      var loffset = (0, _virtualOffset.fromBytes)(bytes, currOffset + 4);
                      firstDataLine = _this2._findFirstData(firstDataLine, loffset);
                      var chunkCount = bytes.readInt32LE(currOffset + 12);
                      currOffset += 16;
                      var chunks = new Array(chunkCount);

                      for (var k = 0; k < chunkCount; k += 1) {
                        var u = (0, _virtualOffset.fromBytes)(bytes, currOffset);
                        var v = (0, _virtualOffset.fromBytes)(bytes, currOffset + 8);
                        currOffset += 16; // this._findFirstData(data, u)

                        chunks[k] = new _chunk.default(u, v, bin);
                      }

                      binIndex[bin] = chunks;
                    }
                  }

                  return {
                    binIndex: binIndex,
                    stats: stats
                  };
                });
                return _context3.abrupt("return", _objectSpread({}, aux, {
                  csi: true,
                  refCount: refCount,
                  maxBlockSize: 1 << 16,
                  firstDataLine: firstDataLine,
                  csiVersion: csiVersion,
                  indices: indices,
                  depth: this.depth,
                  maxBinNumber: this.maxBinNumber,
                  maxRefLength: maxRefLength
                }));

              case 28:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function _parse() {
        return _parse2.apply(this, arguments);
      }

      return _parse;
    }()
  }, {
    key: "parsePseudoBin",
    value: function parsePseudoBin(bytes, offset) {
      var lineCount = (0, _util.longToNumber)(_long.default.fromBytesLE(Array.prototype.slice.call(bytes, offset + 28, offset + 36), true));
      return {
        lineCount: lineCount
      };
    }
  }, {
    key: "blocksForRange",
    value: function () {
      var _blocksForRange = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee4(refName, min, max) {
        var opts,
            indexData,
            refId,
            ba,
            overlappingBins,
            chunks,
            _iterator,
            _step,
            _step$value,
            start,
            end,
            bin,
            binChunks,
            c,
            _args4 = arguments;

        return _regenerator.default.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                opts = _args4.length > 3 && _args4[3] !== undefined ? _args4[3] : {};

                if (min < 0) {
                  min = 0;
                }

                _context4.next = 4;
                return this.parse(opts);

              case 4:
                indexData = _context4.sent;

                if (indexData) {
                  _context4.next = 7;
                  break;
                }

                return _context4.abrupt("return", []);

              case 7:
                refId = indexData.refNameToId[refName];
                ba = indexData.indices[refId];

                if (ba) {
                  _context4.next = 11;
                  break;
                }

                return _context4.abrupt("return", []);

              case 11:
                // const { linearIndex, binIndex } = indexes
                overlappingBins = this.reg2bins(min, max); // List of bin #s that overlap min, max

                chunks = []; // Find chunks in overlapping bins.  Leaf bins (< 4681) are not pruned

                _iterator = _createForOfIteratorHelper(overlappingBins);

                try {
                  for (_iterator.s(); !(_step = _iterator.n()).done;) {
                    _step$value = (0, _slicedToArray2.default)(_step.value, 2), start = _step$value[0], end = _step$value[1];

                    for (bin = start; bin <= end; bin++) {
                      if (ba.binIndex[bin]) {
                        binChunks = ba.binIndex[bin];

                        for (c = 0; c < binChunks.length; ++c) {
                          chunks.push(new _chunk.default(binChunks[c].minv, binChunks[c].maxv, bin));
                        }
                      }
                    }
                  }
                } catch (err) {
                  _iterator.e(err);
                } finally {
                  _iterator.f();
                }

                return _context4.abrupt("return", (0, _util.optimizeChunks)(chunks, new _virtualOffset.default(0, 0)));

              case 16:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function blocksForRange(_x2, _x3, _x4) {
        return _blocksForRange.apply(this, arguments);
      }

      return blocksForRange;
    }()
    /**
     * calculate the list of bins that may overlap with region [beg,end) (zero-based half-open)
     * @returns {Array[number]}
     */

  }, {
    key: "reg2bins",
    value: function reg2bins(beg, end) {
      beg -= 1; // < convert to 1-based closed

      if (beg < 1) beg = 1;
      if (end > Math.pow(2, 50)) end = Math.pow(2, 34); // 17 GiB ought to be enough for anybody

      end -= 1;
      var l = 0;
      var t = 0;
      var s = this.minShift + this.depth * 3;
      var bins = [];

      for (; l <= this.depth; s -= 3, t += lshift(1, l * 3), l += 1) {
        var b = t + rshift(beg, s);
        var e = t + rshift(end, s);
        if (e - b + bins.length > this.maxBinNumber) throw new Error("query ".concat(beg, "-").concat(end, " is too large for current binning scheme (shift ").concat(this.minShift, ", depth ").concat(this.depth, "), try a smaller query or a coarser index binning scheme"));
        bins.push([b, e]);
      }

      return bins;
    }
  }]);
  return CSI;
}(_indexFile.default);

exports.default = CSI;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9jc2kudHMiXSwibmFtZXMiOlsiQ1NJMV9NQUdJQyIsIkNTSTJfTUFHSUMiLCJsc2hpZnQiLCJudW0iLCJiaXRzIiwicnNoaWZ0IiwiTWF0aCIsImZsb29yIiwiQ1NJIiwiYXJncyIsIm1heEJpbk51bWJlciIsImRlcHRoIiwibWluU2hpZnQiLCJyZWZOYW1lIiwib3B0cyIsInBhcnNlIiwiaW5kZXhEYXRhIiwicmVmSWQiLCJyZWZOYW1lVG9JZCIsImlkeCIsImluZGljZXMiLCJzdGF0cyIsImxpbmVDb3VudCIsIkVycm9yIiwiYnl0ZXMiLCJvZmZzZXQiLCJhdXhMZW5ndGgiLCJyZWZJZFRvTmFtZSIsImZvcm1hdEZsYWdzIiwicmVhZEludDMyTEUiLCJjb29yZGluYXRlVHlwZSIsImZvcm1hdCIsImNvbHVtbk51bWJlcnMiLCJyZWYiLCJzdGFydCIsImVuZCIsIm1ldGFWYWx1ZSIsIm1ldGFDaGFyIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwic2tpcExpbmVzIiwibmFtZVNlY3Rpb25MZW5ndGgiLCJfcGFyc2VOYW1lQnl0ZXMiLCJzbGljZSIsIm5hbWVzQnl0ZXMiLCJjdXJyUmVmSWQiLCJjdXJyTmFtZVN0YXJ0IiwiaSIsImxlbmd0aCIsInRvU3RyaW5nIiwicmVuYW1lUmVmU2VxIiwidW56aXAiLCJmaWxlaGFuZGxlIiwicmVhZEZpbGUiLCJyZWFkVUludDMyTEUiLCJjc2lWZXJzaW9uIiwibWF4UmVmTGVuZ3RoIiwiYXV4IiwicGFyc2VBdXhEYXRhIiwicmVmQ291bnQiLCJjdXJyT2Zmc2V0IiwiQXJyYXkiLCJmaWxsIiwibWFwIiwiYmluQ291bnQiLCJiaW5JbmRleCIsImoiLCJiaW4iLCJwYXJzZVBzZXVkb0JpbiIsImxvZmZzZXQiLCJmaXJzdERhdGFMaW5lIiwiX2ZpbmRGaXJzdERhdGEiLCJjaHVua0NvdW50IiwiY2h1bmtzIiwiayIsInUiLCJ2IiwiQ2h1bmsiLCJjc2kiLCJtYXhCbG9ja1NpemUiLCJMb25nIiwiZnJvbUJ5dGVzTEUiLCJwcm90b3R5cGUiLCJjYWxsIiwibWluIiwibWF4IiwiYmEiLCJvdmVybGFwcGluZ0JpbnMiLCJyZWcyYmlucyIsImJpbkNodW5rcyIsImMiLCJwdXNoIiwibWludiIsIm1heHYiLCJWaXJ0dWFsT2Zmc2V0IiwiYmVnIiwibCIsInQiLCJzIiwiYmlucyIsImIiLCJlIiwiSW5kZXhGaWxlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7O0FBQ0E7O0FBRUE7O0FBQ0E7O0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFQSxJQUFNQSxVQUFVLEdBQUcsUUFBbkIsQyxDQUE0Qjs7QUFDNUIsSUFBTUMsVUFBVSxHQUFHLFFBQW5CLEMsQ0FBNEI7O0FBRTVCLFNBQVNDLE1BQVQsQ0FBZ0JDLEdBQWhCLEVBQTZCQyxJQUE3QixFQUEyQztBQUN6QyxTQUFPRCxHQUFHLFlBQUcsQ0FBSCxFQUFRQyxJQUFSLENBQVY7QUFDRDs7QUFDRCxTQUFTQyxNQUFULENBQWdCRixHQUFoQixFQUE2QkMsSUFBN0IsRUFBMkM7QUFDekMsU0FBT0UsSUFBSSxDQUFDQyxLQUFMLENBQVdKLEdBQUcsWUFBRyxDQUFILEVBQVFDLElBQVIsQ0FBZCxDQUFQO0FBQ0Q7O0lBRW9CSSxHOzs7OztBQUluQixlQUFZQyxJQUFaLEVBQXVCO0FBQUE7O0FBQUE7QUFDckIsOEJBQU1BLElBQU47QUFEcUI7QUFBQTtBQUFBO0FBRXJCLFVBQUtDLFlBQUwsR0FBb0IsQ0FBcEI7QUFDQSxVQUFLQyxLQUFMLEdBQWEsQ0FBYjtBQUNBLFVBQUtDLFFBQUwsR0FBZ0IsQ0FBaEI7QUFKcUI7QUFLdEI7Ozs7O2dIQUNlQyxPOzs7Ozs7Ozs7OztBQUFpQkMsZ0JBQUFBLEksMkRBQWdCLEU7O3VCQUN2QixLQUFLQyxLQUFMLENBQVdELElBQVgsQzs7O0FBQWxCRSxnQkFBQUEsUzs7b0JBQ0RBLFM7Ozs7O2lEQUFrQixDQUFDLEM7OztBQUNsQkMsZ0JBQUFBLEssR0FBUUQsU0FBUyxDQUFDRSxXQUFWLENBQXNCTCxPQUF0QixDO0FBQ1JNLGdCQUFBQSxHLEdBQU1ILFNBQVMsQ0FBQ0ksT0FBVixDQUFrQkgsS0FBbEIsQzs7b0JBQ1BFLEc7Ozs7O2lEQUFZLENBQUMsQzs7O0FBQ1ZFLGdCQUFBQSxLLEdBQVVMLFNBQVMsQ0FBQ0ksT0FBVixDQUFrQkgsS0FBbEIsQyxDQUFWSSxLOztxQkFDSkEsSzs7Ozs7aURBQWNBLEtBQUssQ0FBQ0MsUzs7O2lEQUNqQixDQUFDLEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztzQkFHRixJQUFJQyxLQUFKLENBQVUscUNBQVYsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7O2lDQUlLQyxLLEVBQWVDLE0sRUFBZ0JDLFMsRUFBbUI7QUFDN0QsVUFBSUEsU0FBUyxHQUFHLEVBQWhCLEVBQW9CO0FBQ2xCLGVBQU87QUFDTEMsVUFBQUEsV0FBVyxFQUFFLEVBRFI7QUFFTFQsVUFBQUEsV0FBVyxFQUFFO0FBRlIsU0FBUDtBQUlEOztBQUVELFVBQU1VLFdBQVcsR0FBR0osS0FBSyxDQUFDSyxXQUFOLENBQWtCSixNQUFsQixDQUFwQjtBQUNBLFVBQU1LLGNBQWMsR0FDbEJGLFdBQVcsR0FBRyxPQUFkLEdBQXdCLHNCQUF4QixHQUFpRCxnQkFEbkQ7QUFFQSxVQUFNRyxNQUFNLEdBQUk7QUFBRSxXQUFHLFNBQUw7QUFBZ0IsV0FBRyxLQUFuQjtBQUEwQixXQUFHO0FBQTdCLE9BQUQsQ0FFWkgsV0FBVyxHQUFHLEdBRkYsQ0FBZjtBQUdBLFVBQUksQ0FBQ0csTUFBTCxFQUNFLE1BQU0sSUFBSVIsS0FBSiw2Q0FBK0NLLFdBQS9DLEVBQU47QUFDRixVQUFNSSxhQUFhLEdBQUc7QUFDcEJDLFFBQUFBLEdBQUcsRUFBRVQsS0FBSyxDQUFDSyxXQUFOLENBQWtCSixNQUFNLEdBQUcsQ0FBM0IsQ0FEZTtBQUVwQlMsUUFBQUEsS0FBSyxFQUFFVixLQUFLLENBQUNLLFdBQU4sQ0FBa0JKLE1BQU0sR0FBRyxDQUEzQixDQUZhO0FBR3BCVSxRQUFBQSxHQUFHLEVBQUVYLEtBQUssQ0FBQ0ssV0FBTixDQUFrQkosTUFBTSxHQUFHLEVBQTNCO0FBSGUsT0FBdEI7QUFLQSxVQUFNVyxTQUFTLEdBQUdaLEtBQUssQ0FBQ0ssV0FBTixDQUFrQkosTUFBTSxHQUFHLEVBQTNCLENBQWxCO0FBQ0EsVUFBTVksUUFBUSxHQUFHRCxTQUFTLEdBQUdFLE1BQU0sQ0FBQ0MsWUFBUCxDQUFvQkgsU0FBcEIsQ0FBSCxHQUFvQyxFQUE5RDtBQUNBLFVBQU1JLFNBQVMsR0FBR2hCLEtBQUssQ0FBQ0ssV0FBTixDQUFrQkosTUFBTSxHQUFHLEVBQTNCLENBQWxCO0FBQ0EsVUFBTWdCLGlCQUFpQixHQUFHakIsS0FBSyxDQUFDSyxXQUFOLENBQWtCSixNQUFNLEdBQUcsRUFBM0IsQ0FBMUI7O0FBeEI2RCxrQ0EwQnhCLEtBQUtpQixlQUFMLENBQ25DbEIsS0FBSyxDQUFDbUIsS0FBTixDQUFZbEIsTUFBTSxHQUFHLEVBQXJCLEVBQXlCQSxNQUFNLEdBQUcsRUFBVCxHQUFjZ0IsaUJBQXZDLENBRG1DLENBMUJ3QjtBQUFBLFVBMEJyRGQsV0ExQnFELHlCQTBCckRBLFdBMUJxRDtBQUFBLFVBMEJ4Q1QsV0ExQndDLHlCQTBCeENBLFdBMUJ3Qzs7QUE4QjdELGFBQU87QUFDTFMsUUFBQUEsV0FBVyxFQUFYQSxXQURLO0FBRUxULFFBQUFBLFdBQVcsRUFBWEEsV0FGSztBQUdMc0IsUUFBQUEsU0FBUyxFQUFUQSxTQUhLO0FBSUxILFFBQUFBLFFBQVEsRUFBUkEsUUFKSztBQUtMTCxRQUFBQSxhQUFhLEVBQWJBLGFBTEs7QUFNTEQsUUFBQUEsTUFBTSxFQUFOQSxNQU5LO0FBT0xELFFBQUFBLGNBQWMsRUFBZEE7QUFQSyxPQUFQO0FBU0Q7OztvQ0FFZWMsVSxFQUFvQjtBQUNsQyxVQUFJQyxTQUFTLEdBQUcsQ0FBaEI7QUFDQSxVQUFJQyxhQUFhLEdBQUcsQ0FBcEI7QUFDQSxVQUFNbkIsV0FBVyxHQUFHLEVBQXBCO0FBQ0EsVUFBTVQsV0FBc0MsR0FBRyxFQUEvQzs7QUFDQSxXQUFLLElBQUk2QixDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHSCxVQUFVLENBQUNJLE1BQS9CLEVBQXVDRCxDQUFDLElBQUksQ0FBNUMsRUFBK0M7QUFDN0MsWUFBSSxDQUFDSCxVQUFVLENBQUNHLENBQUQsQ0FBZixFQUFvQjtBQUNsQixjQUFJRCxhQUFhLEdBQUdDLENBQXBCLEVBQXVCO0FBQ3JCLGdCQUFJbEMsT0FBTyxHQUFHK0IsVUFBVSxDQUFDSyxRQUFYLENBQW9CLE1BQXBCLEVBQTRCSCxhQUE1QixFQUEyQ0MsQ0FBM0MsQ0FBZDtBQUNBbEMsWUFBQUEsT0FBTyxHQUFHLEtBQUtxQyxZQUFMLENBQWtCckMsT0FBbEIsQ0FBVjtBQUNBYyxZQUFBQSxXQUFXLENBQUNrQixTQUFELENBQVgsR0FBeUJoQyxPQUF6QjtBQUNBSyxZQUFBQSxXQUFXLENBQUNMLE9BQUQsQ0FBWCxHQUF1QmdDLFNBQXZCO0FBQ0Q7O0FBQ0RDLFVBQUFBLGFBQWEsR0FBR0MsQ0FBQyxHQUFHLENBQXBCO0FBQ0FGLFVBQUFBLFNBQVMsSUFBSSxDQUFiO0FBQ0Q7QUFDRjs7QUFDRCxhQUFPO0FBQUUzQixRQUFBQSxXQUFXLEVBQVhBLFdBQUY7QUFBZVMsUUFBQUEsV0FBVyxFQUFYQTtBQUFmLE9BQVA7QUFDRCxLLENBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRWFiLGdCQUFBQSxJLDhEQUFnQixFOytCQUNQcUMscUI7O3VCQUFhLEtBQUtDLFVBQUwsQ0FBZ0JDLFFBQWhCLENBQXlCdkMsSUFBekIsQzs7Ozs7Ozs7QUFBM0JVLGdCQUFBQSxLOztzQkFJRkEsS0FBSyxDQUFDOEIsWUFBTixDQUFtQixDQUFuQixNQUEwQnRELFU7Ozs7O0FBQzVCdUQsZ0JBQUFBLFVBQVUsR0FBRyxDQUFiOzs7OztzQkFDUy9CLEtBQUssQ0FBQzhCLFlBQU4sQ0FBbUIsQ0FBbkIsTUFBMEJyRCxVOzs7OztBQUNuQ3NELGdCQUFBQSxVQUFVLEdBQUcsQ0FBYjs7Ozs7c0JBRU0sSUFBSWhDLEtBQUosQ0FBVSxnQkFBVixDOzs7QUFJUixxQkFBS1gsUUFBTCxHQUFnQlksS0FBSyxDQUFDSyxXQUFOLENBQWtCLENBQWxCLENBQWhCO0FBQ0EscUJBQUtsQixLQUFMLEdBQWFhLEtBQUssQ0FBQ0ssV0FBTixDQUFrQixDQUFsQixDQUFiO0FBQ0EscUJBQUtuQixZQUFMLEdBQW9CLENBQUMsQ0FBQyxLQUFNLENBQUMsS0FBS0MsS0FBTCxHQUFhLENBQWQsSUFBbUIsQ0FBMUIsSUFBZ0MsQ0FBakMsSUFBc0MsQ0FBMUQ7QUFDTTZDLGdCQUFBQSxZLFlBQWUsQyxFQUFNLEtBQUs1QyxRQUFMLEdBQWdCLEtBQUtELEtBQUwsR0FBYSxDO0FBRWxEZSxnQkFBQUEsUyxHQUFZRixLQUFLLENBQUNLLFdBQU4sQ0FBa0IsRUFBbEIsQztBQUNkNEIsZ0JBQUFBLEcsR0FHQTtBQUNGOUIsa0JBQUFBLFdBQVcsRUFBRSxFQURYO0FBRUZULGtCQUFBQSxXQUFXLEVBQUU7QUFGWCxpQjs7QUFJSixvQkFBSVEsU0FBSixFQUFlO0FBQ2IrQixrQkFBQUEsR0FBRyxHQUFHLEtBQUtDLFlBQUwsQ0FBa0JsQyxLQUFsQixFQUF5QixFQUF6QixFQUE2QkUsU0FBN0IsQ0FBTjtBQUNEOztBQUNLaUMsZ0JBQUFBLFEsR0FBV25DLEtBQUssQ0FBQ0ssV0FBTixDQUFrQixLQUFLSCxTQUF2QixDLEVBRWpCOztBQUVJa0MsZ0JBQUFBLFUsR0FBYSxLQUFLbEMsU0FBTCxHQUFpQixDO0FBQzVCTixnQkFBQUEsTyxHQUFVLElBQUl5QyxLQUFKLENBQVVGLFFBQVYsRUFBb0JHLElBQXBCLENBQXlCLENBQXpCLEVBQTRCQyxHQUE1QixDQUFnQyxZQUFNO0FBQ3BEO0FBQ0Esc0JBQU1DLFFBQVEsR0FBR3hDLEtBQUssQ0FBQ0ssV0FBTixDQUFrQitCLFVBQWxCLENBQWpCO0FBQ0FBLGtCQUFBQSxVQUFVLElBQUksQ0FBZDtBQUNBLHNCQUFNSyxRQUFvQyxHQUFHLEVBQTdDO0FBQ0Esc0JBQUk1QyxLQUFKLENBTG9ELENBSzFDOztBQUNWLHVCQUFLLElBQUk2QyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHRixRQUFwQixFQUE4QkUsQ0FBQyxJQUFJLENBQW5DLEVBQXNDO0FBQ3BDLHdCQUFNQyxHQUFHLEdBQUczQyxLQUFLLENBQUM4QixZQUFOLENBQW1CTSxVQUFuQixDQUFaOztBQUNBLHdCQUFJTyxHQUFHLEdBQUcsTUFBSSxDQUFDekQsWUFBZixFQUE2QjtBQUMzQjtBQUNBO0FBQ0FXLHNCQUFBQSxLQUFLLEdBQUcsTUFBSSxDQUFDK0MsY0FBTCxDQUFvQjVDLEtBQXBCLEVBQTJCb0MsVUFBVSxHQUFHLENBQXhDLENBQVI7QUFDQUEsc0JBQUFBLFVBQVUsSUFBSSxJQUFJLENBQUosR0FBUSxDQUFSLEdBQVksRUFBWixHQUFpQixFQUEvQjtBQUNELHFCQUxELE1BS087QUFDTCwwQkFBTVMsT0FBTyxHQUFHLDhCQUFVN0MsS0FBVixFQUFpQm9DLFVBQVUsR0FBRyxDQUE5QixDQUFoQjtBQUNBVSxzQkFBQUEsYUFBYSxHQUFHLE1BQUksQ0FBQ0MsY0FBTCxDQUFvQkQsYUFBcEIsRUFBbUNELE9BQW5DLENBQWhCO0FBQ0EsMEJBQU1HLFVBQVUsR0FBR2hELEtBQUssQ0FBQ0ssV0FBTixDQUFrQitCLFVBQVUsR0FBRyxFQUEvQixDQUFuQjtBQUNBQSxzQkFBQUEsVUFBVSxJQUFJLEVBQWQ7QUFDQSwwQkFBTWEsTUFBTSxHQUFHLElBQUlaLEtBQUosQ0FBVVcsVUFBVixDQUFmOztBQUNBLDJCQUFLLElBQUlFLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdGLFVBQXBCLEVBQWdDRSxDQUFDLElBQUksQ0FBckMsRUFBd0M7QUFDdEMsNEJBQU1DLENBQUMsR0FBRyw4QkFBVW5ELEtBQVYsRUFBaUJvQyxVQUFqQixDQUFWO0FBQ0EsNEJBQU1nQixDQUFDLEdBQUcsOEJBQVVwRCxLQUFWLEVBQWlCb0MsVUFBVSxHQUFHLENBQTlCLENBQVY7QUFDQUEsd0JBQUFBLFVBQVUsSUFBSSxFQUFkLENBSHNDLENBSXRDOztBQUNBYSx3QkFBQUEsTUFBTSxDQUFDQyxDQUFELENBQU4sR0FBWSxJQUFJRyxjQUFKLENBQVVGLENBQVYsRUFBYUMsQ0FBYixFQUFnQlQsR0FBaEIsQ0FBWjtBQUNEOztBQUNERixzQkFBQUEsUUFBUSxDQUFDRSxHQUFELENBQVIsR0FBZ0JNLE1BQWhCO0FBQ0Q7QUFDRjs7QUFFRCx5QkFBTztBQUFFUixvQkFBQUEsUUFBUSxFQUFSQSxRQUFGO0FBQVk1QyxvQkFBQUEsS0FBSyxFQUFMQTtBQUFaLG1CQUFQO0FBQ0QsaUJBL0JlLEM7b0VBa0NYb0MsRztBQUNIcUIsa0JBQUFBLEdBQUcsRUFBRSxJO0FBQ0xuQixrQkFBQUEsUUFBUSxFQUFSQSxRO0FBQ0FvQixrQkFBQUEsWUFBWSxFQUFFLEtBQUssRTtBQUNuQlQsa0JBQUFBLGFBQWEsRUFBYkEsYTtBQUNBZixrQkFBQUEsVUFBVSxFQUFWQSxVO0FBQ0FuQyxrQkFBQUEsT0FBTyxFQUFQQSxPO0FBQ0FULGtCQUFBQSxLQUFLLEVBQUUsS0FBS0EsSztBQUNaRCxrQkFBQUEsWUFBWSxFQUFFLEtBQUtBLFk7QUFDbkI4QyxrQkFBQUEsWUFBWSxFQUFaQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OzttQ0FJV2hDLEssRUFBZUMsTSxFQUFnQjtBQUM1QyxVQUFNSCxTQUFTLEdBQUcsd0JBQ2hCMEQsY0FBS0MsV0FBTCxDQUNFcEIsS0FBSyxDQUFDcUIsU0FBTixDQUFnQnZDLEtBQWhCLENBQXNCd0MsSUFBdEIsQ0FBMkIzRCxLQUEzQixFQUFrQ0MsTUFBTSxHQUFHLEVBQTNDLEVBQStDQSxNQUFNLEdBQUcsRUFBeEQsQ0FERixFQUVFLElBRkYsQ0FEZ0IsQ0FBbEI7QUFNQSxhQUFPO0FBQUVILFFBQUFBLFNBQVMsRUFBVEE7QUFBRixPQUFQO0FBQ0Q7Ozs7c0hBR0NULE8sRUFDQXVFLEcsRUFDQUMsRzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ0F2RSxnQkFBQUEsSSw4REFBZ0IsRTs7QUFFaEIsb0JBQUlzRSxHQUFHLEdBQUcsQ0FBVixFQUFhO0FBQ1hBLGtCQUFBQSxHQUFHLEdBQUcsQ0FBTjtBQUNEOzs7dUJBRXVCLEtBQUtyRSxLQUFMLENBQVdELElBQVgsQzs7O0FBQWxCRSxnQkFBQUEsUzs7b0JBQ0RBLFM7Ozs7O2tEQUNJLEU7OztBQUVIQyxnQkFBQUEsSyxHQUFRRCxTQUFTLENBQUNFLFdBQVYsQ0FBc0JMLE9BQXRCLEM7QUFDUnlFLGdCQUFBQSxFLEdBQUt0RSxTQUFTLENBQUNJLE9BQVYsQ0FBa0JILEtBQWxCLEM7O29CQUNOcUUsRTs7Ozs7a0RBQ0ksRTs7O0FBR1Q7QUFFTUMsZ0JBQUFBLGUsR0FBa0IsS0FBS0MsUUFBTCxDQUFjSixHQUFkLEVBQW1CQyxHQUFuQixDLEVBQXdCOztBQUMxQ1osZ0JBQUFBLE0sR0FBa0IsRSxFQUV4Qjs7dURBQzJCYyxlOzs7QUFBM0Isc0VBQTRDO0FBQUEsZ0ZBQWhDckQsS0FBZ0MsbUJBQXpCQyxHQUF5Qjs7QUFDMUMseUJBQVNnQyxHQUFULEdBQWVqQyxLQUFmLEVBQXNCaUMsR0FBRyxJQUFJaEMsR0FBN0IsRUFBa0NnQyxHQUFHLEVBQXJDLEVBQXlDO0FBQ3ZDLDBCQUFJbUIsRUFBRSxDQUFDckIsUUFBSCxDQUFZRSxHQUFaLENBQUosRUFBc0I7QUFDZHNCLHdCQUFBQSxTQURjLEdBQ0ZILEVBQUUsQ0FBQ3JCLFFBQUgsQ0FBWUUsR0FBWixDQURFOztBQUVwQiw2QkFBU3VCLENBQVQsR0FBYSxDQUFiLEVBQWdCQSxDQUFDLEdBQUdELFNBQVMsQ0FBQ3pDLE1BQTlCLEVBQXNDLEVBQUUwQyxDQUF4QyxFQUEyQztBQUN6Q2pCLDBCQUFBQSxNQUFNLENBQUNrQixJQUFQLENBQVksSUFBSWQsY0FBSixDQUFVWSxTQUFTLENBQUNDLENBQUQsQ0FBVCxDQUFhRSxJQUF2QixFQUE2QkgsU0FBUyxDQUFDQyxDQUFELENBQVQsQ0FBYUcsSUFBMUMsRUFBZ0QxQixHQUFoRCxDQUFaO0FBQ0Q7QUFDRjtBQUNGO0FBQ0Y7Ozs7Ozs7a0RBRU0sMEJBQWVNLE1BQWYsRUFBdUIsSUFBSXFCLHNCQUFKLENBQWtCLENBQWxCLEVBQXFCLENBQXJCLENBQXZCLEM7Ozs7Ozs7Ozs7Ozs7Ozs7QUFHVDs7Ozs7Ozs2QkFJU0MsRyxFQUFhNUQsRyxFQUFhO0FBQ2pDNEQsTUFBQUEsR0FBRyxJQUFJLENBQVAsQ0FEaUMsQ0FDeEI7O0FBQ1QsVUFBSUEsR0FBRyxHQUFHLENBQVYsRUFBYUEsR0FBRyxHQUFHLENBQU47QUFDYixVQUFJNUQsR0FBRyxZQUFHLENBQUgsRUFBUSxFQUFSLENBQVAsRUFBbUJBLEdBQUcsWUFBRyxDQUFILEVBQVEsRUFBUixDQUFILENBSGMsQ0FHQTs7QUFDakNBLE1BQUFBLEdBQUcsSUFBSSxDQUFQO0FBQ0EsVUFBSTZELENBQUMsR0FBRyxDQUFSO0FBQ0EsVUFBSUMsQ0FBQyxHQUFHLENBQVI7QUFDQSxVQUFJQyxDQUFDLEdBQUcsS0FBS3RGLFFBQUwsR0FBZ0IsS0FBS0QsS0FBTCxHQUFhLENBQXJDO0FBQ0EsVUFBTXdGLElBQUksR0FBRyxFQUFiOztBQUNBLGFBQU9ILENBQUMsSUFBSSxLQUFLckYsS0FBakIsRUFBd0J1RixDQUFDLElBQUksQ0FBTCxFQUFRRCxDQUFDLElBQUkvRixNQUFNLENBQUMsQ0FBRCxFQUFJOEYsQ0FBQyxHQUFHLENBQVIsQ0FBbkIsRUFBK0JBLENBQUMsSUFBSSxDQUE1RCxFQUErRDtBQUM3RCxZQUFNSSxDQUFDLEdBQUdILENBQUMsR0FBRzVGLE1BQU0sQ0FBQzBGLEdBQUQsRUFBTUcsQ0FBTixDQUFwQjtBQUNBLFlBQU1HLENBQUMsR0FBR0osQ0FBQyxHQUFHNUYsTUFBTSxDQUFDOEIsR0FBRCxFQUFNK0QsQ0FBTixDQUFwQjtBQUNBLFlBQUlHLENBQUMsR0FBR0QsQ0FBSixHQUFRRCxJQUFJLENBQUNuRCxNQUFiLEdBQXNCLEtBQUt0QyxZQUEvQixFQUNFLE1BQU0sSUFBSWEsS0FBSixpQkFDS3dFLEdBREwsY0FDWTVELEdBRFosNkRBQ2tFLEtBQUt2QixRQUR2RSxxQkFDMEYsS0FBS0QsS0FEL0YsOERBQU47QUFHRndGLFFBQUFBLElBQUksQ0FBQ1IsSUFBTCxDQUFVLENBQUNTLENBQUQsRUFBSUMsQ0FBSixDQUFWO0FBQ0Q7O0FBQ0QsYUFBT0YsSUFBUDtBQUNEOzs7RUFuUDhCRyxrQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBMb25nIGZyb20gJ2xvbmcnXG5pbXBvcnQgeyB1bnppcCB9IGZyb20gJ0BnbW9kL2JnemYtZmlsZWhhbmRsZSdcblxuaW1wb3J0IFZpcnR1YWxPZmZzZXQsIHsgZnJvbUJ5dGVzIH0gZnJvbSAnLi92aXJ0dWFsT2Zmc2V0J1xuaW1wb3J0IENodW5rIGZyb20gJy4vY2h1bmsnXG5pbXBvcnQgeyBsb25nVG9OdW1iZXIsIG9wdGltaXplQ2h1bmtzIH0gZnJvbSAnLi91dGlsJ1xuXG5pbXBvcnQgSW5kZXhGaWxlLCB7IE9wdGlvbnMgfSBmcm9tICcuL2luZGV4RmlsZSdcblxuY29uc3QgQ1NJMV9NQUdJQyA9IDIxNTgyNjU5IC8vIENTSVxcMVxuY29uc3QgQ1NJMl9NQUdJQyA9IDM4MzU5ODc1IC8vIENTSVxcMlxuXG5mdW5jdGlvbiBsc2hpZnQobnVtOiBudW1iZXIsIGJpdHM6IG51bWJlcikge1xuICByZXR1cm4gbnVtICogMiAqKiBiaXRzXG59XG5mdW5jdGlvbiByc2hpZnQobnVtOiBudW1iZXIsIGJpdHM6IG51bWJlcikge1xuICByZXR1cm4gTWF0aC5mbG9vcihudW0gLyAyICoqIGJpdHMpXG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENTSSBleHRlbmRzIEluZGV4RmlsZSB7XG4gIHByaXZhdGUgbWF4QmluTnVtYmVyOiBudW1iZXJcbiAgcHJpdmF0ZSBkZXB0aDogbnVtYmVyXG4gIHByaXZhdGUgbWluU2hpZnQ6IG51bWJlclxuICBjb25zdHJ1Y3RvcihhcmdzOiBhbnkpIHtcbiAgICBzdXBlcihhcmdzKVxuICAgIHRoaXMubWF4QmluTnVtYmVyID0gMFxuICAgIHRoaXMuZGVwdGggPSAwXG4gICAgdGhpcy5taW5TaGlmdCA9IDBcbiAgfVxuICBhc3luYyBsaW5lQ291bnQocmVmTmFtZTogc3RyaW5nLCBvcHRzOiBPcHRpb25zID0ge30pOiBQcm9taXNlPG51bWJlcj4ge1xuICAgIGNvbnN0IGluZGV4RGF0YSA9IGF3YWl0IHRoaXMucGFyc2Uob3B0cylcbiAgICBpZiAoIWluZGV4RGF0YSkgcmV0dXJuIC0xXG4gICAgY29uc3QgcmVmSWQgPSBpbmRleERhdGEucmVmTmFtZVRvSWRbcmVmTmFtZV1cbiAgICBjb25zdCBpZHggPSBpbmRleERhdGEuaW5kaWNlc1tyZWZJZF1cbiAgICBpZiAoIWlkeCkgcmV0dXJuIC0xXG4gICAgY29uc3QgeyBzdGF0cyB9ID0gaW5kZXhEYXRhLmluZGljZXNbcmVmSWRdXG4gICAgaWYgKHN0YXRzKSByZXR1cm4gc3RhdHMubGluZUNvdW50XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgYXN5bmMgaW5kZXhDb3YoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDU0kgaW5kZXhlcyBkbyBub3Qgc3VwcG9ydCBpbmRleGNvdicpXG4gICAgcmV0dXJuIFtdXG4gIH1cblxuICBwYXJzZUF1eERhdGEoYnl0ZXM6IEJ1ZmZlciwgb2Zmc2V0OiBudW1iZXIsIGF1eExlbmd0aDogbnVtYmVyKSB7XG4gICAgaWYgKGF1eExlbmd0aCA8IDMwKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZWZJZFRvTmFtZTogW10sXG4gICAgICAgIHJlZk5hbWVUb0lkOiB7fSxcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBmb3JtYXRGbGFncyA9IGJ5dGVzLnJlYWRJbnQzMkxFKG9mZnNldClcbiAgICBjb25zdCBjb29yZGluYXRlVHlwZSA9XG4gICAgICBmb3JtYXRGbGFncyAmIDB4MTAwMDAgPyAnemVyby1iYXNlZC1oYWxmLW9wZW4nIDogJzEtYmFzZWQtY2xvc2VkJ1xuICAgIGNvbnN0IGZvcm1hdCA9ICh7IDA6ICdnZW5lcmljJywgMTogJ1NBTScsIDI6ICdWQ0YnIH0gYXMge1xuICAgICAgW2tleTogbnVtYmVyXTogc3RyaW5nXG4gICAgfSlbZm9ybWF0RmxhZ3MgJiAweGZdXG4gICAgaWYgKCFmb3JtYXQpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgVGFiaXggcHJlc2V0IGZvcm1hdCBmbGFncyAke2Zvcm1hdEZsYWdzfWApXG4gICAgY29uc3QgY29sdW1uTnVtYmVycyA9IHtcbiAgICAgIHJlZjogYnl0ZXMucmVhZEludDMyTEUob2Zmc2V0ICsgNCksXG4gICAgICBzdGFydDogYnl0ZXMucmVhZEludDMyTEUob2Zmc2V0ICsgOCksXG4gICAgICBlbmQ6IGJ5dGVzLnJlYWRJbnQzMkxFKG9mZnNldCArIDEyKSxcbiAgICB9XG4gICAgY29uc3QgbWV0YVZhbHVlID0gYnl0ZXMucmVhZEludDMyTEUob2Zmc2V0ICsgMTYpXG4gICAgY29uc3QgbWV0YUNoYXIgPSBtZXRhVmFsdWUgPyBTdHJpbmcuZnJvbUNoYXJDb2RlKG1ldGFWYWx1ZSkgOiAnJ1xuICAgIGNvbnN0IHNraXBMaW5lcyA9IGJ5dGVzLnJlYWRJbnQzMkxFKG9mZnNldCArIDIwKVxuICAgIGNvbnN0IG5hbWVTZWN0aW9uTGVuZ3RoID0gYnl0ZXMucmVhZEludDMyTEUob2Zmc2V0ICsgMjQpXG5cbiAgICBjb25zdCB7IHJlZklkVG9OYW1lLCByZWZOYW1lVG9JZCB9ID0gdGhpcy5fcGFyc2VOYW1lQnl0ZXMoXG4gICAgICBieXRlcy5zbGljZShvZmZzZXQgKyAyOCwgb2Zmc2V0ICsgMjggKyBuYW1lU2VjdGlvbkxlbmd0aCksXG4gICAgKVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHJlZklkVG9OYW1lLFxuICAgICAgcmVmTmFtZVRvSWQsXG4gICAgICBza2lwTGluZXMsXG4gICAgICBtZXRhQ2hhcixcbiAgICAgIGNvbHVtbk51bWJlcnMsXG4gICAgICBmb3JtYXQsXG4gICAgICBjb29yZGluYXRlVHlwZSxcbiAgICB9XG4gIH1cblxuICBfcGFyc2VOYW1lQnl0ZXMobmFtZXNCeXRlczogQnVmZmVyKSB7XG4gICAgbGV0IGN1cnJSZWZJZCA9IDBcbiAgICBsZXQgY3Vyck5hbWVTdGFydCA9IDBcbiAgICBjb25zdCByZWZJZFRvTmFtZSA9IFtdXG4gICAgY29uc3QgcmVmTmFtZVRvSWQ6IHsgW2tleTogc3RyaW5nXTogbnVtYmVyIH0gPSB7fVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXNCeXRlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgaWYgKCFuYW1lc0J5dGVzW2ldKSB7XG4gICAgICAgIGlmIChjdXJyTmFtZVN0YXJ0IDwgaSkge1xuICAgICAgICAgIGxldCByZWZOYW1lID0gbmFtZXNCeXRlcy50b1N0cmluZygndXRmOCcsIGN1cnJOYW1lU3RhcnQsIGkpXG4gICAgICAgICAgcmVmTmFtZSA9IHRoaXMucmVuYW1lUmVmU2VxKHJlZk5hbWUpXG4gICAgICAgICAgcmVmSWRUb05hbWVbY3VyclJlZklkXSA9IHJlZk5hbWVcbiAgICAgICAgICByZWZOYW1lVG9JZFtyZWZOYW1lXSA9IGN1cnJSZWZJZFxuICAgICAgICB9XG4gICAgICAgIGN1cnJOYW1lU3RhcnQgPSBpICsgMVxuICAgICAgICBjdXJyUmVmSWQgKz0gMVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyByZWZOYW1lVG9JZCwgcmVmSWRUb05hbWUgfVxuICB9XG5cbiAgLy8gZmV0Y2ggYW5kIHBhcnNlIHRoZSBpbmRleFxuXG4gIGFzeW5jIF9wYXJzZShvcHRzOiBPcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBieXRlcyA9IGF3YWl0IHVuemlwKChhd2FpdCB0aGlzLmZpbGVoYW5kbGUucmVhZEZpbGUob3B0cykpIGFzIEJ1ZmZlcilcblxuICAgIC8vIGNoZWNrIFRCSSBtYWdpYyBudW1iZXJzXG4gICAgbGV0IGNzaVZlcnNpb25cbiAgICBpZiAoYnl0ZXMucmVhZFVJbnQzMkxFKDApID09PSBDU0kxX01BR0lDKSB7XG4gICAgICBjc2lWZXJzaW9uID0gMVxuICAgIH0gZWxzZSBpZiAoYnl0ZXMucmVhZFVJbnQzMkxFKDApID09PSBDU0kyX01BR0lDKSB7XG4gICAgICBjc2lWZXJzaW9uID0gMlxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBhIENTSSBmaWxlJylcbiAgICAgIC8vIFRPRE86IGRvIHdlIG5lZWQgdG8gc3VwcG9ydCBiaWctZW5kaWFuIENTSSBmaWxlcz9cbiAgICB9XG5cbiAgICB0aGlzLm1pblNoaWZ0ID0gYnl0ZXMucmVhZEludDMyTEUoNClcbiAgICB0aGlzLmRlcHRoID0gYnl0ZXMucmVhZEludDMyTEUoOClcbiAgICB0aGlzLm1heEJpbk51bWJlciA9ICgoMSA8PCAoKHRoaXMuZGVwdGggKyAxKSAqIDMpKSAtIDEpIC8gN1xuICAgIGNvbnN0IG1heFJlZkxlbmd0aCA9IDIgKiogKHRoaXMubWluU2hpZnQgKyB0aGlzLmRlcHRoICogMylcblxuICAgIGNvbnN0IGF1eExlbmd0aCA9IGJ5dGVzLnJlYWRJbnQzMkxFKDEyKVxuICAgIGxldCBhdXg6IHtcbiAgICAgIHJlZklkVG9OYW1lOiBzdHJpbmdbXVxuICAgICAgcmVmTmFtZVRvSWQ6IHsgW2tleTogc3RyaW5nXTogbnVtYmVyIH1cbiAgICB9ID0ge1xuICAgICAgcmVmSWRUb05hbWU6IFtdLFxuICAgICAgcmVmTmFtZVRvSWQ6IHt9LFxuICAgIH1cbiAgICBpZiAoYXV4TGVuZ3RoKSB7XG4gICAgICBhdXggPSB0aGlzLnBhcnNlQXV4RGF0YShieXRlcywgMTYsIGF1eExlbmd0aClcbiAgICB9XG4gICAgY29uc3QgcmVmQ291bnQgPSBieXRlcy5yZWFkSW50MzJMRSgxNiArIGF1eExlbmd0aClcblxuICAgIC8vIHJlYWQgdGhlIGluZGV4ZXMgZm9yIGVhY2ggcmVmZXJlbmNlIHNlcXVlbmNlXG4gICAgbGV0IGZpcnN0RGF0YUxpbmU6IFZpcnR1YWxPZmZzZXQgfCB1bmRlZmluZWRcbiAgICBsZXQgY3Vyck9mZnNldCA9IDE2ICsgYXV4TGVuZ3RoICsgNFxuICAgIGNvbnN0IGluZGljZXMgPSBuZXcgQXJyYXkocmVmQ291bnQpLmZpbGwoMCkubWFwKCgpID0+IHtcbiAgICAgIC8vIHRoZSBiaW5uaW5nIGluZGV4XG4gICAgICBjb25zdCBiaW5Db3VudCA9IGJ5dGVzLnJlYWRJbnQzMkxFKGN1cnJPZmZzZXQpXG4gICAgICBjdXJyT2Zmc2V0ICs9IDRcbiAgICAgIGNvbnN0IGJpbkluZGV4OiB7IFtrZXk6IHN0cmluZ106IENodW5rW10gfSA9IHt9XG4gICAgICBsZXQgc3RhdHMgLy8gPCBwcm92aWRlZCBieSBwYXJzaW5nIGEgcHNldWRvLWJpbiwgaWYgcHJlc2VudFxuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBiaW5Db3VudDsgaiArPSAxKSB7XG4gICAgICAgIGNvbnN0IGJpbiA9IGJ5dGVzLnJlYWRVSW50MzJMRShjdXJyT2Zmc2V0KVxuICAgICAgICBpZiAoYmluID4gdGhpcy5tYXhCaW5OdW1iZXIpIHtcbiAgICAgICAgICAvLyB0aGlzIGlzIGEgZmFrZSBiaW4gdGhhdCBhY3R1YWxseSBoYXMgc3RhdHMgaW5mb3JtYXRpb25cbiAgICAgICAgICAvLyBhYm91dCB0aGUgcmVmZXJlbmNlIHNlcXVlbmNlIGluIGl0XG4gICAgICAgICAgc3RhdHMgPSB0aGlzLnBhcnNlUHNldWRvQmluKGJ5dGVzLCBjdXJyT2Zmc2V0ICsgNClcbiAgICAgICAgICBjdXJyT2Zmc2V0ICs9IDQgKyA4ICsgNCArIDE2ICsgMTZcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBsb2Zmc2V0ID0gZnJvbUJ5dGVzKGJ5dGVzLCBjdXJyT2Zmc2V0ICsgNClcbiAgICAgICAgICBmaXJzdERhdGFMaW5lID0gdGhpcy5fZmluZEZpcnN0RGF0YShmaXJzdERhdGFMaW5lLCBsb2Zmc2V0KVxuICAgICAgICAgIGNvbnN0IGNodW5rQ291bnQgPSBieXRlcy5yZWFkSW50MzJMRShjdXJyT2Zmc2V0ICsgMTIpXG4gICAgICAgICAgY3Vyck9mZnNldCArPSAxNlxuICAgICAgICAgIGNvbnN0IGNodW5rcyA9IG5ldyBBcnJheShjaHVua0NvdW50KVxuICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgY2h1bmtDb3VudDsgayArPSAxKSB7XG4gICAgICAgICAgICBjb25zdCB1ID0gZnJvbUJ5dGVzKGJ5dGVzLCBjdXJyT2Zmc2V0KVxuICAgICAgICAgICAgY29uc3QgdiA9IGZyb21CeXRlcyhieXRlcywgY3Vyck9mZnNldCArIDgpXG4gICAgICAgICAgICBjdXJyT2Zmc2V0ICs9IDE2XG4gICAgICAgICAgICAvLyB0aGlzLl9maW5kRmlyc3REYXRhKGRhdGEsIHUpXG4gICAgICAgICAgICBjaHVua3Nba10gPSBuZXcgQ2h1bmsodSwgdiwgYmluKVxuICAgICAgICAgIH1cbiAgICAgICAgICBiaW5JbmRleFtiaW5dID0gY2h1bmtzXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHsgYmluSW5kZXgsIHN0YXRzIH1cbiAgICB9KVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmF1eCxcbiAgICAgIGNzaTogdHJ1ZSxcbiAgICAgIHJlZkNvdW50LFxuICAgICAgbWF4QmxvY2tTaXplOiAxIDw8IDE2LFxuICAgICAgZmlyc3REYXRhTGluZSxcbiAgICAgIGNzaVZlcnNpb24sXG4gICAgICBpbmRpY2VzLFxuICAgICAgZGVwdGg6IHRoaXMuZGVwdGgsXG4gICAgICBtYXhCaW5OdW1iZXI6IHRoaXMubWF4QmluTnVtYmVyLFxuICAgICAgbWF4UmVmTGVuZ3RoLFxuICAgIH1cbiAgfVxuXG4gIHBhcnNlUHNldWRvQmluKGJ5dGVzOiBCdWZmZXIsIG9mZnNldDogbnVtYmVyKSB7XG4gICAgY29uc3QgbGluZUNvdW50ID0gbG9uZ1RvTnVtYmVyKFxuICAgICAgTG9uZy5mcm9tQnl0ZXNMRShcbiAgICAgICAgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYnl0ZXMsIG9mZnNldCArIDI4LCBvZmZzZXQgKyAzNiksXG4gICAgICAgIHRydWUsXG4gICAgICApLFxuICAgIClcbiAgICByZXR1cm4geyBsaW5lQ291bnQgfVxuICB9XG5cbiAgYXN5bmMgYmxvY2tzRm9yUmFuZ2UoXG4gICAgcmVmTmFtZTogc3RyaW5nLFxuICAgIG1pbjogbnVtYmVyLFxuICAgIG1heDogbnVtYmVyLFxuICAgIG9wdHM6IE9wdGlvbnMgPSB7fSxcbiAgKSB7XG4gICAgaWYgKG1pbiA8IDApIHtcbiAgICAgIG1pbiA9IDBcbiAgICB9XG5cbiAgICBjb25zdCBpbmRleERhdGEgPSBhd2FpdCB0aGlzLnBhcnNlKG9wdHMpXG4gICAgaWYgKCFpbmRleERhdGEpIHtcbiAgICAgIHJldHVybiBbXVxuICAgIH1cbiAgICBjb25zdCByZWZJZCA9IGluZGV4RGF0YS5yZWZOYW1lVG9JZFtyZWZOYW1lXVxuICAgIGNvbnN0IGJhID0gaW5kZXhEYXRhLmluZGljZXNbcmVmSWRdXG4gICAgaWYgKCFiYSkge1xuICAgICAgcmV0dXJuIFtdXG4gICAgfVxuXG4gICAgLy8gY29uc3QgeyBsaW5lYXJJbmRleCwgYmluSW5kZXggfSA9IGluZGV4ZXNcblxuICAgIGNvbnN0IG92ZXJsYXBwaW5nQmlucyA9IHRoaXMucmVnMmJpbnMobWluLCBtYXgpIC8vIExpc3Qgb2YgYmluICNzIHRoYXQgb3ZlcmxhcCBtaW4sIG1heFxuICAgIGNvbnN0IGNodW5rczogQ2h1bmtbXSA9IFtdXG5cbiAgICAvLyBGaW5kIGNodW5rcyBpbiBvdmVybGFwcGluZyBiaW5zLiAgTGVhZiBiaW5zICg8IDQ2ODEpIGFyZSBub3QgcHJ1bmVkXG4gICAgZm9yIChjb25zdCBbc3RhcnQsIGVuZF0gb2Ygb3ZlcmxhcHBpbmdCaW5zKSB7XG4gICAgICBmb3IgKGxldCBiaW4gPSBzdGFydDsgYmluIDw9IGVuZDsgYmluKyspIHtcbiAgICAgICAgaWYgKGJhLmJpbkluZGV4W2Jpbl0pIHtcbiAgICAgICAgICBjb25zdCBiaW5DaHVua3MgPSBiYS5iaW5JbmRleFtiaW5dXG4gICAgICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCBiaW5DaHVua3MubGVuZ3RoOyArK2MpIHtcbiAgICAgICAgICAgIGNodW5rcy5wdXNoKG5ldyBDaHVuayhiaW5DaHVua3NbY10ubWludiwgYmluQ2h1bmtzW2NdLm1heHYsIGJpbikpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9wdGltaXplQ2h1bmtzKGNodW5rcywgbmV3IFZpcnR1YWxPZmZzZXQoMCwgMCkpXG4gIH1cblxuICAvKipcbiAgICogY2FsY3VsYXRlIHRoZSBsaXN0IG9mIGJpbnMgdGhhdCBtYXkgb3ZlcmxhcCB3aXRoIHJlZ2lvbiBbYmVnLGVuZCkgKHplcm8tYmFzZWQgaGFsZi1vcGVuKVxuICAgKiBAcmV0dXJucyB7QXJyYXlbbnVtYmVyXX1cbiAgICovXG4gIHJlZzJiaW5zKGJlZzogbnVtYmVyLCBlbmQ6IG51bWJlcikge1xuICAgIGJlZyAtPSAxIC8vIDwgY29udmVydCB0byAxLWJhc2VkIGNsb3NlZFxuICAgIGlmIChiZWcgPCAxKSBiZWcgPSAxXG4gICAgaWYgKGVuZCA+IDIgKiogNTApIGVuZCA9IDIgKiogMzQgLy8gMTcgR2lCIG91Z2h0IHRvIGJlIGVub3VnaCBmb3IgYW55Ym9keVxuICAgIGVuZCAtPSAxXG4gICAgbGV0IGwgPSAwXG4gICAgbGV0IHQgPSAwXG4gICAgbGV0IHMgPSB0aGlzLm1pblNoaWZ0ICsgdGhpcy5kZXB0aCAqIDNcbiAgICBjb25zdCBiaW5zID0gW11cbiAgICBmb3IgKDsgbCA8PSB0aGlzLmRlcHRoOyBzIC09IDMsIHQgKz0gbHNoaWZ0KDEsIGwgKiAzKSwgbCArPSAxKSB7XG4gICAgICBjb25zdCBiID0gdCArIHJzaGlmdChiZWcsIHMpXG4gICAgICBjb25zdCBlID0gdCArIHJzaGlmdChlbmQsIHMpXG4gICAgICBpZiAoZSAtIGIgKyBiaW5zLmxlbmd0aCA+IHRoaXMubWF4QmluTnVtYmVyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYHF1ZXJ5ICR7YmVnfS0ke2VuZH0gaXMgdG9vIGxhcmdlIGZvciBjdXJyZW50IGJpbm5pbmcgc2NoZW1lIChzaGlmdCAke3RoaXMubWluU2hpZnR9LCBkZXB0aCAke3RoaXMuZGVwdGh9KSwgdHJ5IGEgc21hbGxlciBxdWVyeSBvciBhIGNvYXJzZXIgaW5kZXggYmlubmluZyBzY2hlbWVgLFxuICAgICAgICApXG4gICAgICBiaW5zLnB1c2goW2IsIGVdKVxuICAgIH1cbiAgICByZXR1cm4gYmluc1xuICB9XG59XG4iXX0=