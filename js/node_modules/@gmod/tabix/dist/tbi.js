"use strict";

var _interopRequireWildcard = require("@babel/runtime-corejs2/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _getIterator2 = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/get-iterator"));

var _isArray = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/array/is-array"));

var _iterator2 = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/symbol/iterator"));

var _symbol = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/symbol"));

var _from = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/array/from"));

var _construct = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/reflect/construct"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/slicedToArray"));

var _regenerator = _interopRequireDefault(require("@babel/runtime-corejs2/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/inherits"));

var _long = _interopRequireDefault(require("long"));

var _virtualOffset = _interopRequireWildcard(require("./virtualOffset"));

var _chunk = _interopRequireDefault(require("./chunk"));

var _bgzfFilehandle = require("@gmod/bgzf-filehandle");

var _util = require("./util");

var _indexFile = _interopRequireDefault(require("./indexFile"));

function _createForOfIteratorHelper(o) { if (typeof _symbol.default === "undefined" || o[_iterator2.default] == null) { if ((0, _isArray.default)(o) || (o = _unsupportedIterableToArray(o))) { var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var it, normalCompletion = true, didErr = false, err; return { s: function s() { it = (0, _getIterator2.default)(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return (0, _from.default)(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _createSuper(Derived) { return function () { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = (0, _construct.default)(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !_construct.default) return false; if (_construct.default.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call((0, _construct.default)(Date, [], function () {})); return true; } catch (e) { return false; } }

var TBI_MAGIC = 21578324; // TBI\1

var TAD_LIDX_SHIFT = 14;
/**
 * calculate the list of bins that may overlap with region [beg,end) (zero-based half-open)
 * @returns {Array[number]}
 */

function reg2bins(beg, end) {
  beg += 1; // < convert to 1-based closed

  end -= 1;
  return [[0, 0], [1 + (beg >> 26), 1 + (end >> 26)], [9 + (beg >> 23), 9 + (end >> 23)], [73 + (beg >> 20), 73 + (end >> 20)], [585 + (beg >> 17), 585 + (end >> 17)], [4681 + (beg >> 14), 4681 + (end >> 14)]];
}

var TabixIndex = /*#__PURE__*/function (_IndexFile) {
  (0, _inherits2.default)(TabixIndex, _IndexFile);

  var _super = _createSuper(TabixIndex);

  function TabixIndex() {
    (0, _classCallCheck2.default)(this, TabixIndex);
    return _super.apply(this, arguments);
  }

  (0, _createClass2.default)(TabixIndex, [{
    key: "lineCount",
    value: function () {
      var _lineCount = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(refName) {
        var opts,
            indexData,
            refId,
            idx,
            stats,
            _args = arguments;
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                opts = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
                _context.next = 3;
                return this.parse(opts);

              case 3:
                indexData = _context.sent;

                if (indexData) {
                  _context.next = 6;
                  break;
                }

                return _context.abrupt("return", -1);

              case 6:
                refId = indexData.refNameToId[refName];
                idx = indexData.indices[refId];

                if (idx) {
                  _context.next = 10;
                  break;
                }

                return _context.abrupt("return", -1);

              case 10:
                stats = indexData.indices[refId].stats;

                if (!stats) {
                  _context.next = 13;
                  break;
                }

                return _context.abrupt("return", stats.lineCount);

              case 13:
                return _context.abrupt("return", -1);

              case 14:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function lineCount(_x) {
        return _lineCount.apply(this, arguments);
      }

      return lineCount;
    }() // memoize
    // fetch and parse the index

  }, {
    key: "_parse",
    value: function () {
      var _parse2 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2() {
        var _this = this;

        var opts,
            bytes,
            refCount,
            formatFlags,
            coordinateType,
            formatOpts,
            format,
            columnNumbers,
            metaValue,
            depth,
            maxBinNumber,
            maxRefLength,
            metaChar,
            skipLines,
            nameSectionLength,
            _this$_parseNameBytes,
            refNameToId,
            refIdToName,
            currOffset,
            firstDataLine,
            indices,
            _args2 = arguments;

        return _regenerator.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                opts = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : {};
                _context2.t0 = _bgzfFilehandle.unzip;
                _context2.next = 4;
                return this.filehandle.readFile(opts);

              case 4:
                _context2.t1 = _context2.sent;
                _context2.next = 7;
                return (0, _context2.t0)(_context2.t1);

              case 7:
                bytes = _context2.sent;
                (0, _util.checkAbortSignal)(opts.signal); // check TBI magic numbers

                if (!(bytes.readUInt32LE(0) !== TBI_MAGIC
                /* "TBI\1" */
                )) {
                  _context2.next = 11;
                  break;
                }

                throw new Error('Not a TBI file');

              case 11:
                // number of reference sequences in the index
                refCount = bytes.readInt32LE(4);
                formatFlags = bytes.readInt32LE(8);
                coordinateType = formatFlags & 0x10000 ? 'zero-based-half-open' : '1-based-closed';
                formatOpts = {
                  0: 'generic',
                  1: 'SAM',
                  2: 'VCF'
                };
                format = formatOpts[formatFlags & 0xf];

                if (format) {
                  _context2.next = 18;
                  break;
                }

                throw new Error("invalid Tabix preset format flags ".concat(formatFlags));

              case 18:
                columnNumbers = {
                  ref: bytes.readInt32LE(12),
                  start: bytes.readInt32LE(16),
                  end: bytes.readInt32LE(20)
                };
                metaValue = bytes.readInt32LE(24);
                depth = 5;
                maxBinNumber = ((1 << (depth + 1) * 3) - 1) / 7;
                maxRefLength = Math.pow(2, 14 + depth * 3);
                metaChar = metaValue ? String.fromCharCode(metaValue) : null;
                skipLines = bytes.readInt32LE(28); // read sequence dictionary

                nameSectionLength = bytes.readInt32LE(32);
                _this$_parseNameBytes = this._parseNameBytes(bytes.slice(36, 36 + nameSectionLength)), refNameToId = _this$_parseNameBytes.refNameToId, refIdToName = _this$_parseNameBytes.refIdToName; // read the indexes for each reference sequence

                currOffset = 36 + nameSectionLength;
                indices = new Array(refCount).fill(0).map(function () {
                  // the binning index
                  var binCount = bytes.readInt32LE(currOffset);
                  currOffset += 4;
                  var binIndex = {};
                  var stats;

                  for (var j = 0; j < binCount; j += 1) {
                    var bin = bytes.readUInt32LE(currOffset);
                    currOffset += 4;

                    if (bin > maxBinNumber + 1) {
                      throw new Error('tabix index contains too many bins, please use a CSI index');
                    } else if (bin === maxBinNumber + 1) {
                      var chunkCount = bytes.readInt32LE(currOffset);
                      currOffset += 4;

                      if (chunkCount === 2) {
                        stats = _this.parsePseudoBin(bytes, currOffset);
                      }

                      currOffset += 16 * chunkCount;
                    } else {
                      var _chunkCount = bytes.readInt32LE(currOffset);

                      currOffset += 4;
                      var chunks = new Array(_chunkCount);

                      for (var k = 0; k < _chunkCount; k += 1) {
                        var u = (0, _virtualOffset.fromBytes)(bytes, currOffset);
                        var v = (0, _virtualOffset.fromBytes)(bytes, currOffset + 8);
                        currOffset += 16;
                        firstDataLine = _this._findFirstData(firstDataLine, u);
                        chunks[k] = new _chunk.default(u, v, bin);
                      }

                      binIndex[bin] = chunks;
                    }
                  } // the linear index


                  var linearCount = bytes.readInt32LE(currOffset);
                  currOffset += 4;
                  var linearIndex = new Array(linearCount);

                  for (var _k = 0; _k < linearCount; _k += 1) {
                    linearIndex[_k] = (0, _virtualOffset.fromBytes)(bytes, currOffset);
                    currOffset += 8;
                    firstDataLine = _this._findFirstData(firstDataLine, linearIndex[_k]);
                  }

                  return {
                    binIndex: binIndex,
                    linearIndex: linearIndex,
                    stats: stats
                  };
                });
                return _context2.abrupt("return", {
                  indices: indices,
                  metaChar: metaChar,
                  maxBinNumber: maxBinNumber,
                  maxRefLength: maxRefLength,
                  skipLines: skipLines,
                  firstDataLine: firstDataLine,
                  columnNumbers: columnNumbers,
                  coordinateType: coordinateType,
                  format: format,
                  refIdToName: refIdToName,
                  refNameToId: refNameToId,
                  maxBlockSize: 1 << 16
                });

              case 30:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function _parse() {
        return _parse2.apply(this, arguments);
      }

      return _parse;
    }()
  }, {
    key: "parsePseudoBin",
    value: function parsePseudoBin(bytes, offset) {
      var lineCount = (0, _util.longToNumber)(_long.default.fromBytesLE(bytes.slice(offset + 16, offset + 24), true));
      return {
        lineCount: lineCount
      };
    }
  }, {
    key: "_parseNameBytes",
    value: function _parseNameBytes(namesBytes) {
      var currRefId = 0;
      var currNameStart = 0;
      var refIdToName = [];
      var refNameToId = {};

      for (var i = 0; i < namesBytes.length; i += 1) {
        if (!namesBytes[i]) {
          if (currNameStart < i) {
            var refName = namesBytes.toString('utf8', currNameStart, i);
            refName = this.renameRefSeq(refName);
            refIdToName[currRefId] = refName;
            refNameToId[refName] = currRefId;
          }

          currNameStart = i + 1;
          currRefId += 1;
        }
      }

      return {
        refNameToId: refNameToId,
        refIdToName: refIdToName
      };
    }
  }, {
    key: "blocksForRange",
    value: function () {
      var _blocksForRange = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee3(refName, min, max) {
        var opts,
            indexData,
            refId,
            ba,
            minOffset,
            overlappingBins,
            chunks,
            _iterator,
            _step,
            _step$value,
            start,
            end,
            bin,
            binChunks,
            c,
            nintv,
            lowest,
            minLin,
            maxLin,
            i,
            vp,
            _args3 = arguments;

        return _regenerator.default.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                opts = _args3.length > 3 && _args3[3] !== undefined ? _args3[3] : {};

                if (min < 0) {
                  min = 0;
                }

                _context3.next = 4;
                return this.parse(opts);

              case 4:
                indexData = _context3.sent;

                if (indexData) {
                  _context3.next = 7;
                  break;
                }

                return _context3.abrupt("return", []);

              case 7:
                refId = indexData.refNameToId[refName];
                ba = indexData.indices[refId];

                if (ba) {
                  _context3.next = 11;
                  break;
                }

                return _context3.abrupt("return", []);

              case 11:
                minOffset = ba.linearIndex.length ? ba.linearIndex[min >> TAD_LIDX_SHIFT >= ba.linearIndex.length ? ba.linearIndex.length - 1 : min >> TAD_LIDX_SHIFT] : new _virtualOffset.default(0, 0);

                if (!minOffset) {
                  console.warn('querying outside of possible tabix range');
                } // const { linearIndex, binIndex } = indexes


                overlappingBins = reg2bins(min, max); // List of bin #s that overlap min, max

                chunks = []; // Find chunks in overlapping bins.  Leaf bins (< 4681) are not pruned

                _iterator = _createForOfIteratorHelper(overlappingBins);

                try {
                  for (_iterator.s(); !(_step = _iterator.n()).done;) {
                    _step$value = (0, _slicedToArray2.default)(_step.value, 2), start = _step$value[0], end = _step$value[1];

                    for (bin = start; bin <= end; bin++) {
                      if (ba.binIndex[bin]) {
                        binChunks = ba.binIndex[bin];

                        for (c = 0; c < binChunks.length; ++c) {
                          chunks.push(new _chunk.default(binChunks[c].minv, binChunks[c].maxv, bin));
                        }
                      }
                    }
                  } // Use the linear index to find minimum file position of chunks that could contain alignments in the region

                } catch (err) {
                  _iterator.e(err);
                } finally {
                  _iterator.f();
                }

                nintv = ba.linearIndex.length;
                lowest = null;
                minLin = Math.min(min >> 14, nintv - 1);
                maxLin = Math.min(max >> 14, nintv - 1);

                for (i = minLin; i <= maxLin; ++i) {
                  vp = ba.linearIndex[i];

                  if (vp) {
                    if (!lowest || vp.compareTo(lowest) < 0) {
                      lowest = vp;
                    }
                  }
                }

                return _context3.abrupt("return", (0, _util.optimizeChunks)(chunks, lowest));

              case 23:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function blocksForRange(_x2, _x3, _x4) {
        return _blocksForRange.apply(this, arguments);
      }

      return blocksForRange;
    }()
  }]);
  return TabixIndex;
}(_indexFile.default);

exports.default = TabixIndex;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy90YmkudHMiXSwibmFtZXMiOlsiVEJJX01BR0lDIiwiVEFEX0xJRFhfU0hJRlQiLCJyZWcyYmlucyIsImJlZyIsImVuZCIsIlRhYml4SW5kZXgiLCJyZWZOYW1lIiwib3B0cyIsInBhcnNlIiwiaW5kZXhEYXRhIiwicmVmSWQiLCJyZWZOYW1lVG9JZCIsImlkeCIsImluZGljZXMiLCJzdGF0cyIsImxpbmVDb3VudCIsInVuemlwIiwiZmlsZWhhbmRsZSIsInJlYWRGaWxlIiwiYnl0ZXMiLCJzaWduYWwiLCJyZWFkVUludDMyTEUiLCJFcnJvciIsInJlZkNvdW50IiwicmVhZEludDMyTEUiLCJmb3JtYXRGbGFncyIsImNvb3JkaW5hdGVUeXBlIiwiZm9ybWF0T3B0cyIsImZvcm1hdCIsImNvbHVtbk51bWJlcnMiLCJyZWYiLCJzdGFydCIsIm1ldGFWYWx1ZSIsImRlcHRoIiwibWF4QmluTnVtYmVyIiwibWF4UmVmTGVuZ3RoIiwibWV0YUNoYXIiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJza2lwTGluZXMiLCJuYW1lU2VjdGlvbkxlbmd0aCIsIl9wYXJzZU5hbWVCeXRlcyIsInNsaWNlIiwicmVmSWRUb05hbWUiLCJjdXJyT2Zmc2V0IiwiQXJyYXkiLCJmaWxsIiwibWFwIiwiYmluQ291bnQiLCJiaW5JbmRleCIsImoiLCJiaW4iLCJjaHVua0NvdW50IiwicGFyc2VQc2V1ZG9CaW4iLCJjaHVua3MiLCJrIiwidSIsInYiLCJmaXJzdERhdGFMaW5lIiwiX2ZpbmRGaXJzdERhdGEiLCJDaHVuayIsImxpbmVhckNvdW50IiwibGluZWFySW5kZXgiLCJtYXhCbG9ja1NpemUiLCJvZmZzZXQiLCJMb25nIiwiZnJvbUJ5dGVzTEUiLCJuYW1lc0J5dGVzIiwiY3VyclJlZklkIiwiY3Vyck5hbWVTdGFydCIsImkiLCJsZW5ndGgiLCJ0b1N0cmluZyIsInJlbmFtZVJlZlNlcSIsIm1pbiIsIm1heCIsImJhIiwibWluT2Zmc2V0IiwiVmlydHVhbE9mZnNldCIsImNvbnNvbGUiLCJ3YXJuIiwib3ZlcmxhcHBpbmdCaW5zIiwiYmluQ2h1bmtzIiwiYyIsInB1c2giLCJtaW52IiwibWF4diIsIm5pbnR2IiwibG93ZXN0IiwibWluTGluIiwiTWF0aCIsIm1heExpbiIsInZwIiwiY29tcGFyZVRvIiwiSW5kZXhGaWxlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7Ozs7Ozs7Ozs7O0FBRUEsSUFBTUEsU0FBUyxHQUFHLFFBQWxCLEMsQ0FBMkI7O0FBQzNCLElBQU1DLGNBQWMsR0FBRyxFQUF2QjtBQUVBOzs7OztBQUlBLFNBQVNDLFFBQVQsQ0FBa0JDLEdBQWxCLEVBQStCQyxHQUEvQixFQUE0QztBQUMxQ0QsRUFBQUEsR0FBRyxJQUFJLENBQVAsQ0FEMEMsQ0FDakM7O0FBQ1RDLEVBQUFBLEdBQUcsSUFBSSxDQUFQO0FBQ0EsU0FBTyxDQUNMLENBQUMsQ0FBRCxFQUFJLENBQUosQ0FESyxFQUVMLENBQUMsS0FBS0QsR0FBRyxJQUFJLEVBQVosQ0FBRCxFQUFrQixLQUFLQyxHQUFHLElBQUksRUFBWixDQUFsQixDQUZLLEVBR0wsQ0FBQyxLQUFLRCxHQUFHLElBQUksRUFBWixDQUFELEVBQWtCLEtBQUtDLEdBQUcsSUFBSSxFQUFaLENBQWxCLENBSEssRUFJTCxDQUFDLE1BQU1ELEdBQUcsSUFBSSxFQUFiLENBQUQsRUFBbUIsTUFBTUMsR0FBRyxJQUFJLEVBQWIsQ0FBbkIsQ0FKSyxFQUtMLENBQUMsT0FBT0QsR0FBRyxJQUFJLEVBQWQsQ0FBRCxFQUFvQixPQUFPQyxHQUFHLElBQUksRUFBZCxDQUFwQixDQUxLLEVBTUwsQ0FBQyxRQUFRRCxHQUFHLElBQUksRUFBZixDQUFELEVBQXFCLFFBQVFDLEdBQUcsSUFBSSxFQUFmLENBQXJCLENBTkssQ0FBUDtBQVFEOztJQUVvQkMsVTs7Ozs7Ozs7Ozs7OztnSEFDSEMsTzs7Ozs7Ozs7Ozs7QUFB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QUNNb0MsZ0JBQUFBLEssR0FBUVgsRUFBRSxDQUFDZCxXQUFILENBQWVTLE07QUFDekJpQixnQkFBQUEsTSxHQUFTLEk7QUFDUEMsZ0JBQUFBLE0sR0FBU0MsSUFBSSxDQUFDaEIsR0FBTCxDQUFTQSxHQUFHLElBQUksRUFBaEIsRUFBb0JhLEtBQUssR0FBRyxDQUE1QixDO0FBQ1RJLGdCQUFBQSxNLEdBQVNELElBQUksQ0FBQ2hCLEdBQUwsQ0FBU0MsR0FBRyxJQUFJLEVBQWhCLEVBQW9CWSxLQUFLLEdBQUcsQ0FBNUIsQzs7QUFDZixxQkFBU2pCLENBQVQsR0FBYW1CLE1BQWIsRUFBcUJuQixDQUFDLElBQUlxQixNQUExQixFQUFrQyxFQUFFckIsQ0FBcEMsRUFBdUM7QUFDL0JzQixrQkFBQUEsRUFEK0IsR0FDMUJoQixFQUFFLENBQUNkLFdBQUgsQ0FBZVEsQ0FBZixDQUQwQjs7QUFFckMsc0JBQUlzQixFQUFKLEVBQVE7QUFDTix3QkFBSSxDQUFDSixNQUFELElBQVdJLEVBQUUsQ0FBQ0MsU0FBSCxDQUFhTCxNQUFiLElBQXVCLENBQXRDLEVBQXlDO0FBQ3ZDQSxzQkFBQUEsTUFBTSxHQUFHSSxFQUFUO0FBQ0Q7QUFDRjtBQUNGOztrREFFTSwwQkFBZXRDLE1BQWYsRUFBdUJrQyxNQUF2QixDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7RUFyTjZCTSxrQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBMb25nIGZyb20gJ2xvbmcnXG5pbXBvcnQgVmlydHVhbE9mZnNldCwgeyBmcm9tQnl0ZXMgfSBmcm9tICcuL3ZpcnR1YWxPZmZzZXQnXG5pbXBvcnQgQ2h1bmsgZnJvbSAnLi9jaHVuaydcbmltcG9ydCB7IHVuemlwIH0gZnJvbSAnQGdtb2QvYmd6Zi1maWxlaGFuZGxlJ1xuaW1wb3J0IHsgbG9uZ1RvTnVtYmVyLCBvcHRpbWl6ZUNodW5rcywgY2hlY2tBYm9ydFNpZ25hbCB9IGZyb20gJy4vdXRpbCdcbmltcG9ydCBJbmRleEZpbGUsIHsgT3B0aW9ucyB9IGZyb20gJy4vaW5kZXhGaWxlJ1xuXG5jb25zdCBUQklfTUFHSUMgPSAyMTU3ODMyNCAvLyBUQklcXDFcbmNvbnN0IFRBRF9MSURYX1NISUZUID0gMTRcblxuLyoqXG4gKiBjYWxjdWxhdGUgdGhlIGxpc3Qgb2YgYmlucyB0aGF0IG1heSBvdmVybGFwIHdpdGggcmVnaW9uIFtiZWcsZW5kKSAoemVyby1iYXNlZCBoYWxmLW9wZW4pXG4gKiBAcmV0dXJucyB7QXJyYXlbbnVtYmVyXX1cbiAqL1xuZnVuY3Rpb24gcmVnMmJpbnMoYmVnOiBudW1iZXIsIGVuZDogbnVtYmVyKSB7XG4gIGJlZyArPSAxIC8vIDwgY29udmVydCB0byAxLWJhc2VkIGNsb3NlZFxuICBlbmQgLT0gMVxuICByZXR1cm4gW1xuICAgIFswLCAwXSxcbiAgICBbMSArIChiZWcgPj4gMjYpLCAxICsgKGVuZCA+PiAyNildLFxuICAgIFs5ICsgKGJlZyA+PiAyMyksIDkgKyAoZW5kID4+IDIzKV0sXG4gICAgWzczICsgKGJlZyA+PiAyMCksIDczICsgKGVuZCA+PiAyMCldLFxuICAgIFs1ODUgKyAoYmVnID4+IDE3KSwgNTg1ICsgKGVuZCA+PiAxNyldLFxuICAgIFs0NjgxICsgKGJlZyA+PiAxNCksIDQ2ODEgKyAoZW5kID4+IDE0KV0sXG4gIF1cbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGFiaXhJbmRleCBleHRlbmRzIEluZGV4RmlsZSB7XG4gIGFzeW5jIGxpbmVDb3VudChyZWZOYW1lOiBzdHJpbmcsIG9wdHM6IE9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IGluZGV4RGF0YSA9IGF3YWl0IHRoaXMucGFyc2Uob3B0cylcbiAgICBpZiAoIWluZGV4RGF0YSkgcmV0dXJuIC0xXG4gICAgY29uc3QgcmVmSWQgPSBpbmRleERhdGEucmVmTmFtZVRvSWRbcmVmTmFtZV1cbiAgICBjb25zdCBpZHggPSBpbmRleERhdGEuaW5kaWNlc1tyZWZJZF1cbiAgICBpZiAoIWlkeCkgcmV0dXJuIC0xXG4gICAgY29uc3QgeyBzdGF0cyB9ID0gaW5kZXhEYXRhLmluZGljZXNbcmVmSWRdXG4gICAgaWYgKHN0YXRzKSByZXR1cm4gc3RhdHMubGluZUNvdW50XG4gICAgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBtZW1vaXplXG4gIC8vIGZldGNoIGFuZCBwYXJzZSB0aGUgaW5kZXhcbiAgYXN5bmMgX3BhcnNlKG9wdHM6IE9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IGJ5dGVzID0gYXdhaXQgdW56aXAoKGF3YWl0IHRoaXMuZmlsZWhhbmRsZS5yZWFkRmlsZShvcHRzKSkgYXMgQnVmZmVyKVxuICAgIGNoZWNrQWJvcnRTaWduYWwob3B0cy5zaWduYWwpXG5cbiAgICAvLyBjaGVjayBUQkkgbWFnaWMgbnVtYmVyc1xuICAgIGlmIChieXRlcy5yZWFkVUludDMyTEUoMCkgIT09IFRCSV9NQUdJQyAvKiBcIlRCSVxcMVwiICovKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBhIFRCSSBmaWxlJylcbiAgICAgIC8vIFRPRE86IGRvIHdlIG5lZWQgdG8gc3VwcG9ydCBiaWctZW5kaWFuIFRCSSBmaWxlcz9cbiAgICB9XG5cbiAgICAvLyBudW1iZXIgb2YgcmVmZXJlbmNlIHNlcXVlbmNlcyBpbiB0aGUgaW5kZXhcbiAgICBjb25zdCByZWZDb3VudCA9IGJ5dGVzLnJlYWRJbnQzMkxFKDQpXG4gICAgY29uc3QgZm9ybWF0RmxhZ3MgPSBieXRlcy5yZWFkSW50MzJMRSg4KVxuICAgIGNvbnN0IGNvb3JkaW5hdGVUeXBlID1cbiAgICAgIGZvcm1hdEZsYWdzICYgMHgxMDAwMCA/ICd6ZXJvLWJhc2VkLWhhbGYtb3BlbicgOiAnMS1iYXNlZC1jbG9zZWQnXG4gICAgY29uc3QgZm9ybWF0T3B0czogeyBba2V5OiBudW1iZXJdOiBzdHJpbmcgfSA9IHtcbiAgICAgIDA6ICdnZW5lcmljJyxcbiAgICAgIDE6ICdTQU0nLFxuICAgICAgMjogJ1ZDRicsXG4gICAgfVxuICAgIGNvbnN0IGZvcm1hdCA9IGZvcm1hdE9wdHNbZm9ybWF0RmxhZ3MgJiAweGZdXG4gICAgaWYgKCFmb3JtYXQpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgVGFiaXggcHJlc2V0IGZvcm1hdCBmbGFncyAke2Zvcm1hdEZsYWdzfWApXG4gICAgY29uc3QgY29sdW1uTnVtYmVycyA9IHtcbiAgICAgIHJlZjogYnl0ZXMucmVhZEludDMyTEUoMTIpLFxuICAgICAgc3RhcnQ6IGJ5dGVzLnJlYWRJbnQzMkxFKDE2KSxcbiAgICAgIGVuZDogYnl0ZXMucmVhZEludDMyTEUoMjApLFxuICAgIH1cbiAgICBjb25zdCBtZXRhVmFsdWUgPSBieXRlcy5yZWFkSW50MzJMRSgyNClcbiAgICBjb25zdCBkZXB0aCA9IDVcbiAgICBjb25zdCBtYXhCaW5OdW1iZXIgPSAoKDEgPDwgKChkZXB0aCArIDEpICogMykpIC0gMSkgLyA3XG4gICAgY29uc3QgbWF4UmVmTGVuZ3RoID0gMiAqKiAoMTQgKyBkZXB0aCAqIDMpXG4gICAgY29uc3QgbWV0YUNoYXIgPSBtZXRhVmFsdWUgPyBTdHJpbmcuZnJvbUNoYXJDb2RlKG1ldGFWYWx1ZSkgOiBudWxsXG4gICAgY29uc3Qgc2tpcExpbmVzID0gYnl0ZXMucmVhZEludDMyTEUoMjgpXG5cbiAgICAvLyByZWFkIHNlcXVlbmNlIGRpY3Rpb25hcnlcbiAgICBjb25zdCBuYW1lU2VjdGlvbkxlbmd0aCA9IGJ5dGVzLnJlYWRJbnQzMkxFKDMyKVxuICAgIGNvbnN0IHsgcmVmTmFtZVRvSWQsIHJlZklkVG9OYW1lIH0gPSB0aGlzLl9wYXJzZU5hbWVCeXRlcyhcbiAgICAgIGJ5dGVzLnNsaWNlKDM2LCAzNiArIG5hbWVTZWN0aW9uTGVuZ3RoKSxcbiAgICApXG5cbiAgICAvLyByZWFkIHRoZSBpbmRleGVzIGZvciBlYWNoIHJlZmVyZW5jZSBzZXF1ZW5jZVxuICAgIGxldCBjdXJyT2Zmc2V0ID0gMzYgKyBuYW1lU2VjdGlvbkxlbmd0aFxuICAgIGxldCBmaXJzdERhdGFMaW5lOiBWaXJ0dWFsT2Zmc2V0IHwgdW5kZWZpbmVkXG4gICAgY29uc3QgaW5kaWNlcyA9IG5ldyBBcnJheShyZWZDb3VudCkuZmlsbCgwKS5tYXAoKCkgPT4ge1xuICAgICAgLy8gdGhlIGJpbm5pbmcgaW5kZXhcbiAgICAgIGNvbnN0IGJpbkNvdW50ID0gYnl0ZXMucmVhZEludDMyTEUoY3Vyck9mZnNldClcbiAgICAgIGN1cnJPZmZzZXQgKz0gNFxuICAgICAgY29uc3QgYmluSW5kZXg6IHsgW2tleTogbnVtYmVyXTogQ2h1bmtbXSB9ID0ge31cbiAgICAgIGxldCBzdGF0c1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBiaW5Db3VudDsgaiArPSAxKSB7XG4gICAgICAgIGNvbnN0IGJpbiA9IGJ5dGVzLnJlYWRVSW50MzJMRShjdXJyT2Zmc2V0KVxuICAgICAgICBjdXJyT2Zmc2V0ICs9IDRcbiAgICAgICAgaWYgKGJpbiA+IG1heEJpbk51bWJlciArIDEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAndGFiaXggaW5kZXggY29udGFpbnMgdG9vIG1hbnkgYmlucywgcGxlYXNlIHVzZSBhIENTSSBpbmRleCcsXG4gICAgICAgICAgKVxuICAgICAgICB9IGVsc2UgaWYgKGJpbiA9PT0gbWF4QmluTnVtYmVyICsgMSkge1xuICAgICAgICAgIGNvbnN0IGNodW5rQ291bnQgPSBieXRlcy5yZWFkSW50MzJMRShjdXJyT2Zmc2V0KVxuICAgICAgICAgIGN1cnJPZmZzZXQgKz0gNFxuICAgICAgICAgIGlmIChjaHVua0NvdW50ID09PSAyKSB7XG4gICAgICAgICAgICBzdGF0cyA9IHRoaXMucGFyc2VQc2V1ZG9CaW4oYnl0ZXMsIGN1cnJPZmZzZXQpXG4gICAgICAgICAgfVxuICAgICAgICAgIGN1cnJPZmZzZXQgKz0gMTYgKiBjaHVua0NvdW50XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgY2h1bmtDb3VudCA9IGJ5dGVzLnJlYWRJbnQzMkxFKGN1cnJPZmZzZXQpXG4gICAgICAgICAgY3Vyck9mZnNldCArPSA0XG4gICAgICAgICAgY29uc3QgY2h1bmtzID0gbmV3IEFycmF5KGNodW5rQ291bnQpXG4gICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBjaHVua0NvdW50OyBrICs9IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IHUgPSBmcm9tQnl0ZXMoYnl0ZXMsIGN1cnJPZmZzZXQpXG4gICAgICAgICAgICBjb25zdCB2ID0gZnJvbUJ5dGVzKGJ5dGVzLCBjdXJyT2Zmc2V0ICsgOClcbiAgICAgICAgICAgIGN1cnJPZmZzZXQgKz0gMTZcbiAgICAgICAgICAgIGZpcnN0RGF0YUxpbmUgPSB0aGlzLl9maW5kRmlyc3REYXRhKGZpcnN0RGF0YUxpbmUsIHUpXG4gICAgICAgICAgICBjaHVua3Nba10gPSBuZXcgQ2h1bmsodSwgdiwgYmluKVxuICAgICAgICAgIH1cbiAgICAgICAgICBiaW5JbmRleFtiaW5dID0gY2h1bmtzXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gdGhlIGxpbmVhciBpbmRleFxuICAgICAgY29uc3QgbGluZWFyQ291bnQgPSBieXRlcy5yZWFkSW50MzJMRShjdXJyT2Zmc2V0KVxuICAgICAgY3Vyck9mZnNldCArPSA0XG4gICAgICBjb25zdCBsaW5lYXJJbmRleCA9IG5ldyBBcnJheShsaW5lYXJDb3VudClcbiAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgbGluZWFyQ291bnQ7IGsgKz0gMSkge1xuICAgICAgICBsaW5lYXJJbmRleFtrXSA9IGZyb21CeXRlcyhieXRlcywgY3Vyck9mZnNldClcbiAgICAgICAgY3Vyck9mZnNldCArPSA4XG4gICAgICAgIGZpcnN0RGF0YUxpbmUgPSB0aGlzLl9maW5kRmlyc3REYXRhKGZpcnN0RGF0YUxpbmUsIGxpbmVhckluZGV4W2tdKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHsgYmluSW5kZXgsIGxpbmVhckluZGV4LCBzdGF0cyB9XG4gICAgfSlcblxuICAgIHJldHVybiB7XG4gICAgICBpbmRpY2VzLFxuICAgICAgbWV0YUNoYXIsXG4gICAgICBtYXhCaW5OdW1iZXIsXG4gICAgICBtYXhSZWZMZW5ndGgsXG4gICAgICBza2lwTGluZXMsXG4gICAgICBmaXJzdERhdGFMaW5lLFxuICAgICAgY29sdW1uTnVtYmVycyxcbiAgICAgIGNvb3JkaW5hdGVUeXBlLFxuICAgICAgZm9ybWF0LFxuICAgICAgcmVmSWRUb05hbWUsXG4gICAgICByZWZOYW1lVG9JZCxcbiAgICAgIG1heEJsb2NrU2l6ZTogMSA8PCAxNixcbiAgICB9XG4gIH1cblxuICBwYXJzZVBzZXVkb0JpbihieXRlczogQnVmZmVyLCBvZmZzZXQ6IG51bWJlcikge1xuICAgIGNvbnN0IGxpbmVDb3VudCA9IGxvbmdUb051bWJlcihcbiAgICAgIExvbmcuZnJvbUJ5dGVzTEUoXG4gICAgICAgIChieXRlcy5zbGljZShvZmZzZXQgKyAxNiwgb2Zmc2V0ICsgMjQpIGFzIHVua25vd24pIGFzIG51bWJlcltdLFxuICAgICAgICB0cnVlLFxuICAgICAgKSxcbiAgICApXG4gICAgcmV0dXJuIHsgbGluZUNvdW50IH1cbiAgfVxuXG4gIF9wYXJzZU5hbWVCeXRlcyhuYW1lc0J5dGVzOiBCdWZmZXIpIHtcbiAgICBsZXQgY3VyclJlZklkID0gMFxuICAgIGxldCBjdXJyTmFtZVN0YXJ0ID0gMFxuICAgIGNvbnN0IHJlZklkVG9OYW1lOiBzdHJpbmdbXSA9IFtdXG4gICAgY29uc3QgcmVmTmFtZVRvSWQ6IHsgW2tleTogc3RyaW5nXTogbnVtYmVyIH0gPSB7fVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXNCeXRlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgaWYgKCFuYW1lc0J5dGVzW2ldKSB7XG4gICAgICAgIGlmIChjdXJyTmFtZVN0YXJ0IDwgaSkge1xuICAgICAgICAgIGxldCByZWZOYW1lID0gbmFtZXNCeXRlcy50b1N0cmluZygndXRmOCcsIGN1cnJOYW1lU3RhcnQsIGkpXG4gICAgICAgICAgcmVmTmFtZSA9IHRoaXMucmVuYW1lUmVmU2VxKHJlZk5hbWUpXG4gICAgICAgICAgcmVmSWRUb05hbWVbY3VyclJlZklkXSA9IHJlZk5hbWVcbiAgICAgICAgICByZWZOYW1lVG9JZFtyZWZOYW1lXSA9IGN1cnJSZWZJZFxuICAgICAgICB9XG4gICAgICAgIGN1cnJOYW1lU3RhcnQgPSBpICsgMVxuICAgICAgICBjdXJyUmVmSWQgKz0gMVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyByZWZOYW1lVG9JZCwgcmVmSWRUb05hbWUgfVxuICB9XG5cbiAgYXN5bmMgYmxvY2tzRm9yUmFuZ2UoXG4gICAgcmVmTmFtZTogc3RyaW5nLFxuICAgIG1pbjogbnVtYmVyLFxuICAgIG1heDogbnVtYmVyLFxuICAgIG9wdHM6IE9wdGlvbnMgPSB7fSxcbiAgKSB7XG4gICAgaWYgKG1pbiA8IDApIHtcbiAgICAgIG1pbiA9IDBcbiAgICB9XG5cbiAgICBjb25zdCBpbmRleERhdGEgPSBhd2FpdCB0aGlzLnBhcnNlKG9wdHMpXG4gICAgaWYgKCFpbmRleERhdGEpIHtcbiAgICAgIHJldHVybiBbXVxuICAgIH1cbiAgICBjb25zdCByZWZJZCA9IGluZGV4RGF0YS5yZWZOYW1lVG9JZFtyZWZOYW1lXVxuICAgIGNvbnN0IGJhID0gaW5kZXhEYXRhLmluZGljZXNbcmVmSWRdXG4gICAgaWYgKCFiYSkge1xuICAgICAgcmV0dXJuIFtdXG4gICAgfVxuXG4gICAgY29uc3QgbWluT2Zmc2V0ID0gYmEubGluZWFySW5kZXgubGVuZ3RoXG4gICAgICA/IGJhLmxpbmVhckluZGV4W1xuICAgICAgICAgIG1pbiA+PiBUQURfTElEWF9TSElGVCA+PSBiYS5saW5lYXJJbmRleC5sZW5ndGhcbiAgICAgICAgICAgID8gYmEubGluZWFySW5kZXgubGVuZ3RoIC0gMVxuICAgICAgICAgICAgOiBtaW4gPj4gVEFEX0xJRFhfU0hJRlRcbiAgICAgICAgXVxuICAgICAgOiBuZXcgVmlydHVhbE9mZnNldCgwLCAwKVxuICAgIGlmICghbWluT2Zmc2V0KSB7XG4gICAgICBjb25zb2xlLndhcm4oJ3F1ZXJ5aW5nIG91dHNpZGUgb2YgcG9zc2libGUgdGFiaXggcmFuZ2UnKVxuICAgIH1cblxuICAgIC8vIGNvbnN0IHsgbGluZWFySW5kZXgsIGJpbkluZGV4IH0gPSBpbmRleGVzXG5cbiAgICBjb25zdCBvdmVybGFwcGluZ0JpbnMgPSByZWcyYmlucyhtaW4sIG1heCkgLy8gTGlzdCBvZiBiaW4gI3MgdGhhdCBvdmVybGFwIG1pbiwgbWF4XG4gICAgY29uc3QgY2h1bmtzOiBDaHVua1tdID0gW11cblxuICAgIC8vIEZpbmQgY2h1bmtzIGluIG92ZXJsYXBwaW5nIGJpbnMuICBMZWFmIGJpbnMgKDwgNDY4MSkgYXJlIG5vdCBwcnVuZWRcbiAgICBmb3IgKGNvbnN0IFtzdGFydCwgZW5kXSBvZiBvdmVybGFwcGluZ0JpbnMpIHtcbiAgICAgIGZvciAobGV0IGJpbiA9IHN0YXJ0OyBiaW4gPD0gZW5kOyBiaW4rKykge1xuICAgICAgICBpZiAoYmEuYmluSW5kZXhbYmluXSkge1xuICAgICAgICAgIGNvbnN0IGJpbkNodW5rcyA9IGJhLmJpbkluZGV4W2Jpbl1cbiAgICAgICAgICBmb3IgKGxldCBjID0gMDsgYyA8IGJpbkNodW5rcy5sZW5ndGg7ICsrYykge1xuICAgICAgICAgICAgY2h1bmtzLnB1c2gobmV3IENodW5rKGJpbkNodW5rc1tjXS5taW52LCBiaW5DaHVua3NbY10ubWF4diwgYmluKSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBVc2UgdGhlIGxpbmVhciBpbmRleCB0byBmaW5kIG1pbmltdW0gZmlsZSBwb3NpdGlvbiBvZiBjaHVua3MgdGhhdCBjb3VsZCBjb250YWluIGFsaWdubWVudHMgaW4gdGhlIHJlZ2lvblxuICAgIGNvbnN0IG5pbnR2ID0gYmEubGluZWFySW5kZXgubGVuZ3RoXG4gICAgbGV0IGxvd2VzdCA9IG51bGxcbiAgICBjb25zdCBtaW5MaW4gPSBNYXRoLm1pbihtaW4gPj4gMTQsIG5pbnR2IC0gMSlcbiAgICBjb25zdCBtYXhMaW4gPSBNYXRoLm1pbihtYXggPj4gMTQsIG5pbnR2IC0gMSlcbiAgICBmb3IgKGxldCBpID0gbWluTGluOyBpIDw9IG1heExpbjsgKytpKSB7XG4gICAgICBjb25zdCB2cCA9IGJhLmxpbmVhckluZGV4W2ldXG4gICAgICBpZiAodnApIHtcbiAgICAgICAgaWYgKCFsb3dlc3QgfHwgdnAuY29tcGFyZVRvKGxvd2VzdCkgPCAwKSB7XG4gICAgICAgICAgbG93ZXN0ID0gdnBcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvcHRpbWl6ZUNodW5rcyhjaHVua3MsIGxvd2VzdClcbiAgfVxufVxuIl19