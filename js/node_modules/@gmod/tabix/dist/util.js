"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.longToNumber = longToNumber;
exports.checkAbortSignal = checkAbortSignal;
exports.abortBreakPoint = abortBreakPoint;
exports.canMergeBlocks = canMergeBlocks;
exports.optimizeChunks = optimizeChunks;

var _regenerator = _interopRequireDefault(require("@babel/runtime-corejs2/regenerator"));

var _promise = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/promise"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/asyncToGenerator"));

var _construct = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/reflect/construct"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/classCallCheck"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/assertThisInitialized"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/inherits"));

var _wrapNativeSuper2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/wrapNativeSuper"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/defineProperty"));

var _minSafeInteger = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/number/min-safe-integer"));

var _maxSafeInteger = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/number/max-safe-integer"));

function _createSuper(Derived) { return function () { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = (0, _construct.default)(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !_construct.default) return false; if (_construct.default.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call((0, _construct.default)(Date, [], function () {})); return true; } catch (e) { return false; } }

function longToNumber(long) {
  if (long.greaterThan(_maxSafeInteger.default) || long.lessThan(_minSafeInteger.default)) {
    throw new Error('integer overflow');
  }

  return long.toNumber();
}

var AbortError = /*#__PURE__*/function (_Error) {
  (0, _inherits2.default)(AbortError, _Error);

  var _super = _createSuper(AbortError);

  function AbortError() {
    var _this;

    (0, _classCallCheck2.default)(this, AbortError);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "code", void 0);
    return _this;
  }

  return AbortError;
}( /*#__PURE__*/(0, _wrapNativeSuper2.default)(Error));
/**
 * Properly check if the given AbortSignal is aborted.
 * Per the standard, if the signal reads as aborted,
 * this function throws either a DOMException AbortError, or a regular error
 * with a `code` attribute set to `ERR_ABORTED`.
 *
 * For convenience, passing `undefined` is a no-op
 *
 * @param {AbortSignal} [signal] an AbortSignal, or anything with an `aborted` attribute
 * @returns nothing
 */


function checkAbortSignal(signal) {
  if (!signal) return;

  if (signal.aborted) {
    // console.log('bam aborted!')
    if (typeof DOMException !== 'undefined') // eslint-disable-next-line  no-undef
      throw new DOMException('aborted', 'AbortError');else {
      var e = new AbortError('aborted');
      e.code = 'ERR_ABORTED';
      throw e;
    }
  }
}
/**
 * Skips to the next tick, then runs `checkAbortSignal`.
 * Await this to inside an otherwise synchronous loop to
 * provide a place to break when an abort signal is received.
 * @param {AbortSignal} signal
 */


function abortBreakPoint(_x) {
  return _abortBreakPoint.apply(this, arguments);
}

function _abortBreakPoint() {
  _abortBreakPoint = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(signal) {
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return _promise.default.resolve();

          case 2:
            checkAbortSignal(signal);

          case 3:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _abortBreakPoint.apply(this, arguments);
}

function canMergeBlocks(chunk1, chunk2) {
  return chunk2.minv.blockPosition - chunk1.maxv.blockPosition < 65000 && chunk2.maxv.blockPosition - chunk1.minv.blockPosition < 5000000;
}

function optimizeChunks(chunks, lowest) {
  var mergedChunks = [];
  var lastChunk = null;

  if (chunks.length === 0) {
    return chunks;
  }

  chunks.sort(function (c0, c1) {
    var dif = c0.minv.blockPosition - c1.minv.blockPosition;

    if (dif !== 0) {
      return dif;
    } else {
      return c0.minv.dataPosition - c1.minv.dataPosition;
    }
  });
  chunks.forEach(function (chunk) {
    if (!lowest || chunk.maxv.compareTo(lowest) > 0) {
      if (lastChunk === null) {
        mergedChunks.push(chunk);
        lastChunk = chunk;
      } else {
        if (canMergeBlocks(lastChunk, chunk)) {
          if (chunk.maxv.compareTo(lastChunk.maxv) > 0) {
            lastChunk.maxv = chunk.maxv;
          }
        } else {
          mergedChunks.push(chunk);
          lastChunk = chunk;
        }
      }
    } // else {
    //   console.log(`skipping chunk ${chunk}`)
    // }

  });
  return mergedChunks;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy91dGlsLnRzIl0sIm5hbWVzIjpbImxvbmdUb051bWJlciIsImxvbmciLCJncmVhdGVyVGhhbiIsImxlc3NUaGFuIiwiRXJyb3IiLCJ0b051bWJlciIsIkFib3J0RXJyb3IiLCJjaGVja0Fib3J0U2lnbmFsIiwic2lnbmFsIiwiYWJvcnRlZCIsIkRPTUV4Y2VwdGlvbiIsImUiLCJjb2RlIiwiYWJvcnRCcmVha1BvaW50IiwicmVzb2x2ZSIsImNhbk1lcmdlQmxvY2tzIiwiY2h1bmsxIiwiY2h1bmsyIiwibWludiIsImJsb2NrUG9zaXRpb24iLCJtYXh2Iiwib3B0aW1pemVDaHVua3MiLCJjaHVua3MiLCJsb3dlc3QiLCJtZXJnZWRDaHVua3MiLCJsYXN0Q2h1bmsiLCJsZW5ndGgiLCJzb3J0IiwiYzAiLCJjMSIsImRpZiIsImRhdGFQb3NpdGlvbiIsImZvckVhY2giLCJjaHVuayIsImNvbXBhcmVUbyIsInB1c2giXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFHTyxTQUFTQSxZQUFULENBQXNCQyxJQUF0QixFQUFrQztBQUN2QyxNQUNFQSxJQUFJLENBQUNDLFdBQUwsNkJBQ0FELElBQUksQ0FBQ0UsUUFBTCx5QkFGRixFQUdFO0FBQ0EsVUFBTSxJQUFJQyxLQUFKLENBQVUsa0JBQVYsQ0FBTjtBQUNEOztBQUNELFNBQU9ILElBQUksQ0FBQ0ksUUFBTCxFQUFQO0FBQ0Q7O0lBRUtDLFU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OytDQUFtQkYsSztBQUd6Qjs7Ozs7Ozs7Ozs7OztBQVdPLFNBQVNHLGdCQUFULENBQTBCQyxNQUExQixFQUFnRDtBQUNyRCxNQUFJLENBQUNBLE1BQUwsRUFBYTs7QUFFYixNQUFJQSxNQUFNLENBQUNDLE9BQVgsRUFBb0I7QUFDbEI7QUFDQSxRQUFJLE9BQU9DLFlBQVAsS0FBd0IsV0FBNUIsRUFDRTtBQUNBLFlBQU0sSUFBSUEsWUFBSixDQUFpQixTQUFqQixFQUE0QixZQUE1QixDQUFOLENBRkYsS0FHSztBQUNILFVBQU1DLENBQUMsR0FBRyxJQUFJTCxVQUFKLENBQWUsU0FBZixDQUFWO0FBQ0FLLE1BQUFBLENBQUMsQ0FBQ0MsSUFBRixHQUFTLGFBQVQ7QUFDQSxZQUFNRCxDQUFOO0FBQ0Q7QUFDRjtBQUNGO0FBRUQ7Ozs7Ozs7O1NBTXNCRSxlOzs7Ozs2RkFBZixpQkFBK0JMLE1BQS9CO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLG1CQUNDLGlCQUFRTSxPQUFSLEVBREQ7O0FBQUE7QUFFTFAsWUFBQUEsZ0JBQWdCLENBQUNDLE1BQUQsQ0FBaEI7O0FBRks7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRzs7OztBQUtBLFNBQVNPLGNBQVQsQ0FBd0JDLE1BQXhCLEVBQXVDQyxNQUF2QyxFQUFzRDtBQUMzRCxTQUNFQSxNQUFNLENBQUNDLElBQVAsQ0FBWUMsYUFBWixHQUE0QkgsTUFBTSxDQUFDSSxJQUFQLENBQVlELGFBQXhDLEdBQXdELEtBQXhELElBQ0FGLE1BQU0sQ0FBQ0csSUFBUCxDQUFZRCxhQUFaLEdBQTRCSCxNQUFNLENBQUNFLElBQVAsQ0FBWUMsYUFBeEMsR0FBd0QsT0FGMUQ7QUFJRDs7QUFFTSxTQUFTRSxjQUFULENBQXdCQyxNQUF4QixFQUF5Q0MsTUFBekMsRUFBZ0U7QUFDckUsTUFBTUMsWUFBcUIsR0FBRyxFQUE5QjtBQUNBLE1BQUlDLFNBQXVCLEdBQUcsSUFBOUI7O0FBRUEsTUFBSUgsTUFBTSxDQUFDSSxNQUFQLEtBQWtCLENBQXRCLEVBQXlCO0FBQ3ZCLFdBQU9KLE1BQVA7QUFDRDs7QUFFREEsRUFBQUEsTUFBTSxDQUFDSyxJQUFQLENBQVksVUFBU0MsRUFBVCxFQUFhQyxFQUFiLEVBQWlCO0FBQzNCLFFBQU1DLEdBQUcsR0FBR0YsRUFBRSxDQUFDVixJQUFILENBQVFDLGFBQVIsR0FBd0JVLEVBQUUsQ0FBQ1gsSUFBSCxDQUFRQyxhQUE1Qzs7QUFDQSxRQUFJVyxHQUFHLEtBQUssQ0FBWixFQUFlO0FBQ2IsYUFBT0EsR0FBUDtBQUNELEtBRkQsTUFFTztBQUNMLGFBQU9GLEVBQUUsQ0FBQ1YsSUFBSCxDQUFRYSxZQUFSLEdBQXVCRixFQUFFLENBQUNYLElBQUgsQ0FBUWEsWUFBdEM7QUFDRDtBQUNGLEdBUEQ7QUFTQVQsRUFBQUEsTUFBTSxDQUFDVSxPQUFQLENBQWUsVUFBQUMsS0FBSyxFQUFJO0FBQ3RCLFFBQUksQ0FBQ1YsTUFBRCxJQUFXVSxLQUFLLENBQUNiLElBQU4sQ0FBV2MsU0FBWCxDQUFxQlgsTUFBckIsSUFBK0IsQ0FBOUMsRUFBaUQ7QUFDL0MsVUFBSUUsU0FBUyxLQUFLLElBQWxCLEVBQXdCO0FBQ3RCRCxRQUFBQSxZQUFZLENBQUNXLElBQWIsQ0FBa0JGLEtBQWxCO0FBQ0FSLFFBQUFBLFNBQVMsR0FBR1EsS0FBWjtBQUNELE9BSEQsTUFHTztBQUNMLFlBQUlsQixjQUFjLENBQUNVLFNBQUQsRUFBWVEsS0FBWixDQUFsQixFQUFzQztBQUNwQyxjQUFJQSxLQUFLLENBQUNiLElBQU4sQ0FBV2MsU0FBWCxDQUFxQlQsU0FBUyxDQUFDTCxJQUEvQixJQUF1QyxDQUEzQyxFQUE4QztBQUM1Q0ssWUFBQUEsU0FBUyxDQUFDTCxJQUFWLEdBQWlCYSxLQUFLLENBQUNiLElBQXZCO0FBQ0Q7QUFDRixTQUpELE1BSU87QUFDTEksVUFBQUEsWUFBWSxDQUFDVyxJQUFiLENBQWtCRixLQUFsQjtBQUNBUixVQUFBQSxTQUFTLEdBQUdRLEtBQVo7QUFDRDtBQUNGO0FBQ0YsS0FmcUIsQ0FnQnRCO0FBQ0E7QUFDQTs7QUFDRCxHQW5CRDtBQXFCQSxTQUFPVCxZQUFQO0FBQ0QiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQ2h1bmsgZnJvbSAnLi9jaHVuaydcbmltcG9ydCBWaXJ0dWFsT2Zmc2V0IGZyb20gJy4vdmlydHVhbE9mZnNldCdcblxuZXhwb3J0IGZ1bmN0aW9uIGxvbmdUb051bWJlcihsb25nOiBMb25nKSB7XG4gIGlmIChcbiAgICBsb25nLmdyZWF0ZXJUaGFuKE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSB8fFxuICAgIGxvbmcubGVzc1RoYW4oTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIpXG4gICkge1xuICAgIHRocm93IG5ldyBFcnJvcignaW50ZWdlciBvdmVyZmxvdycpXG4gIH1cbiAgcmV0dXJuIGxvbmcudG9OdW1iZXIoKVxufVxuXG5jbGFzcyBBYm9ydEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBwdWJsaWMgY29kZTogc3RyaW5nIHwgdW5kZWZpbmVkXG59XG4vKipcbiAqIFByb3Blcmx5IGNoZWNrIGlmIHRoZSBnaXZlbiBBYm9ydFNpZ25hbCBpcyBhYm9ydGVkLlxuICogUGVyIHRoZSBzdGFuZGFyZCwgaWYgdGhlIHNpZ25hbCByZWFkcyBhcyBhYm9ydGVkLFxuICogdGhpcyBmdW5jdGlvbiB0aHJvd3MgZWl0aGVyIGEgRE9NRXhjZXB0aW9uIEFib3J0RXJyb3IsIG9yIGEgcmVndWxhciBlcnJvclxuICogd2l0aCBhIGBjb2RlYCBhdHRyaWJ1dGUgc2V0IHRvIGBFUlJfQUJPUlRFRGAuXG4gKlxuICogRm9yIGNvbnZlbmllbmNlLCBwYXNzaW5nIGB1bmRlZmluZWRgIGlzIGEgbm8tb3BcbiAqXG4gKiBAcGFyYW0ge0Fib3J0U2lnbmFsfSBbc2lnbmFsXSBhbiBBYm9ydFNpZ25hbCwgb3IgYW55dGhpbmcgd2l0aCBhbiBgYWJvcnRlZGAgYXR0cmlidXRlXG4gKiBAcmV0dXJucyBub3RoaW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjaGVja0Fib3J0U2lnbmFsKHNpZ25hbD86IEFib3J0U2lnbmFsKSB7XG4gIGlmICghc2lnbmFsKSByZXR1cm5cblxuICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAvLyBjb25zb2xlLmxvZygnYmFtIGFib3J0ZWQhJylcbiAgICBpZiAodHlwZW9mIERPTUV4Y2VwdGlvbiAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgIG5vLXVuZGVmXG4gICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKCdhYm9ydGVkJywgJ0Fib3J0RXJyb3InKVxuICAgIGVsc2Uge1xuICAgICAgY29uc3QgZSA9IG5ldyBBYm9ydEVycm9yKCdhYm9ydGVkJylcbiAgICAgIGUuY29kZSA9ICdFUlJfQUJPUlRFRCdcbiAgICAgIHRocm93IGVcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBTa2lwcyB0byB0aGUgbmV4dCB0aWNrLCB0aGVuIHJ1bnMgYGNoZWNrQWJvcnRTaWduYWxgLlxuICogQXdhaXQgdGhpcyB0byBpbnNpZGUgYW4gb3RoZXJ3aXNlIHN5bmNocm9ub3VzIGxvb3AgdG9cbiAqIHByb3ZpZGUgYSBwbGFjZSB0byBicmVhayB3aGVuIGFuIGFib3J0IHNpZ25hbCBpcyByZWNlaXZlZC5cbiAqIEBwYXJhbSB7QWJvcnRTaWduYWx9IHNpZ25hbFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYWJvcnRCcmVha1BvaW50KHNpZ25hbD86IEFib3J0U2lnbmFsKSB7XG4gIGF3YWl0IFByb21pc2UucmVzb2x2ZSgpXG4gIGNoZWNrQWJvcnRTaWduYWwoc2lnbmFsKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY2FuTWVyZ2VCbG9ja3MoY2h1bmsxOiBDaHVuaywgY2h1bmsyOiBDaHVuaykge1xuICByZXR1cm4gKFxuICAgIGNodW5rMi5taW52LmJsb2NrUG9zaXRpb24gLSBjaHVuazEubWF4di5ibG9ja1Bvc2l0aW9uIDwgNjUwMDAgJiZcbiAgICBjaHVuazIubWF4di5ibG9ja1Bvc2l0aW9uIC0gY2h1bmsxLm1pbnYuYmxvY2tQb3NpdGlvbiA8IDUwMDAwMDBcbiAgKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gb3B0aW1pemVDaHVua3MoY2h1bmtzOiBDaHVua1tdLCBsb3dlc3Q6IFZpcnR1YWxPZmZzZXQpIHtcbiAgY29uc3QgbWVyZ2VkQ2h1bmtzOiBDaHVua1tdID0gW11cbiAgbGV0IGxhc3RDaHVuazogQ2h1bmsgfCBudWxsID0gbnVsbFxuXG4gIGlmIChjaHVua3MubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGNodW5rc1xuICB9XG5cbiAgY2h1bmtzLnNvcnQoZnVuY3Rpb24oYzAsIGMxKSB7XG4gICAgY29uc3QgZGlmID0gYzAubWludi5ibG9ja1Bvc2l0aW9uIC0gYzEubWludi5ibG9ja1Bvc2l0aW9uXG4gICAgaWYgKGRpZiAhPT0gMCkge1xuICAgICAgcmV0dXJuIGRpZlxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYzAubWludi5kYXRhUG9zaXRpb24gLSBjMS5taW52LmRhdGFQb3NpdGlvblxuICAgIH1cbiAgfSlcblxuICBjaHVua3MuZm9yRWFjaChjaHVuayA9PiB7XG4gICAgaWYgKCFsb3dlc3QgfHwgY2h1bmsubWF4di5jb21wYXJlVG8obG93ZXN0KSA+IDApIHtcbiAgICAgIGlmIChsYXN0Q2h1bmsgPT09IG51bGwpIHtcbiAgICAgICAgbWVyZ2VkQ2h1bmtzLnB1c2goY2h1bmspXG4gICAgICAgIGxhc3RDaHVuayA9IGNodW5rXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoY2FuTWVyZ2VCbG9ja3MobGFzdENodW5rLCBjaHVuaykpIHtcbiAgICAgICAgICBpZiAoY2h1bmsubWF4di5jb21wYXJlVG8obGFzdENodW5rLm1heHYpID4gMCkge1xuICAgICAgICAgICAgbGFzdENodW5rLm1heHYgPSBjaHVuay5tYXh2XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1lcmdlZENodW5rcy5wdXNoKGNodW5rKVxuICAgICAgICAgIGxhc3RDaHVuayA9IGNodW5rXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gZWxzZSB7XG4gICAgLy8gICBjb25zb2xlLmxvZyhgc2tpcHBpbmcgY2h1bmsgJHtjaHVua31gKVxuICAgIC8vIH1cbiAgfSlcblxuICByZXR1cm4gbWVyZ2VkQ2h1bmtzXG59XG4iXX0=