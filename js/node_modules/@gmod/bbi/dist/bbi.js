"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BBI = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _binaryParser = require("@gmod/binary-parser");

var _genericFilehandle = require("generic-filehandle");

var _rxjs = require("rxjs");

var _operators = require("rxjs/operators");

var _abortablePromiseCache = _interopRequireDefault(require("abortable-promise-cache"));

var _quickLru = _interopRequireDefault(require("quick-lru"));

var _blockView = require("./blockView");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var BIG_WIG_MAGIC = -2003829722;
var BIG_BED_MAGIC = -2021002517;

/* get the compiled parsers for different sections of the bigwig file
 *
 * @param isBE - is big endian, typically false
 * @return an object with compiled parsers
 */
function getParsers(isBE) {
  var le = isBE ? 'big' : 'little';
  var headerParser = new _binaryParser.Parser().endianess(le).int32('magic').uint16('version').uint16('numZoomLevels').uint64('chromTreeOffset').uint64('unzoomedDataOffset').uint64('unzoomedIndexOffset').uint16('fieldCount').uint16('definedFieldCount').uint64('asOffset') // autoSql offset, used in bigbed
  .uint64('totalSummaryOffset').uint32('uncompressBufSize').uint64('extHeaderOffset') // name index offset, used in bigbed
  .array('zoomLevels', {
    length: 'numZoomLevels',
    type: new _binaryParser.Parser().uint32('reductionLevel').uint32('reserved').uint64('dataOffset').uint64('indexOffset')
  });
  var totalSummaryParser = new _binaryParser.Parser().endianess(le).uint64('basesCovered').double('scoreMin').double('scoreMax').double('scoreSum').double('scoreSumSquares');
  var chromTreeParser = new _binaryParser.Parser().endianess(le).uint32('magic').uint32('blockSize').uint32('keySize').uint32('valSize').uint64('itemCount');
  var isLeafNode = new _binaryParser.Parser().endianess(le).uint8('isLeafNode').skip(1).uint16('cnt');
  return {
    chromTreeParser: chromTreeParser,
    totalSummaryParser: totalSummaryParser,
    headerParser: headerParser,
    isLeafNode: isLeafNode
  };
}

var BBI = /*#__PURE__*/function () {
  (0, _createClass2.default)(BBI, [{
    key: "getHeader",

    /* fetch and parse header information from a bigwig or bigbed file
     * @param abortSignal - abort the operation, can be null
     * @return a Header object
     */
    value: function getHeader() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var options = 'aborted' in opts ? {
        signal: opts
      } : opts;
      return this.headerCache.get(JSON.stringify(options), options, options.signal);
    }
    /*
     * @param filehandle - a filehandle from generic-filehandle or implementing something similar to the node10 fs.promises API
     * @param path - a Local file path as a string
     * @param url - a URL string
     * @param renameRefSeqs - an optional method to rename the internal reference sequences using a mapping function
     */

  }]);

  function BBI() {
    var _this = this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck2.default)(this, BBI);
    (0, _defineProperty2.default)(this, "bbi", void 0);
    (0, _defineProperty2.default)(this, "headerCache", new _abortablePromiseCache.default({
      cache: new _quickLru.default({
        maxSize: 1
      }),
      fill: function () {
        var _fill = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(params, signal) {
          return _regenerator.default.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  return _context.abrupt("return", _this._getHeader(_objectSpread(_objectSpread({}, params), {}, {
                    signal: signal
                  })));

                case 1:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }));

        function fill(_x, _x2) {
          return _fill.apply(this, arguments);
        }

        return fill;
      }()
    }));
    (0, _defineProperty2.default)(this, "renameRefSeqs", void 0);
    var filehandle = options.filehandle,
        renameRefSeqs = options.renameRefSeqs,
        path = options.path,
        url = options.url;

    this.renameRefSeqs = renameRefSeqs || function (s) {
      return s;
    };

    if (filehandle) {
      this.bbi = filehandle;
    } else if (url) {
      this.bbi = new _genericFilehandle.RemoteFile(url);
    } else if (path) {
      this.bbi = new _genericFilehandle.LocalFile(path);
    } else {
      throw new Error('no file given');
    }
  }

  (0, _createClass2.default)(BBI, [{
    key: "_getHeader",
    value: function () {
      var _getHeader2 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2(opts) {
        var header, chroms;
        return _regenerator.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this._getMainHeader(opts);

              case 2:
                header = _context2.sent;
                _context2.next = 5;
                return this._readChromTree(header, opts);

              case 5:
                chroms = _context2.sent;
                return _context2.abrupt("return", _objectSpread(_objectSpread({}, header), chroms));

              case 7:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function _getHeader(_x3) {
        return _getHeader2.apply(this, arguments);
      }

      return _getHeader;
    }()
  }, {
    key: "_getMainHeader",
    value: function () {
      var _getMainHeader2 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee3(opts) {
        var requestSize,
            _yield$this$bbi$read,
            buffer,
            isBigEndian,
            ret,
            header,
            tail,
            _args3 = arguments;

        return _regenerator.default.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                requestSize = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : 2000;
                _context3.next = 3;
                return this.bbi.read(Buffer.alloc(requestSize), 0, requestSize, 0, opts);

              case 3:
                _yield$this$bbi$read = _context3.sent;
                buffer = _yield$this$bbi$read.buffer;
                isBigEndian = this._isBigEndian(buffer);
                ret = getParsers(isBigEndian);
                header = ret.headerParser.parse(buffer).result;
                header.fileType = header.magic === BIG_BED_MAGIC ? 'bigbed' : 'bigwig';

                if (!(header.asOffset > requestSize || header.totalSummaryOffset > requestSize)) {
                  _context3.next = 11;
                  break;
                }

                return _context3.abrupt("return", this._getMainHeader(opts, requestSize * 2));

              case 11:
                if (header.asOffset) {
                  header.autoSql = buffer.slice(header.asOffset, buffer.indexOf(0, header.asOffset)).toString('utf8');
                }

                if (!(header.totalSummaryOffset > requestSize)) {
                  _context3.next = 14;
                  break;
                }

                return _context3.abrupt("return", this._getMainHeader(opts, requestSize * 2));

              case 14:
                if (header.totalSummaryOffset) {
                  tail = buffer.slice(header.totalSummaryOffset);
                  header.totalSummary = ret.totalSummaryParser.parse(tail).result;
                }

                return _context3.abrupt("return", _objectSpread(_objectSpread({}, header), {}, {
                  isBigEndian: isBigEndian
                }));

              case 16:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function _getMainHeader(_x4) {
        return _getMainHeader2.apply(this, arguments);
      }

      return _getMainHeader;
    }()
  }, {
    key: "_isBigEndian",
    value: function _isBigEndian(buffer) {
      var ret = buffer.readInt32LE(0);

      if (ret === BIG_WIG_MAGIC || ret === BIG_BED_MAGIC) {
        return false;
      }

      ret = buffer.readInt32BE(0);

      if (ret === BIG_WIG_MAGIC || ret === BIG_BED_MAGIC) {
        return true;
      }

      throw new Error('not a BigWig/BigBed file');
    } // todo: add progress if long running

  }, {
    key: "_readChromTree",
    value: function () {
      var _readChromTree2 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee5(header, opts) {
        var _this2 = this;

        var isBE, le, refsByNumber, refsByName, chromTreeOffset, unzoomedDataOffset, _yield$this$bbi$read2, data, p, keySize, leafNodeParser, nonleafNodeParser, rootNodeOffset, bptReadNode;

        return _regenerator.default.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                isBE = header.isBigEndian;
                le = isBE ? 'big' : 'little';
                refsByNumber = [];
                refsByName = {};
                chromTreeOffset = header.chromTreeOffset;
                unzoomedDataOffset = header.unzoomedDataOffset;

                while (unzoomedDataOffset % 4 !== 0) {
                  unzoomedDataOffset += 1;
                }

                _context5.next = 9;
                return this.bbi.read(Buffer.alloc(unzoomedDataOffset - chromTreeOffset), 0, unzoomedDataOffset - chromTreeOffset, chromTreeOffset, opts);

              case 9:
                _yield$this$bbi$read2 = _context5.sent;
                data = _yield$this$bbi$read2.buffer;
                p = getParsers(isBE);
                keySize = p.chromTreeParser.parse(data).result.keySize;
                leafNodeParser = new _binaryParser.Parser().endianess(le).string('key', {
                  stripNull: true,
                  length: keySize
                }).uint32('refId').uint32('refSize');
                nonleafNodeParser = new _binaryParser.Parser().endianess(le).skip(keySize).uint64('childOffset');
                rootNodeOffset = 32;

                bptReadNode = /*#__PURE__*/function () {
                  var _ref = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee4(currentOffset) {
                    var offset, ret, _ret$result, isLeafNode, cnt, n, leafRet, _leafRet$result, _key, refId, refSize, refRec, nextNodes, _n, nonleafRet, childOffset;

                    return _regenerator.default.wrap(function _callee4$(_context4) {
                      while (1) {
                        switch (_context4.prev = _context4.next) {
                          case 0:
                            offset = currentOffset;

                            if (!(offset >= data.length)) {
                              _context4.next = 3;
                              break;
                            }

                            throw new Error('reading beyond end of buffer');

                          case 3:
                            ret = p.isLeafNode.parse(data.slice(offset));
                            _ret$result = ret.result, isLeafNode = _ret$result.isLeafNode, cnt = _ret$result.cnt;
                            offset += ret.offset;

                            if (!isLeafNode) {
                              _context4.next = 10;
                              break;
                            }

                            for (n = 0; n < cnt; n += 1) {
                              leafRet = leafNodeParser.parse(data.slice(offset));
                              offset += leafRet.offset;
                              _leafRet$result = leafRet.result, _key = _leafRet$result.key, refId = _leafRet$result.refId, refSize = _leafRet$result.refSize;
                              refRec = {
                                name: _key,
                                id: refId,
                                length: refSize
                              };
                              refsByName[_this2.renameRefSeqs(_key)] = refId;
                              refsByNumber[refId] = refRec;
                            }

                            _context4.next = 14;
                            break;

                          case 10:
                            // parse index node
                            nextNodes = [];

                            for (_n = 0; _n < cnt; _n += 1) {
                              nonleafRet = nonleafNodeParser.parse(data.slice(offset));
                              childOffset = nonleafRet.result.childOffset;
                              offset += nonleafRet.offset;
                              childOffset -= chromTreeOffset;
                              nextNodes.push(bptReadNode(childOffset));
                            }

                            _context4.next = 14;
                            return Promise.all(nextNodes);

                          case 14:
                          case "end":
                            return _context4.stop();
                        }
                      }
                    }, _callee4);
                  }));

                  return function bptReadNode(_x7) {
                    return _ref.apply(this, arguments);
                  };
                }();

                _context5.next = 19;
                return bptReadNode(rootNodeOffset);

              case 19:
                return _context5.abrupt("return", {
                  refsByName: refsByName,
                  refsByNumber: refsByNumber
                });

              case 20:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function _readChromTree(_x5, _x6) {
        return _readChromTree2.apply(this, arguments);
      }

      return _readChromTree;
    }()
    /*
     * fetches the "unzoomed" view of the bigwig data. this is the default for bigbed
     * @param abortSignal - a signal to optionally abort this operation
     */

  }, {
    key: "getUnzoomedView",
    value: function () {
      var _getUnzoomedView = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee6(opts) {
        var _yield$this$getHeader, unzoomedIndexOffset, zoomLevels, refsByName, uncompressBufSize, isBigEndian, fileType, nzl, cirLen;

        return _regenerator.default.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return this.getHeader(opts);

              case 2:
                _yield$this$getHeader = _context6.sent;
                unzoomedIndexOffset = _yield$this$getHeader.unzoomedIndexOffset;
                zoomLevels = _yield$this$getHeader.zoomLevels;
                refsByName = _yield$this$getHeader.refsByName;
                uncompressBufSize = _yield$this$getHeader.uncompressBufSize;
                isBigEndian = _yield$this$getHeader.isBigEndian;
                fileType = _yield$this$getHeader.fileType;
                nzl = zoomLevels[0];
                cirLen = nzl ? nzl.dataOffset - unzoomedIndexOffset : 4000;
                return _context6.abrupt("return", new _blockView.BlockView(this.bbi, refsByName, unzoomedIndexOffset, cirLen, isBigEndian, uncompressBufSize > 0, fileType));

              case 12:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function getUnzoomedView(_x8) {
        return _getUnzoomedView.apply(this, arguments);
      }

      return getUnzoomedView;
    }()
    /*
     * abstract method - get the view for a given scale
     */

  }, {
    key: "getFeatureStream",

    /**
     * Gets features from a BigWig file
     *
     * @param refName - The chromosome name
     * @param start - The start of a region
     * @param end - The end of a region
     * @param opts - An object containing basesPerSpan (e.g. pixels per basepair) or scale used to infer the zoomLevel to use
     */
    value: function () {
      var _getFeatureStream = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee7(refName, start, end) {
        var opts,
            chrName,
            view,
            _args7 = arguments;
        return _regenerator.default.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                opts = _args7.length > 3 && _args7[3] !== undefined ? _args7[3] : {
                  scale: 1
                };
                _context7.next = 3;
                return this.getHeader(opts);

              case 3:
                chrName = this.renameRefSeqs(refName);

                if (!opts.basesPerSpan) {
                  _context7.next = 10;
                  break;
                }

                _context7.next = 7;
                return this.getView(1 / opts.basesPerSpan, opts);

              case 7:
                view = _context7.sent;
                _context7.next = 19;
                break;

              case 10:
                if (!opts.scale) {
                  _context7.next = 16;
                  break;
                }

                _context7.next = 13;
                return this.getView(opts.scale, opts);

              case 13:
                view = _context7.sent;
                _context7.next = 19;
                break;

              case 16:
                _context7.next = 18;
                return this.getView(1, opts);

              case 18:
                view = _context7.sent;

              case 19:
                if (view) {
                  _context7.next = 21;
                  break;
                }

                throw new Error('unable to get block view for data');

              case 21:
                return _context7.abrupt("return", new _rxjs.Observable(function (observer) {
                  view.readWigData(chrName, start, end, observer, opts);
                }));

              case 22:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function getFeatureStream(_x9, _x10, _x11) {
        return _getFeatureStream.apply(this, arguments);
      }

      return getFeatureStream;
    }()
  }, {
    key: "getFeatures",
    value: function () {
      var _getFeatures = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee8(refName, start, end) {
        var opts,
            ob,
            ret,
            _args8 = arguments;
        return _regenerator.default.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                opts = _args8.length > 3 && _args8[3] !== undefined ? _args8[3] : {
                  scale: 1
                };
                _context8.next = 3;
                return this.getFeatureStream(refName, start, end, opts);

              case 3:
                ob = _context8.sent;
                _context8.next = 6;
                return ob.pipe((0, _operators.reduce)(function (acc, curr) {
                  return acc.concat(curr);
                })).toPromise();

              case 6:
                ret = _context8.sent;
                return _context8.abrupt("return", ret || []);

              case 8:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function getFeatures(_x12, _x13, _x14) {
        return _getFeatures.apply(this, arguments);
      }

      return getFeatures;
    }()
  }]);
  return BBI;
}();

exports.BBI = BBI;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9iYmkudHMiXSwibmFtZXMiOlsiQklHX1dJR19NQUdJQyIsIkJJR19CRURfTUFHSUMiLCJnZXRQYXJzZXJzIiwiaXNCRSIsImxlIiwiaGVhZGVyUGFyc2VyIiwiUGFyc2VyIiwiZW5kaWFuZXNzIiwiaW50MzIiLCJ1aW50MTYiLCJ1aW50NjQiLCJ1aW50MzIiLCJhcnJheSIsImxlbmd0aCIsInR5cGUiLCJ0b3RhbFN1bW1hcnlQYXJzZXIiLCJkb3VibGUiLCJjaHJvbVRyZWVQYXJzZXIiLCJpc0xlYWZOb2RlIiwidWludDgiLCJza2lwIiwiQkJJIiwib3B0cyIsIm9wdGlvbnMiLCJzaWduYWwiLCJoZWFkZXJDYWNoZSIsImdldCIsIkpTT04iLCJzdHJpbmdpZnkiLCJBYm9ydGFibGVQcm9taXNlQ2FjaGUiLCJjYWNoZSIsIlF1aWNrTFJVIiwibWF4U2l6ZSIsImZpbGwiLCJwYXJhbXMiLCJfZ2V0SGVhZGVyIiwiZmlsZWhhbmRsZSIsInJlbmFtZVJlZlNlcXMiLCJwYXRoIiwidXJsIiwicyIsImJiaSIsIlJlbW90ZUZpbGUiLCJMb2NhbEZpbGUiLCJFcnJvciIsIl9nZXRNYWluSGVhZGVyIiwiaGVhZGVyIiwiX3JlYWRDaHJvbVRyZWUiLCJjaHJvbXMiLCJyZXF1ZXN0U2l6ZSIsInJlYWQiLCJCdWZmZXIiLCJhbGxvYyIsImJ1ZmZlciIsImlzQmlnRW5kaWFuIiwiX2lzQmlnRW5kaWFuIiwicmV0IiwicGFyc2UiLCJyZXN1bHQiLCJmaWxlVHlwZSIsIm1hZ2ljIiwiYXNPZmZzZXQiLCJ0b3RhbFN1bW1hcnlPZmZzZXQiLCJhdXRvU3FsIiwic2xpY2UiLCJpbmRleE9mIiwidG9TdHJpbmciLCJ0YWlsIiwidG90YWxTdW1tYXJ5IiwicmVhZEludDMyTEUiLCJyZWFkSW50MzJCRSIsInJlZnNCeU51bWJlciIsInJlZnNCeU5hbWUiLCJjaHJvbVRyZWVPZmZzZXQiLCJ1bnpvb21lZERhdGFPZmZzZXQiLCJkYXRhIiwicCIsImtleVNpemUiLCJsZWFmTm9kZVBhcnNlciIsInN0cmluZyIsInN0cmlwTnVsbCIsIm5vbmxlYWZOb2RlUGFyc2VyIiwicm9vdE5vZGVPZmZzZXQiLCJicHRSZWFkTm9kZSIsImN1cnJlbnRPZmZzZXQiLCJvZmZzZXQiLCJjbnQiLCJuIiwibGVhZlJldCIsImtleSIsInJlZklkIiwicmVmU2l6ZSIsInJlZlJlYyIsIm5hbWUiLCJpZCIsIm5leHROb2RlcyIsIm5vbmxlYWZSZXQiLCJjaGlsZE9mZnNldCIsInB1c2giLCJQcm9taXNlIiwiYWxsIiwiZ2V0SGVhZGVyIiwidW56b29tZWRJbmRleE9mZnNldCIsInpvb21MZXZlbHMiLCJ1bmNvbXByZXNzQnVmU2l6ZSIsIm56bCIsImNpckxlbiIsImRhdGFPZmZzZXQiLCJCbG9ja1ZpZXciLCJyZWZOYW1lIiwic3RhcnQiLCJlbmQiLCJzY2FsZSIsImNock5hbWUiLCJiYXNlc1BlclNwYW4iLCJnZXRWaWV3IiwidmlldyIsIk9ic2VydmFibGUiLCJvYnNlcnZlciIsInJlYWRXaWdEYXRhIiwiZ2V0RmVhdHVyZVN0cmVhbSIsIm9iIiwicGlwZSIsImFjYyIsImN1cnIiLCJjb25jYXQiLCJ0b1Byb21pc2UiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7Ozs7O0FBRUEsSUFBTUEsYUFBYSxHQUFHLENBQUMsVUFBdkI7QUFDQSxJQUFNQyxhQUFhLEdBQUcsQ0FBQyxVQUF2Qjs7QUF5Q0E7Ozs7O0FBS0EsU0FBU0MsVUFBVCxDQUFvQkMsSUFBcEIsRUFBd0M7QUFDdEMsTUFBTUMsRUFBRSxHQUFHRCxJQUFJLEdBQUcsS0FBSCxHQUFXLFFBQTFCO0FBQ0EsTUFBTUUsWUFBWSxHQUFHLElBQUlDLG9CQUFKLEdBQ2xCQyxTQURrQixDQUNSSCxFQURRLEVBRWxCSSxLQUZrQixDQUVaLE9BRlksRUFHbEJDLE1BSGtCLENBR1gsU0FIVyxFQUlsQkEsTUFKa0IsQ0FJWCxlQUpXLEVBS2xCQyxNQUxrQixDQUtYLGlCQUxXLEVBTWxCQSxNQU5rQixDQU1YLG9CQU5XLEVBT2xCQSxNQVBrQixDQU9YLHFCQVBXLEVBUWxCRCxNQVJrQixDQVFYLFlBUlcsRUFTbEJBLE1BVGtCLENBU1gsbUJBVFcsRUFVbEJDLE1BVmtCLENBVVgsVUFWVyxFQVVDO0FBVkQsR0FXbEJBLE1BWGtCLENBV1gsb0JBWFcsRUFZbEJDLE1BWmtCLENBWVgsbUJBWlcsRUFhbEJELE1BYmtCLENBYVgsaUJBYlcsRUFhUTtBQWJSLEdBY2xCRSxLQWRrQixDQWNaLFlBZFksRUFjRTtBQUNuQkMsSUFBQUEsTUFBTSxFQUFFLGVBRFc7QUFFbkJDLElBQUFBLElBQUksRUFBRSxJQUFJUixvQkFBSixHQUNISyxNQURHLENBQ0ksZ0JBREosRUFFSEEsTUFGRyxDQUVJLFVBRkosRUFHSEQsTUFIRyxDQUdJLFlBSEosRUFJSEEsTUFKRyxDQUlJLGFBSko7QUFGYSxHQWRGLENBQXJCO0FBdUJBLE1BQU1LLGtCQUFrQixHQUFHLElBQUlULG9CQUFKLEdBQ3hCQyxTQUR3QixDQUNkSCxFQURjLEVBRXhCTSxNQUZ3QixDQUVqQixjQUZpQixFQUd4Qk0sTUFId0IsQ0FHakIsVUFIaUIsRUFJeEJBLE1BSndCLENBSWpCLFVBSmlCLEVBS3hCQSxNQUx3QixDQUtqQixVQUxpQixFQU14QkEsTUFOd0IsQ0FNakIsaUJBTmlCLENBQTNCO0FBUUEsTUFBTUMsZUFBZSxHQUFHLElBQUlYLG9CQUFKLEdBQ3JCQyxTQURxQixDQUNYSCxFQURXLEVBRXJCTyxNQUZxQixDQUVkLE9BRmMsRUFHckJBLE1BSHFCLENBR2QsV0FIYyxFQUlyQkEsTUFKcUIsQ0FJZCxTQUpjLEVBS3JCQSxNQUxxQixDQUtkLFNBTGMsRUFNckJELE1BTnFCLENBTWQsV0FOYyxDQUF4QjtBQVFBLE1BQU1RLFVBQVUsR0FBRyxJQUFJWixvQkFBSixHQUNoQkMsU0FEZ0IsQ0FDTkgsRUFETSxFQUVoQmUsS0FGZ0IsQ0FFVixZQUZVLEVBR2hCQyxJQUhnQixDQUdYLENBSFcsRUFJaEJYLE1BSmdCLENBSVQsS0FKUyxDQUFuQjtBQU1BLFNBQU87QUFDTFEsSUFBQUEsZUFBZSxFQUFmQSxlQURLO0FBRUxGLElBQUFBLGtCQUFrQixFQUFsQkEsa0JBRks7QUFHTFYsSUFBQUEsWUFBWSxFQUFaQSxZQUhLO0FBSUxhLElBQUFBLFVBQVUsRUFBVkE7QUFKSyxHQUFQO0FBTUQ7O0lBUXFCRyxHOzs7O0FBWXBCOzs7O2dDQUkwRDtBQUFBLFVBQXpDQyxJQUF5Qyx1RUFBSixFQUFJO0FBQ3hELFVBQU1DLE9BQU8sR0FBRyxhQUFhRCxJQUFiLEdBQW9CO0FBQUVFLFFBQUFBLE1BQU0sRUFBRUY7QUFBVixPQUFwQixHQUF1Q0EsSUFBdkQ7QUFDQSxhQUFPLEtBQUtHLFdBQUwsQ0FBaUJDLEdBQWpCLENBQXFCQyxJQUFJLENBQUNDLFNBQUwsQ0FBZUwsT0FBZixDQUFyQixFQUE4Q0EsT0FBOUMsRUFBdURBLE9BQU8sQ0FBQ0MsTUFBL0QsQ0FBUDtBQUNEO0FBRUQ7Ozs7Ozs7OztBQU1BLGlCQU9FO0FBQUE7O0FBQUEsUUFOQUQsT0FNQSx1RUFESSxFQUNKO0FBQUE7QUFBQTtBQUFBLHVEQS9Cc0IsSUFBSU0sOEJBQUosQ0FBMEI7QUFDaERDLE1BQUFBLEtBQUssRUFBRSxJQUFJQyxpQkFBSixDQUFhO0FBQUVDLFFBQUFBLE9BQU8sRUFBRTtBQUFYLE9BQWIsQ0FEeUM7QUFFaERDLE1BQUFBLElBQUk7QUFBQSw0RkFBRSxpQkFBT0MsTUFBUCxFQUFvQlYsTUFBcEI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLG1EQUNHLEtBQUksQ0FBQ1csVUFBTCxpQ0FBcUJELE1BQXJCO0FBQTZCVixvQkFBQUEsTUFBTSxFQUFOQTtBQUE3QixxQkFESDs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxTQUFGOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBRjRDLEtBQTFCLENBK0J0QjtBQUFBO0FBQUEsUUFDUVksVUFEUixHQUNpRGIsT0FEakQsQ0FDUWEsVUFEUjtBQUFBLFFBQ29CQyxhQURwQixHQUNpRGQsT0FEakQsQ0FDb0JjLGFBRHBCO0FBQUEsUUFDbUNDLElBRG5DLEdBQ2lEZixPQURqRCxDQUNtQ2UsSUFEbkM7QUFBQSxRQUN5Q0MsR0FEekMsR0FDaURoQixPQURqRCxDQUN5Q2dCLEdBRHpDOztBQUVBLFNBQUtGLGFBQUwsR0FBcUJBLGFBQWEsSUFBSyxVQUFDRyxDQUFEO0FBQUEsYUFBdUJBLENBQXZCO0FBQUEsS0FBdkM7O0FBQ0EsUUFBSUosVUFBSixFQUFnQjtBQUNkLFdBQUtLLEdBQUwsR0FBV0wsVUFBWDtBQUNELEtBRkQsTUFFTyxJQUFJRyxHQUFKLEVBQVM7QUFDZCxXQUFLRSxHQUFMLEdBQVcsSUFBSUMsNkJBQUosQ0FBZUgsR0FBZixDQUFYO0FBQ0QsS0FGTSxNQUVBLElBQUlELElBQUosRUFBVTtBQUNmLFdBQUtHLEdBQUwsR0FBVyxJQUFJRSw0QkFBSixDQUFjTCxJQUFkLENBQVg7QUFDRCxLQUZNLE1BRUE7QUFDTCxZQUFNLElBQUlNLEtBQUosQ0FBVSxlQUFWLENBQU47QUFDRDtBQUNGOzs7OztrSEFFd0J0QixJOzs7Ozs7O3VCQUNGLEtBQUt1QixjQUFMLENBQW9CdkIsSUFBcEIsQzs7O0FBQWZ3QixnQkFBQUEsTTs7dUJBQ2UsS0FBS0MsY0FBTCxDQUFvQkQsTUFBcEIsRUFBNEJ4QixJQUE1QixDOzs7QUFBZjBCLGdCQUFBQSxNO2tGQUNNRixNLEdBQVdFLE07Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7c0hBR0kxQixJOzs7Ozs7Ozs7Ozs7OztBQUFzQjJCLGdCQUFBQSxXLDhEQUFjLEk7O3VCQUN0QyxLQUFLUixHQUFMLENBQVNTLElBQVQsQ0FBY0MsTUFBTSxDQUFDQyxLQUFQLENBQWFILFdBQWIsQ0FBZCxFQUF5QyxDQUF6QyxFQUE0Q0EsV0FBNUMsRUFBeUQsQ0FBekQsRUFBNEQzQixJQUE1RCxDOzs7O0FBQWpCK0IsZ0JBQUFBLE0sd0JBQUFBLE07QUFDRkMsZ0JBQUFBLFcsR0FBYyxLQUFLQyxZQUFMLENBQWtCRixNQUFsQixDO0FBQ2RHLGdCQUFBQSxHLEdBQU10RCxVQUFVLENBQUNvRCxXQUFELEM7QUFDaEJSLGdCQUFBQSxNLEdBQVNVLEdBQUcsQ0FBQ25ELFlBQUosQ0FBaUJvRCxLQUFqQixDQUF1QkosTUFBdkIsRUFBK0JLLE07QUFDOUNaLGdCQUFBQSxNQUFNLENBQUNhLFFBQVAsR0FBa0JiLE1BQU0sQ0FBQ2MsS0FBUCxLQUFpQjNELGFBQWpCLEdBQWlDLFFBQWpDLEdBQTRDLFFBQTlEOztzQkFDSTZDLE1BQU0sQ0FBQ2UsUUFBUCxHQUFrQlosV0FBbEIsSUFBaUNILE1BQU0sQ0FBQ2dCLGtCQUFQLEdBQTRCYixXOzs7OztrREFDeEQsS0FBS0osY0FBTCxDQUFvQnZCLElBQXBCLEVBQTBCMkIsV0FBVyxHQUFHLENBQXhDLEM7OztBQUVULG9CQUFJSCxNQUFNLENBQUNlLFFBQVgsRUFBcUI7QUFDbkJmLGtCQUFBQSxNQUFNLENBQUNpQixPQUFQLEdBQWlCVixNQUFNLENBQ3BCVyxLQURjLENBQ1JsQixNQUFNLENBQUNlLFFBREMsRUFDU1IsTUFBTSxDQUFDWSxPQUFQLENBQWUsQ0FBZixFQUFrQm5CLE1BQU0sQ0FBQ2UsUUFBekIsQ0FEVCxFQUVkSyxRQUZjLENBRUwsTUFGSyxDQUFqQjtBQUdEOztzQkFDR3BCLE1BQU0sQ0FBQ2dCLGtCQUFQLEdBQTRCYixXOzs7OztrREFDdkIsS0FBS0osY0FBTCxDQUFvQnZCLElBQXBCLEVBQTBCMkIsV0FBVyxHQUFHLENBQXhDLEM7OztBQUVULG9CQUFJSCxNQUFNLENBQUNnQixrQkFBWCxFQUErQjtBQUN2Qkssa0JBQUFBLElBRHVCLEdBQ2hCZCxNQUFNLENBQUNXLEtBQVAsQ0FBYWxCLE1BQU0sQ0FBQ2dCLGtCQUFwQixDQURnQjtBQUU3QmhCLGtCQUFBQSxNQUFNLENBQUNzQixZQUFQLEdBQXNCWixHQUFHLENBQUN6QyxrQkFBSixDQUF1QjBDLEtBQXZCLENBQTZCVSxJQUE3QixFQUFtQ1QsTUFBekQ7QUFDRDs7a0ZBQ1daLE07QUFBUVEsa0JBQUFBLFdBQVcsRUFBWEE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7aUNBR0RELE0sRUFBeUI7QUFDNUMsVUFBSUcsR0FBRyxHQUFHSCxNQUFNLENBQUNnQixXQUFQLENBQW1CLENBQW5CLENBQVY7O0FBQ0EsVUFBSWIsR0FBRyxLQUFLeEQsYUFBUixJQUF5QndELEdBQUcsS0FBS3ZELGFBQXJDLEVBQW9EO0FBQ2xELGVBQU8sS0FBUDtBQUNEOztBQUNEdUQsTUFBQUEsR0FBRyxHQUFHSCxNQUFNLENBQUNpQixXQUFQLENBQW1CLENBQW5CLENBQU47O0FBQ0EsVUFBSWQsR0FBRyxLQUFLeEQsYUFBUixJQUF5QndELEdBQUcsS0FBS3ZELGFBQXJDLEVBQW9EO0FBQ2xELGVBQU8sSUFBUDtBQUNEOztBQUNELFlBQU0sSUFBSTJDLEtBQUosQ0FBVSwwQkFBVixDQUFOO0FBQ0QsSyxDQUVEOzs7OztzSEFDNkJFLE0sRUFBZ0J4QixJOzs7Ozs7Ozs7QUFDckNuQixnQkFBQUEsSSxHQUFPMkMsTUFBTSxDQUFDUSxXO0FBQ2RsRCxnQkFBQUEsRSxHQUFLRCxJQUFJLEdBQUcsS0FBSCxHQUFXLFE7QUFDcEJvRSxnQkFBQUEsWSxHQUFnRixFO0FBQ2hGQyxnQkFBQUEsVSxHQUF3QyxFO0FBQ3RDQyxnQkFBQUEsZSxHQUFvQjNCLE0sQ0FBcEIyQixlO0FBQ0ZDLGdCQUFBQSxrQixHQUF1QjVCLE0sQ0FBdkI0QixrQjs7QUFFTix1QkFBT0Esa0JBQWtCLEdBQUcsQ0FBckIsS0FBMkIsQ0FBbEMsRUFBcUM7QUFDbkNBLGtCQUFBQSxrQkFBa0IsSUFBSSxDQUF0QjtBQUNEOzs7dUJBRThCLEtBQUtqQyxHQUFMLENBQVNTLElBQVQsQ0FDN0JDLE1BQU0sQ0FBQ0MsS0FBUCxDQUFhc0Isa0JBQWtCLEdBQUdELGVBQWxDLENBRDZCLEVBRTdCLENBRjZCLEVBRzdCQyxrQkFBa0IsR0FBR0QsZUFIUSxFQUk3QkEsZUFKNkIsRUFLN0JuRCxJQUw2QixDOzs7O0FBQWZxRCxnQkFBQUEsSSx5QkFBUnRCLE07QUFRRnVCLGdCQUFBQSxDLEdBQUkxRSxVQUFVLENBQUNDLElBQUQsQztBQUNaMEUsZ0JBQUFBLE8sR0FBWUQsQ0FBQyxDQUFDM0QsZUFBRixDQUFrQndDLEtBQWxCLENBQXdCa0IsSUFBeEIsRUFBOEJqQixNLENBQTFDbUIsTztBQUNGQyxnQkFBQUEsYyxHQUFpQixJQUFJeEUsb0JBQUosR0FDcEJDLFNBRG9CLENBQ1ZILEVBRFUsRUFFcEIyRSxNQUZvQixDQUViLEtBRmEsRUFFTjtBQUFFQyxrQkFBQUEsU0FBUyxFQUFFLElBQWI7QUFBbUJuRSxrQkFBQUEsTUFBTSxFQUFFZ0U7QUFBM0IsaUJBRk0sRUFHcEJsRSxNQUhvQixDQUdiLE9BSGEsRUFJcEJBLE1BSm9CLENBSWIsU0FKYSxDO0FBS2pCc0UsZ0JBQUFBLGlCLEdBQW9CLElBQUkzRSxvQkFBSixHQUN2QkMsU0FEdUIsQ0FDYkgsRUFEYSxFQUV2QmdCLElBRnVCLENBRWxCeUQsT0FGa0IsRUFHdkJuRSxNQUh1QixDQUdoQixhQUhnQixDO0FBSXBCd0UsZ0JBQUFBLGMsR0FBaUIsRTs7QUFDakJDLGdCQUFBQSxXO3FHQUFjLGtCQUFPQyxhQUFQO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDZEMsNEJBQUFBLE1BRGMsR0FDTEQsYUFESzs7QUFBQSxrQ0FFZEMsTUFBTSxJQUFJVixJQUFJLENBQUM5RCxNQUZEO0FBQUE7QUFBQTtBQUFBOztBQUFBLGtDQUVlLElBQUkrQixLQUFKLENBQVUsOEJBQVYsQ0FGZjs7QUFBQTtBQUdaWSw0QkFBQUEsR0FIWSxHQUdOb0IsQ0FBQyxDQUFDMUQsVUFBRixDQUFhdUMsS0FBYixDQUFtQmtCLElBQUksQ0FBQ1gsS0FBTCxDQUFXcUIsTUFBWCxDQUFuQixDQUhNO0FBQUEsMENBSVU3QixHQUFHLENBQUNFLE1BSmQsRUFJVnhDLFVBSlUsZUFJVkEsVUFKVSxFQUlFb0UsR0FKRixlQUlFQSxHQUpGO0FBS2xCRCw0QkFBQUEsTUFBTSxJQUFJN0IsR0FBRyxDQUFDNkIsTUFBZDs7QUFMa0IsaUNBTWRuRSxVQU5jO0FBQUE7QUFBQTtBQUFBOztBQU9oQixpQ0FBU3FFLENBQVQsR0FBYSxDQUFiLEVBQWdCQSxDQUFDLEdBQUdELEdBQXBCLEVBQXlCQyxDQUFDLElBQUksQ0FBOUIsRUFBaUM7QUFDekJDLDhCQUFBQSxPQUR5QixHQUNmVixjQUFjLENBQUNyQixLQUFmLENBQXFCa0IsSUFBSSxDQUFDWCxLQUFMLENBQVdxQixNQUFYLENBQXJCLENBRGU7QUFFL0JBLDhCQUFBQSxNQUFNLElBQUlHLE9BQU8sQ0FBQ0gsTUFBbEI7QUFGK0IsZ0RBR0NHLE9BQU8sQ0FBQzlCLE1BSFQsRUFHdkIrQixJQUh1QixtQkFHdkJBLEdBSHVCLEVBR2xCQyxLQUhrQixtQkFHbEJBLEtBSGtCLEVBR1hDLE9BSFcsbUJBR1hBLE9BSFc7QUFJekJDLDhCQUFBQSxNQUp5QixHQUloQjtBQUFFQyxnQ0FBQUEsSUFBSSxFQUFFSixJQUFSO0FBQWFLLGdDQUFBQSxFQUFFLEVBQUVKLEtBQWpCO0FBQXdCN0UsZ0NBQUFBLE1BQU0sRUFBRThFO0FBQWhDLCtCQUpnQjtBQUsvQm5CLDhCQUFBQSxVQUFVLENBQUMsTUFBSSxDQUFDbkMsYUFBTCxDQUFtQm9ELElBQW5CLENBQUQsQ0FBVixHQUFzQ0MsS0FBdEM7QUFDQW5CLDhCQUFBQSxZQUFZLENBQUNtQixLQUFELENBQVosR0FBc0JFLE1BQXRCO0FBQ0Q7O0FBZGU7QUFBQTs7QUFBQTtBQWdCaEI7QUFDTUcsNEJBQUFBLFNBakJVLEdBaUJFLEVBakJGOztBQWtCaEIsaUNBQVNSLEVBQVQsR0FBYSxDQUFiLEVBQWdCQSxFQUFDLEdBQUdELEdBQXBCLEVBQXlCQyxFQUFDLElBQUksQ0FBOUIsRUFBaUM7QUFDekJTLDhCQUFBQSxVQUR5QixHQUNaZixpQkFBaUIsQ0FBQ3hCLEtBQWxCLENBQXdCa0IsSUFBSSxDQUFDWCxLQUFMLENBQVdxQixNQUFYLENBQXhCLENBRFk7QUFFekJZLDhCQUFBQSxXQUZ5QixHQUVURCxVQUFVLENBQUN0QyxNQUZGLENBRXpCdUMsV0FGeUI7QUFHL0JaLDhCQUFBQSxNQUFNLElBQUlXLFVBQVUsQ0FBQ1gsTUFBckI7QUFDQVksOEJBQUFBLFdBQVcsSUFBSXhCLGVBQWY7QUFDQXNCLDhCQUFBQSxTQUFTLENBQUNHLElBQVYsQ0FBZWYsV0FBVyxDQUFDYyxXQUFELENBQTFCO0FBQ0Q7O0FBeEJlO0FBQUEsbUNBeUJWRSxPQUFPLENBQUNDLEdBQVIsQ0FBWUwsU0FBWixDQXpCVTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxtQjs7a0NBQWRaLFc7Ozs7Ozt1QkE0QkFBLFdBQVcsQ0FBQ0QsY0FBRCxDOzs7a0RBQ1Y7QUFDTFYsa0JBQUFBLFVBQVUsRUFBVkEsVUFESztBQUVMRCxrQkFBQUEsWUFBWSxFQUFaQTtBQUZLLGlCOzs7Ozs7Ozs7Ozs7Ozs7O0FBTVQ7Ozs7Ozs7O3VIQUlnQ2pELEk7Ozs7Ozs7O3VCQVFwQixLQUFLK0UsU0FBTCxDQUFlL0UsSUFBZixDOzs7O0FBTlJnRixnQkFBQUEsbUIseUJBQUFBLG1CO0FBQ0FDLGdCQUFBQSxVLHlCQUFBQSxVO0FBQ0EvQixnQkFBQUEsVSx5QkFBQUEsVTtBQUNBZ0MsZ0JBQUFBLGlCLHlCQUFBQSxpQjtBQUNBbEQsZ0JBQUFBLFcseUJBQUFBLFc7QUFDQUssZ0JBQUFBLFEseUJBQUFBLFE7QUFFSThDLGdCQUFBQSxHLEdBQU1GLFVBQVUsQ0FBQyxDQUFELEM7QUFDaEJHLGdCQUFBQSxNLEdBQVNELEdBQUcsR0FBR0EsR0FBRyxDQUFDRSxVQUFKLEdBQWlCTCxtQkFBcEIsR0FBMEMsSTtrREFDckQsSUFBSU0sb0JBQUosQ0FDTCxLQUFLbkUsR0FEQSxFQUVMK0IsVUFGSyxFQUdMOEIsbUJBSEssRUFJTEksTUFKSyxFQUtMcEQsV0FMSyxFQU1Ma0QsaUJBQWlCLEdBQUcsQ0FOZixFQU9MN0MsUUFQSyxDOzs7Ozs7Ozs7Ozs7Ozs7O0FBV1Q7Ozs7Ozs7QUFLQTs7Ozs7Ozs7O3dIQVNFa0QsTyxFQUNBQyxLLEVBQ0FDLEc7Ozs7Ozs7OztBQUNBekYsZ0JBQUFBLEksOERBQW1FO0FBQUUwRixrQkFBQUEsS0FBSyxFQUFFO0FBQVQsaUI7O3VCQUU3RCxLQUFLWCxTQUFMLENBQWUvRSxJQUFmLEM7OztBQUNBMkYsZ0JBQUFBLE8sR0FBVSxLQUFLNUUsYUFBTCxDQUFtQndFLE9BQW5CLEM7O3FCQUdadkYsSUFBSSxDQUFDNEYsWTs7Ozs7O3VCQUNNLEtBQUtDLE9BQUwsQ0FBYSxJQUFJN0YsSUFBSSxDQUFDNEYsWUFBdEIsRUFBb0M1RixJQUFwQyxDOzs7QUFBYjhGLGdCQUFBQSxJOzs7OztxQkFDUzlGLElBQUksQ0FBQzBGLEs7Ozs7Ozt1QkFDRCxLQUFLRyxPQUFMLENBQWE3RixJQUFJLENBQUMwRixLQUFsQixFQUF5QjFGLElBQXpCLEM7OztBQUFiOEYsZ0JBQUFBLEk7Ozs7Ozt1QkFFYSxLQUFLRCxPQUFMLENBQWEsQ0FBYixFQUFnQjdGLElBQWhCLEM7OztBQUFiOEYsZ0JBQUFBLEk7OztvQkFHR0EsSTs7Ozs7c0JBQ0csSUFBSXhFLEtBQUosQ0FBVSxtQ0FBVixDOzs7a0RBRUQsSUFBSXlFLGdCQUFKLENBQWUsVUFBQ0MsUUFBRCxFQUF5QztBQUM3REYsa0JBQUFBLElBQUksQ0FBQ0csV0FBTCxDQUFpQk4sT0FBakIsRUFBMEJILEtBQTFCLEVBQWlDQyxHQUFqQyxFQUFzQ08sUUFBdEMsRUFBZ0RoRyxJQUFoRDtBQUNELGlCQUZNLEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7bUhBTVB1RixPLEVBQ0FDLEssRUFDQUMsRzs7Ozs7Ozs7O0FBQ0F6RixnQkFBQUEsSSw4REFBbUU7QUFBRTBGLGtCQUFBQSxLQUFLLEVBQUU7QUFBVCxpQjs7dUJBRWxELEtBQUtRLGdCQUFMLENBQXNCWCxPQUF0QixFQUErQkMsS0FBL0IsRUFBc0NDLEdBQXRDLEVBQTJDekYsSUFBM0MsQzs7O0FBQVhtRyxnQkFBQUEsRTs7dUJBRVlBLEVBQUUsQ0FBQ0MsSUFBSCxDQUFRLHVCQUFPLFVBQUNDLEdBQUQsRUFBTUMsSUFBTjtBQUFBLHlCQUFlRCxHQUFHLENBQUNFLE1BQUosQ0FBV0QsSUFBWCxDQUFmO0FBQUEsaUJBQVAsQ0FBUixFQUFpREUsU0FBakQsRTs7O0FBQVp0RSxnQkFBQUEsRztrREFDQ0EsR0FBRyxJQUFJLEUiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQYXJzZXIgfSBmcm9tICdAZ21vZC9iaW5hcnktcGFyc2VyJ1xuaW1wb3J0IHsgTG9jYWxGaWxlLCBSZW1vdGVGaWxlLCBHZW5lcmljRmlsZWhhbmRsZSB9IGZyb20gJ2dlbmVyaWMtZmlsZWhhbmRsZSdcbmltcG9ydCB7IE9ic2VydmFibGUsIE9ic2VydmVyIH0gZnJvbSAncnhqcydcbmltcG9ydCB7IHJlZHVjZSB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJ1xuaW1wb3J0IEFib3J0YWJsZVByb21pc2VDYWNoZSBmcm9tICdhYm9ydGFibGUtcHJvbWlzZS1jYWNoZSdcbmltcG9ydCBRdWlja0xSVSBmcm9tICdxdWljay1scnUnXG5pbXBvcnQgeyBCbG9ja1ZpZXcgfSBmcm9tICcuL2Jsb2NrVmlldydcblxuY29uc3QgQklHX1dJR19NQUdJQyA9IC0yMDAzODI5NzIyXG5jb25zdCBCSUdfQkVEX01BR0lDID0gLTIwMjEwMDI1MTdcblxuZXhwb3J0IGludGVyZmFjZSBGZWF0dXJlIHtcbiAgc3RhcnQ6IG51bWJlclxuICBlbmQ6IG51bWJlclxuICBzY29yZTogbnVtYmVyXG4gIHJlc3Q/OiBzdHJpbmcgLy8gZm9yIGJpZ2JlZCBsaW5lXG4gIG1pblNjb3JlPzogbnVtYmVyIC8vIGZvciBzdW1tYXJ5IGxpbmVcbiAgbWF4U2NvcmU/OiBudW1iZXIgLy8gZm9yIHN1bW1hcnkgbGluZVxuICBzdW1tYXJ5PzogYm9vbGVhbiAvLyBpcyBzdW1tYXJ5IGxpbmVcbiAgdW5pcXVlSWQ/OiBzdHJpbmcgLy8gZm9yIGJpZ2JlZCBjb250YWlucyB1bmlxdWVJZCBjYWxjdWxhdGVkIGZyb20gZmlsZSBvZmZzZXRcbiAgZmllbGQ/OiBudW1iZXIgLy8gdXNlZCBpbiBiaWdiZWQgc2VhcmNoaW5nXG59XG5pbnRlcmZhY2UgU3RhdGlzdGljcyB7XG4gIHNjb3JlU3VtOiBudW1iZXJcbiAgYmFzZXNDb3ZlcmVkOiBudW1iZXJcbiAgc2NvcmVTdW1TcXVhcmVzOiBudW1iZXJcbn1cblxuaW50ZXJmYWNlIFJlZkluZm8ge1xuICBuYW1lOiBzdHJpbmdcbiAgaWQ6IG51bWJlclxuICBsZW5ndGg6IG51bWJlclxufVxuZXhwb3J0IGludGVyZmFjZSBIZWFkZXIge1xuICBhdXRvU3FsOiBzdHJpbmdcbiAgdG90YWxTdW1tYXJ5OiBTdGF0aXN0aWNzXG4gIHpvb21MZXZlbHM6IGFueVxuICB1bnpvb21lZEluZGV4T2Zmc2V0OiBudW1iZXJcbiAgdW56b29tZWREYXRhT2Zmc2V0OiBudW1iZXJcbiAgZGVmaW5lZEZpZWxkQ291bnQ6IG51bWJlclxuICB1bmNvbXByZXNzQnVmU2l6ZTogbnVtYmVyXG4gIGNocm9tVHJlZU9mZnNldDogbnVtYmVyXG4gIGZpbGVTaXplOiBudW1iZXJcbiAgZXh0SGVhZGVyT2Zmc2V0OiBudW1iZXJcbiAgaXNCaWdFbmRpYW46IGJvb2xlYW5cbiAgZmlsZVR5cGU6IHN0cmluZ1xuICByZWZzQnlOYW1lOiB7IFtrZXk6IHN0cmluZ106IG51bWJlciB9XG4gIHJlZnNCeU51bWJlcjogeyBba2V5OiBudW1iZXJdOiBSZWZJbmZvIH1cbn1cblxuLyogZ2V0IHRoZSBjb21waWxlZCBwYXJzZXJzIGZvciBkaWZmZXJlbnQgc2VjdGlvbnMgb2YgdGhlIGJpZ3dpZyBmaWxlXG4gKlxuICogQHBhcmFtIGlzQkUgLSBpcyBiaWcgZW5kaWFuLCB0eXBpY2FsbHkgZmFsc2VcbiAqIEByZXR1cm4gYW4gb2JqZWN0IHdpdGggY29tcGlsZWQgcGFyc2Vyc1xuICovXG5mdW5jdGlvbiBnZXRQYXJzZXJzKGlzQkU6IGJvb2xlYW4pOiBhbnkge1xuICBjb25zdCBsZSA9IGlzQkUgPyAnYmlnJyA6ICdsaXR0bGUnXG4gIGNvbnN0IGhlYWRlclBhcnNlciA9IG5ldyBQYXJzZXIoKVxuICAgIC5lbmRpYW5lc3MobGUpXG4gICAgLmludDMyKCdtYWdpYycpXG4gICAgLnVpbnQxNigndmVyc2lvbicpXG4gICAgLnVpbnQxNignbnVtWm9vbUxldmVscycpXG4gICAgLnVpbnQ2NCgnY2hyb21UcmVlT2Zmc2V0JylcbiAgICAudWludDY0KCd1bnpvb21lZERhdGFPZmZzZXQnKVxuICAgIC51aW50NjQoJ3Vuem9vbWVkSW5kZXhPZmZzZXQnKVxuICAgIC51aW50MTYoJ2ZpZWxkQ291bnQnKVxuICAgIC51aW50MTYoJ2RlZmluZWRGaWVsZENvdW50JylcbiAgICAudWludDY0KCdhc09mZnNldCcpIC8vIGF1dG9TcWwgb2Zmc2V0LCB1c2VkIGluIGJpZ2JlZFxuICAgIC51aW50NjQoJ3RvdGFsU3VtbWFyeU9mZnNldCcpXG4gICAgLnVpbnQzMigndW5jb21wcmVzc0J1ZlNpemUnKVxuICAgIC51aW50NjQoJ2V4dEhlYWRlck9mZnNldCcpIC8vIG5hbWUgaW5kZXggb2Zmc2V0LCB1c2VkIGluIGJpZ2JlZFxuICAgIC5hcnJheSgnem9vbUxldmVscycsIHtcbiAgICAgIGxlbmd0aDogJ251bVpvb21MZXZlbHMnLFxuICAgICAgdHlwZTogbmV3IFBhcnNlcigpXG4gICAgICAgIC51aW50MzIoJ3JlZHVjdGlvbkxldmVsJylcbiAgICAgICAgLnVpbnQzMigncmVzZXJ2ZWQnKVxuICAgICAgICAudWludDY0KCdkYXRhT2Zmc2V0JylcbiAgICAgICAgLnVpbnQ2NCgnaW5kZXhPZmZzZXQnKSxcbiAgICB9KVxuXG4gIGNvbnN0IHRvdGFsU3VtbWFyeVBhcnNlciA9IG5ldyBQYXJzZXIoKVxuICAgIC5lbmRpYW5lc3MobGUpXG4gICAgLnVpbnQ2NCgnYmFzZXNDb3ZlcmVkJylcbiAgICAuZG91YmxlKCdzY29yZU1pbicpXG4gICAgLmRvdWJsZSgnc2NvcmVNYXgnKVxuICAgIC5kb3VibGUoJ3Njb3JlU3VtJylcbiAgICAuZG91YmxlKCdzY29yZVN1bVNxdWFyZXMnKVxuXG4gIGNvbnN0IGNocm9tVHJlZVBhcnNlciA9IG5ldyBQYXJzZXIoKVxuICAgIC5lbmRpYW5lc3MobGUpXG4gICAgLnVpbnQzMignbWFnaWMnKVxuICAgIC51aW50MzIoJ2Jsb2NrU2l6ZScpXG4gICAgLnVpbnQzMigna2V5U2l6ZScpXG4gICAgLnVpbnQzMigndmFsU2l6ZScpXG4gICAgLnVpbnQ2NCgnaXRlbUNvdW50JylcblxuICBjb25zdCBpc0xlYWZOb2RlID0gbmV3IFBhcnNlcigpXG4gICAgLmVuZGlhbmVzcyhsZSlcbiAgICAudWludDgoJ2lzTGVhZk5vZGUnKVxuICAgIC5za2lwKDEpXG4gICAgLnVpbnQxNignY250JylcblxuICByZXR1cm4ge1xuICAgIGNocm9tVHJlZVBhcnNlcixcbiAgICB0b3RhbFN1bW1hcnlQYXJzZXIsXG4gICAgaGVhZGVyUGFyc2VyLFxuICAgIGlzTGVhZk5vZGUsXG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBSZXF1ZXN0T3B0aW9ucyB7XG4gIHNpZ25hbD86IEFib3J0U2lnbmFsXG4gIGhlYWRlcnM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+XG4gIFtrZXk6IHN0cmluZ106IHVua25vd25cbn1cblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEJCSSB7XG4gIHByb3RlY3RlZCBiYmk6IEdlbmVyaWNGaWxlaGFuZGxlXG5cbiAgcHJvdGVjdGVkIGhlYWRlckNhY2hlID0gbmV3IEFib3J0YWJsZVByb21pc2VDYWNoZSh7XG4gICAgY2FjaGU6IG5ldyBRdWlja0xSVSh7IG1heFNpemU6IDEgfSksXG4gICAgZmlsbDogYXN5bmMgKHBhcmFtczogYW55LCBzaWduYWw/OiBBYm9ydFNpZ25hbCkgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldEhlYWRlcih7IC4uLnBhcmFtcywgc2lnbmFsIH0pXG4gICAgfSxcbiAgfSlcblxuICBwcm90ZWN0ZWQgcmVuYW1lUmVmU2VxczogKGE6IHN0cmluZykgPT4gc3RyaW5nXG5cbiAgLyogZmV0Y2ggYW5kIHBhcnNlIGhlYWRlciBpbmZvcm1hdGlvbiBmcm9tIGEgYmlnd2lnIG9yIGJpZ2JlZCBmaWxlXG4gICAqIEBwYXJhbSBhYm9ydFNpZ25hbCAtIGFib3J0IHRoZSBvcGVyYXRpb24sIGNhbiBiZSBudWxsXG4gICAqIEByZXR1cm4gYSBIZWFkZXIgb2JqZWN0XG4gICAqL1xuICBwdWJsaWMgZ2V0SGVhZGVyKG9wdHM6IFJlcXVlc3RPcHRpb25zIHwgQWJvcnRTaWduYWwgPSB7fSkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSAnYWJvcnRlZCcgaW4gb3B0cyA/IHsgc2lnbmFsOiBvcHRzIH0gOiBvcHRzXG4gICAgcmV0dXJuIHRoaXMuaGVhZGVyQ2FjaGUuZ2V0KEpTT04uc3RyaW5naWZ5KG9wdGlvbnMpLCBvcHRpb25zLCBvcHRpb25zLnNpZ25hbClcbiAgfVxuXG4gIC8qXG4gICAqIEBwYXJhbSBmaWxlaGFuZGxlIC0gYSBmaWxlaGFuZGxlIGZyb20gZ2VuZXJpYy1maWxlaGFuZGxlIG9yIGltcGxlbWVudGluZyBzb21ldGhpbmcgc2ltaWxhciB0byB0aGUgbm9kZTEwIGZzLnByb21pc2VzIEFQSVxuICAgKiBAcGFyYW0gcGF0aCAtIGEgTG9jYWwgZmlsZSBwYXRoIGFzIGEgc3RyaW5nXG4gICAqIEBwYXJhbSB1cmwgLSBhIFVSTCBzdHJpbmdcbiAgICogQHBhcmFtIHJlbmFtZVJlZlNlcXMgLSBhbiBvcHRpb25hbCBtZXRob2QgdG8gcmVuYW1lIHRoZSBpbnRlcm5hbCByZWZlcmVuY2Ugc2VxdWVuY2VzIHVzaW5nIGEgbWFwcGluZyBmdW5jdGlvblxuICAgKi9cbiAgcHVibGljIGNvbnN0cnVjdG9yKFxuICAgIG9wdGlvbnM6IHtcbiAgICAgIGZpbGVoYW5kbGU/OiBHZW5lcmljRmlsZWhhbmRsZVxuICAgICAgcGF0aD86IHN0cmluZ1xuICAgICAgdXJsPzogc3RyaW5nXG4gICAgICByZW5hbWVSZWZTZXFzPzogKGE6IHN0cmluZykgPT4gc3RyaW5nXG4gICAgfSA9IHt9LFxuICApIHtcbiAgICBjb25zdCB7IGZpbGVoYW5kbGUsIHJlbmFtZVJlZlNlcXMsIHBhdGgsIHVybCB9ID0gb3B0aW9uc1xuICAgIHRoaXMucmVuYW1lUmVmU2VxcyA9IHJlbmFtZVJlZlNlcXMgfHwgKChzOiBzdHJpbmcpOiBzdHJpbmcgPT4gcylcbiAgICBpZiAoZmlsZWhhbmRsZSkge1xuICAgICAgdGhpcy5iYmkgPSBmaWxlaGFuZGxlXG4gICAgfSBlbHNlIGlmICh1cmwpIHtcbiAgICAgIHRoaXMuYmJpID0gbmV3IFJlbW90ZUZpbGUodXJsKVxuICAgIH0gZWxzZSBpZiAocGF0aCkge1xuICAgICAgdGhpcy5iYmkgPSBuZXcgTG9jYWxGaWxlKHBhdGgpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbm8gZmlsZSBnaXZlbicpXG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBfZ2V0SGVhZGVyKG9wdHM6IFJlcXVlc3RPcHRpb25zKSB7XG4gICAgY29uc3QgaGVhZGVyID0gYXdhaXQgdGhpcy5fZ2V0TWFpbkhlYWRlcihvcHRzKVxuICAgIGNvbnN0IGNocm9tcyA9IGF3YWl0IHRoaXMuX3JlYWRDaHJvbVRyZWUoaGVhZGVyLCBvcHRzKVxuICAgIHJldHVybiB7IC4uLmhlYWRlciwgLi4uY2hyb21zIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgX2dldE1haW5IZWFkZXIob3B0czogUmVxdWVzdE9wdGlvbnMsIHJlcXVlc3RTaXplID0gMjAwMCk6IFByb21pc2U8SGVhZGVyPiB7XG4gICAgY29uc3QgeyBidWZmZXIgfSA9IGF3YWl0IHRoaXMuYmJpLnJlYWQoQnVmZmVyLmFsbG9jKHJlcXVlc3RTaXplKSwgMCwgcmVxdWVzdFNpemUsIDAsIG9wdHMpXG4gICAgY29uc3QgaXNCaWdFbmRpYW4gPSB0aGlzLl9pc0JpZ0VuZGlhbihidWZmZXIpXG4gICAgY29uc3QgcmV0ID0gZ2V0UGFyc2Vycyhpc0JpZ0VuZGlhbilcbiAgICBjb25zdCBoZWFkZXIgPSByZXQuaGVhZGVyUGFyc2VyLnBhcnNlKGJ1ZmZlcikucmVzdWx0XG4gICAgaGVhZGVyLmZpbGVUeXBlID0gaGVhZGVyLm1hZ2ljID09PSBCSUdfQkVEX01BR0lDID8gJ2JpZ2JlZCcgOiAnYmlnd2lnJ1xuICAgIGlmIChoZWFkZXIuYXNPZmZzZXQgPiByZXF1ZXN0U2l6ZSB8fCBoZWFkZXIudG90YWxTdW1tYXJ5T2Zmc2V0ID4gcmVxdWVzdFNpemUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXRNYWluSGVhZGVyKG9wdHMsIHJlcXVlc3RTaXplICogMilcbiAgICB9XG4gICAgaWYgKGhlYWRlci5hc09mZnNldCkge1xuICAgICAgaGVhZGVyLmF1dG9TcWwgPSBidWZmZXJcbiAgICAgICAgLnNsaWNlKGhlYWRlci5hc09mZnNldCwgYnVmZmVyLmluZGV4T2YoMCwgaGVhZGVyLmFzT2Zmc2V0KSlcbiAgICAgICAgLnRvU3RyaW5nKCd1dGY4JylcbiAgICB9XG4gICAgaWYgKGhlYWRlci50b3RhbFN1bW1hcnlPZmZzZXQgPiByZXF1ZXN0U2l6ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldE1haW5IZWFkZXIob3B0cywgcmVxdWVzdFNpemUgKiAyKVxuICAgIH1cbiAgICBpZiAoaGVhZGVyLnRvdGFsU3VtbWFyeU9mZnNldCkge1xuICAgICAgY29uc3QgdGFpbCA9IGJ1ZmZlci5zbGljZShoZWFkZXIudG90YWxTdW1tYXJ5T2Zmc2V0KVxuICAgICAgaGVhZGVyLnRvdGFsU3VtbWFyeSA9IHJldC50b3RhbFN1bW1hcnlQYXJzZXIucGFyc2UodGFpbCkucmVzdWx0XG4gICAgfVxuICAgIHJldHVybiB7IC4uLmhlYWRlciwgaXNCaWdFbmRpYW4gfVxuICB9XG5cbiAgcHJpdmF0ZSBfaXNCaWdFbmRpYW4oYnVmZmVyOiBCdWZmZXIpOiBib29sZWFuIHtcbiAgICBsZXQgcmV0ID0gYnVmZmVyLnJlYWRJbnQzMkxFKDApXG4gICAgaWYgKHJldCA9PT0gQklHX1dJR19NQUdJQyB8fCByZXQgPT09IEJJR19CRURfTUFHSUMpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICByZXQgPSBidWZmZXIucmVhZEludDMyQkUoMClcbiAgICBpZiAocmV0ID09PSBCSUdfV0lHX01BR0lDIHx8IHJldCA9PT0gQklHX0JFRF9NQUdJQykge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdub3QgYSBCaWdXaWcvQmlnQmVkIGZpbGUnKVxuICB9XG5cbiAgLy8gdG9kbzogYWRkIHByb2dyZXNzIGlmIGxvbmcgcnVubmluZ1xuICBwcml2YXRlIGFzeW5jIF9yZWFkQ2hyb21UcmVlKGhlYWRlcjogSGVhZGVyLCBvcHRzOiB7IHNpZ25hbD86IEFib3J0U2lnbmFsIH0pIHtcbiAgICBjb25zdCBpc0JFID0gaGVhZGVyLmlzQmlnRW5kaWFuXG4gICAgY29uc3QgbGUgPSBpc0JFID8gJ2JpZycgOiAnbGl0dGxlJ1xuICAgIGNvbnN0IHJlZnNCeU51bWJlcjogeyBba2V5OiBudW1iZXJdOiB7IG5hbWU6IHN0cmluZzsgaWQ6IG51bWJlcjsgbGVuZ3RoOiBudW1iZXIgfSB9ID0gW11cbiAgICBjb25zdCByZWZzQnlOYW1lOiB7IFtrZXk6IHN0cmluZ106IG51bWJlciB9ID0ge31cbiAgICBjb25zdCB7IGNocm9tVHJlZU9mZnNldCB9ID0gaGVhZGVyXG4gICAgbGV0IHsgdW56b29tZWREYXRhT2Zmc2V0IH0gPSBoZWFkZXJcblxuICAgIHdoaWxlICh1bnpvb21lZERhdGFPZmZzZXQgJSA0ICE9PSAwKSB7XG4gICAgICB1bnpvb21lZERhdGFPZmZzZXQgKz0gMVxuICAgIH1cblxuICAgIGNvbnN0IHsgYnVmZmVyOiBkYXRhIH0gPSBhd2FpdCB0aGlzLmJiaS5yZWFkKFxuICAgICAgQnVmZmVyLmFsbG9jKHVuem9vbWVkRGF0YU9mZnNldCAtIGNocm9tVHJlZU9mZnNldCksXG4gICAgICAwLFxuICAgICAgdW56b29tZWREYXRhT2Zmc2V0IC0gY2hyb21UcmVlT2Zmc2V0LFxuICAgICAgY2hyb21UcmVlT2Zmc2V0LFxuICAgICAgb3B0cyxcbiAgICApXG5cbiAgICBjb25zdCBwID0gZ2V0UGFyc2Vycyhpc0JFKVxuICAgIGNvbnN0IHsga2V5U2l6ZSB9ID0gcC5jaHJvbVRyZWVQYXJzZXIucGFyc2UoZGF0YSkucmVzdWx0XG4gICAgY29uc3QgbGVhZk5vZGVQYXJzZXIgPSBuZXcgUGFyc2VyKClcbiAgICAgIC5lbmRpYW5lc3MobGUpXG4gICAgICAuc3RyaW5nKCdrZXknLCB7IHN0cmlwTnVsbDogdHJ1ZSwgbGVuZ3RoOiBrZXlTaXplIH0pXG4gICAgICAudWludDMyKCdyZWZJZCcpXG4gICAgICAudWludDMyKCdyZWZTaXplJylcbiAgICBjb25zdCBub25sZWFmTm9kZVBhcnNlciA9IG5ldyBQYXJzZXIoKVxuICAgICAgLmVuZGlhbmVzcyhsZSlcbiAgICAgIC5za2lwKGtleVNpemUpXG4gICAgICAudWludDY0KCdjaGlsZE9mZnNldCcpXG4gICAgY29uc3Qgcm9vdE5vZGVPZmZzZXQgPSAzMlxuICAgIGNvbnN0IGJwdFJlYWROb2RlID0gYXN5bmMgKGN1cnJlbnRPZmZzZXQ6IG51bWJlcik6IFByb21pc2U8dm9pZD4gPT4ge1xuICAgICAgbGV0IG9mZnNldCA9IGN1cnJlbnRPZmZzZXRcbiAgICAgIGlmIChvZmZzZXQgPj0gZGF0YS5sZW5ndGgpIHRocm93IG5ldyBFcnJvcigncmVhZGluZyBiZXlvbmQgZW5kIG9mIGJ1ZmZlcicpXG4gICAgICBjb25zdCByZXQgPSBwLmlzTGVhZk5vZGUucGFyc2UoZGF0YS5zbGljZShvZmZzZXQpKVxuICAgICAgY29uc3QgeyBpc0xlYWZOb2RlLCBjbnQgfSA9IHJldC5yZXN1bHRcbiAgICAgIG9mZnNldCArPSByZXQub2Zmc2V0XG4gICAgICBpZiAoaXNMZWFmTm9kZSkge1xuICAgICAgICBmb3IgKGxldCBuID0gMDsgbiA8IGNudDsgbiArPSAxKSB7XG4gICAgICAgICAgY29uc3QgbGVhZlJldCA9IGxlYWZOb2RlUGFyc2VyLnBhcnNlKGRhdGEuc2xpY2Uob2Zmc2V0KSlcbiAgICAgICAgICBvZmZzZXQgKz0gbGVhZlJldC5vZmZzZXRcbiAgICAgICAgICBjb25zdCB7IGtleSwgcmVmSWQsIHJlZlNpemUgfSA9IGxlYWZSZXQucmVzdWx0XG4gICAgICAgICAgY29uc3QgcmVmUmVjID0geyBuYW1lOiBrZXksIGlkOiByZWZJZCwgbGVuZ3RoOiByZWZTaXplIH1cbiAgICAgICAgICByZWZzQnlOYW1lW3RoaXMucmVuYW1lUmVmU2VxcyhrZXkpXSA9IHJlZklkXG4gICAgICAgICAgcmVmc0J5TnVtYmVyW3JlZklkXSA9IHJlZlJlY1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBwYXJzZSBpbmRleCBub2RlXG4gICAgICAgIGNvbnN0IG5leHROb2RlcyA9IFtdXG4gICAgICAgIGZvciAobGV0IG4gPSAwOyBuIDwgY250OyBuICs9IDEpIHtcbiAgICAgICAgICBjb25zdCBub25sZWFmUmV0ID0gbm9ubGVhZk5vZGVQYXJzZXIucGFyc2UoZGF0YS5zbGljZShvZmZzZXQpKVxuICAgICAgICAgIGxldCB7IGNoaWxkT2Zmc2V0IH0gPSBub25sZWFmUmV0LnJlc3VsdFxuICAgICAgICAgIG9mZnNldCArPSBub25sZWFmUmV0Lm9mZnNldFxuICAgICAgICAgIGNoaWxkT2Zmc2V0IC09IGNocm9tVHJlZU9mZnNldFxuICAgICAgICAgIG5leHROb2Rlcy5wdXNoKGJwdFJlYWROb2RlKGNoaWxkT2Zmc2V0KSlcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChuZXh0Tm9kZXMpXG4gICAgICB9XG4gICAgfVxuICAgIGF3YWl0IGJwdFJlYWROb2RlKHJvb3ROb2RlT2Zmc2V0KVxuICAgIHJldHVybiB7XG4gICAgICByZWZzQnlOYW1lLFxuICAgICAgcmVmc0J5TnVtYmVyLFxuICAgIH1cbiAgfVxuXG4gIC8qXG4gICAqIGZldGNoZXMgdGhlIFwidW56b29tZWRcIiB2aWV3IG9mIHRoZSBiaWd3aWcgZGF0YS4gdGhpcyBpcyB0aGUgZGVmYXVsdCBmb3IgYmlnYmVkXG4gICAqIEBwYXJhbSBhYm9ydFNpZ25hbCAtIGEgc2lnbmFsIHRvIG9wdGlvbmFsbHkgYWJvcnQgdGhpcyBvcGVyYXRpb25cbiAgICovXG4gIHByb3RlY3RlZCBhc3luYyBnZXRVbnpvb21lZFZpZXcob3B0czogUmVxdWVzdE9wdGlvbnMpOiBQcm9taXNlPEJsb2NrVmlldz4ge1xuICAgIGNvbnN0IHtcbiAgICAgIHVuem9vbWVkSW5kZXhPZmZzZXQsXG4gICAgICB6b29tTGV2ZWxzLFxuICAgICAgcmVmc0J5TmFtZSxcbiAgICAgIHVuY29tcHJlc3NCdWZTaXplLFxuICAgICAgaXNCaWdFbmRpYW4sXG4gICAgICBmaWxlVHlwZSxcbiAgICB9ID0gYXdhaXQgdGhpcy5nZXRIZWFkZXIob3B0cylcbiAgICBjb25zdCBuemwgPSB6b29tTGV2ZWxzWzBdXG4gICAgY29uc3QgY2lyTGVuID0gbnpsID8gbnpsLmRhdGFPZmZzZXQgLSB1bnpvb21lZEluZGV4T2Zmc2V0IDogNDAwMFxuICAgIHJldHVybiBuZXcgQmxvY2tWaWV3KFxuICAgICAgdGhpcy5iYmksXG4gICAgICByZWZzQnlOYW1lLFxuICAgICAgdW56b29tZWRJbmRleE9mZnNldCxcbiAgICAgIGNpckxlbixcbiAgICAgIGlzQmlnRW5kaWFuLFxuICAgICAgdW5jb21wcmVzc0J1ZlNpemUgPiAwLFxuICAgICAgZmlsZVR5cGUsXG4gICAgKVxuICB9XG5cbiAgLypcbiAgICogYWJzdHJhY3QgbWV0aG9kIC0gZ2V0IHRoZSB2aWV3IGZvciBhIGdpdmVuIHNjYWxlXG4gICAqL1xuICBwcm90ZWN0ZWQgYWJzdHJhY3QgYXN5bmMgZ2V0VmlldyhzY2FsZTogbnVtYmVyLCBvcHRzOiBSZXF1ZXN0T3B0aW9ucyk6IFByb21pc2U8QmxvY2tWaWV3PlxuXG4gIC8qKlxuICAgKiBHZXRzIGZlYXR1cmVzIGZyb20gYSBCaWdXaWcgZmlsZVxuICAgKlxuICAgKiBAcGFyYW0gcmVmTmFtZSAtIFRoZSBjaHJvbW9zb21lIG5hbWVcbiAgICogQHBhcmFtIHN0YXJ0IC0gVGhlIHN0YXJ0IG9mIGEgcmVnaW9uXG4gICAqIEBwYXJhbSBlbmQgLSBUaGUgZW5kIG9mIGEgcmVnaW9uXG4gICAqIEBwYXJhbSBvcHRzIC0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgYmFzZXNQZXJTcGFuIChlLmcuIHBpeGVscyBwZXIgYmFzZXBhaXIpIG9yIHNjYWxlIHVzZWQgdG8gaW5mZXIgdGhlIHpvb21MZXZlbCB0byB1c2VcbiAgICovXG4gIHB1YmxpYyBhc3luYyBnZXRGZWF0dXJlU3RyZWFtKFxuICAgIHJlZk5hbWU6IHN0cmluZyxcbiAgICBzdGFydDogbnVtYmVyLFxuICAgIGVuZDogbnVtYmVyLFxuICAgIG9wdHM6IFJlcXVlc3RPcHRpb25zICYgeyBzY2FsZT86IG51bWJlcjsgYmFzZXNQZXJTcGFuPzogbnVtYmVyIH0gPSB7IHNjYWxlOiAxIH0sXG4gICk6IFByb21pc2U8T2JzZXJ2YWJsZTxGZWF0dXJlW10+PiB7XG4gICAgYXdhaXQgdGhpcy5nZXRIZWFkZXIob3B0cylcbiAgICBjb25zdCBjaHJOYW1lID0gdGhpcy5yZW5hbWVSZWZTZXFzKHJlZk5hbWUpXG4gICAgbGV0IHZpZXc6IEJsb2NrVmlld1xuXG4gICAgaWYgKG9wdHMuYmFzZXNQZXJTcGFuKSB7XG4gICAgICB2aWV3ID0gYXdhaXQgdGhpcy5nZXRWaWV3KDEgLyBvcHRzLmJhc2VzUGVyU3Bhbiwgb3B0cylcbiAgICB9IGVsc2UgaWYgKG9wdHMuc2NhbGUpIHtcbiAgICAgIHZpZXcgPSBhd2FpdCB0aGlzLmdldFZpZXcob3B0cy5zY2FsZSwgb3B0cylcbiAgICB9IGVsc2Uge1xuICAgICAgdmlldyA9IGF3YWl0IHRoaXMuZ2V0VmlldygxLCBvcHRzKVxuICAgIH1cblxuICAgIGlmICghdmlldykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmFibGUgdG8gZ2V0IGJsb2NrIHZpZXcgZm9yIGRhdGEnKVxuICAgIH1cbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGUoKG9ic2VydmVyOiBPYnNlcnZlcjxGZWF0dXJlW10+KTogdm9pZCA9PiB7XG4gICAgICB2aWV3LnJlYWRXaWdEYXRhKGNock5hbWUsIHN0YXJ0LCBlbmQsIG9ic2VydmVyLCBvcHRzKVxuICAgIH0pXG4gIH1cblxuICBwdWJsaWMgYXN5bmMgZ2V0RmVhdHVyZXMoXG4gICAgcmVmTmFtZTogc3RyaW5nLFxuICAgIHN0YXJ0OiBudW1iZXIsXG4gICAgZW5kOiBudW1iZXIsXG4gICAgb3B0czogUmVxdWVzdE9wdGlvbnMgJiB7IHNjYWxlPzogbnVtYmVyOyBiYXNlc1BlclNwYW4/OiBudW1iZXIgfSA9IHsgc2NhbGU6IDEgfSxcbiAgKTogUHJvbWlzZTxGZWF0dXJlW10+IHtcbiAgICBjb25zdCBvYiA9IGF3YWl0IHRoaXMuZ2V0RmVhdHVyZVN0cmVhbShyZWZOYW1lLCBzdGFydCwgZW5kLCBvcHRzKVxuXG4gICAgY29uc3QgcmV0ID0gYXdhaXQgb2IucGlwZShyZWR1Y2UoKGFjYywgY3VycikgPT4gYWNjLmNvbmNhdChjdXJyKSkpLnRvUHJvbWlzZSgpXG4gICAgcmV0dXJuIHJldCB8fCBbXVxuICB9XG59XG4iXX0=