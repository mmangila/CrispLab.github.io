"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.filterUndef = filterUndef;
exports.BigBed = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _binaryParser = require("@gmod/binary-parser");

var _rxjs = require("rxjs");

var _operators = require("rxjs/operators");

var _abortablePromiseCache = _interopRequireDefault(require("abortable-promise-cache"));

var _quickLru = _interopRequireDefault(require("quick-lru"));

var _bbi = require("./bbi");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function filterUndef(ts) {
  return ts.filter(function (t) {
    return !!t;
  });
}

var BigBed = /*#__PURE__*/function (_BBI) {
  (0, _inherits2.default)(BigBed, _BBI);

  var _super = _createSuper(BigBed);

  function BigBed(opts) {
    var _this;

    (0, _classCallCheck2.default)(this, BigBed);
    _this = _super.call(this, opts);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "readIndicesCache", new _abortablePromiseCache.default({
      cache: new _quickLru.default({
        maxSize: 1
      }),
      fill: function () {
        var _fill = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(args, signal) {
          return _regenerator.default.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  return _context.abrupt("return", _this._readIndices(_objectSpread(_objectSpread({}, args), {}, {
                    signal: signal
                  })));

                case 1:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }));

        function fill(_x, _x2) {
          return _fill.apply(this, arguments);
        }

        return fill;
      }()
    }));
    return _this;
  }

  (0, _createClass2.default)(BigBed, [{
    key: "readIndices",
    value: function readIndices() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var options = 'aborted' in opts ? {
        signal: opts
      } : opts;
      return this.readIndicesCache.get(JSON.stringify(options), options, options.signal);
    }
    /*
     * retrieve unzoomed view for any scale
     * @param scale - unused
     * @param abortSignal - an optional AbortSignal to kill operation
     * @return promise for a BlockView
     */

  }, {
    key: "getView",
    value: function () {
      var _getView = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2(scale, opts) {
        return _regenerator.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                return _context2.abrupt("return", this.getUnzoomedView(opts));

              case 1:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getView(_x3, _x4) {
        return _getView.apply(this, arguments);
      }

      return getView;
    }()
    /*
     * parse the bigbed extraIndex fields
     * @param abortSignal to abort operation
     * @return a Promise for an array of Index data structure since there can be multiple extraIndexes in a bigbed, see bedToBigBed documentation
     */

  }, {
    key: "_readIndices",
    value: function () {
      var _readIndices2 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee3(opts) {
        var _yield$this$getHeader, extHeaderOffset, isBigEndian, _yield$this$bbi$read, data, le, ret, count, offset, blocklen, len, _yield$this$bbi$read2, buffer, extParser, indices, i;

        return _regenerator.default.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this.getHeader(opts);

              case 2:
                _yield$this$getHeader = _context3.sent;
                extHeaderOffset = _yield$this$getHeader.extHeaderOffset;
                isBigEndian = _yield$this$getHeader.isBigEndian;
                _context3.next = 7;
                return this.bbi.read(Buffer.alloc(64), 0, 64, extHeaderOffset);

              case 7:
                _yield$this$bbi$read = _context3.sent;
                data = _yield$this$bbi$read.buffer;
                le = isBigEndian ? 'big' : 'little';
                ret = new _binaryParser.Parser().endianess(le).uint16('size').uint16('count').uint64('offset').parse(data).result;
                count = ret.count, offset = ret.offset; // no extra index is defined if count==0

                if (!(count === 0)) {
                  _context3.next = 14;
                  break;
                }

                return _context3.abrupt("return", []);

              case 14:
                blocklen = 20;
                len = blocklen * count;
                _context3.next = 18;
                return this.bbi.read(Buffer.alloc(len), 0, len, offset);

              case 18:
                _yield$this$bbi$read2 = _context3.sent;
                buffer = _yield$this$bbi$read2.buffer;
                extParser = new _binaryParser.Parser().endianess(le).int16('type').int16('fieldcount').uint64('offset').skip(4).int16('field');
                indices = [];

                for (i = 0; i < count; i += 1) {
                  indices.push(extParser.parse(buffer.slice(i * blocklen)).result);
                }

                return _context3.abrupt("return", indices);

              case 24:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function _readIndices(_x5) {
        return _readIndices2.apply(this, arguments);
      }

      return _readIndices;
    }()
    /*
     * perform a search in the bigbed extraIndex to find which blocks in the bigbed data to look for the
     * actual feature data
     *
     * @param name - the name to search for
     * @param opts - a SearchOptions argument with optional signal
     * @return a Promise for an array of bigbed block Loc entries
     */

  }, {
    key: "searchExtraIndexBlocks",
    value: function () {
      var _searchExtraIndexBlocks = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee6(name) {
        var _this2 = this;

        var opts,
            _yield$this$getHeader2,
            isBigEndian,
            indices,
            locs,
            _args6 = arguments;

        return _regenerator.default.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                opts = _args6.length > 1 && _args6[1] !== undefined ? _args6[1] : {};
                _context6.next = 3;
                return this.getHeader(opts);

              case 3:
                _yield$this$getHeader2 = _context6.sent;
                isBigEndian = _yield$this$getHeader2.isBigEndian;
                _context6.next = 7;
                return this.readIndices(opts);

              case 7:
                indices = _context6.sent;

                if (indices.length) {
                  _context6.next = 10;
                  break;
                }

                return _context6.abrupt("return", []);

              case 10:
                locs = indices.map( /*#__PURE__*/function () {
                  var _ref = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee5(index) {
                    var offset, field, _yield$_this2$bbi$rea, data, p, _p$parse$result, blockSize, keySize, valSize, bpt, bptReadNode, rootNodeOffset;

                    return _regenerator.default.wrap(function _callee5$(_context5) {
                      while (1) {
                        switch (_context5.prev = _context5.next) {
                          case 0:
                            offset = index.offset, field = index.field;
                            _context5.next = 3;
                            return _this2.bbi.read(Buffer.alloc(32), 0, 32, offset, opts);

                          case 3:
                            _yield$_this2$bbi$rea = _context5.sent;
                            data = _yield$_this2$bbi$rea.buffer;
                            p = new _binaryParser.Parser().endianess(isBigEndian ? 'big' : 'little').int32('magic').int32('blockSize').int32('keySize').int32('valSize').uint64('itemCount');
                            _p$parse$result = p.parse(data).result, blockSize = _p$parse$result.blockSize, keySize = _p$parse$result.keySize, valSize = _p$parse$result.valSize;
                            bpt = new _binaryParser.Parser().endianess(isBigEndian ? 'big' : 'little').int8('nodeType').skip(1).int16('cnt').choice({
                              tag: 'nodeType',
                              choices: {
                                0: new _binaryParser.Parser().array('leafkeys', {
                                  length: 'cnt',
                                  type: new _binaryParser.Parser().string('key', {
                                    length: keySize,
                                    stripNull: true
                                  }).uint64('offset')
                                }),
                                1: new _binaryParser.Parser().array('keys', {
                                  length: 'cnt',
                                  type: new _binaryParser.Parser().string('key', {
                                    length: keySize,
                                    stripNull: true
                                  }).uint64('offset').uint32('length').uint32('reserved')
                                })
                              }
                            });

                            bptReadNode = /*#__PURE__*/function () {
                              var _ref2 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee4(nodeOffset) {
                                var len, _yield$_this2$bbi$rea2, buffer, node, lastOffset, i, key, _i;

                                return _regenerator.default.wrap(function _callee4$(_context4) {
                                  while (1) {
                                    switch (_context4.prev = _context4.next) {
                                      case 0:
                                        len = 4 + blockSize * (keySize + valSize);
                                        _context4.next = 3;
                                        return _this2.bbi.read(Buffer.alloc(len), 0, len, nodeOffset, opts);

                                      case 3:
                                        _yield$_this2$bbi$rea2 = _context4.sent;
                                        buffer = _yield$_this2$bbi$rea2.buffer;
                                        node = bpt.parse(buffer).result;

                                        if (!node.leafkeys) {
                                          _context4.next = 17;
                                          break;
                                        }

                                        i = 0;

                                      case 8:
                                        if (!(i < node.leafkeys.length)) {
                                          _context4.next = 16;
                                          break;
                                        }

                                        key = node.leafkeys[i].key;

                                        if (!(name.localeCompare(key) < 0 && lastOffset)) {
                                          _context4.next = 12;
                                          break;
                                        }

                                        return _context4.abrupt("return", bptReadNode(lastOffset));

                                      case 12:
                                        lastOffset = node.leafkeys[i].offset;

                                      case 13:
                                        i += 1;
                                        _context4.next = 8;
                                        break;

                                      case 16:
                                        return _context4.abrupt("return", bptReadNode(lastOffset));

                                      case 17:
                                        _i = 0;

                                      case 18:
                                        if (!(_i < node.keys.length)) {
                                          _context4.next = 24;
                                          break;
                                        }

                                        if (!(node.keys[_i].key === name)) {
                                          _context4.next = 21;
                                          break;
                                        }

                                        return _context4.abrupt("return", _objectSpread(_objectSpread({}, node.keys[_i]), {}, {
                                          field: field
                                        }));

                                      case 21:
                                        _i += 1;
                                        _context4.next = 18;
                                        break;

                                      case 24:
                                        return _context4.abrupt("return", undefined);

                                      case 25:
                                      case "end":
                                        return _context4.stop();
                                    }
                                  }
                                }, _callee4);
                              }));

                              return function bptReadNode(_x8) {
                                return _ref2.apply(this, arguments);
                              };
                            }();

                            rootNodeOffset = 32;
                            return _context5.abrupt("return", bptReadNode(offset + rootNodeOffset));

                          case 11:
                          case "end":
                            return _context5.stop();
                        }
                      }
                    }, _callee5);
                  }));

                  return function (_x7) {
                    return _ref.apply(this, arguments);
                  };
                }());
                _context6.t0 = filterUndef;
                _context6.next = 14;
                return Promise.all(locs);

              case 14:
                _context6.t1 = _context6.sent;
                return _context6.abrupt("return", (0, _context6.t0)(_context6.t1));

              case 16:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function searchExtraIndexBlocks(_x6) {
        return _searchExtraIndexBlocks.apply(this, arguments);
      }

      return searchExtraIndexBlocks;
    }()
    /*
     * retrieve the features from the bigbed data that were found through the lookup of the extraIndex
     * note that there can be multiple extraIndex, see the BigBed specification and the -extraIndex argument to bedToBigBed
     *
     * @param name - the name to search for
     * @param opts - a SearchOptions argument with optional signal
     * @return a Promise for an array of Feature
     */

  }, {
    key: "searchExtraIndex",
    value: function () {
      var _searchExtraIndex = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee7(name) {
        var opts,
            blocks,
            view,
            res,
            ret,
            _args7 = arguments;
        return _regenerator.default.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                opts = _args7.length > 1 && _args7[1] !== undefined ? _args7[1] : {};
                _context7.next = 3;
                return this.searchExtraIndexBlocks(name, opts);

              case 3:
                blocks = _context7.sent;

                if (blocks.length) {
                  _context7.next = 6;
                  break;
                }

                return _context7.abrupt("return", []);

              case 6:
                _context7.next = 8;
                return this.getUnzoomedView(opts);

              case 8:
                view = _context7.sent;
                res = blocks.map(function (block) {
                  return new _rxjs.Observable(function (observer) {
                    view.readFeatures(observer, [block], opts);
                  }).pipe((0, _operators.reduce)(function (acc, curr) {
                    return acc.concat(curr);
                  }), (0, _operators.map)(function (x) {
                    for (var i = 0; i < x.length; i += 1) {
                      x[i].field = block.field; // eslint-disable-line
                    }

                    return x;
                  }));
                });
                _context7.next = 12;
                return _rxjs.merge.apply(void 0, (0, _toConsumableArray2.default)(res)).toPromise();

              case 12:
                ret = _context7.sent;
                return _context7.abrupt("return", ret.filter(function (f) {
                  return f.rest.split('\t')[f.field - 3] === name;
                }));

              case 14:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function searchExtraIndex(_x9) {
        return _searchExtraIndex.apply(this, arguments);
      }

      return searchExtraIndex;
    }()
  }]);
  return BigBed;
}(_bbi.BBI);

exports.BigBed = BigBed;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9iaWdiZWQudHMiXSwibmFtZXMiOlsiZmlsdGVyVW5kZWYiLCJ0cyIsImZpbHRlciIsInQiLCJCaWdCZWQiLCJvcHRzIiwiQWJvcnRhYmxlUHJvbWlzZUNhY2hlIiwiY2FjaGUiLCJRdWlja0xSVSIsIm1heFNpemUiLCJmaWxsIiwiYXJncyIsInNpZ25hbCIsIl9yZWFkSW5kaWNlcyIsIm9wdGlvbnMiLCJyZWFkSW5kaWNlc0NhY2hlIiwiZ2V0IiwiSlNPTiIsInN0cmluZ2lmeSIsInNjYWxlIiwiZ2V0VW56b29tZWRWaWV3IiwiZ2V0SGVhZGVyIiwiZXh0SGVhZGVyT2Zmc2V0IiwiaXNCaWdFbmRpYW4iLCJiYmkiLCJyZWFkIiwiQnVmZmVyIiwiYWxsb2MiLCJkYXRhIiwiYnVmZmVyIiwibGUiLCJyZXQiLCJQYXJzZXIiLCJlbmRpYW5lc3MiLCJ1aW50MTYiLCJ1aW50NjQiLCJwYXJzZSIsInJlc3VsdCIsImNvdW50Iiwib2Zmc2V0IiwiYmxvY2tsZW4iLCJsZW4iLCJleHRQYXJzZXIiLCJpbnQxNiIsInNraXAiLCJpbmRpY2VzIiwiaSIsInB1c2giLCJzbGljZSIsIm5hbWUiLCJyZWFkSW5kaWNlcyIsImxlbmd0aCIsImxvY3MiLCJtYXAiLCJpbmRleCIsImZpZWxkIiwicCIsImludDMyIiwiYmxvY2tTaXplIiwia2V5U2l6ZSIsInZhbFNpemUiLCJicHQiLCJpbnQ4IiwiY2hvaWNlIiwidGFnIiwiY2hvaWNlcyIsImFycmF5IiwidHlwZSIsInN0cmluZyIsInN0cmlwTnVsbCIsInVpbnQzMiIsImJwdFJlYWROb2RlIiwibm9kZU9mZnNldCIsIm5vZGUiLCJsZWFma2V5cyIsImtleSIsImxvY2FsZUNvbXBhcmUiLCJsYXN0T2Zmc2V0Iiwia2V5cyIsInVuZGVmaW5lZCIsInJvb3ROb2RlT2Zmc2V0IiwiUHJvbWlzZSIsImFsbCIsInNlYXJjaEV4dHJhSW5kZXhCbG9ja3MiLCJibG9ja3MiLCJ2aWV3IiwicmVzIiwiYmxvY2siLCJPYnNlcnZhYmxlIiwib2JzZXJ2ZXIiLCJyZWFkRmVhdHVyZXMiLCJwaXBlIiwiYWNjIiwiY3VyciIsImNvbmNhdCIsIngiLCJtZXJnZSIsInRvUHJvbWlzZSIsImYiLCJyZXN0Iiwic3BsaXQiLCJCQkkiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUVBOzs7Ozs7Ozs7O0FBaUJPLFNBQVNBLFdBQVQsQ0FBd0JDLEVBQXhCLEVBQW9EO0FBQ3pELFNBQU9BLEVBQUUsQ0FBQ0MsTUFBSCxDQUFVLFVBQUNDLENBQUQ7QUFBQSxXQUE4QixDQUFDLENBQUNBLENBQWhDO0FBQUEsR0FBVixDQUFQO0FBQ0Q7O0lBRVlDLE07Ozs7O0FBUVgsa0JBQW1CQyxJQUFuQixFQUE4QjtBQUFBOztBQUFBO0FBQzVCLDhCQUFNQSxJQUFOO0FBRDRCLG1HQVBKLElBQUlDLDhCQUFKLENBQTBCO0FBQ2xEQyxNQUFBQSxLQUFLLEVBQUUsSUFBSUMsaUJBQUosQ0FBYTtBQUFFQyxRQUFBQSxPQUFPLEVBQUU7QUFBWCxPQUFiLENBRDJDO0FBRWxEQyxNQUFBQSxJQUFJO0FBQUEsNEZBQUUsaUJBQU9DLElBQVAsRUFBa0JDLE1BQWxCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxtREFDRyxNQUFLQyxZQUFMLGlDQUF1QkYsSUFBdkI7QUFBNkJDLG9CQUFBQSxNQUFNLEVBQU5BO0FBQTdCLHFCQURIOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFNBQUY7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFGOEMsS0FBMUIsQ0FPSTtBQUFBO0FBRTdCOzs7O2tDQUUyRDtBQUFBLFVBQXpDUCxJQUF5Qyx1RUFBSixFQUFJO0FBQzFELFVBQU1TLE9BQU8sR0FBRyxhQUFhVCxJQUFiLEdBQW9CO0FBQUVPLFFBQUFBLE1BQU0sRUFBRVA7QUFBVixPQUFwQixHQUF1Q0EsSUFBdkQ7QUFDQSxhQUFPLEtBQUtVLGdCQUFMLENBQXNCQyxHQUF0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QU9BLENBQUMsQ0FBQ0MsSUFBRixDQUFPQyxLQUFQLENBQWEsSUFBYixFQUFtQkYsQ0FBQyxDQUFDM0MsS0FBRixHQUFVLENBQTdCLE1BQW9DTixJQUEzQztBQUNELGlCQUZNLEM7Ozs7Ozs7Ozs7Ozs7Ozs7OztFQS9LaUJvRCxRIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUGFyc2VyIH0gZnJvbSAnQGdtb2QvYmluYXJ5LXBhcnNlcidcbmltcG9ydCB7IE9ic2VydmFibGUsIE9ic2VydmVyLCBtZXJnZSB9IGZyb20gJ3J4anMnXG5pbXBvcnQgeyBtYXAsIHJlZHVjZSB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJ1xuaW1wb3J0IEFib3J0YWJsZVByb21pc2VDYWNoZSBmcm9tICdhYm9ydGFibGUtcHJvbWlzZS1jYWNoZSdcbmltcG9ydCBRdWlja0xSVSBmcm9tICdxdWljay1scnUnXG5cbmltcG9ydCB7IEJCSSwgRmVhdHVyZSwgUmVxdWVzdE9wdGlvbnMgfSBmcm9tICcuL2JiaSdcbmltcG9ydCB7IEJsb2NrVmlldyB9IGZyb20gJy4vYmxvY2tWaWV3J1xuXG5pbnRlcmZhY2UgTG9jIHtcbiAga2V5OiBzdHJpbmdcbiAgb2Zmc2V0OiBudW1iZXJcbiAgbGVuZ3RoOiBudW1iZXJcbiAgZmllbGQ/OiBudW1iZXJcbn1cblxuaW50ZXJmYWNlIEluZGV4IHtcbiAgdHlwZTogbnVtYmVyXG4gIGZpZWxkY291bnQ6IG51bWJlclxuICBvZmZzZXQ6IG51bWJlclxuICBmaWVsZDogbnVtYmVyXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmaWx0ZXJVbmRlZjxUPih0czogKFQgfCB1bmRlZmluZWQpW10pOiBUW10ge1xuICByZXR1cm4gdHMuZmlsdGVyKCh0OiBUIHwgdW5kZWZpbmVkKTogdCBpcyBUID0+ICEhdClcbn1cblxuZXhwb3J0IGNsYXNzIEJpZ0JlZCBleHRlbmRzIEJCSSB7XG4gIHB1YmxpYyByZWFkSW5kaWNlc0NhY2hlID0gbmV3IEFib3J0YWJsZVByb21pc2VDYWNoZSh7XG4gICAgY2FjaGU6IG5ldyBRdWlja0xSVSh7IG1heFNpemU6IDEgfSksXG4gICAgZmlsbDogYXN5bmMgKGFyZ3M6IGFueSwgc2lnbmFsPzogQWJvcnRTaWduYWwpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLl9yZWFkSW5kaWNlcyh7IC4uLmFyZ3MsIHNpZ25hbCB9KVxuICAgIH0sXG4gIH0pXG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKG9wdHM6IGFueSkge1xuICAgIHN1cGVyKG9wdHMpXG4gIH1cblxuICBwdWJsaWMgcmVhZEluZGljZXMob3B0czogQWJvcnRTaWduYWwgfCBSZXF1ZXN0T3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9ICdhYm9ydGVkJyBpbiBvcHRzID8geyBzaWduYWw6IG9wdHMgfSA6IG9wdHNcbiAgICByZXR1cm4gdGhpcy5yZWFkSW5kaWNlc0NhY2hlLmdldChKU09OLnN0cmluZ2lmeShvcHRpb25zKSwgb3B0aW9ucywgb3B0aW9ucy5zaWduYWwpXG4gIH1cblxuICAvKlxuICAgKiByZXRyaWV2ZSB1bnpvb21lZCB2aWV3IGZvciBhbnkgc2NhbGVcbiAgICogQHBhcmFtIHNjYWxlIC0gdW51c2VkXG4gICAqIEBwYXJhbSBhYm9ydFNpZ25hbCAtIGFuIG9wdGlvbmFsIEFib3J0U2lnbmFsIHRvIGtpbGwgb3BlcmF0aW9uXG4gICAqIEByZXR1cm4gcHJvbWlzZSBmb3IgYSBCbG9ja1ZpZXdcbiAgICovXG4gIHByb3RlY3RlZCBhc3luYyBnZXRWaWV3KHNjYWxlOiBudW1iZXIsIG9wdHM6IFJlcXVlc3RPcHRpb25zKTogUHJvbWlzZTxCbG9ja1ZpZXc+IHtcbiAgICByZXR1cm4gdGhpcy5nZXRVbnpvb21lZFZpZXcob3B0cylcbiAgfVxuXG4gIC8qXG4gICAqIHBhcnNlIHRoZSBiaWdiZWQgZXh0cmFJbmRleCBmaWVsZHNcbiAgICogQHBhcmFtIGFib3J0U2lnbmFsIHRvIGFib3J0IG9wZXJhdGlvblxuICAgKiBAcmV0dXJuIGEgUHJvbWlzZSBmb3IgYW4gYXJyYXkgb2YgSW5kZXggZGF0YSBzdHJ1Y3R1cmUgc2luY2UgdGhlcmUgY2FuIGJlIG11bHRpcGxlIGV4dHJhSW5kZXhlcyBpbiBhIGJpZ2JlZCwgc2VlIGJlZFRvQmlnQmVkIGRvY3VtZW50YXRpb25cbiAgICovXG4gIHByaXZhdGUgYXN5bmMgX3JlYWRJbmRpY2VzKG9wdHM6IFJlcXVlc3RPcHRpb25zKTogUHJvbWlzZTxJbmRleFtdPiB7XG4gICAgY29uc3QgeyBleHRIZWFkZXJPZmZzZXQsIGlzQmlnRW5kaWFuIH0gPSBhd2FpdCB0aGlzLmdldEhlYWRlcihvcHRzKVxuICAgIGNvbnN0IHsgYnVmZmVyOiBkYXRhIH0gPSBhd2FpdCB0aGlzLmJiaS5yZWFkKEJ1ZmZlci5hbGxvYyg2NCksIDAsIDY0LCBleHRIZWFkZXJPZmZzZXQpXG4gICAgY29uc3QgbGUgPSBpc0JpZ0VuZGlhbiA/ICdiaWcnIDogJ2xpdHRsZSdcbiAgICBjb25zdCByZXQgPSBuZXcgUGFyc2VyKClcbiAgICAgIC5lbmRpYW5lc3MobGUpXG4gICAgICAudWludDE2KCdzaXplJylcbiAgICAgIC51aW50MTYoJ2NvdW50JylcbiAgICAgIC51aW50NjQoJ29mZnNldCcpXG4gICAgICAucGFyc2UoZGF0YSkucmVzdWx0XG4gICAgY29uc3QgeyBjb3VudCwgb2Zmc2V0IH0gPSByZXRcblxuICAgIC8vIG5vIGV4dHJhIGluZGV4IGlzIGRlZmluZWQgaWYgY291bnQ9PTBcbiAgICBpZiAoY291bnQgPT09IDApIHtcbiAgICAgIHJldHVybiBbXVxuICAgIH1cblxuICAgIGNvbnN0IGJsb2NrbGVuID0gMjBcbiAgICBjb25zdCBsZW4gPSBibG9ja2xlbiAqIGNvdW50XG4gICAgY29uc3QgeyBidWZmZXIgfSA9IGF3YWl0IHRoaXMuYmJpLnJlYWQoQnVmZmVyLmFsbG9jKGxlbiksIDAsIGxlbiwgb2Zmc2V0KVxuICAgIGNvbnN0IGV4dFBhcnNlciA9IG5ldyBQYXJzZXIoKVxuICAgICAgLmVuZGlhbmVzcyhsZSlcbiAgICAgIC5pbnQxNigndHlwZScpXG4gICAgICAuaW50MTYoJ2ZpZWxkY291bnQnKVxuICAgICAgLnVpbnQ2NCgnb2Zmc2V0JylcbiAgICAgIC5za2lwKDQpXG4gICAgICAuaW50MTYoJ2ZpZWxkJylcbiAgICBjb25zdCBpbmRpY2VzID0gW11cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkgKz0gMSkge1xuICAgICAgaW5kaWNlcy5wdXNoKGV4dFBhcnNlci5wYXJzZShidWZmZXIuc2xpY2UoaSAqIGJsb2NrbGVuKSkucmVzdWx0KVxuICAgIH1cbiAgICByZXR1cm4gaW5kaWNlc1xuICB9XG5cbiAgLypcbiAgICogcGVyZm9ybSBhIHNlYXJjaCBpbiB0aGUgYmlnYmVkIGV4dHJhSW5kZXggdG8gZmluZCB3aGljaCBibG9ja3MgaW4gdGhlIGJpZ2JlZCBkYXRhIHRvIGxvb2sgZm9yIHRoZVxuICAgKiBhY3R1YWwgZmVhdHVyZSBkYXRhXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lIC0gdGhlIG5hbWUgdG8gc2VhcmNoIGZvclxuICAgKiBAcGFyYW0gb3B0cyAtIGEgU2VhcmNoT3B0aW9ucyBhcmd1bWVudCB3aXRoIG9wdGlvbmFsIHNpZ25hbFxuICAgKiBAcmV0dXJuIGEgUHJvbWlzZSBmb3IgYW4gYXJyYXkgb2YgYmlnYmVkIGJsb2NrIExvYyBlbnRyaWVzXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIHNlYXJjaEV4dHJhSW5kZXhCbG9ja3MobmFtZTogc3RyaW5nLCBvcHRzOiBSZXF1ZXN0T3B0aW9ucyA9IHt9KTogUHJvbWlzZTxMb2NbXT4ge1xuICAgIGNvbnN0IHsgaXNCaWdFbmRpYW4gfSA9IGF3YWl0IHRoaXMuZ2V0SGVhZGVyKG9wdHMpXG4gICAgY29uc3QgaW5kaWNlcyA9IGF3YWl0IHRoaXMucmVhZEluZGljZXMob3B0cylcbiAgICBpZiAoIWluZGljZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gW11cbiAgICB9XG4gICAgY29uc3QgbG9jcyA9IGluZGljZXMubWFwKFxuICAgICAgYXN5bmMgKGluZGV4OiBhbnkpOiBQcm9taXNlPExvYyB8IHVuZGVmaW5lZD4gPT4ge1xuICAgICAgICBjb25zdCB7IG9mZnNldCwgZmllbGQgfSA9IGluZGV4XG4gICAgICAgIGNvbnN0IHsgYnVmZmVyOiBkYXRhIH0gPSBhd2FpdCB0aGlzLmJiaS5yZWFkKEJ1ZmZlci5hbGxvYygzMiksIDAsIDMyLCBvZmZzZXQsIG9wdHMpXG4gICAgICAgIGNvbnN0IHAgPSBuZXcgUGFyc2VyKClcbiAgICAgICAgICAuZW5kaWFuZXNzKGlzQmlnRW5kaWFuID8gJ2JpZycgOiAnbGl0dGxlJylcbiAgICAgICAgICAuaW50MzIoJ21hZ2ljJylcbiAgICAgICAgICAuaW50MzIoJ2Jsb2NrU2l6ZScpXG4gICAgICAgICAgLmludDMyKCdrZXlTaXplJylcbiAgICAgICAgICAuaW50MzIoJ3ZhbFNpemUnKVxuICAgICAgICAgIC51aW50NjQoJ2l0ZW1Db3VudCcpXG5cbiAgICAgICAgY29uc3QgeyBibG9ja1NpemUsIGtleVNpemUsIHZhbFNpemUgfSA9IHAucGFyc2UoZGF0YSkucmVzdWx0XG4gICAgICAgIGNvbnN0IGJwdCA9IG5ldyBQYXJzZXIoKVxuICAgICAgICAgIC5lbmRpYW5lc3MoaXNCaWdFbmRpYW4gPyAnYmlnJyA6ICdsaXR0bGUnKVxuICAgICAgICAgIC5pbnQ4KCdub2RlVHlwZScpXG4gICAgICAgICAgLnNraXAoMSlcbiAgICAgICAgICAuaW50MTYoJ2NudCcpXG4gICAgICAgICAgLmNob2ljZSh7XG4gICAgICAgICAgICB0YWc6ICdub2RlVHlwZScsXG4gICAgICAgICAgICBjaG9pY2VzOiB7XG4gICAgICAgICAgICAgIDA6IG5ldyBQYXJzZXIoKS5hcnJheSgnbGVhZmtleXMnLCB7XG4gICAgICAgICAgICAgICAgbGVuZ3RoOiAnY250JyxcbiAgICAgICAgICAgICAgICB0eXBlOiBuZXcgUGFyc2VyKClcbiAgICAgICAgICAgICAgICAgIC5zdHJpbmcoJ2tleScsIHsgbGVuZ3RoOiBrZXlTaXplLCBzdHJpcE51bGw6IHRydWUgfSlcbiAgICAgICAgICAgICAgICAgIC51aW50NjQoJ29mZnNldCcpLFxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgMTogbmV3IFBhcnNlcigpLmFycmF5KCdrZXlzJywge1xuICAgICAgICAgICAgICAgIGxlbmd0aDogJ2NudCcsXG4gICAgICAgICAgICAgICAgdHlwZTogbmV3IFBhcnNlcigpXG4gICAgICAgICAgICAgICAgICAuc3RyaW5nKCdrZXknLCB7IGxlbmd0aDoga2V5U2l6ZSwgc3RyaXBOdWxsOiB0cnVlIH0pXG4gICAgICAgICAgICAgICAgICAudWludDY0KCdvZmZzZXQnKVxuICAgICAgICAgICAgICAgICAgLnVpbnQzMignbGVuZ3RoJylcbiAgICAgICAgICAgICAgICAgIC51aW50MzIoJ3Jlc2VydmVkJyksXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9KVxuXG4gICAgICAgIGNvbnN0IGJwdFJlYWROb2RlID0gYXN5bmMgKG5vZGVPZmZzZXQ6IG51bWJlcik6IFByb21pc2U8TG9jIHwgdW5kZWZpbmVkPiA9PiB7XG4gICAgICAgICAgY29uc3QgbGVuID0gNCArIGJsb2NrU2l6ZSAqIChrZXlTaXplICsgdmFsU2l6ZSlcbiAgICAgICAgICBjb25zdCB7IGJ1ZmZlciB9ID0gYXdhaXQgdGhpcy5iYmkucmVhZChCdWZmZXIuYWxsb2MobGVuKSwgMCwgbGVuLCBub2RlT2Zmc2V0LCBvcHRzKVxuICAgICAgICAgIGNvbnN0IG5vZGUgPSBicHQucGFyc2UoYnVmZmVyKS5yZXN1bHRcbiAgICAgICAgICBpZiAobm9kZS5sZWFma2V5cykge1xuICAgICAgICAgICAgbGV0IGxhc3RPZmZzZXRcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5sZWFma2V5cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICBjb25zdCB7IGtleSB9ID0gbm9kZS5sZWFma2V5c1tpXVxuICAgICAgICAgICAgICBpZiAobmFtZS5sb2NhbGVDb21wYXJlKGtleSkgPCAwICYmIGxhc3RPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYnB0UmVhZE5vZGUobGFzdE9mZnNldClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsYXN0T2Zmc2V0ID0gbm9kZS5sZWFma2V5c1tpXS5vZmZzZXRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBicHRSZWFkTm9kZShsYXN0T2Zmc2V0KVxuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUua2V5cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgaWYgKG5vZGUua2V5c1tpXS5rZXkgPT09IG5hbWUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHsgLi4ubm9kZS5rZXlzW2ldLCBmaWVsZCB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJvb3ROb2RlT2Zmc2V0ID0gMzJcbiAgICAgICAgcmV0dXJuIGJwdFJlYWROb2RlKG9mZnNldCArIHJvb3ROb2RlT2Zmc2V0KVxuICAgICAgfSxcbiAgICApXG4gICAgcmV0dXJuIGZpbHRlclVuZGVmKGF3YWl0IFByb21pc2UuYWxsKGxvY3MpKVxuICB9XG5cbiAgLypcbiAgICogcmV0cmlldmUgdGhlIGZlYXR1cmVzIGZyb20gdGhlIGJpZ2JlZCBkYXRhIHRoYXQgd2VyZSBmb3VuZCB0aHJvdWdoIHRoZSBsb29rdXAgb2YgdGhlIGV4dHJhSW5kZXhcbiAgICogbm90ZSB0aGF0IHRoZXJlIGNhbiBiZSBtdWx0aXBsZSBleHRyYUluZGV4LCBzZWUgdGhlIEJpZ0JlZCBzcGVjaWZpY2F0aW9uIGFuZCB0aGUgLWV4dHJhSW5kZXggYXJndW1lbnQgdG8gYmVkVG9CaWdCZWRcbiAgICpcbiAgICogQHBhcmFtIG5hbWUgLSB0aGUgbmFtZSB0byBzZWFyY2ggZm9yXG4gICAqIEBwYXJhbSBvcHRzIC0gYSBTZWFyY2hPcHRpb25zIGFyZ3VtZW50IHdpdGggb3B0aW9uYWwgc2lnbmFsXG4gICAqIEByZXR1cm4gYSBQcm9taXNlIGZvciBhbiBhcnJheSBvZiBGZWF0dXJlXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgc2VhcmNoRXh0cmFJbmRleChuYW1lOiBzdHJpbmcsIG9wdHM6IFJlcXVlc3RPcHRpb25zID0ge30pOiBQcm9taXNlPEZlYXR1cmVbXT4ge1xuICAgIGNvbnN0IGJsb2NrcyA9IGF3YWl0IHRoaXMuc2VhcmNoRXh0cmFJbmRleEJsb2NrcyhuYW1lLCBvcHRzKVxuICAgIGlmICghYmxvY2tzLmxlbmd0aCkgcmV0dXJuIFtdXG4gICAgY29uc3QgdmlldyA9IGF3YWl0IHRoaXMuZ2V0VW56b29tZWRWaWV3KG9wdHMpXG4gICAgY29uc3QgcmVzID0gYmxvY2tzLm1hcChibG9jayA9PiB7XG4gICAgICByZXR1cm4gbmV3IE9ic2VydmFibGUoKG9ic2VydmVyOiBPYnNlcnZlcjxGZWF0dXJlW10+KSA9PiB7XG4gICAgICAgIHZpZXcucmVhZEZlYXR1cmVzKG9ic2VydmVyLCBbYmxvY2tdLCBvcHRzKVxuICAgICAgfSkucGlwZShcbiAgICAgICAgcmVkdWNlKChhY2MsIGN1cnIpID0+IGFjYy5jb25jYXQoY3VycikpLFxuICAgICAgICBtYXAoeCA9PiB7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB4Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgeFtpXS5maWVsZCA9IGJsb2NrLmZpZWxkIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHhcbiAgICAgICAgfSksXG4gICAgICApXG4gICAgfSlcbiAgICBjb25zdCByZXQgPSBhd2FpdCBtZXJnZSguLi5yZXMpLnRvUHJvbWlzZSgpXG4gICAgcmV0dXJuIHJldC5maWx0ZXIoKGY6IGFueSkgPT4ge1xuICAgICAgcmV0dXJuIGYucmVzdC5zcGxpdCgnXFx0JylbZi5maWVsZCAtIDNdID09PSBuYW1lXG4gICAgfSlcbiAgfVxufVxuIl19