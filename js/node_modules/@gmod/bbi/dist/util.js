"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.groupBlocks = groupBlocks;
exports.checkAbortSignal = checkAbortSignal;
exports.abortBreakPoint = abortBreakPoint;
exports.AbortError = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _wrapNativeSuper2 = _interopRequireDefault(require("@babel/runtime/helpers/wrapNativeSuper"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

/* eslint no-bitwise: ["error", { "allow": ["|"] }] */
var AbortError = /*#__PURE__*/function (_Error) {
  (0, _inherits2.default)(AbortError, _Error);

  var _super = _createSuper(AbortError);

  function AbortError(message) {
    var _this;

    (0, _classCallCheck2.default)(this, AbortError);
    _this = _super.call(this, message);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "code", void 0);
    _this.code = 'ERR_ABORTED';
    return _this;
  }

  return AbortError;
}( /*#__PURE__*/(0, _wrapNativeSuper2.default)(Error)); // sort blocks by file offset and
// group blocks that are within 2KB of eachother


exports.AbortError = AbortError;

function groupBlocks(blocks) {
  blocks.sort(function (b0, b1) {
    return (b0.offset | 0) - (b1.offset | 0);
  });
  var blockGroups = [];
  var lastBlock;
  var lastBlockEnd;

  for (var i = 0; i < blocks.length; i += 1) {
    if (lastBlock && blocks[i].offset - lastBlockEnd <= 2000) {
      lastBlock.length += blocks[i].length - lastBlockEnd + blocks[i].offset;
      lastBlock.blocks.push(blocks[i]);
    } else {
      blockGroups.push(lastBlock = {
        blocks: [blocks[i]],
        length: blocks[i].length,
        offset: blocks[i].offset
      });
    }

    lastBlockEnd = lastBlock.offset + lastBlock.length;
  }

  return blockGroups;
}
/**
 * Properly check if the given AbortSignal is aborted.
 * Per the standard, if the signal reads as aborted,
 * this function throws either a DOMException AbortError, or a regular error
 * with a `code` attribute set to `ERR_ABORTED`.
 *
 * For convenience, passing `undefined` is a no-op
 *
 * @param {AbortSignal} [signal] an AbortSignal, or anything with an `aborted` attribute
 * @returns nothing
 */


function checkAbortSignal(signal) {
  if (!signal) return;

  if (signal.aborted) {
    // console.log('bam aborted!')
    if (typeof DOMException !== 'undefined') {
      throw new DOMException('aborted', 'AbortError');
    } else {
      var e = new AbortError('aborted');
      e.code = 'ERR_ABORTED';
      throw e;
    }
  }
}
/**
 * Skips to the next tick, then runs `checkAbortSignal`.
 * Await this to inside an otherwise synchronous loop to
 * provide a place to break when an abort signal is received.
 * @param {AbortSignal} signal
 */


function abortBreakPoint(_x) {
  return _abortBreakPoint.apply(this, arguments);
}

function _abortBreakPoint() {
  _abortBreakPoint = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(signal) {
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return Promise.resolve();

          case 2:
            checkAbortSignal(signal);

          case 3:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _abortBreakPoint.apply(this, arguments);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy91dGlsLnRzIl0sIm5hbWVzIjpbIkFib3J0RXJyb3IiLCJtZXNzYWdlIiwiY29kZSIsIkVycm9yIiwiZ3JvdXBCbG9ja3MiLCJibG9ja3MiLCJzb3J0IiwiYjAiLCJiMSIsIm9mZnNldCIsImJsb2NrR3JvdXBzIiwibGFzdEJsb2NrIiwibGFzdEJsb2NrRW5kIiwiaSIsImxlbmd0aCIsInB1c2giLCJjaGVja0Fib3J0U2lnbmFsIiwic2lnbmFsIiwiYWJvcnRlZCIsIkRPTUV4Y2VwdGlvbiIsImUiLCJhYm9ydEJyZWFrUG9pbnQiLCJQcm9taXNlIiwicmVzb2x2ZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0lBQ2FBLFU7Ozs7O0FBR1gsc0JBQW1CQyxPQUFuQixFQUFvQztBQUFBOztBQUFBO0FBQ2xDLDhCQUFNQSxPQUFOO0FBRGtDO0FBRWxDLFVBQUtDLElBQUwsR0FBWSxhQUFaO0FBRmtDO0FBR25DOzs7K0NBTjZCQyxLLElBUWhDO0FBQ0E7Ozs7O0FBQ08sU0FBU0MsV0FBVCxDQUFxQkMsTUFBckIsRUFBMkM7QUFDaERBLEVBQUFBLE1BQU0sQ0FBQ0MsSUFBUCxDQUFZLFVBQUNDLEVBQUQsRUFBS0MsRUFBTDtBQUFBLFdBQVksQ0FBQ0QsRUFBRSxDQUFDRSxNQUFILEdBQVksQ0FBYixLQUFtQkQsRUFBRSxDQUFDQyxNQUFILEdBQVksQ0FBL0IsQ0FBWjtBQUFBLEdBQVo7QUFFQSxNQUFNQyxXQUFXLEdBQUcsRUFBcEI7QUFDQSxNQUFJQyxTQUFKO0FBQ0EsTUFBSUMsWUFBSjs7QUFDQSxPQUFLLElBQUlDLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdSLE1BQU0sQ0FBQ1MsTUFBM0IsRUFBbUNELENBQUMsSUFBSSxDQUF4QyxFQUEyQztBQUN6QyxRQUFJRixTQUFTLElBQUlOLE1BQU0sQ0FBQ1EsQ0FBRCxDQUFOLENBQVVKLE1BQVYsR0FBbUJHLFlBQW5CLElBQW1DLElBQXBELEVBQTBEO0FBQ3hERCxNQUFBQSxTQUFTLENBQUNHLE1BQVYsSUFBb0JULE1BQU0sQ0FBQ1EsQ0FBRCxDQUFOLENBQVVDLE1BQVYsR0FBbUJGLFlBQW5CLEdBQWtDUCxNQUFNLENBQUNRLENBQUQsQ0FBTixDQUFVSixNQUFoRTtBQUNBRSxNQUFBQSxTQUFTLENBQUNOLE1BQVYsQ0FBaUJVLElBQWpCLENBQXNCVixNQUFNLENBQUNRLENBQUQsQ0FBNUI7QUFDRCxLQUhELE1BR087QUFDTEgsTUFBQUEsV0FBVyxDQUFDSyxJQUFaLENBQ0dKLFNBQVMsR0FBRztBQUNYTixRQUFBQSxNQUFNLEVBQUUsQ0FBQ0EsTUFBTSxDQUFDUSxDQUFELENBQVAsQ0FERztBQUVYQyxRQUFBQSxNQUFNLEVBQUVULE1BQU0sQ0FBQ1EsQ0FBRCxDQUFOLENBQVVDLE1BRlA7QUFHWEwsUUFBQUEsTUFBTSxFQUFFSixNQUFNLENBQUNRLENBQUQsQ0FBTixDQUFVSjtBQUhQLE9BRGY7QUFPRDs7QUFDREcsSUFBQUEsWUFBWSxHQUFHRCxTQUFTLENBQUNGLE1BQVYsR0FBbUJFLFNBQVMsQ0FBQ0csTUFBNUM7QUFDRDs7QUFFRCxTQUFPSixXQUFQO0FBQ0Q7QUFFRDs7Ozs7Ozs7Ozs7OztBQVdPLFNBQVNNLGdCQUFULENBQTBCQyxNQUExQixFQUFzRDtBQUMzRCxNQUFJLENBQUNBLE1BQUwsRUFBYTs7QUFFYixNQUFJQSxNQUFNLENBQUNDLE9BQVgsRUFBb0I7QUFDbEI7QUFDQSxRQUFJLE9BQU9DLFlBQVAsS0FBd0IsV0FBNUIsRUFBeUM7QUFDdkMsWUFBTSxJQUFJQSxZQUFKLENBQWlCLFNBQWpCLEVBQTRCLFlBQTVCLENBQU47QUFDRCxLQUZELE1BRU87QUFDTCxVQUFNQyxDQUFDLEdBQUcsSUFBSXBCLFVBQUosQ0FBZSxTQUFmLENBQVY7QUFDQW9CLE1BQUFBLENBQUMsQ0FBQ2xCLElBQUYsR0FBUyxhQUFUO0FBQ0EsWUFBTWtCLENBQU47QUFDRDtBQUNGO0FBQ0Y7QUFFRDs7Ozs7Ozs7U0FNc0JDLGU7Ozs7OzZGQUFmLGlCQUErQkosTUFBL0I7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsbUJBQ0NLLE9BQU8sQ0FBQ0MsT0FBUixFQUREOztBQUFBO0FBRUxQLFlBQUFBLGdCQUFnQixDQUFDQyxNQUFELENBQWhCOztBQUZLO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEciLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQgbm8tYml0d2lzZTogW1wiZXJyb3JcIiwgeyBcImFsbG93XCI6IFtcInxcIl0gfV0gKi9cbmV4cG9ydCBjbGFzcyBBYm9ydEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBwdWJsaWMgY29kZTogc3RyaW5nXG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKG1lc3NhZ2U6IHN0cmluZykge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgdGhpcy5jb2RlID0gJ0VSUl9BQk9SVEVEJ1xuICB9XG59XG4vLyBzb3J0IGJsb2NrcyBieSBmaWxlIG9mZnNldCBhbmRcbi8vIGdyb3VwIGJsb2NrcyB0aGF0IGFyZSB3aXRoaW4gMktCIG9mIGVhY2hvdGhlclxuZXhwb3J0IGZ1bmN0aW9uIGdyb3VwQmxvY2tzKGJsb2NrczogYW55W10pOiBhbnlbXSB7XG4gIGJsb2Nrcy5zb3J0KChiMCwgYjEpID0+IChiMC5vZmZzZXQgfCAwKSAtIChiMS5vZmZzZXQgfCAwKSlcblxuICBjb25zdCBibG9ja0dyb3VwcyA9IFtdXG4gIGxldCBsYXN0QmxvY2tcbiAgbGV0IGxhc3RCbG9ja0VuZFxuICBmb3IgKGxldCBpID0gMDsgaSA8IGJsb2Nrcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGlmIChsYXN0QmxvY2sgJiYgYmxvY2tzW2ldLm9mZnNldCAtIGxhc3RCbG9ja0VuZCA8PSAyMDAwKSB7XG4gICAgICBsYXN0QmxvY2subGVuZ3RoICs9IGJsb2Nrc1tpXS5sZW5ndGggLSBsYXN0QmxvY2tFbmQgKyBibG9ja3NbaV0ub2Zmc2V0XG4gICAgICBsYXN0QmxvY2suYmxvY2tzLnB1c2goYmxvY2tzW2ldKVxuICAgIH0gZWxzZSB7XG4gICAgICBibG9ja0dyb3Vwcy5wdXNoKFxuICAgICAgICAobGFzdEJsb2NrID0ge1xuICAgICAgICAgIGJsb2NrczogW2Jsb2Nrc1tpXV0sXG4gICAgICAgICAgbGVuZ3RoOiBibG9ja3NbaV0ubGVuZ3RoLFxuICAgICAgICAgIG9mZnNldDogYmxvY2tzW2ldLm9mZnNldCxcbiAgICAgICAgfSksXG4gICAgICApXG4gICAgfVxuICAgIGxhc3RCbG9ja0VuZCA9IGxhc3RCbG9jay5vZmZzZXQgKyBsYXN0QmxvY2subGVuZ3RoXG4gIH1cblxuICByZXR1cm4gYmxvY2tHcm91cHNcbn1cblxuLyoqXG4gKiBQcm9wZXJseSBjaGVjayBpZiB0aGUgZ2l2ZW4gQWJvcnRTaWduYWwgaXMgYWJvcnRlZC5cbiAqIFBlciB0aGUgc3RhbmRhcmQsIGlmIHRoZSBzaWduYWwgcmVhZHMgYXMgYWJvcnRlZCxcbiAqIHRoaXMgZnVuY3Rpb24gdGhyb3dzIGVpdGhlciBhIERPTUV4Y2VwdGlvbiBBYm9ydEVycm9yLCBvciBhIHJlZ3VsYXIgZXJyb3JcbiAqIHdpdGggYSBgY29kZWAgYXR0cmlidXRlIHNldCB0byBgRVJSX0FCT1JURURgLlxuICpcbiAqIEZvciBjb252ZW5pZW5jZSwgcGFzc2luZyBgdW5kZWZpbmVkYCBpcyBhIG5vLW9wXG4gKlxuICogQHBhcmFtIHtBYm9ydFNpZ25hbH0gW3NpZ25hbF0gYW4gQWJvcnRTaWduYWwsIG9yIGFueXRoaW5nIHdpdGggYW4gYGFib3J0ZWRgIGF0dHJpYnV0ZVxuICogQHJldHVybnMgbm90aGluZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tBYm9ydFNpZ25hbChzaWduYWw/OiBBYm9ydFNpZ25hbCk6IHZvaWQge1xuICBpZiAoIXNpZ25hbCkgcmV0dXJuXG5cbiAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgLy8gY29uc29sZS5sb2coJ2JhbSBhYm9ydGVkIScpXG4gICAgaWYgKHR5cGVvZiBET01FeGNlcHRpb24gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKCdhYm9ydGVkJywgJ0Fib3J0RXJyb3InKVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBlID0gbmV3IEFib3J0RXJyb3IoJ2Fib3J0ZWQnKVxuICAgICAgZS5jb2RlID0gJ0VSUl9BQk9SVEVEJ1xuICAgICAgdGhyb3cgZVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFNraXBzIHRvIHRoZSBuZXh0IHRpY2ssIHRoZW4gcnVucyBgY2hlY2tBYm9ydFNpZ25hbGAuXG4gKiBBd2FpdCB0aGlzIHRvIGluc2lkZSBhbiBvdGhlcndpc2Ugc3luY2hyb25vdXMgbG9vcCB0b1xuICogcHJvdmlkZSBhIHBsYWNlIHRvIGJyZWFrIHdoZW4gYW4gYWJvcnQgc2lnbmFsIGlzIHJlY2VpdmVkLlxuICogQHBhcmFtIHtBYm9ydFNpZ25hbH0gc2lnbmFsXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhYm9ydEJyZWFrUG9pbnQoc2lnbmFsPzogQWJvcnRTaWduYWwpOiBQcm9taXNlPHZvaWQ+IHtcbiAgYXdhaXQgUHJvbWlzZS5yZXNvbHZlKClcbiAgY2hlY2tBYm9ydFNpZ25hbChzaWduYWwpXG59XG4iXX0=