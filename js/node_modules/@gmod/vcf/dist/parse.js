"use strict";var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));var _vcfReserved = _interopRequireDefault(require("./vcfReserved"));var

Breakend = /*#__PURE__*/function () {function Breakend() {(0, _classCallCheck2.default)(this, Breakend);}(0, _createClass2.default)(Breakend, [{ key: "toString", value: function toString()
    {
      var char = this.MateDirection === 'left' ? ']' : '[';
      if (this.Join === 'left') {
        return "".concat(char).concat(this.MatePosition).concat(char).concat(this.Replacement);
      }
      return "".concat(this.Replacement).concat(char).concat(this.MatePosition).concat(char);
    } }]);return Breakend;}();


/**
                                * Class representing a VCF parser, instantiated with the VCF header.
                                * @param {object} args
                                * @param {string} args.header - The VCF header. Supports both LF and CRLF
                                * newlines.
                                * @param {boolean} args.strict - Whether to parse in strict mode or not (default true)
                                */var
VCF = /*#__PURE__*/function () {
  function VCF(args) {var _this = this;(0, _classCallCheck2.default)(this, VCF);
    if (!args || !args.header || !args.header.length) {
      throw new Error('empty header received');
    }
    var headerLines = args.header.split(/[\r\n]+/).filter(function (line) {return line;});
    if (!headerLines.length) {
      throw new Error('no non-empty header lines specified');
    }

    // allow access to the Breakend class in case anybody wants to use it for checking
    this.Breakend = Breakend;
    this.strict = args.strict !== undefined ? args.strict : true; // true by default
    this.metadata = JSON.parse(
    JSON.stringify({
      INFO: _vcfReserved.default.InfoFields,
      FORMAT: _vcfReserved.default.GenotypeFields,
      ALT: _vcfReserved.default.AltTypes,
      FILTER: _vcfReserved.default.FilterTypes }));


    headerLines.forEach(function (line) {
      if (!line.startsWith('#')) {
        throw new Error("Bad line in header:\n".concat(line));
      }
      if (line.startsWith('##')) {
        _this._parseMetadata(line);
      } else if (line) {
        var fields = line.split('\t');
        var thisHeader = fields.slice(0, 8);
        var correctHeader = [
        '#CHROM',
        'POS',
        'ID',
        'REF',
        'ALT',
        'QUAL',
        'FILTER',
        'INFO'];

        if (fields.length < 8) {
          throw new Error("VCF header missing columns:\n".concat(line));
        } else if (fields.length === 9) {
          throw new Error("VCF header has FORMAT but no samples:\n".concat(line));
        } else if (
        thisHeader.length !== correctHeader.length ||
        !thisHeader.every(function (value, index) {return value === correctHeader[index];}))
        {
          throw new Error("VCF column headers not correct:\n".concat(line));
        }
        _this.samples = fields.slice(9);
      }
    });
    if (!this.samples) throw new Error('VCF does not have a header line');
  }

  /**
     * Parse a VCF metadata line (i.e. a line that starts with "##") and add its
     * properties to the object.
     * @param {string} line - A line from the VCF. Supports both LF and CRLF
     * newlines.
     */(0, _createClass2.default)(VCF, [{ key: "_parseMetadata", value: function _parseMetadata(
    line) {var _line$trim$match$slic =
      line.
      trim().
      match(/^##(.+?)=(.*)/).
      slice(1, 3),_line$trim$match$slic2 = (0, _slicedToArray2.default)(_line$trim$match$slic, 2),metaKey = _line$trim$match$slic2[0],metaVal = _line$trim$match$slic2[1];
      if (metaVal.startsWith('<')) {
        if (!(metaKey in this.metadata)) {
          this.metadata[metaKey] = {};
        }var _this$_parseStructure =
        this._parseStructuredMetaVal(metaVal),_this$_parseStructure2 = (0, _slicedToArray2.default)(_this$_parseStructure, 2),id = _this$_parseStructure2[0],keyVals = _this$_parseStructure2[1];
        this.metadata[metaKey][id] = keyVals;
      } else {
        this.metadata[metaKey] = metaVal;
      }
    }

    /**
       * Parse a VCF header structured meta string (i.e. a meta value that starts
       * with "<ID=...")
       * @param {string} metaVal - The VCF metadata value
       *
       * @returns {Array} - Array with two entries, 1) a string of the metadata ID
       * and 2) an object with the other key-value pairs in the metadata
       */ }, { key: "_parseStructuredMetaVal", value: function _parseStructuredMetaVal(
    metaVal) {
      var keyVals = this._parseKeyValue(metaVal.replace(/^<|>$/g, ''), ',');
      var id = keyVals.ID;
      delete keyVals.ID;
      if ('Number' in keyVals) {
        if (!Number.isNaN(Number(keyVals.Number))) {
          keyVals.Number = Number(keyVals.Number);
        }
      }
      return [id, keyVals];
    }

    /**
       * Get metadata filtered by the elements in args. For example, can pass
       * ('INFO', 'DP') to only get info on an metadata tag that was like
       * "##INFO=<ID=DP,...>"
       * @param  {...string} args - List of metadata filter strings.
       *
       * @returns {any} An object, string, or number, depending on the filtering
       */ }, { key: "getMetadata", value: function getMetadata()
    {
      var filteredMetadata = this.metadata;for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {args[_key] = arguments[_key];}
      for (var i = 0; i < args.length; i += 1) {
        filteredMetadata = filteredMetadata[args[i]];
        if (!filteredMetadata) return filteredMetadata;
      }
      return filteredMetadata;
    }

    /**
       * Sometimes VCFs have key-value strings that allow the separator within
       * the value if it's in quotes, like:
       * 'ID=DB,Number=0,Type=Flag,Description="dbSNP membership, build 129"'
       *
       * Parse this at a low level since we can't just split at "," (or whatever
       * separator). Above line would be parsed to:
       * {ID: 'DB', Number: '0', Type: 'Flag', Description: 'dbSNP membership, build 129'}
       * @param {string} str - Key-value pairs in a string
       * @param {string} [pairSeparator] - A string that separates sets of key-value
       * pairs
       *
       * @returns {object} An object containing the key-value pairs
       */ }, { key: "_parseKeyValue", value: function _parseKeyValue(
    str) {var pairSeparator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ';';
      var data = {};
      var currKey = '';
      var currValue = '';
      var state = 1; // states: 1: read key to = or pair sep, 2: read value to sep or quote, 3: read value to quote
      for (var i = 0; i < str.length; i += 1) {
        if (state === 1) {
          // read key to = or pair sep
          if (str[i] === '=') {
            state = 2;
          } else if (str[i] !== pairSeparator) {
            currKey += str[i];
          } else if (currValue === '') {
            data[currKey] = null;
            currKey = '';
          }
        } else if (state === 2) {
          // read value to pair sep or quote
          if (str[i] === pairSeparator) {
            data[currKey] = currValue;
            currKey = '';
            currValue = '';
            state = 1;
          } else if (str[i] === '"') {
            state = 3;
          } else currValue += str[i];
        } else if (state === 3) {
          // read value to quote
          if (str[i] !== '"') currValue += str[i];else
          state = 2;
        }
      }
      if (state === 2 || state === 3) {
        data[currKey] = currValue;
      } else if (state === 1) {
        data[currKey] = null;
      }
      return data;
    }

    /**
       * Parse a VCF line into an object like { CHROM POS ID REF ALT QUAL FILTER
       * INFO } with SAMPLES optionally included if present in the VCF
       * @param {string} line - A string of a line from a VCF. Supports both LF and
       * CRLF newlines.
       */ }, { key: "parseLine", value: function parseLine(
    line) {var _this2 = this;
      // eslint-disable-next-line no-param-reassign
      line = line.trim();
      if (!line.length) return undefined;
      var currChar = 0;
      for (var currField = 0; currChar < line.length; currChar += 1) {
        if (line[currChar] === '\t') {
          currField += 1;
        }
        if (currField === 9) {
          // reached genotypes, rest of fields are evaluated lazily
          break;
        }
      }
      var fields = line.substr(0, currChar).split('\t');
      var rest = line.substr(currChar + 1);
      var variant = {
        CHROM: fields[0],
        POS: Number(fields[1]),
        ID: fields[2] === '.' ? null : fields[2].split(';'),
        REF: fields[3],
        ALT: fields[4] === '.' ? null : fields[4].split(','),
        QUAL: fields[5] === '.' ? null : parseFloat(fields[5]) };

      if (fields[6] === '.') {
        variant.FILTER = null;
      } else if (fields[6] === 'PASS') {
        variant.FILTER = 'PASS';
      } else {
        variant.FILTER = fields[6].split(';');
      }
      if (this.strict && fields[7] === undefined) {
        throw new Error(
        "no INFO field specified, must contain at least a '.' (turn off strict mode to allow)");

      }
      var info =
      fields[7] === undefined || fields[7] === '.' ?
      {} :
      this._parseKeyValue(fields[7]);
      Object.keys(info).forEach(function (key) {
        var items;
        if (info[key]) {
          items = info[key].split(',');
          items = items.map(function (val) {return val === '.' ? null : val;});
        } else items = info[key];
        var itemType = _this2.getMetadata('INFO', key, 'Type');
        if (itemType) {
          if (itemType === 'Integer' || itemType === 'Float') {
            items = items.map(function (val) {
              if (val === null) return null;
              return Number(val);
            });
          } else if (itemType === 'Flag') {
            if (info[key])
              // eslint-disable-next-line no-console
              console.warn("Info field ".concat(
              key, " is a Flag and should not have a value (got value ").concat(info[key], ")"));else

            items = true;
          }
        }
        info[key] = items;
      });
      variant.INFO = info;

      // if this has SVTYPE=BND, parse ALTS for breakend descriptions
      if (variant.ALT && info && info.SVTYPE && info.SVTYPE[0] === 'BND') {
        variant.ALT = variant.ALT.map(this._parseBreakend.bind(this));
      }

      // This creates a closure that allows us to attach "SAMPLES" as a lazy
      // attribute

      function Variant(stuff) {
        Object.assign(this, stuff);
      }

      var that = this;

      Object.defineProperty(Variant.prototype, 'SAMPLES', {
        get: function get() {
          var samples = that._parseGenotypes(fields[8], rest);

          Object.defineProperty(this, 'SAMPLES', {
            value: samples });


          return samples;
        } });


      return new Variant(variant);
    } }, { key: "_parseBreakend", value: function _parseBreakend(

    breakendString) {
      var tokens = breakendString.split(/[[\]]/);
      if (tokens.length > 1) {
        var parsed = new Breakend();
        parsed.MateDirection = breakendString.includes('[') ? 'right' : 'left';
        for (var i = 0; i < tokens.length; i += 1) {
          var tok = tokens[i];
          if (tok) {
            if (tok.includes(':')) {
              // this is the remote location
              parsed.MatePosition = tok;
              parsed.Join = parsed.Replacement ? 'right' : 'left';
            } else {
              // this is the local alteration
              parsed.Replacement = tok;
            }
          }
        }
        return parsed;
      }
      // if there is not more than one token, there are no [ or ] characters,
      // so just return it unmodified
      return breakendString;
    } }, { key: "_parseGenotypes", value: function _parseGenotypes(

    formatKeys, rest) {var _this3 = this;
      // eslint-disable-next-line no-param-reassign
      rest = rest.split('\t');
      var genotypes = {};
      // eslint-disable-next-line no-param-reassign
      formatKeys = formatKeys && formatKeys.split(':');
      this.samples.forEach(function (sample, index) {
        genotypes[sample] = {};
        formatKeys.forEach(function (key) {
          genotypes[sample][key] = null;
        });
        rest[index].split(':').forEach(function (formatValue, formatIndex) {
          var thisValue;
          if (
          formatValue === '' ||
          formatValue === '.' ||
          formatValue === undefined)
          {
            thisValue = null;
          } else {
            thisValue = formatValue.
            split(',').
            map(function (val) {return val === '.' ? null : val;});
            var valueType = _this3.getMetadata(
            'FORMAT',
            formatKeys[formatIndex],
            'Type');

            if ((valueType === 'Integer' || valueType === 'Float') && thisValue) {
              thisValue = thisValue.map(function (val) {
                if (!val) return null;
                return Number(val);
              });
            }
          }
          genotypes[sample][formatKeys[formatIndex]] = thisValue;
        }, {});
      });
      return genotypes;
    } }]);return VCF;}();


module.exports = VCF;