"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");

var _promise = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/promise"));

var _values = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/values"));

var _keys = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/keys"));

var _maxSafeInteger = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/number/max-safe-integer"));

var _regenerator = _interopRequireDefault(require("@babel/runtime-corejs2/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/createClass"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/toConsumableArray"));

var Long = require('long');

var _require = require('@gmod/binary-parser'),
    Parser = _require.Parser;

var fs = // eslint-disable-next-line camelcase
typeof __webpack_require__ !== 'function' ? require('fs-extra') : undefined;
var TWOBIT_MAGIC = 0x1a412743;

function tinyMemoize(_class, methodName) {
  var method = _class.prototype[methodName];
  var memoAttrName = "_memo_".concat(methodName);

  _class.prototype[methodName] = function _tinyMemoized() {
    if (!(memoAttrName in this)) this[memoAttrName] = method.call(this);
    return this[memoAttrName];
  };
}

var twoBit = ['T', 'C', 'A', 'G']; // byteTo4Bases is an array of byteValue -> 'ACTG'
// the weird `...keys()` incantation generates an array of numbers 0 to 255

var byteTo4Bases = (0, _toConsumableArray2.default)(Array(256).keys()).map(function (x, i) {
  return twoBit[i >> 6 & 3] + twoBit[i >> 4 & 3] + twoBit[i >> 2 & 3] + twoBit[i & 3];
});
var maskedByteTo4Bases = byteTo4Bases.map(function (bases) {
  return bases.toLowerCase();
}); // LocalFile is pretty much just an implementation of the node 10+ fs.promises filehandle,
// can switch to that when the API is stable

var LocalFile =
/*#__PURE__*/
function () {
  function LocalFile(path) {
    (0, _classCallCheck2.default)(this, LocalFile);
    this.fdPromise = fs.open(path, 'r');
  }

  (0, _createClass2.default)(LocalFile, [{
    key: "read",
    value: function () {
      var _read = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee(buf, offset, length, position) {
        var fd;
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this.fdPromise;

              case 2:
                fd = _context.sent;
                return _context.abrupt("return", fs.read(fd, buf, offset, length, position));

              case 4:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function read(_x, _x2, _x3, _x4) {
        return _read.apply(this, arguments);
      }

      return read;
    }()
  }]);
  return LocalFile;
}();

var TwoBitFile =
/*#__PURE__*/
function () {
  /**
   * @param {object} args
   * @param {string} [args.path] filesystem path for the .2bit file to open
   * @param {Filehandle} [args.filehandle] node fs.promises-like filehandle for the .2bit file.
   *  Only needs to support `filehandle.read(buffer, offset, length, position)`
   */
  function TwoBitFile(_ref) {
    var filehandle = _ref.filehandle,
        path = _ref.path,
        seqChunkSize = _ref.seqChunkSize;
    (0, _classCallCheck2.default)(this, TwoBitFile);
    if (filehandle) this.filehandle = filehandle;else if (path) this.filehandle = new LocalFile(path);
    this.isBigEndian = undefined;
    this.seqChunkSize = seqChunkSize || 32000;
  }

  (0, _createClass2.default)(TwoBitFile, [{
    key: "_getParser",
    value: function () {
      var _getParser2 = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee2(name) {
        var parser;
        return _regenerator.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this._getParsers();

              case 2:
                _context2.t0 = name;
                parser = _context2.sent[_context2.t0];

                if (parser) {
                  _context2.next = 6;
                  break;
                }

                throw new Error("parser ".concat(name, " not found"));

              case 6:
                return _context2.abrupt("return", parser);

              case 7:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function _getParser(_x5) {
        return _getParser2.apply(this, arguments);
      }

      return _getParser;
    }()
  }, {
    key: "_detectEndianness",
    value: function () {
      var _detectEndianness2 = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee3() {
        var _ref2, buffer;

        return _regenerator.default.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this.filehandle.read(Buffer.allocUnsafe(8), 0, 8, 0);

              case 2:
                _ref2 = _context3.sent;
                buffer = _ref2.buffer;

                if (!(buffer.readInt32LE(0) === TWOBIT_MAGIC)) {
                  _context3.next = 9;
                  break;
                }

                this.isBigEndian = false;
                this.version = buffer.readInt32LE(4);
                _context3.next = 15;
                break;

              case 9:
                if (!(buffer.readInt32BE(0) === TWOBIT_MAGIC)) {
                  _context3.next = 14;
                  break;
                }

                this.isBigEndian = true;
                this.version = buffer.readInt32BE(4);
                _context3.next = 15;
                break;

              case 14:
                throw new Error('not a 2bit file');

              case 15:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function _detectEndianness() {
        return _detectEndianness2.apply(this, arguments);
      }

      return _detectEndianness;
    }() // memoize

    /**
     * @private
     * detects the file's endianness and instantiates our binary parsers accordingly
     */

  }, {
    key: "_getParsers",
    value: function () {
      var _getParsers2 = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee4() {
        var endianess, lebe, indexEntryParser, header;
        return _regenerator.default.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this._detectEndianness();

              case 2:
                endianess = this.isBigEndian ? 'big' : 'little';
                lebe = this.isBigEndian ? 'be' : 'le';
                indexEntryParser = new Parser().endianess(endianess).uint8('nameLength').string('name', {
                  length: 'nameLength'
                });

                if (this.version === 1) {
                  indexEntryParser = indexEntryParser.buffer('offsetBytes', {
                    length: 8
                  });
                } else {
                  indexEntryParser = indexEntryParser.uint32('offset');
                }
                /* istanbul ignore next */


                header = new Parser().endianess(endianess).int32('magic', {
                  assert: function assert(m) {
                    return m === 0x1a412743;
                  }
                }).int32('version', {
                  /* istanbul ignore next */
                  assert: function assert(v) {
                    return v === 0 || v === 1;
                  }
                }).uint32('sequenceCount', {
                  /* istanbul ignore next */
                  assert: function assert(v) {
                    return v >= 0;
                  }
                }).uint32('reserved');
                return _context4.abrupt("return", {
                  header: header,
                  index: new Parser().endianess(endianess).uint32('sequenceCount').uint32('reserved').array('index', {
                    length: 'sequenceCount',
                    type: indexEntryParser
                  }),
                  record1: new Parser().endianess(endianess).uint32('dnaSize').uint32('nBlockCount'),
                  record2: new Parser().endianess(endianess).uint32('nBlockCount').array('nBlockStarts', {
                    length: 'nBlockCount',
                    type: "uint32".concat(lebe)
                  }).array('nBlockSizes', {
                    length: 'nBlockCount',
                    type: "uint32".concat(lebe)
                  }).uint32('maskBlockCount'),
                  record3: new Parser().endianess(endianess).uint32('maskBlockCount').array('maskBlockStarts', {
                    length: 'maskBlockCount',
                    type: "uint32".concat(lebe)
                  }).array('maskBlockSizes', {
                    length: 'maskBlockCount',
                    type: "uint32".concat(lebe)
                  }).int32('reserved') // .buffer('packedDna', { length: 'dnaSize' }),

                });

              case 8:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function _getParsers() {
        return _getParsers2.apply(this, arguments);
      }

      return _getParsers;
    }() // memoize

    /**
     * @returns {Promise} for object with the file's header information, like
     *  `{ magic: 0x1a412743, version: 0, sequenceCount: 42, reserved: 0 }`
     */

  }, {
    key: "getHeader",
    value: function () {
      var _getHeader = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee5() {
        var _ref3, buffer, headerParser;

        return _regenerator.default.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return this._detectEndianness();

              case 2:
                _context5.next = 4;
                return this.filehandle.read(Buffer.allocUnsafe(16), 0, 16, 0);

              case 4:
                _ref3 = _context5.sent;
                buffer = _ref3.buffer;
                _context5.next = 8;
                return this._getParser('header');

              case 8:
                headerParser = _context5.sent;
                return _context5.abrupt("return", headerParser.parse(buffer).result);

              case 10:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function getHeader() {
        return _getHeader.apply(this, arguments);
      }

      return getHeader;
    }() // memoize

    /**
     * @returns {Promise} for object with the file's index of offsets, like `{ seqName: fileOffset, ...}`
     */

  }, {
    key: "getIndex",
    value: function () {
      var _getIndex = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee6() {
        var _this = this;

        var header, maxIndexLength, _ref4, buffer, indexParser, indexData, index;

        return _regenerator.default.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return this.getHeader();

              case 2:
                header = _context6.sent;
                maxIndexLength = 8 + header.sequenceCount * (1 + 256 + (this.version === 1 ? 8 : 4));
                _context6.next = 6;
                return this.filehandle.read(Buffer.allocUnsafe(maxIndexLength), 0, maxIndexLength, 8);

              case 6:
                _ref4 = _context6.sent;
                buffer = _ref4.buffer;
                _context6.next = 10;
                return this._getParser('index');

              case 10:
                indexParser = _context6.sent;
                indexData = indexParser.parse(buffer).result.index;
                index = {};

                if (this.version === 1) {
                  indexData.forEach(function (_ref5) {
                    var name = _ref5.name,
                        offsetBytes = _ref5.offsetBytes;
                    var long = Long.fromBytes(offsetBytes, true, !_this.isBigEndian);
                    if (long.greaterThan(_maxSafeInteger.default)) throw new Error('integer overflow. File offset greater than 2^53-1 encountered. This library can only handle offsets up to 2^53-1.');
                    index[name] = long.toNumber();
                  });
                } else {
                  indexData.forEach(function (_ref6) {
                    var name = _ref6.name,
                        offset = _ref6.offset;
                    index[name] = offset;
                  });
                }

                return _context6.abrupt("return", index);

              case 15:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function getIndex() {
        return _getIndex.apply(this, arguments);
      }

      return getIndex;
    }()
    /**
     * @returns {Promise} for an array of string sequence names that are found in the file
     */

  }, {
    key: "getSequenceNames",
    value: function () {
      var _getSequenceNames = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee7() {
        var index;
        return _regenerator.default.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return this.getIndex();

              case 2:
                index = _context7.sent;
                return _context7.abrupt("return", (0, _keys.default)(index));

              case 4:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function getSequenceNames() {
        return _getSequenceNames.apply(this, arguments);
      }

      return getSequenceNames;
    }()
    /**
     * @returns {Promise} for an object listing the lengths of all sequences like `{seqName: length, ...}`
     */

  }, {
    key: "getSequenceSizes",
    value: function () {
      var _getSequenceSizes = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee8() {
        var _this2 = this;

        var index, seqNames, sizePromises, sizes, returnObject, i;
        return _regenerator.default.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.next = 2;
                return this.getIndex();

              case 2:
                index = _context8.sent;
                seqNames = (0, _keys.default)(index);
                sizePromises = (0, _values.default)(index).map(function (offset) {
                  return _this2._getSequenceSize(offset);
                });
                _context8.next = 7;
                return _promise.default.all(sizePromises);

              case 7:
                sizes = _context8.sent;
                returnObject = {};

                for (i = 0; i < seqNames.length; i += 1) {
                  returnObject[seqNames[i]] = sizes[i];
                }

                return _context8.abrupt("return", returnObject);

              case 11:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function getSequenceSizes() {
        return _getSequenceSizes.apply(this, arguments);
      }

      return getSequenceSizes;
    }()
    /**
     * @param {string} seqName name of the sequence
     * @returns {Promise} for the sequence's length, or undefined if it is not in the file
     */

  }, {
    key: "getSequenceSize",
    value: function () {
      var _getSequenceSize2 = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee9(seqName) {
        var index, offset;
        return _regenerator.default.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                _context9.next = 2;
                return this.getIndex();

              case 2:
                index = _context9.sent;
                offset = index[seqName];

                if (offset) {
                  _context9.next = 6;
                  break;
                }

                return _context9.abrupt("return", undefined);

              case 6:
                return _context9.abrupt("return", this._getSequenceSize(offset));

              case 7:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function getSequenceSize(_x6) {
        return _getSequenceSize2.apply(this, arguments);
      }

      return getSequenceSize;
    }()
  }, {
    key: "_getSequenceSize",
    value: function () {
      var _getSequenceSize3 = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee10(offset) {
        var rec1;
        return _regenerator.default.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                if (!(offset === undefined || offset < 0)) {
                  _context10.next = 2;
                  break;
                }

                throw new Error('invalid offset');

              case 2:
                _context10.next = 4;
                return this._parseItem(offset, 8, 'record1');

              case 4:
                rec1 = _context10.sent;
                return _context10.abrupt("return", rec1.dnaSize);

              case 6:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function _getSequenceSize(_x7) {
        return _getSequenceSize3.apply(this, arguments);
      }

      return _getSequenceSize;
    }()
  }, {
    key: "_getSequenceRecord",
    value: function () {
      var _getSequenceRecord2 = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee11(offset) {
        var rec1, rec2DataLength, rec2, rec3DataLength, rec3, rec;
        return _regenerator.default.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                if (!(offset === undefined || offset < 0)) {
                  _context11.next = 2;
                  break;
                }

                throw new Error('invalid offset');

              case 2:
                _context11.next = 4;
                return this._parseItem(offset, 8, 'record1');

              case 4:
                rec1 = _context11.sent;
                rec2DataLength = rec1.nBlockCount * 8 + 8;
                _context11.next = 8;
                return this._parseItem(offset + 4, rec2DataLength, 'record2');

              case 8:
                rec2 = _context11.sent;
                rec3DataLength = rec2.maskBlockCount * 8 + 8;
                _context11.next = 12;
                return this._parseItem(offset + 4 + rec2DataLength - 4, rec3DataLength, 'record3');

              case 12:
                rec3 = _context11.sent;
                rec = {
                  dnaSize: rec1.dnaSize,
                  nBlocks: {
                    starts: rec2.nBlockStarts,
                    sizes: rec2.nBlockSizes
                  },
                  maskBlocks: {
                    starts: rec3.maskBlockStarts,
                    sizes: rec3.maskBlockSizes
                  },
                  dnaPosition: offset + 4 + rec2DataLength - 4 + rec3DataLength
                };
                return _context11.abrupt("return", rec);

              case 15:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function _getSequenceRecord(_x8) {
        return _getSequenceRecord2.apply(this, arguments);
      }

      return _getSequenceRecord;
    }()
  }, {
    key: "_parseItem",
    value: function () {
      var _parseItem2 = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee12(offset, length, parserName) {
        var _ref7, buffer, parser;

        return _regenerator.default.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                _context12.next = 2;
                return this.filehandle.read(Buffer.allocUnsafe(length), 0, length, offset);

              case 2:
                _ref7 = _context12.sent;
                buffer = _ref7.buffer;
                _context12.next = 6;
                return this._getParser(parserName);

              case 6:
                parser = _context12.sent;
                return _context12.abrupt("return", parser.parse(buffer).result);

              case 8:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function _parseItem(_x9, _x10, _x11) {
        return _parseItem2.apply(this, arguments);
      }

      return _parseItem;
    }()
    /**
     * @param {string} seqName name of the sequence you want
     * @param {number} [regionStart] optional 0-based half-open start of the sequence region to fetch.
     * @param {number} [regionEnd] optional 0-based half-open end of the sequence region to fetch. defaults to end of the sequence
     * @returns {Promise} for a string of sequence bases
     */

  }, {
    key: "getSequence",
    value: function () {
      var _getSequence = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee13(seqName) {
        var regionStart,
            regionEnd,
            index,
            offset,
            record,
            nBlocks,
            maskBlocks,
            baseBytes,
            baseBytesOffset,
            _ref8,
            buffer,
            sequenceBases,
            genomicPosition,
            baseIsMasked,
            currentNBlock,
            bytePosition,
            subPosition,
            byte,
            _args13 = arguments;

        return _regenerator.default.wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                regionStart = _args13.length > 1 && _args13[1] !== undefined ? _args13[1] : 0;
                regionEnd = _args13.length > 2 ? _args13[2] : undefined;
                _context13.next = 4;
                return this.getIndex();

              case 4:
                index = _context13.sent;
                offset = index[seqName];

                if (offset) {
                  _context13.next = 8;
                  break;
                }

                return _context13.abrupt("return", undefined);

              case 8:
                _context13.next = 10;
                return this._getSequenceRecord(offset);

              case 10:
                record = _context13.sent;

                if (!(regionStart < 0)) {
                  _context13.next = 13;
                  break;
                }

                throw new TypeError('regionStart cannot be less than 0');

              case 13:
                // end defaults to the end of the sequence
                if (regionEnd === undefined || regionEnd > record.dnaSize) {
                  regionEnd = record.dnaSize;
                }

                nBlocks = this._getOverlappingBlocks(regionStart, regionEnd, record.nBlocks.starts, record.nBlocks.sizes);
                maskBlocks = this._getOverlappingBlocks(regionStart, regionEnd, record.maskBlocks.starts, record.maskBlocks.sizes);
                baseBytes = Buffer.allocUnsafe(Math.ceil((regionEnd - regionStart) / 4) + 1);
                baseBytesOffset = Math.floor(regionStart / 4);
                _context13.next = 20;
                return this.filehandle.read(baseBytes, 0, baseBytes.length, record.dnaPosition + baseBytesOffset);

              case 20:
                _ref8 = _context13.sent;
                buffer = _ref8.buffer;
                sequenceBases = '';

                for (genomicPosition = regionStart; genomicPosition < regionEnd; genomicPosition += 1) {
                  // check whether we are currently masked
                  while (maskBlocks.length && maskBlocks[0].end <= genomicPosition) {
                    maskBlocks.shift();
                  }

                  baseIsMasked = maskBlocks[0] && maskBlocks[0].start <= genomicPosition && maskBlocks[0].end > genomicPosition; // process the N block if we have one

                  if (nBlocks[0] && genomicPosition >= nBlocks[0].start && genomicPosition < nBlocks[0].end) {
                    currentNBlock = nBlocks.shift();

                    for (; genomicPosition < currentNBlock.end && genomicPosition < regionEnd; genomicPosition += 1) {
                      sequenceBases += baseIsMasked ? 'n' : 'N';
                    }

                    genomicPosition -= 1;
                  } else {
                    bytePosition = Math.floor(genomicPosition / 4) - baseBytesOffset;
                    subPosition = genomicPosition % 4;
                    byte = buffer[bytePosition];
                    sequenceBases += baseIsMasked ? maskedByteTo4Bases[byte][subPosition] : byteTo4Bases[byte][subPosition];
                  }
                }

                return _context13.abrupt("return", sequenceBases);

              case 25:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      function getSequence(_x12) {
        return _getSequence.apply(this, arguments);
      }

      return getSequence;
    }()
  }, {
    key: "_getOverlappingBlocks",
    value: function _getOverlappingBlocks(regionStart, regionEnd, blockStarts, blockSizes) {
      // find the start and end indexes of the blocks that match
      var startIndex;
      var endIndex;

      for (var i = 0; i < blockStarts.length; i += 1) {
        var blockStart = blockStarts[i];
        var blockSize = blockSizes[i];

        if (regionStart >= blockStart + blockSize || regionEnd <= blockStart) {
          // block does not overlap the region
          if (startIndex !== undefined) {
            endIndex = i;
            break;
          }
        } else if (startIndex === undefined) startIndex = i; // block does overlap the region, record this if it is the first

      }

      if (startIndex === undefined) return []; // now format some block objects to return

      if (endIndex === undefined) endIndex = blockStarts.length;
      var blocks = new Array(endIndex - startIndex);

      for (var blockNum = startIndex; blockNum < endIndex; blockNum += 1) {
        blocks[blockNum - startIndex] = {
          start: blockStarts[blockNum],
          end: blockStarts[blockNum] + blockSizes[blockNum],
          size: blockSizes[blockNum]
        };
      }

      return blocks;
    }
  }]);
  return TwoBitFile;
}();

tinyMemoize(TwoBitFile, '_getParsers');
tinyMemoize(TwoBitFile, 'getIndex');
tinyMemoize(TwoBitFile, 'getHeader');
module.exports = TwoBitFile;