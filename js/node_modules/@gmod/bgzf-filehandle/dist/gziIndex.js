"use strict";var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));var Long = require('long');
var LocalFile = require('./localFile');

// const COMPRESSED_POSITION = 0
var UNCOMPRESSED_POSITION = 1;var

GziIndex = /*#__PURE__*/function () {
  function GziIndex(_ref) {var filehandle = _ref.filehandle,path = _ref.path;(0, _classCallCheck2.default)(this, GziIndex);
    if (filehandle) this.filehandle = filehandle;else
    if (path) this.filehandle = new LocalFile(path);else
    throw new TypeError('either filehandle or path must be defined');
  }(0, _createClass2.default)(GziIndex, [{ key: "_readLongWithOverflow", value: function _readLongWithOverflow(

    buf) {var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;var unsigned = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      var long = Long.fromBytesLE(buf.slice(offset, offset + 8), unsigned);
      if (
      long.greaterThan(Number.MAX_SAFE_INTEGER) ||
      long.lessThan(Number.MIN_SAFE_INTEGER))

      throw new TypeError('integer overflow');

      return long.toNumber();
    } }, { key: "_getIndex", value: function _getIndex()

    {
      if (!this.index) this.index = this._readIndex();
      return this.index;
    } }, { key: "_readIndex", value: function () {var _readIndex2 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee() {var buf, numEntries, entries, bufSize, entryNumber, compressedPosition, uncompressedPosition;return _regenerator.default.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:


                buf = Buffer.allocUnsafe(8);_context.next = 3;return (
                  this.filehandle.read(buf, 0, 8, 0));case 3:
                numEntries = this._readLongWithOverflow(buf, 0, true);if (
                numEntries) {_context.next = 6;break;}return _context.abrupt("return", [[0, 0]]);case 6:

                entries = new Array(numEntries + 1);
                entries[0] = [0, 0];

                // TODO rewrite this to make an index-index that stays in memory
                bufSize = 8 * 2 * numEntries;if (!(
                bufSize > Number.MAX_SAFE_INTEGER)) {_context.next = 11;break;}throw (
                  new TypeError('integer overflow'));case 11:
                buf = Buffer.allocUnsafe(bufSize);_context.next = 14;return (
                  this.filehandle.read(buf, 0, bufSize, 8));case 14:
                for (entryNumber = 0; entryNumber < numEntries; entryNumber += 1) {
                  compressedPosition = this._readLongWithOverflow(
                  buf,
                  entryNumber * 16);

                  uncompressedPosition = this._readLongWithOverflow(
                  buf,
                  entryNumber * 16 + 8);

                  entries[entryNumber + 1] = [compressedPosition, uncompressedPosition];
                }return _context.abrupt("return",

                entries);case 16:case "end":return _context.stop();}}}, _callee, this);}));function _readIndex() {return _readIndex2.apply(this, arguments);}return _readIndex;}()


    /**
                                                                                                                                                                                    * @returns {object} the entry for the last block in the index
                                                                                                                                                                                    */ }, { key: "getLastBlock", value: function () {var _getLastBlock = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2() {var entries;return _regenerator.default.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:_context2.next = 2;return (

                  this._getIndex());case 2:entries = _context2.sent;if (
                entries.length) {_context2.next = 5;break;}return _context2.abrupt("return", undefined);case 5:return _context2.abrupt("return",
                entries[entries.length - 1]);case 6:case "end":return _context2.stop();}}}, _callee2, this);}));function getLastBlock() {return _getLastBlock.apply(this, arguments);}return getLastBlock;}()


    /**
                                                                                                                                                                                                               * get an array of block records that must be read to execute
                                                                                                                                                                                                               * the given virtual read operation
                                                                                                                                                                                                               *
                                                                                                                                                                                                               * @param {number} position uncompressed read position
                                                                                                                                                                                                               * @param {number} length uncompressed read length
                                                                                                                                                                                                               * @returns {Promise} for an array of block records, the
                                                                                                                                                                                                               * last of which should *not* be included in the read
                                                                                                                                                                                                               */ }, { key: "getRelevantBlocksForRead", value: function () {var _getRelevantBlocksForRead = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee3(
      length, position) {var endPosition, entries, relevant, compare, lowerBound, upperBound, searchPosition, comparison, i;return _regenerator.default.wrap(function _callee3$(_context3) {while (1) {switch (_context3.prev = _context3.next) {case 0:
                endPosition = position + length;if (!(
                length === 0)) {_context3.next = 3;break;}return _context3.abrupt("return", []);case 3:_context3.next = 5;return (
                  this._getIndex());case 5:entries = _context3.sent;
                relevant = [];

                // binary search to find the block that the
                // read starts in and extend forward from that
                compare = function compare(entry, nextEntry) {
                  var uncompressedPosition = entry[UNCOMPRESSED_POSITION];
                  var nextUncompressedPosition = nextEntry ?
                  nextEntry[UNCOMPRESSED_POSITION] :
                  Infinity;
                  // block overlaps read start
                  if (
                  uncompressedPosition <= position &&
                  nextUncompressedPosition > position)
                  {
                    return 0;
                    // block is before read start
                  }
                  if (uncompressedPosition < position) {
                    return -1;
                  }
                  // block is after read start
                  return 1;
                };

                lowerBound = 0;
                upperBound = entries.length - 1;
                searchPosition = Math.floor(entries.length / 2);

                comparison = compare(
                entries[searchPosition],
                entries[searchPosition + 1]);

                while (comparison !== 0) {
                  if (comparison > 0) {
                    upperBound = searchPosition - 1;
                  } else if (comparison < 0) {
                    lowerBound = searchPosition + 1;
                  }
                  searchPosition = Math.ceil((upperBound - lowerBound) / 2) + lowerBound;
                  comparison = compare(entries[searchPosition], entries[searchPosition + 1]);
                }

                // here's where we read forward
                relevant.push(entries[searchPosition]);
                i = searchPosition + 1;case 15:if (!(
                i < entries.length)) {_context3.next = 22;break;}
                relevant.push(entries[i]);if (!(
                entries[i][UNCOMPRESSED_POSITION] >= endPosition)) {_context3.next = 19;break;}return _context3.abrupt("break", 22);case 19:i += 1;_context3.next = 15;break;case 22:

                if (relevant[relevant.length - 1][UNCOMPRESSED_POSITION] < endPosition) {
                  relevant.push([]);
                }return _context3.abrupt("return",
                relevant);case 24:case "end":return _context3.stop();}}}, _callee3, this);}));function getRelevantBlocksForRead(_x, _x2) {return _getRelevantBlocksForRead.apply(this, arguments);}return getRelevantBlocksForRead;}()


    // /**
    //  * get a virtual block record giving the position and length of a BGZF region that
    //  * must be read to execute the given virtual read operation
    //  *
    //  * @param {number} position uncompressed file position we would like to start reading at
    //  * @param {number} length number of uncompressed bytes we would like to read
    //  * @returns {object} as `{compressedPosition, uncompressedPosition, compressedSize}`. If
    //  * compressedSize is undefined, the read should end at the end of the file.
    //  */
    // async calculateMultiBlockRead(length, position) {
    //   const entries = await this._getIndex()
    //   const endPosition = position + length
    //   let readStart
    //   let readLength
    //   let readUncompressedStart
    //   for (let i = 0; i < entries.length; i += 1) {
    //     const entry = entries[i]
    //     if (readStart === undefined && entry.uncompressedPosition <= position) {
    //       readStart = entry.compressedPosition
    //       readUncompressedStart = entry.uncompressedPosition
    //     }
    //     if (
    //       readLength === undefined &&
    //       entry.uncompressedPosition >= endPosition
    //     ) {
    //       readLength = entry.compressedPosition - readStart
    //     }
    //   }

    //   return {
    //     compressedPosition: readStart,
    //     uncompressedPosition: readUncompressedStart,
    //     compressedSize: readLength,
    //   }
    // }
  }]);return GziIndex;}();

module.exports = GziIndex;