"use strict";var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));var _require = require('./unzip'),unzip = _require.unzip;
var LocalFile = require('./localFile');
var GziIndex = require('./gziIndex');var

BgzFilehandle = /*#__PURE__*/function () {
  function BgzFilehandle(_ref) {var filehandle = _ref.filehandle,path = _ref.path,gziFilehandle = _ref.gziFilehandle,gziPath = _ref.gziPath;(0, _classCallCheck2.default)(this, BgzFilehandle);
    if (filehandle) this.filehandle = filehandle;else
    if (path) this.filehandle = new LocalFile(path);else
    throw new TypeError('either filehandle or path must be defined');

    if (!gziFilehandle && !gziPath && !path)
    throw new TypeError('either gziFilehandle or gziPath must be defined');

    this.gzi = new GziIndex({
      filehandle: gziFilehandle,
      path: !gziFilehandle && !gziPath && path ? gziPath : "".concat(path, ".gzi") });

  }(0, _createClass2.default)(BgzFilehandle, [{ key: "stat", value: function () {var _stat = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee() {var compressedStat;return _regenerator.default.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:_context.next = 2;return (


                  this.filehandle.stat());case 2:compressedStat = _context.sent;_context.t0 =
                Object;_context.t1 = compressedStat;_context.next = 7;return (
                  this.getUncompressedFileSize());case 7:_context.t2 = _context.sent;_context.t3 =
                undefined;_context.t4 =
                undefined;_context.t5 = { size: _context.t2, blocks: _context.t3, blksize: _context.t4 };return _context.abrupt("return", _context.t0.assign.call(_context.t0, _context.t1, _context.t5));case 12:case "end":return _context.stop();}}}, _callee, this);}));function stat() {return _stat.apply(this, arguments);}return stat;}() }, { key: "getUncompressedFileSize", value: function () {var _getUncompressedFileSize = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2() {var _ref2, _ref3, uncompressedPosition, _ref4, size, buf, _ref5, bytesRead, lastBlockUncompressedSize;return _regenerator.default.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:_context2.next = 2;return (






                  this.gzi.getLastBlock());case 2:_ref2 = _context2.sent;_ref3 = (0, _slicedToArray2.default)(_ref2, 2);uncompressedPosition = _ref3[1];_context2.next = 7;return (

                  this.filehandle.stat());case 7:_ref4 = _context2.sent;size = _ref4.size;

                buf = Buffer.allocUnsafe(4);
                // note: there should be a 28-byte EOF marker (an empty block) at
                // the end of the file, so we skip backward past that
                _context2.next = 12;return this.filehandle.read(buf, 0, 4, size - 28 - 4);case 12:_ref5 = _context2.sent;bytesRead = _ref5.bytesRead;if (!(
                bytesRead !== 4)) {_context2.next = 16;break;}throw new Error('read error');case 16:
                lastBlockUncompressedSize = buf.readUInt32LE(0);return _context2.abrupt("return",
                uncompressedPosition + lastBlockUncompressedSize);case 18:case "end":return _context2.stop();}}}, _callee2, this);}));function getUncompressedFileSize() {return _getUncompressedFileSize.apply(this, arguments);}return getUncompressedFileSize;}() }, { key: "_readAndUncompressBlock", value: function () {var _readAndUncompressBlock2 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee3(



      blockBuffer, _ref6, _ref7) {var _ref8, compressedPosition, _ref9, nextCompressedPosition, next, blockCompressedLength, unzippedBuffer;return _regenerator.default.wrap(function _callee3$(_context3) {while (1) {switch (_context3.prev = _context3.next) {case 0:_ref8 = (0, _slicedToArray2.default)(_ref6, 1),
                compressedPosition = _ref8[0];_ref9 = (0, _slicedToArray2.default)(_ref7, 1),
                nextCompressedPosition = _ref9[0];

                next = nextCompressedPosition;if (
                next) {_context3.next = 7;break;}_context3.next = 6;return (
                  this.filehandle.stat());case 6:next = _context3.sent.size;case 7:


                // read the compressed data into the block buffer
                blockCompressedLength = next - compressedPosition;_context3.next = 10;return (

                  this.filehandle.read(
                  blockBuffer,
                  0,
                  blockCompressedLength,
                  compressedPosition));case 10:_context3.next = 12;return (



                  unzip(
                  blockBuffer.slice(0, blockCompressedLength)));case 12:unzippedBuffer = _context3.sent;return _context3.abrupt("return",


                unzippedBuffer);case 14:case "end":return _context3.stop();}}}, _callee3, this);}));function _readAndUncompressBlock(_x, _x2, _x3) {return _readAndUncompressBlock2.apply(this, arguments);}return _readAndUncompressBlock;}() }, { key: "read", value: function () {var _read = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee4(


      buf, offset, length, position) {var blockPositions, blockBuffer, destinationOffset, bytesRead, blockNum, uncompressedBuffer, _blockPositions$block, uncompressedPosition, sourceOffset, sourceEnd;return _regenerator.default.wrap(function _callee4$(_context4) {while (1) {switch (_context4.prev = _context4.next) {case 0:_context4.next = 2;return (

                  this.gzi.getRelevantBlocksForRead(
                  length,
                  position));case 2:blockPositions = _context4.sent;

                blockBuffer = Buffer.allocUnsafe(32768 * 2);
                // uncompress the blocks and read from them one at a time to keep memory usage down
                destinationOffset = offset;
                bytesRead = 0;

                blockNum = 0;case 7:if (!(
                blockNum < blockPositions.length - 1)) {_context4.next = 18;break;}_context4.next = 10;return (



                  this._readAndUncompressBlock(
                  blockBuffer,
                  blockPositions[blockNum],
                  blockPositions[blockNum + 1]));case 10:uncompressedBuffer = _context4.sent;_blockPositions$block = (0, _slicedToArray2.default)(

                blockPositions[blockNum], 2), uncompressedPosition = _blockPositions$block[1];
                sourceOffset =
                uncompressedPosition >= position ? 0 : position - uncompressedPosition;
                sourceEnd =
                Math.min(
                position + length,
                uncompressedPosition + uncompressedBuffer.length) -
                uncompressedPosition;
                if (sourceOffset >= 0 && sourceOffset < uncompressedBuffer.length) {
                  uncompressedBuffer.copy(buf, destinationOffset, sourceOffset, sourceEnd);
                  destinationOffset += sourceEnd - sourceOffset;
                  bytesRead += sourceEnd - sourceOffset;
                }case 15:blockNum += 1;_context4.next = 7;break;case 18:return _context4.abrupt("return",


                { bytesRead: bytesRead, buffer: buf });case 19:case "end":return _context4.stop();}}}, _callee4, this);}));function read(_x4, _x5, _x6, _x7) {return _read.apply(this, arguments);}return read;}() }]);return BgzFilehandle;}();



module.exports = BgzFilehandle;