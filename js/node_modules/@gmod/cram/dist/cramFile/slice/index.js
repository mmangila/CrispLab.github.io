"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

var _values = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/values"));

var _promise = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/promise"));

var _filter = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/filter"));

var _concat = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/concat"));

var _regenerator = _interopRequireDefault(require("@babel/runtime-corejs3/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/createClass"));

var _flags = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/flags"));

var _forEach = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/for-each"));

var _map = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/map"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/toConsumableArray"));

var _context17;

var _require = require('../../errors'),
    CramMalformedError = _require.CramMalformedError,
    CramBufferOverrunError = _require.CramBufferOverrunError,
    CramArgumentError = _require.CramArgumentError;

var _require2 = require('../util'),
    parseItem = _require2.parseItem,
    tinyMemoize = _require2.tinyMemoize,
    sequenceMD5 = _require2.sequenceMD5;

var Constants = require('../constants');

var decodeRecord = require('./decodeRecord');
/**
 * @private
 * Try to estimate the template length from a bunch of interrelated multi-segment reads.
 * @param {Array[CramRecord]} allRecords
 * @param {number} currentRecordNumber
 * @param {CramRecord} thisRecord
 */


function calculateMultiSegmentMatedTemplateLength(allRecords, currentRecordNumber, thisRecord) {
  function getAllMatedRecords(startRecord) {
    var records = [startRecord];

    if (startRecord.mateRecordNumber >= 0) {
      var mateRecord = allRecords[startRecord.mateRecordNumber];
      if (!mateRecord) throw new CramMalformedError('intra-slice mate record not found, this file seems malformed');
      records.push.apply(records, (0, _toConsumableArray2.default)(getAllMatedRecords(mateRecord)));
    }

    return records;
  }

  var matedRecords = getAllMatedRecords(thisRecord);
  var starts = (0, _map.default)(matedRecords).call(matedRecords, function (r) {
    return r.alignmentStart;
  });
  var ends = (0, _map.default)(matedRecords).call(matedRecords, function (r) {
    return r.alignmentStart + r.readLength - 1;
  });
  var estimatedTemplateLength = Math.max.apply(Math, (0, _toConsumableArray2.default)(ends)) - Math.min.apply(Math, (0, _toConsumableArray2.default)(starts)) + 1;
  if (estimatedTemplateLength >= 0) (0, _forEach.default)(matedRecords).call(matedRecords, function (r) {
    if (r.templateLength !== undefined) throw new CramMalformedError('mate pair group has some members that have template lengths already, this file seems malformed');
    r.templateLength = estimatedTemplateLength;
  });
}
/**
 * @private
 * Attempt to calculate the `templateLength` for a pair of intra-slice paired reads.
 * Ported from htslib. Algorithm is imperfect.
 * @param {CramRecord} thisRecord
 * @param {CramRecord} mateRecord
 */


function calculateIntraSliceMatePairTemplateLength(thisRecord, mateRecord) {
  // this just estimates the template length by using the simple (non-gapped) end coordinate of each
  // read, because gapping in the alignment doesn't mean the template is longer or shorter
  var start = Math.min(thisRecord.alignmentStart, mateRecord.alignmentStart);
  var end = Math.max(thisRecord.alignmentStart + thisRecord.readLength - 1, mateRecord.alignmentStart + mateRecord.readLength - 1);
  var lengthEstimate = end - start + 1;
  thisRecord.templateLength = lengthEstimate;
  mateRecord.templateLength = lengthEstimate;
}
/**
 * @private establishes a mate-pair relationship between two records in the same slice.
 * CRAM compresses mate-pair relationships between records in the same slice down into
 * just one record having the index in the slice of its mate
 */


function associateIntraSliceMate(allRecords, currentRecordNumber, thisRecord, mateRecord) {
  if (!mateRecord) throw new CramMalformedError('could not resolve intra-slice mate pairs, file seems truncated or malformed');
  var complicatedMultiSegment = !!(mateRecord.mate || mateRecord.mateRecordNumber !== undefined && mateRecord.mateRecordNumber !== currentRecordNumber); // Deal with lossy read names

  if (!thisRecord.readName) {
    thisRecord.readName = String(thisRecord.uniqueId);
    mateRecord.readName = thisRecord.readName;
  }

  thisRecord.mate = {
    sequenceId: mateRecord.sequenceId,
    alignmentStart: mateRecord.alignmentStart,
    uniqueId: mateRecord.uniqueId
  };
  if (mateRecord.readName) thisRecord.mate.readName = mateRecord.readName; // the mate record might have its own mate pointer, if this is some kind of
  // multi-segment (more than paired) scheme, so only relate that one back to this one
  // if it does not have any other relationship

  if (!mateRecord.mate && mateRecord.mateRecordNumber === undefined) {
    mateRecord.mate = {
      sequenceId: thisRecord.sequenceId,
      alignmentStart: thisRecord.alignmentStart,
      uniqueId: thisRecord.uniqueId
    };
    if (thisRecord.readName) mateRecord.mate.readName = thisRecord.readName;
  } // make sure the proper flags and cramFlags are set on both records
  // paired


  thisRecord.flags |= Constants.BAM_FPAIRED; // set mate unmapped if needed

  if ((0, _flags.default)(mateRecord) & Constants.BAM_FUNMAP) {
    thisRecord.flags |= Constants.BAM_FMUNMAP; // thisRecord.templateLength = 0
  }

  if ((0, _flags.default)(thisRecord) & Constants.BAM_FUNMAP) {
    // thisRecord.templateLength = 0
    mateRecord.flags |= Constants.BAM_FMUNMAP;
  } // set mate reversed if needed


  if ((0, _flags.default)(mateRecord) & Constants.BAM_FREVERSE) {
    thisRecord.flags |= Constants.BAM_FMREVERSE;
  }

  if ((0, _flags.default)(thisRecord) & Constants.BAM_FREVERSE) {
    mateRecord.flags |= Constants.BAM_FMREVERSE;
  }

  if (thisRecord.templateLength === undefined) {
    if (complicatedMultiSegment) calculateMultiSegmentMatedTemplateLength(allRecords, currentRecordNumber, thisRecord);else calculateIntraSliceMatePairTemplateLength(thisRecord, mateRecord);
  } // delete this last because it's used by the
  // complicated template length estimation


  delete thisRecord.mateRecordNumber;
}

var CramSlice =
/*#__PURE__*/
function () {
  function CramSlice(container, position) {
    (0, _classCallCheck2.default)(this, CramSlice);
    this.container = container;
    this.file = container.file;
    this.containerPosition = position;
  } // memoize


  (0, _createClass2.default)(CramSlice, [{
    key: "getHeader",
    value: function () {
      var _getHeader = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee() {
        var sectionParsers, containerHeader, header;
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this.file.getSectionParsers();

              case 2:
                sectionParsers = _context.sent;
                _context.next = 5;
                return this.container.getHeader();

              case 5:
                containerHeader = _context.sent;
                _context.next = 8;
                return this.file.readBlock(containerHeader._endPosition + this.containerPosition);

              case 8:
                header = _context.sent;

                if (!(header.contentType === 'MAPPED_SLICE_HEADER')) {
                  _context.next = 13;
                  break;
                }

                header.content = parseItem(header.content, sectionParsers.cramMappedSliceHeader.parser, 0, containerHeader._endPosition);
                _context.next = 18;
                break;

              case 13:
                if (!(header.contentType === 'UNMAPPED_SLICE_HEADER')) {
                  _context.next = 17;
                  break;
                }

                header.content = parseItem(header.content, sectionParsers.cramUnmappedSliceHeader.parser, 0, containerHeader._endPosition);
                _context.next = 18;
                break;

              case 17:
                throw new CramMalformedError("error reading slice header block, invalid content type ".concat(header._contentType));

              case 18:
                return _context.abrupt("return", header);

              case 19:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getHeader() {
        return _getHeader.apply(this, arguments);
      }

      return getHeader;
    }() // memoize

  }, {
    key: "getBlocks",
    value: function () {
      var _getBlocks = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee2() {
        var header, blockPosition, blocks, i;
        return _regenerator.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.getHeader();

              case 2:
                header = _context2.sent;
                // read all the blocks into memory and store them
                blockPosition = header._endPosition;
                blocks = new Array(header.content.numBlocks);
                i = 0;

              case 6:
                if (!(i < blocks.length)) {
                  _context2.next = 14;
                  break;
                }

                _context2.next = 9;
                return this.file.readBlock(blockPosition);

              case 9:
                blocks[i] = _context2.sent;
                blockPosition = blocks[i]._endPosition;

              case 11:
                i += 1;
                _context2.next = 6;
                break;

              case 14:
                return _context2.abrupt("return", blocks);

              case 15:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getBlocks() {
        return _getBlocks.apply(this, arguments);
      }

      return getBlocks;
    }() // no memoize

  }, {
    key: "getCoreDataBlock",
    value: function () {
      var _getCoreDataBlock = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee3() {
        var blocks;
        return _regenerator.default.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this.getBlocks();

              case 2:
                blocks = _context3.sent;
                return _context3.abrupt("return", blocks[0]);

              case 4:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function getCoreDataBlock() {
        return _getCoreDataBlock.apply(this, arguments);
      }

      return getCoreDataBlock;
    }() // memoize

  }, {
    key: "_getBlocksContentIdIndex",
    value: function () {
      var _getBlocksContentIdIndex2 = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee4() {
        var blocks, blocksByContentId;
        return _regenerator.default.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this.getBlocks();

              case 2:
                blocks = _context4.sent;
                blocksByContentId = {};
                (0, _forEach.default)(blocks).call(blocks, function (block) {
                  if (block.contentType === 'EXTERNAL_DATA') {
                    blocksByContentId[block.contentId] = block;
                  }
                });
                return _context4.abrupt("return", blocksByContentId);

              case 6:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function _getBlocksContentIdIndex() {
        return _getBlocksContentIdIndex2.apply(this, arguments);
      }

      return _getBlocksContentIdIndex;
    }()
  }, {
    key: "getBlockByContentId",
    value: function () {
      var _getBlockByContentId = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee5(id) {
        var blocksByContentId;
        return _regenerator.default.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return this._getBlocksContentIdIndex();

              case 2:
                blocksByContentId = _context5.sent;
                return _context5.abrupt("return", blocksByContentId[id]);

              case 4:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function getBlockByContentId(_x) {
        return _getBlockByContentId.apply(this, arguments);
      }

      return getBlockByContentId;
    }()
  }, {
    key: "getReferenceRegion",
    value: function () {
      var _getReferenceRegion = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee6() {
        var sliceHeader, compressionScheme, refBlock, seq;
        return _regenerator.default.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return this.getHeader();

              case 2:
                sliceHeader = _context6.sent.content;

                if (!(sliceHeader.refSeqId < 0)) {
                  _context6.next = 5;
                  break;
                }

                return _context6.abrupt("return", undefined);

              case 5:
                _context6.next = 7;
                return this.container.getCompressionScheme();

              case 7:
                compressionScheme = _context6.sent;

                if (!(sliceHeader.refBaseBlockId >= 0)) {
                  _context6.next = 15;
                  break;
                }

                refBlock = this.getBlockByContentId(sliceHeader.refBaseBlockId);

                if (refBlock) {
                  _context6.next = 12;
                  break;
                }

                throw new CramMalformedError('embedded reference specified, but reference block does not exist');

              case 12:
                if (!(sliceHeader.span > refBlock.uncompressedSize)) {
                  _context6.next = 14;
                  break;
                }

                throw new CramMalformedError('Embedded reference is too small');

              case 14:
                return _context6.abrupt("return", {
                  seq: refBlock.data.toString('utf8'),
                  start: sliceHeader.refSeqStart,
                  end: sliceHeader.refSeqStart + sliceHeader.refSeqSpan - 1,
                  span: sliceHeader.refSeqSpan
                });

              case 15:
                if (!(compressionScheme.referenceRequired || this.file.fetchReferenceSequenceCallback)) {
                  _context6.next = 24;
                  break;
                }

                if (this.file.fetchReferenceSequenceCallback) {
                  _context6.next = 18;
                  break;
                }

                throw new Error('reference sequence not embedded, and seqFetch callback not provided, cannot fetch reference sequence');

              case 18:
                _context6.next = 20;
                return this.file.fetchReferenceSequenceCallback(sliceHeader.refSeqId, sliceHeader.refSeqStart, sliceHeader.refSeqStart + sliceHeader.refSeqSpan - 1);

              case 20:
                seq = _context6.sent;

                if (!(seq.length !== sliceHeader.refSeqSpan)) {
                  _context6.next = 23;
                  break;
                }

                throw new CramArgumentError('seqFetch callback returned a reference sequence of the wrong length');

              case 23:
                return _context6.abrupt("return", {
                  seq: seq,
                  start: sliceHeader.refSeqStart,
                  end: sliceHeader.refSeqStart + sliceHeader.refSeqSpan - 1,
                  span: sliceHeader.refSeqSpan
                });

              case 24:
                return _context6.abrupt("return", undefined);

              case 25:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function getReferenceRegion() {
        return _getReferenceRegion.apply(this, arguments);
      }

      return getReferenceRegion;
    }()
  }, {
    key: "getAllRecords",
    value: function getAllRecords() {
      return this.getRecords(function () {
        return true;
      });
    }
  }, {
    key: "_fetchRecords",
    value: function () {
      var _fetchRecords2 = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee7() {
        var _this = this;

        var _ref, majorVersion, compressionScheme, sliceHeader, blocksByContentId, refRegion, _context7, _context8, _context9, _context10, _context11, seq, start, end, seqMd5, storedMd5, coreDataBlock, cursors, decodeDataSeries, records, i, _i, mateRecordNumber;

        return _regenerator.default.wrap(function _callee7$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                _context12.next = 2;
                return this.file.getDefinition();

              case 2:
                _ref = _context12.sent;
                majorVersion = _ref.majorVersion;
                _context12.next = 6;
                return this.container.getCompressionScheme();

              case 6:
                compressionScheme = _context12.sent;
                _context12.next = 9;
                return this.getHeader();

              case 9:
                sliceHeader = _context12.sent;
                _context12.next = 12;
                return this._getBlocksContentIdIndex();

              case 12:
                blocksByContentId = _context12.sent;

                if (!(majorVersion > 1 && this.file.options.checkSequenceMD5 && sliceHeader.content.refSeqId >= 0 && sliceHeader.content.md5.join('') !== '0000000000000000')) {
                  _context12.next = 23;
                  break;
                }

                _context12.next = 16;
                return this.getReferenceRegion();

              case 16:
                refRegion = _context12.sent;

                if (!refRegion) {
                  _context12.next = 23;
                  break;
                }

                seq = refRegion.seq, start = refRegion.start, end = refRegion.end;
                seqMd5 = sequenceMD5(seq);
                storedMd5 = (0, _map.default)(_context7 = sliceHeader.content.md5).call(_context7, function (byte) {
                  return (byte < 16 ? '0' : '') + byte.toString(16);
                }).join('');

                if (!(seqMd5 !== storedMd5)) {
                  _context12.next = 23;
                  break;
                }

                throw new CramMalformedError((0, _concat.default)(_context8 = (0, _concat.default)(_context9 = (0, _concat.default)(_context10 = (0, _concat.default)(_context11 = "MD5 checksum reference mismatch for ref ".concat(sliceHeader.content.refSeqId, " pos ")).call(_context11, start, "..")).call(_context10, end, ". recorded MD5: ")).call(_context9, storedMd5, ", calculated MD5: ")).call(_context8, seqMd5));

              case 23:
                _context12.next = 25;
                return this.getCoreDataBlock();

              case 25:
                coreDataBlock = _context12.sent;
                cursors = {
                  lastAlignmentStart: sliceHeader.content.refSeqStart || 0,
                  coreBlock: {
                    bitPosition: 7,
                    bytePosition: 0
                  },
                  externalBlocks: {
                    getCursor: function getCursor(contentId) {
                      if (!this[contentId]) this[contentId] = {
                        bitPosition: 7,
                        bytePosition: 0
                      };
                      return this[contentId];
                    }
                  }
                };

                decodeDataSeries = function decodeDataSeries(dataSeriesName) {
                  var codec = compressionScheme.getCodecForDataSeries(dataSeriesName);
                  if (!codec) throw new CramMalformedError("no codec defined for ".concat(dataSeriesName, " data series")); // console.log(dataSeriesName, Object.getPrototypeOf(codec))

                  return codec.decode(_this, coreDataBlock, blocksByContentId, cursors);
                };

                records = new Array(sliceHeader.content.numRecords);
                i = 0;

              case 30:
                if (!(i < records.length)) {
                  _context12.next = 48;
                  break;
                }

                _context12.prev = 31;
                records[i] = decodeRecord(this, decodeDataSeries, compressionScheme, sliceHeader, coreDataBlock, blocksByContentId, cursors, majorVersion, i);
                records[i].uniqueId = sliceHeader.contentPosition + sliceHeader.content.recordCounter + i + 1;
                _context12.next = 45;
                break;

              case 36:
                _context12.prev = 36;
                _context12.t0 = _context12["catch"](31);

                if (!(_context12.t0 instanceof CramBufferOverrunError)) {
                  _context12.next = 44;
                  break;
                }

                console.warn('read attempted beyond end of buffer, file seems truncated.');
                records = (0, _filter.default)(records).call(records, function (r) {
                  return !!r;
                });
                return _context12.abrupt("break", 48);

              case 44:
                throw _context12.t0;

              case 45:
                i += 1;
                _context12.next = 30;
                break;

              case 48:
                // interpret `recordsToNextFragment` attributes to make standard `mate` objects
                // Resolve mate pair cross-references between records in this slice
                for (_i = 0; _i < records.length; _i += 1) {
                  mateRecordNumber = records[_i].mateRecordNumber;
                  if (mateRecordNumber >= 0) associateIntraSliceMate(records, _i, records[_i], records[mateRecordNumber]);
                }

                return _context12.abrupt("return", records);

              case 50:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee7, this, [[31, 36]]);
      }));

      function _fetchRecords() {
        return _fetchRecords2.apply(this, arguments);
      }

      return _fetchRecords;
    }()
  }, {
    key: "getRecords",
    value: function () {
      var _getRecords = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee9(filterFunction) {
        var _context13,
            _this2 = this;

        var cacheKey, recordsPromise, records, sliceHeader, _context14, singleRefId, _compressionScheme, refRegions, i, seqId, refRegion, end, _i2, _seqId, _refRegion;

        return _regenerator.default.wrap(function _callee9$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                // fetch the features if necessary, using the file-level feature cache
                cacheKey = this.container.filePosition + this.containerPosition;
                recordsPromise = this.file.featureCache.get(cacheKey);

                if (!recordsPromise) {
                  recordsPromise = this._fetchRecords();
                  this.file.featureCache.set(cacheKey, recordsPromise);
                }

                _context16.t0 = _filter.default;
                _context16.next = 6;
                return recordsPromise;

              case 6:
                _context16.t1 = _context13 = _context16.sent;
                _context16.t2 = _context13;
                _context16.t3 = filterFunction;
                records = (0, _context16.t0)(_context16.t1).call(_context16.t2, _context16.t3);

                if (!(records.length && this.file.fetchReferenceSequenceCallback)) {
                  _context16.next = 24;
                  break;
                }

                _context16.next = 13;
                return this.getHeader();

              case 13:
                sliceHeader = _context16.sent;

                if (!(sliceHeader.content.refSeqId >= 0 || // single-ref slice
                sliceHeader.content.refSeqId === -2 // multi-ref slice
                )) {
                  _context16.next = 24;
                  break;
                }

                singleRefId = sliceHeader.content.refSeqId >= 0 ? sliceHeader.content.refSeqId : undefined;
                _context16.next = 18;
                return this.container.getCompressionScheme();

              case 18:
                _compressionScheme = _context16.sent;
                refRegions = {}; // seqId => { start, end, seq }
                // iterate over the records to find the spans of the reference sequences we need to fetch

                for (i = 0; i < records.length; i += 1) {
                  seqId = singleRefId !== undefined ? singleRefId : records[i].sequenceId;
                  refRegion = refRegions[seqId];

                  if (!refRegion) {
                    refRegion = {
                      id: seqId,
                      start: records[i].alignmentStart,
                      end: -Infinity
                    };
                    refRegions[seqId] = refRegion;
                  }

                  end = records[i].alignmentStart + (records[i].lengthOnRef || records[i].readLength) - 1;
                  if (end > refRegion.end) refRegion.end = end;
                  if (records[i].alignmentStart < refRegion.start) refRegion.start = records[i].alignmentStart;
                } // fetch the `seq` for all of the ref regions


                _context16.next = 23;
                return _promise.default.all((0, _map.default)(_context14 = (0, _values.default)(refRegions)).call(_context14,
                /*#__PURE__*/
                function () {
                  var _ref2 = (0, _asyncToGenerator2.default)(
                  /*#__PURE__*/
                  _regenerator.default.mark(function _callee8(refRegion) {
                    return _regenerator.default.wrap(function _callee8$(_context15) {
                      while (1) {
                        switch (_context15.prev = _context15.next) {
                          case 0:
                            if (!(refRegion.id !== -1 && refRegion.start <= refRegion.end)) {
                              _context15.next = 4;
                              break;
                            }

                            _context15.next = 3;
                            return _this2.file.fetchReferenceSequenceCallback(refRegion.id, refRegion.start, refRegion.end);

                          case 3:
                            refRegion.seq = _context15.sent;

                          case 4:
                          case "end":
                            return _context15.stop();
                        }
                      }
                    }, _callee8);
                  }));

                  return function (_x3) {
                    return _ref2.apply(this, arguments);
                  };
                }()));

              case 23:
                // now decorate all the records with them
                for (_i2 = 0; _i2 < records.length; _i2 += 1) {
                  _seqId = singleRefId !== undefined ? singleRefId : records[_i2].sequenceId;
                  _refRegion = refRegions[_seqId];

                  if (_refRegion && _refRegion.seq) {
                    records[_i2].addReferenceSequence(_refRegion, _compressionScheme);
                  }
                }

              case 24:
                return _context16.abrupt("return", records);

              case 25:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee9, this);
      }));

      function getRecords(_x2) {
        return _getRecords.apply(this, arguments);
      }

      return getRecords;
    }()
  }]);
  return CramSlice;
}(); // memoize several methods in the class for performance


(0, _forEach.default)(_context17 = 'getHeader getBlocks _getBlocksContentIdIndex'.split(' ')).call(_context17, function (method) {
  return tinyMemoize(CramSlice, method);
});
module.exports = CramSlice;