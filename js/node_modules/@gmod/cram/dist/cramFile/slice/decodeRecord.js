"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

var _concat = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/concat"));

var _isNan = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/number/is-nan"));

var _forEach = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/for-each"));

var _flags = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/flags"));

var _slice = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/slice"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/toConsumableArray"));

var _parseInt = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/number/parse-int"));

var _minSafeInteger = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/number/min-safe-integer"));

var _maxSafeInteger = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/number/max-safe-integer"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/slicedToArray"));

var _indexOf = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/index-of"));

var Long = require('long');

var _require = require('../../errors'),
    CramMalformedError = _require.CramMalformedError,
    CramUnimplementedError = _require.CramUnimplementedError;

var CramRecord = require('../record');

var Constants = require('../constants');
/**
 * given a Buffer, read a string up to the first null character
 * @private
 */


function readNullTerminatedStringFromBuffer(buffer) {
  var zeroOffset = (0, _indexOf.default)(buffer).call(buffer, 0);
  if (zeroOffset === -1) return buffer.toString('utf8');
  return buffer.toString('utf8', 0, zeroOffset);
}
/**
 * parse a BAM tag's array value from a binary buffer
 * @private
 */


function parseTagValueArray(buffer) {
  var arrayType = String.fromCharCode(buffer[0]);
  var length = buffer.readInt32LE(1);
  var schema = {
    c: ['readInt8', 1],
    C: ['readUInt8', 1],
    s: ['readInt16LE', 2],
    S: ['readUInt16LE', 2],
    i: ['readInt32LE', 4],
    I: ['readUInt32LE', 4],
    f: ['readFloatLE', 4]
  }[arrayType];
  if (!schema) throw new CramMalformedError("invalid tag value array type '".concat(arrayType, "'"));

  var _schema = (0, _slicedToArray2.default)(schema, 2),
      getMethod = _schema[0],
      itemSize = _schema[1];

  var array = new Array(length);
  var offset = 5;

  for (var i = 0; i < length; i += 1) {
    array[i] = buffer[getMethod](offset);
    offset += itemSize;
  }

  return array;
}

function parseTagData(tagType, buffer) {
  if (!buffer.readInt32LE) buffer = Buffer.from(buffer);
  if (tagType === 'Z') return readNullTerminatedStringFromBuffer(buffer);
  if (tagType === 'A') return String.fromCharCode(buffer[0]);

  if (tagType === 'I') {
    var val = Long.fromBytesLE(buffer);
    if (val.greaterThan(_maxSafeInteger.default) || val.lessThan(_minSafeInteger.default)) throw new CramUnimplementedError('integer overflow');
    return val.toNumber();
  }

  if (tagType === 'i') return buffer.readInt32LE(0);
  if (tagType === 's') return buffer.readInt16LE(0);
  if (tagType === 'S') return buffer.readUInt16LE(0);
  if (tagType === 'c') return buffer.readInt8(0);
  if (tagType === 'C') return buffer.readUInt8(0);
  if (tagType === 'f') return buffer.readFloatLE(0);

  if (tagType === 'H') {
    var hex = readNullTerminatedStringFromBuffer(buffer);
    return (0, _parseInt.default)(hex.replace(/^0x/, ''), 16);
  }

  if (tagType === 'B') return parseTagValueArray(buffer);
  throw new CramMalformedError("Unrecognized tag type ".concat(tagType));
}

function decodeReadFeatures(cramRecord, readFeatureCount, decodeDataSeries, compressionScheme, majorVersion) {
  var currentReadPos = 0;
  var currentRefPos = cramRecord.alignmentStart - 1;
  var readFeatures = new Array(readFeatureCount);

  function decodeRFData(_ref) {
    var _ref2 = (0, _slicedToArray2.default)(_ref, 2),
        type = _ref2[0],
        dataSeriesName = _ref2[1];

    var data = decodeDataSeries(dataSeriesName);

    if (type === 'character') {
      return String.fromCharCode(data);
    }

    if (type === 'string') {
      return data.toString('utf8');
    }

    if (type === 'numArray') {
      return data.toArray();
    } // else if (type === 'number') {
    //   return data[0]
    // }


    return data;
  }

  for (var i = 0; i < readFeatureCount; i += 1) {
    var code = String.fromCharCode(decodeDataSeries('FC'));
    var readPosDelta = decodeDataSeries('FP');
    var readFeature = {
      code: code
    }; // map of operator name -> data series name

    var data1Schema = {
      B: ['character', 'BA'],
      S: ['string', majorVersion > 1 ? 'SC' : 'IN'],
      // IN if cram v1, SC otherwise
      X: ['number', 'BS'],
      D: ['number', 'DL'],
      I: ['string', 'IN'],
      i: ['character', 'BA'],
      b: ['string', 'BB'],
      q: ['numArray', 'QQ'],
      Q: ['number', 'QS'],
      H: ['number', 'HC'],
      P: ['number', 'PD'],
      N: ['number', 'RS']
    }[code];
    if (!data1Schema) throw new CramMalformedError("invalid read feature code \"".concat(code, "\""));
    readFeature.data = decodeRFData(data1Schema); // if this is a tag with two data items, make the data an array and add the second item

    var data2Schema = {
      B: ['number', 'QS']
    }[code];
    if (data2Schema) readFeature.data = [readFeature.data, decodeRFData(data2Schema)];
    currentReadPos += readPosDelta;
    readFeature.pos = currentReadPos;
    currentRefPos += readPosDelta;
    readFeature.refPos = currentRefPos; // for gapping features, adjust the reference position for read features that follow

    if (code === 'D' || code === 'N') currentRefPos += readFeature.data;else if (code === 'I' || code === 'S') currentRefPos -= readFeature.data.length;else if (code === 'i') currentRefPos -= 1;
    readFeatures[i] = readFeature;
  }

  return readFeatures;
}

function thingToString(thing) {
  if (thing instanceof Buffer) {
    return readNullTerminatedStringFromBuffer(thing);
  }

  if (thing.length && (0, _indexOf.default)(thing)) {
    // array-like
    if (!thing[thing.length - 1]) {
      // trim zeroes off the end if necessary
      var termIndex = (0, _indexOf.default)(thing).call(thing, 0);
      return String.fromCharCode.apply(String, (0, _toConsumableArray2.default)((0, _slice.default)(thing).call(thing, 0, termIndex)));
    }

    return String.fromCharCode.apply(String, (0, _toConsumableArray2.default)(thing));
  }

  return String(thing);
}

function decodeRecord(slice, decodeDataSeries, compressionScheme, sliceHeader, coreDataBlock, blocksByContentId, cursors, majorVersion, recordNumber) {
  var cramRecord = new CramRecord();
  cramRecord.flags = decodeDataSeries('BF'); // note: the C data type of compressionFlags is byte in cram v1
  // and int32 in cram v2+, but that does not matter for us here
  // in javascript land.

  cramRecord.cramFlags = decodeDataSeries('CF');
  if (majorVersion > 1 && sliceHeader.content.refSeqId === -2) cramRecord.sequenceId = decodeDataSeries('RI');else cramRecord.sequenceId = sliceHeader.content.refSeqId;
  cramRecord.readLength = decodeDataSeries('RL'); // if APDelta, will calculate the true start in a second pass

  cramRecord.alignmentStart = decodeDataSeries('AP');
  if (compressionScheme.APdelta) cramRecord.alignmentStart += cursors.lastAlignmentStart;
  cursors.lastAlignmentStart = cramRecord.alignmentStart;
  cramRecord.readGroupId = decodeDataSeries('RG');
  if (compressionScheme.readNamesIncluded) cramRecord.readName = thingToString(decodeDataSeries('RN')); // mate record

  if (cramRecord.isDetached()) {
    // note: the MF is a byte in 1.0, int32 in 2+, but once again this doesn't matter for javascript
    var mate = {};
    mate.flags = decodeDataSeries('MF');

    if (!compressionScheme.readNamesIncluded) {
      mate.readName = thingToString(decodeDataSeries('RN'));
      cramRecord.readName = mate.readName;
    }

    mate.sequenceId = decodeDataSeries('NS');
    mate.alignmentStart = decodeDataSeries('NP');
    if ((0, _flags.default)(mate) || mate.sequenceId > -1) cramRecord.mate = mate;
    cramRecord.templateSize = decodeDataSeries('TS'); // set mate unmapped if needed

    if ((0, _flags.default)(mate) & Constants.CRAM_M_UNMAP) {
      cramRecord.flags |= Constants.BAM_FMUNMAP;
    } // set mate reversed if needed


    if ((0, _flags.default)(mate) & Constants.CRAM_M_REVERSE) {
      cramRecord.flags |= Constants.BAM_FMREVERSE;
    } // detachedCount++

  } else if (cramRecord.hasMateDownStream()) {
    cramRecord.mateRecordNumber = decodeDataSeries('NF') + recordNumber + 1;
  } // TODO: the aux tag parsing will have to be refactored if we want to support
  // cram v1


  var TLindex = decodeDataSeries('TL');
  if (TLindex < 0)
    /* TODO: check nTL: TLindex >= compressionHeader.tagEncoding.size */
    throw new CramMalformedError('invalid TL index'); // TN = tag names

  var TN = compressionScheme.getTagNames(TLindex);
  var ntags = TN.length;

  for (var i = 0; i < ntags; i += 1) {
    var tagId = TN[i];
    var tagName = tagId.substr(0, 2);
    var tagType = tagId.substr(2, 1);
    var tagCodec = compressionScheme.getCodecForTag(tagId);
    if (!tagCodec) throw new CramMalformedError("no codec defined for auxiliary tag ".concat(tagId));
    var tagData = tagCodec.decode(slice, coreDataBlock, blocksByContentId, cursors);
    cramRecord.tags[tagName] = parseTagData(tagType, tagData);
  }

  if (!cramRecord.isSegmentUnmapped()) {
    var _context;

    // reading read features
    var
    /* int */
    readFeatureCount = decodeDataSeries('FN');

    if (readFeatureCount) {
      cramRecord.readFeatures = decodeReadFeatures(cramRecord, readFeatureCount, decodeDataSeries, compressionScheme, majorVersion);
    } // compute the read's true span on the reference sequence, and the end coordinate of the alignment on the reference


    var lengthOnRef = cramRecord.readLength;
    if (cramRecord.readFeatures) (0, _forEach.default)(_context = cramRecord.readFeatures).call(_context, function (_ref3) {
      var code = _ref3.code,
          data = _ref3.data;
      if (code === 'D' || code === 'N') lengthOnRef += data;else if (code === 'I' || code === 'S') lengthOnRef -= data.length;else if (code === 'i') lengthOnRef -= 1;
    });

    if ((0, _isNan.default)(lengthOnRef)) {
      var _context2;

      console.warn("".concat(cramRecord.readName || (0, _concat.default)(_context2 = "".concat(cramRecord.sequenceId, ":")).call(_context2, cramRecord.alignmentStart), " record has invalid read features"));
      lengthOnRef = cramRecord.readLength;
    }

    cramRecord.lengthOnRef = lengthOnRef; // mapping quality

    cramRecord.mappingQuality = decodeDataSeries('MQ');

    if (cramRecord.isPreservingQualityScores()) {
      var bases = new Array(cramRecord.readLength);

      for (var _i = 0; _i < bases.length; _i += 1) {
        bases[_i] = decodeDataSeries('QS');
      }

      cramRecord.qualityScores = bases;
    }
  } else if (cramRecord.isUnknownBases()) {
    cramRecord.readBases = null;
    cramRecord.qualityScores = null;
  } else {
    var _bases = new Array(cramRecord.readLength);

    for (var _i2 = 0; _i2 < _bases.length; _i2 += 1) {
      _bases[_i2] = decodeDataSeries('BA');
    }

    cramRecord.readBases = String.fromCharCode.apply(String, _bases);

    if (cramRecord.isPreservingQualityScores()) {
      for (var _i3 = 0; _i3 < _bases.length; _i3 += 1) {
        _bases[_i3] = decodeDataSeries('QS');
      }

      cramRecord.qualityScores = _bases;
    }
  }

  return cramRecord;
}

module.exports = decodeRecord;