"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

var _keys = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/keys"));

var _forEach = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/for-each"));

var _assign = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/assign"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/createClass"));

var _require = require('../../errors'),
    CramMalformedError = _require.CramMalformedError;

var _require2 = require('../codecs'),
    instantiateCodec = _require2.instantiateCodec; // the hardcoded data type to be decoded for each core
// data field


var dataSeriesTypes = {
  BF: 'int',
  CF: 'int',
  RI: 'int',
  RL: 'int',
  AP: 'int',
  RG: 'int',
  MF: 'int',
  NS: 'int',
  NP: 'int',
  TS: 'int',
  NF: 'int',
  TC: 'byte',
  TN: 'int',
  FN: 'int',
  FC: 'byte',
  FP: 'int',
  BS: 'byte',
  IN: 'byteArray',
  SC: 'byteArray',
  DL: 'int',
  BA: 'byte',
  BB: 'byteArray',
  RS: 'int',
  PD: 'int',
  HC: 'int',
  MQ: 'int',
  RN: 'byteArray',
  QS: 'byte',
  QQ: 'byteArray',
  TL: 'int',
  TM: 'ignore',
  TV: 'ignore'
};

function parseSubstitutionMatrix(byteArray) {
  var matrix = new Array(5);

  for (var i = 0; i < 5; i += 1) {
    matrix[i] = new Array(4);
  }

  matrix[0][byteArray[0] >> 6 & 3] = 'C';
  matrix[0][byteArray[0] >> 4 & 3] = 'G';
  matrix[0][byteArray[0] >> 2 & 3] = 'T';
  matrix[0][byteArray[0] >> 0 & 3] = 'N';
  matrix[1][byteArray[1] >> 6 & 3] = 'A';
  matrix[1][byteArray[1] >> 4 & 3] = 'G';
  matrix[1][byteArray[1] >> 2 & 3] = 'T';
  matrix[1][byteArray[1] >> 0 & 3] = 'N';
  matrix[2][byteArray[2] >> 6 & 3] = 'A';
  matrix[2][byteArray[2] >> 4 & 3] = 'C';
  matrix[2][byteArray[2] >> 2 & 3] = 'T';
  matrix[2][byteArray[2] >> 0 & 3] = 'N';
  matrix[3][byteArray[3] >> 6 & 3] = 'A';
  matrix[3][byteArray[3] >> 4 & 3] = 'C';
  matrix[3][byteArray[3] >> 2 & 3] = 'G';
  matrix[3][byteArray[3] >> 0 & 3] = 'N';
  matrix[4][byteArray[4] >> 6 & 3] = 'A';
  matrix[4][byteArray[4] >> 4 & 3] = 'C';
  matrix[4][byteArray[4] >> 2 & 3] = 'G';
  matrix[4][byteArray[4] >> 0 & 3] = 'T';
  return matrix;
}

var CramContainerCompressionScheme =
/*#__PURE__*/
function () {
  function CramContainerCompressionScheme(content) {
    (0, _classCallCheck2.default)(this, CramContainerCompressionScheme);
    (0, _assign.default)(this, content); // interpret some of the preservation map tags for convenient use

    this.readNamesIncluded = content.preservation.RN;
    this.APdelta = content.preservation.AP;
    this.referenceRequired = !!content.preservation.RR;
    this.tagIdsDictionary = content.preservation.TD;
    this.substitutionMatrix = parseSubstitutionMatrix(content.preservation.SM);
    this.dataSeriesCodecCache = {};
    this.tagCodecCache = {};
  }
  /**
   * @param {string} tagName three-character tag name
   * @private
   */


  (0, _createClass2.default)(CramContainerCompressionScheme, [{
    key: "getCodecForTag",
    value: function getCodecForTag(tagName) {
      if (!this.tagCodecCache[tagName]) {
        var encodingData = this.tagEncoding[tagName];

        if (encodingData) {
          this.tagCodecCache[tagName] = instantiateCodec(encodingData, 'byteArray' // all tags are byte array data
          );
        }
      }

      return this.tagCodecCache[tagName];
    }
    /**
     *
     * @param {number} tagListId ID of the tag list to fetch from the tag dictionary
     * @private
     */

  }, {
    key: "getTagNames",
    value: function getTagNames(tagListId) {
      return this.tagIdsDictionary[tagListId];
    }
  }, {
    key: "getCodecForDataSeries",
    value: function getCodecForDataSeries(dataSeriesName) {
      if (!this.dataSeriesCodecCache[dataSeriesName]) {
        var encodingData = this.dataSeriesEncoding[dataSeriesName];

        if (encodingData) {
          var dataType = dataSeriesTypes[dataSeriesName];
          if (!dataType) throw new CramMalformedError("data series name ".concat(dataSeriesName, " not defined in file compression header"));
          this.dataSeriesCodecCache[dataSeriesName] = instantiateCodec(encodingData, dataType);
        }
      }

      return this.dataSeriesCodecCache[dataSeriesName];
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var _context,
          _this = this;

      var data = {};
      (0, _forEach.default)(_context = (0, _keys.default)(this)).call(_context, function (k) {
        if (/Cache$/.test(k)) return;
        data[k] = _this[k];
      });
      return data;
    }
  }]);
  return CramContainerCompressionScheme;
}();

module.exports = CramContainerCompressionScheme;