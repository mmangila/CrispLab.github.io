"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

var _forEach = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/for-each"));

var _concat = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/concat"));

var _regenerator = _interopRequireDefault(require("@babel/runtime-corejs3/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/createClass"));

var _context14;

var zlib = require('zlib');

var crc32 = require('buffer-crc32');

var LRU = require('quick-lru');

var _require = require('../errors'),
    CramUnimplementedError = _require.CramUnimplementedError,
    CramMalformedError = _require.CramMalformedError;

var rans = require('../rans');

var _require2 = require('./sectionParsers'),
    cramFileDefinitionParser = _require2.cramFileDefinition,
    _getSectionParsers = _require2.getSectionParsers;

var CramContainer = require('./container');

var _require3 = require('../io'),
    open = _require3.open;

var _require4 = require('./util'),
    parseItem = _require4.parseItem,
    tinyMemoize = _require4.tinyMemoize;

var _require5 = require('../sam'),
    parseHeaderText = _require5.parseHeaderText;

var CramFile =
/*#__PURE__*/
function () {
  /**
   * @param {object} args
   * @param {object} [args.filehandle] - a filehandle that implements the stat() and
   * read() methods of the Node filehandle API https://nodejs.org/api/fs.html#fs_class_filehandle
   * @param {object} [args.path] - path to the cram file
   * @param {object} [args.url] - url for the cram file.  also supports file:// urls for local files
   * @param {function} [args.seqFetch] - a function with signature
   * `(seqId, startCoordinate, endCoordinate)` that returns a promise for a string of sequence bases
   * @param {number} [args.cacheSize] optional maximum number of CRAM records to cache.  default 20,000
   * @param {boolean} [args.checkSequenceMD5] - default true. if false, disables verifying the MD5
   * checksum of the reference sequence underlying a slice. In some applications, this check can cause an inconvenient amount (many megabases) of sequences to be fetched.
   */
  function CramFile(args) {
    (0, _classCallCheck2.default)(this, CramFile);
    this.file = open(args.url, args.path, args.filehandle);
    this.validateChecksums = true;
    this.fetchReferenceSequenceCallback = args.seqFetch;
    this.options = {
      checkSequenceMD5: args.checkSequenceMD5 !== false,
      cacheSize: args.cacheSize !== undefined ? args.cacheSize : 20000
    }; // cache of features in a slice, keyed by the
    // slice offset. caches all of the features in a slice, or none.
    // the cache is actually used by the slice object, it's just
    // kept here at the level of the file

    this.featureCache = new LRU({
      maxSize: this.options.cacheSize
    });
  }

  (0, _createClass2.default)(CramFile, [{
    key: "toString",
    value: function toString() {
      if (this.file.filename) return this.file.filename;
      if (this.file.url) return this.file.url;
      return '(cram file)';
    } // can just read this object like a filehandle

  }, {
    key: "read",
    value: function read(buffer, offset, length, position) {
      return this.file.read(buffer, offset, length, position);
    } // can just stat this object like a filehandle

  }, {
    key: "stat",
    value: function stat() {
      return this.file.stat();
    } // memoized

  }, {
    key: "getDefinition",
    value: function () {
      var _getDefinition = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee() {
        var headbytes, definition;
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                headbytes = Buffer.allocUnsafe(cramFileDefinitionParser.maxLength);
                _context.next = 3;
                return this.file.read(headbytes, 0, cramFileDefinitionParser.maxLength, 0);

              case 3:
                definition = cramFileDefinitionParser.parser.parse(headbytes).result;

                if (!(definition.majorVersion !== 2 && definition.majorVersion !== 3)) {
                  _context.next = 6;
                  break;
                }

                throw new CramUnimplementedError("CRAM version ".concat(definition.majorVersion, " not supported"));

              case 6:
                return _context.abrupt("return", definition);

              case 7:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getDefinition() {
        return _getDefinition.apply(this, arguments);
      }

      return getDefinition;
    }() // memoize

  }, {
    key: "getSamHeader",
    value: function () {
      var _getSamHeader = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee2() {
        var firstContainer, _ref, content, headerLength, textStart, text;

        return _regenerator.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.getContainerById(0);

              case 2:
                firstContainer = _context2.sent;

                if (firstContainer) {
                  _context2.next = 5;
                  break;
                }

                throw new CramMalformedError('file contains no containers');

              case 5:
                _context2.next = 7;
                return firstContainer.getFirstBlock();

              case 7:
                _ref = _context2.sent;
                content = _ref.content;
                // find the end of the trailing zeros in the header text
                headerLength = content.readInt32LE(0);
                textStart = 4; // let textEnd = content.length - 1
                // while (textEnd >= textStart && !content[textEnd]) textEnd -= 1
                // trim off the trailing zeros

                text = content.toString('utf8', textStart, textStart + headerLength);
                this.header = text;
                return _context2.abrupt("return", parseHeaderText(text));

              case 14:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getSamHeader() {
        return _getSamHeader.apply(this, arguments);
      }

      return getSamHeader;
    }()
  }, {
    key: "getHeaderText",
    value: function () {
      var _getHeaderText = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee3() {
        return _regenerator.default.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this.getSamHeader();

              case 2:
                return _context3.abrupt("return", this.header);

              case 3:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function getHeaderText() {
        return _getHeaderText.apply(this, arguments);
      }

      return getHeaderText;
    }() // memoize

  }, {
    key: "getSectionParsers",
    value: function () {
      var _getSectionParsers2 = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee4() {
        var _ref2, majorVersion;

        return _regenerator.default.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this.getDefinition();

              case 2:
                _ref2 = _context4.sent;
                majorVersion = _ref2.majorVersion;
                return _context4.abrupt("return", _getSectionParsers(majorVersion));

              case 5:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function getSectionParsers() {
        return _getSectionParsers2.apply(this, arguments);
      }

      return getSectionParsers;
    }()
  }, {
    key: "getContainerById",
    value: function () {
      var _getContainerById = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee5(containerNumber) {
        var sectionParsers, position, _ref3, fileSize, cramContainerHeader1, currentContainer, i, currentHeader, j, block;

        return _regenerator.default.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return this.getSectionParsers();

              case 2:
                sectionParsers = _context5.sent;
                position = sectionParsers.cramFileDefinition.maxLength;
                _context5.next = 6;
                return this.file.stat();

              case 6:
                _ref3 = _context5.sent;
                fileSize = _ref3.size;
                cramContainerHeader1 = sectionParsers.cramContainerHeader1; // skip with a series of reads to the proper container

                i = 0;

              case 10:
                if (!(i <= containerNumber)) {
                  _context5.next = 36;
                  break;
                }

                if (!(position + cramContainerHeader1.maxLength + 8 >= fileSize)) {
                  _context5.next = 13;
                  break;
                }

                return _context5.abrupt("return", undefined);

              case 13:
                currentContainer = this.getContainerAtPosition(position);
                _context5.next = 16;
                return currentContainer.getHeader();

              case 16:
                currentHeader = _context5.sent;

                if (currentHeader) {
                  _context5.next = 19;
                  break;
                }

                throw new CramMalformedError("container ".concat(containerNumber, " not found in file"));

              case 19:
                if (!(i === 0)) {
                  _context5.next = 32;
                  break;
                }

                position = currentHeader._endPosition;
                j = 0;

              case 22:
                if (!(j < currentHeader.numBlocks)) {
                  _context5.next = 30;
                  break;
                }

                _context5.next = 25;
                return this.readBlock(position);

              case 25:
                block = _context5.sent;
                position = block._endPosition;

              case 27:
                j += 1;
                _context5.next = 22;
                break;

              case 30:
                _context5.next = 33;
                break;

              case 32:
                // otherwise, just traverse to the next container using the container's length
                position += currentHeader._size + currentHeader.length;

              case 33:
                i += 1;
                _context5.next = 10;
                break;

              case 36:
                return _context5.abrupt("return", currentContainer);

              case 37:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function getContainerById(_x) {
        return _getContainerById.apply(this, arguments);
      }

      return getContainerById;
    }()
  }, {
    key: "checkCrc32",
    value: function () {
      var _checkCrc = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee6(position, length, recordedCrc32, description) {
        var b, calculatedCrc32, _context6, _context7;

        return _regenerator.default.wrap(function _callee6$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                b = Buffer.allocUnsafe(length);
                _context8.next = 3;
                return this.file.read(b, 0, length, position);

              case 3:
                calculatedCrc32 = crc32.unsigned(b);

                if (!(calculatedCrc32 !== recordedCrc32)) {
                  _context8.next = 6;
                  break;
                }

                throw new CramMalformedError((0, _concat.default)(_context6 = (0, _concat.default)(_context7 = "crc mismatch in ".concat(description, ": recorded CRC32 = ")).call(_context7, recordedCrc32, ", but calculated CRC32 = ")).call(_context6, calculatedCrc32));

              case 6:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee6, this);
      }));

      function checkCrc32(_x2, _x3, _x4, _x5) {
        return _checkCrc.apply(this, arguments);
      }

      return checkCrc32;
    }()
    /**
     * @returns {Promise[number]} the number of containers in the file
     */

  }, {
    key: "containerCount",
    value: function () {
      var _containerCount = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee7() {
        var sectionParsers, _ref4, fileSize, cramContainerHeader1, containerCount, position, currentHeader, j, block;

        return _regenerator.default.wrap(function _callee7$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                _context9.next = 2;
                return this.getSectionParsers();

              case 2:
                sectionParsers = _context9.sent;
                _context9.next = 5;
                return this.file.stat();

              case 5:
                _ref4 = _context9.sent;
                fileSize = _ref4.size;
                cramContainerHeader1 = sectionParsers.cramContainerHeader1;
                containerCount = 0;
                position = sectionParsers.cramFileDefinition.maxLength;

              case 10:
                if (!(position + cramContainerHeader1.maxLength + 8 < fileSize)) {
                  _context9.next = 33;
                  break;
                }

                _context9.next = 13;
                return this.getContainerAtPosition(position).getHeader();

              case 13:
                currentHeader = _context9.sent;

                if (currentHeader) {
                  _context9.next = 16;
                  break;
                }

                return _context9.abrupt("break", 33);

              case 16:
                if (!(containerCount === 0)) {
                  _context9.next = 29;
                  break;
                }

                position = currentHeader._endPosition;
                j = 0;

              case 19:
                if (!(j < currentHeader.numBlocks)) {
                  _context9.next = 27;
                  break;
                }

                _context9.next = 22;
                return this.readBlock(position);

              case 22:
                block = _context9.sent;
                position = block._endPosition;

              case 24:
                j += 1;
                _context9.next = 19;
                break;

              case 27:
                _context9.next = 30;
                break;

              case 29:
                // otherwise, just traverse to the next container using the container's length
                position += currentHeader._size + currentHeader.length;

              case 30:
                containerCount += 1;
                _context9.next = 10;
                break;

              case 33:
                return _context9.abrupt("return", containerCount);

              case 34:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee7, this);
      }));

      function containerCount() {
        return _containerCount.apply(this, arguments);
      }

      return containerCount;
    }()
  }, {
    key: "getContainerAtPosition",
    value: function getContainerAtPosition(position) {
      return new CramContainer(this, position);
    }
  }, {
    key: "readBlockHeader",
    value: function () {
      var _readBlockHeader = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee8(position) {
        var sectionParsers, cramBlockHeader, _ref5, fileSize, buffer;

        return _regenerator.default.wrap(function _callee8$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                _context10.next = 2;
                return this.getSectionParsers();

              case 2:
                sectionParsers = _context10.sent;
                cramBlockHeader = sectionParsers.cramBlockHeader;
                _context10.next = 6;
                return this.file.stat();

              case 6:
                _ref5 = _context10.sent;
                fileSize = _ref5.size;

                if (!(position + cramBlockHeader.maxLength >= fileSize)) {
                  _context10.next = 10;
                  break;
                }

                return _context10.abrupt("return", undefined);

              case 10:
                buffer = Buffer.allocUnsafe(cramBlockHeader.maxLength);
                _context10.next = 13;
                return this.file.read(buffer, 0, cramBlockHeader.maxLength, position);

              case 13:
                return _context10.abrupt("return", parseItem(buffer, cramBlockHeader.parser, 0, position));

              case 14:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee8, this);
      }));

      function readBlockHeader(_x6) {
        return _readBlockHeader.apply(this, arguments);
      }

      return readBlockHeader;
    }()
  }, {
    key: "_parseSection",
    value: function () {
      var _parseSection2 = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee9(section, position) {
        var _context11;

        var size,
            preReadBuffer,
            buffer,
            _ref6,
            fileSize,
            data,
            _args9 = arguments;

        return _regenerator.default.wrap(function _callee9$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                size = _args9.length > 2 && _args9[2] !== undefined ? _args9[2] : section.maxLength;
                preReadBuffer = _args9.length > 3 ? _args9[3] : undefined;

                if (!preReadBuffer) {
                  _context12.next = 6;
                  break;
                }

                buffer = preReadBuffer;
                _context12.next = 15;
                break;

              case 6:
                _context12.next = 8;
                return this.file.stat();

              case 8:
                _ref6 = _context12.sent;
                fileSize = _ref6.size;

                if (!(position + size >= fileSize)) {
                  _context12.next = 12;
                  break;
                }

                return _context12.abrupt("return", undefined);

              case 12:
                buffer = Buffer.allocUnsafe(size);
                _context12.next = 15;
                return this.file.read(buffer, 0, size, position);

              case 15:
                data = parseItem(buffer, section.parser, 0, position);

                if (!(data._size !== size)) {
                  _context12.next = 18;
                  break;
                }

                throw new CramMalformedError((0, _concat.default)(_context11 = "section read error: requested size ".concat(size, " does not equal parsed size ")).call(_context11, data._size));

              case 18:
                return _context12.abrupt("return", data);

              case 19:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee9, this);
      }));

      function _parseSection(_x7, _x8) {
        return _parseSection2.apply(this, arguments);
      }

      return _parseSection;
    }()
  }, {
    key: "_uncompress",
    value: function _uncompress(compressionMethod, inputBuffer, outputBuffer) {
      if (compressionMethod === 'gzip') {
        var result = zlib.gunzipSync(inputBuffer);
        result.copy(outputBuffer);
      } else if (compressionMethod === 'rans') {
        rans.uncompress(inputBuffer, outputBuffer);
      } else {
        throw new CramUnimplementedError("".concat(compressionMethod, " decompression not yet implemented"));
      }
    }
  }, {
    key: "readBlock",
    value: function () {
      var _readBlock = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee10(position) {
        var _ref7, majorVersion, sectionParsers, block, blockContentPosition, uncompressedData, compressedData, crc;

        return _regenerator.default.wrap(function _callee10$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                _context13.next = 2;
                return this.getDefinition();

              case 2:
                _ref7 = _context13.sent;
                majorVersion = _ref7.majorVersion;
                _context13.next = 6;
                return this.getSectionParsers();

              case 6:
                sectionParsers = _context13.sent;
                _context13.next = 9;
                return this.readBlockHeader(position);

              case 9:
                block = _context13.sent;
                blockContentPosition = block._endPosition;
                block.contentPosition = block._endPosition;
                uncompressedData = Buffer.allocUnsafe(block.uncompressedSize);

                if (!(block.compressionMethod !== 'raw')) {
                  _context13.next = 20;
                  break;
                }

                compressedData = Buffer.allocUnsafe(block.compressedSize);
                _context13.next = 17;
                return this.read(compressedData, 0, block.compressedSize, blockContentPosition);

              case 17:
                this._uncompress(block.compressionMethod, compressedData, uncompressedData);

                _context13.next = 22;
                break;

              case 20:
                _context13.next = 22;
                return this.read(uncompressedData, 0, block.uncompressedSize, blockContentPosition);

              case 22:
                block.content = uncompressedData;

                if (!(majorVersion >= 3)) {
                  _context13.next = 35;
                  break;
                }

                _context13.next = 26;
                return this._parseSection(sectionParsers.cramBlockCrc32, blockContentPosition + block.compressedSize);

              case 26:
                crc = _context13.sent;
                block.crc32 = crc.crc32; // check the block data crc32

                if (!this.validateChecksums) {
                  _context13.next = 31;
                  break;
                }

                _context13.next = 31;
                return this.checkCrc32(position, block._size + block.compressedSize, block.crc32, 'block data');

              case 31:
                // make the endposition and size reflect the whole block
                block._endPosition = crc._endPosition;
                block._size = block.compressedSize + sectionParsers.cramBlockCrc32.maxLength;
                _context13.next = 37;
                break;

              case 35:
                block._endPosition = blockContentPosition + block.compressedSize;
                block._size = block.compressedSize;

              case 37:
                return _context13.abrupt("return", block);

              case 38:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee10, this);
      }));

      function readBlock(_x9) {
        return _readBlock.apply(this, arguments);
      }

      return readBlock;
    }()
  }]);
  return CramFile;
}();

(0, _forEach.default)(_context14 = 'getDefinition getSectionParsers getSamHeader'.split(' ')).call(_context14, function (method) {
  return tinyMemoize(CramFile, method);
});
module.exports = CramFile;