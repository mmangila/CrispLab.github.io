"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

var _keys = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/keys"));

var _forEach = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/for-each"));

var _flags = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/flags"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/createClass"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/toConsumableArray"));

var Constants = require('./constants');

function decodeReadSequence(cramRecord, refRegion) {
  // if it has no length, it has no sequence
  if (!cramRecord.lengthOnRef && !cramRecord.readLength) return undefined;
  if (cramRecord.isUnknownBases()) return undefined; // remember: all coordinates are 1-based closed

  var regionSeqOffset = cramRecord.alignmentStart - refRegion.start;
  if (!cramRecord.readFeatures) return refRegion.seq.substr(regionSeqOffset, cramRecord.lengthOnRef).toUpperCase();
  var bases = '';
  var regionPos = regionSeqOffset;
  var currentReadFeature = 0;

  while (bases.length < cramRecord.readLength) {
    if (currentReadFeature < cramRecord.readFeatures.length) {
      var feature = cramRecord.readFeatures[currentReadFeature];

      if (feature.code === 'Q' || feature.code === 'q') {
        currentReadFeature += 1;
      } else if (feature.pos === bases.length + 1) {
        // process the read feature
        currentReadFeature += 1;

        if (feature.code === 'b') {
          // specify a base pair for some reason
          var ret = feature.data.split(',');
          var added = String.fromCharCode.apply(String, (0, _toConsumableArray2.default)(ret));
          bases += added;
          regionPos += added.length;
        } else if (feature.code === 'B') {
          // base pair and associated quality
          // TODO: do we need to set the quality in the qual scores?
          bases += feature.data[0];
          regionPos += 1;
        } else if (feature.code === 'X') {
          // base substitution
          bases += feature.sub;
          regionPos += 1;
        } else if (feature.code === 'I') {
          // insertion
          bases += feature.data;
        } else if (feature.code === 'D') {
          // deletion
          regionPos += feature.data;
        } else if (feature.code === 'i') {
          // insert single base
          bases += feature.data;
        } else if (feature.code === 'N') {
          // reference skip. delete some bases
          // do nothing
          // seqBases.splice(feature.pos - 1, feature.data)
          regionPos += feature.data;
        } else if (feature.code === 'S') {
          // soft clipped bases that should be present in the read seq
          // seqBases.splice(feature.pos - 1, 0, ...feature.data.split(''))
          bases += feature.data;
        } else if (feature.code === 'P') {// padding, do nothing
        } else if (feature.code === 'H') {// hard clip, do nothing
        }
      } else if (currentReadFeature < cramRecord.readFeatures.length) {
        // put down a chunk of sequence up to the next read feature
        var chunk = refRegion.seq.substr(regionPos, cramRecord.readFeatures[currentReadFeature].pos - bases.length - 1);
        bases += chunk;
        regionPos += chunk.length;
      }
    } else {
      // put down a chunk of reference up to the full read length
      var _chunk = refRegion.seq.substr(regionPos, cramRecord.readLength - bases.length);

      bases += _chunk;
      regionPos += _chunk.length;
    }
  }

  return bases.toUpperCase();
}

var baseNumbers = {
  a: 0,
  A: 0,
  c: 1,
  C: 1,
  g: 2,
  G: 2,
  t: 3,
  T: 3,
  n: 4,
  N: 4
};

function decodeBaseSubstitution(cramRecord, refRegion, compressionScheme, readFeature) {
  if (!refRegion) return; // decode base substitution code using the substitution matrix

  var refCoord = readFeature.refPos - refRegion.start;
  var refBase = refRegion.seq.charAt(refCoord);
  if (refBase) readFeature.ref = refBase;
  var baseNumber = baseNumbers[refBase];
  if (baseNumber === undefined) baseNumber = 4;
  var substitutionScheme = compressionScheme.substitutionMatrix[baseNumber];
  var base = substitutionScheme[readFeature.data];
  if (base) readFeature.sub = base;
}
/**
 * Class of each CRAM record returned by this API.
 */


var CramRecord =
/*#__PURE__*/
function () {
  function CramRecord() {
    (0, _classCallCheck2.default)(this, CramRecord);
    this.tags = {};
  }
  /**
   * @returns {boolean} true if the read is paired, regardless of whether both segments are mapped
   */


  (0, _createClass2.default)(CramRecord, [{
    key: "isPaired",
    value: function isPaired() {
      return !!((0, _flags.default)(this) & Constants.BAM_FPAIRED);
    }
    /** @returns {boolean} true if the read is paired, and both segments are mapped */

  }, {
    key: "isProperlyPaired",
    value: function isProperlyPaired() {
      return !!((0, _flags.default)(this) & Constants.BAM_FPROPER_PAIR);
    }
    /** @returns {boolean} true if the read itself is unmapped; conflictive with isProperlyPaired */

  }, {
    key: "isSegmentUnmapped",
    value: function isSegmentUnmapped() {
      return !!((0, _flags.default)(this) & Constants.BAM_FUNMAP);
    }
    /** @returns {boolean} true if the read itself is unmapped; conflictive with isProperlyPaired */

  }, {
    key: "isMateUnmapped",
    value: function isMateUnmapped() {
      return !!((0, _flags.default)(this) & Constants.BAM_FMUNMAP);
    }
    /** @returns {boolean} true if the read is mapped to the reverse strand */

  }, {
    key: "isReverseComplemented",
    value: function isReverseComplemented() {
      return !!((0, _flags.default)(this) & Constants.BAM_FREVERSE);
    }
    /** @returns {boolean} true if the mate is mapped to the reverse strand */

  }, {
    key: "isMateReverseComplemented",
    value: function isMateReverseComplemented() {
      return !!((0, _flags.default)(this) & Constants.BAM_FMREVERSE);
    }
    /** @returns {boolean} true if this is read number 1 in a pair */

  }, {
    key: "isRead1",
    value: function isRead1() {
      return !!((0, _flags.default)(this) & Constants.BAM_FREAD1);
    }
    /** @returns {boolean} true if this is read number 2 in a pair */

  }, {
    key: "isRead2",
    value: function isRead2() {
      return !!((0, _flags.default)(this) & Constants.BAM_FREAD2);
    }
    /** @returns {boolean} true if this is a secondary alignment */

  }, {
    key: "isSecondary",
    value: function isSecondary() {
      return !!((0, _flags.default)(this) & Constants.BAM_FSECONDARY);
    }
    /** @returns {boolean} true if this read has failed QC checks */

  }, {
    key: "isFailedQc",
    value: function isFailedQc() {
      return !!((0, _flags.default)(this) & Constants.BAM_FQCFAIL);
    }
    /** @returns {boolean} true if the read is an optical or PCR duplicate */

  }, {
    key: "isDuplicate",
    value: function isDuplicate() {
      return !!((0, _flags.default)(this) & Constants.BAM_FDUP);
    }
    /** @returns {boolean} true if this is a supplementary alignment */

  }, {
    key: "isSupplementary",
    value: function isSupplementary() {
      return !!((0, _flags.default)(this) & Constants.BAM_FSUPPLEMENTARY);
    }
    /**
     * @returns {boolean} true if the read is detached
     */

  }, {
    key: "isDetached",
    value: function isDetached() {
      return !!(this.cramFlags & Constants.CRAM_FLAG_DETACHED);
    }
    /** @returns {boolean} true if the read has a mate in this same CRAM segment */

  }, {
    key: "hasMateDownStream",
    value: function hasMateDownStream() {
      return !!(this.cramFlags & Constants.CRAM_FLAG_MATE_DOWNSTREAM);
    }
    /** @returns {boolean} true if the read contains qual scores */

  }, {
    key: "isPreservingQualityScores",
    value: function isPreservingQualityScores() {
      return !!(this.cramFlags & Constants.CRAM_FLAG_PRESERVE_QUAL_SCORES);
    }
    /** @returns {boolean} true if the read has no sequence bases */

  }, {
    key: "isUnknownBases",
    value: function isUnknownBases() {
      return !!(this.cramFlags & Constants.CRAM_FLAG_NO_SEQ);
    }
    /**
     * Get the original sequence of this read.
     * @returns {String} sequence basepairs
     */

  }, {
    key: "getReadBases",
    value: function getReadBases() {
      if (!this.readBases && this._refRegion) {
        this.readBases = decodeReadSequence(this, this._refRegion);
      }

      return this.readBases;
    }
    /**
     * Get the pair orientation of a paired read. Adapted from igv.js
     * @returns {String} of paired orientatin
     */

  }, {
    key: "getPairOrientation",
    value: function getPairOrientation() {
      if (!this.isSegmentUnmapped() && this.isPaired() && !this.isMateUnmapped() && this.mate && this.sequenceId === this.mate.sequenceId) {
        var s1 = this.isReverseComplemented() ? 'R' : 'F';
        var s2 = this.isMateReverseComplemented() ? 'R' : 'F';
        var o1 = ' ';
        var o2 = ' ';

        if (this.isRead1()) {
          o1 = '1';
          o2 = '2';
        } else if (this.isRead2()) {
          o1 = '2';
          o2 = '1';
        }

        var tmp = [];
        var isize = this.templateLength || this.templateSize;

        if (this.alignmentStart > this.mate.alignmentStart && isize > 0) {
          isize = -isize;
        }

        if (isize > 0) {
          tmp[0] = s1;
          tmp[1] = o1;
          tmp[2] = s2;
          tmp[3] = o2;
        } else {
          tmp[2] = s1;
          tmp[3] = o1;
          tmp[0] = s2;
          tmp[1] = o2;
        }

        return tmp.join('');
      }

      return null;
    }
    /**
     * Annotates this feature with the given reference sequence basepair
     * information. This will add a `sub` and a `ref` item to base
     * subsitution read features given the actual substituted and reference
     * base pairs, and will make the `getReadSequence()` method work.
     *
     * @param {object} refRegion
     * @param {number} refRegion.start
     * @param {number} refRegion.end
     * @param {string} refRegion.seq
     * @param {CramContainerCompressionScheme} compressionScheme
     * @returns {undefined} nothing
     */

  }, {
    key: "addReferenceSequence",
    value: function addReferenceSequence(refRegion, compressionScheme) {
      var _this = this;

      if (this.readFeatures) {
        var _context;

        // use the reference bases to decode the bases
        // substituted in each base substitution
        (0, _forEach.default)(_context = this.readFeatures).call(_context, function (readFeature) {
          if (readFeature.code === 'X') decodeBaseSubstitution(_this, refRegion, compressionScheme, readFeature);
        });
      } // if this region completely covers this read,
      // keep a reference to it


      if (!this.readBases && refRegion.start <= this.alignmentStart && refRegion.end >= this.alignmentStart + (this.lengthOnRef || this.readLength) - 1) {
        this._refRegion = refRegion;
      }
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var _context2,
          _this2 = this;

      var data = {};
      (0, _forEach.default)(_context2 = (0, _keys.default)(this)).call(_context2, function (k) {
        if (k.charAt(0) === '_') return;
        data[k] = _this2[k];
      });
      data.readBases = this.getReadBases();
      return data;
    }
  }]);
  return CramRecord;
}();

module.exports = CramRecord;