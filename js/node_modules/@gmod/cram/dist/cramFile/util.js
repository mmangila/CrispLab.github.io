"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

var _promise = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/promise"));

var md5 = require('md5');

var _require = require('../errors'),
    CramBufferOverrunError = _require.CramBufferOverrunError;

module.exports = {
  itf8Size: function itf8Size(v) {
    if (!(v & ~0x7f)) return 1;
    if (!(v & ~0x3fff)) return 2;
    if (!(v & ~0x1fffff)) return 3;
    if (!(v & ~0xfffffff)) return 4;
    return 5;
  },
  parseItf8: function parseItf8(buffer, initialOffset) {
    var offset = initialOffset;
    var countFlags = buffer[offset];
    var result;

    if (countFlags < 0x80) {
      result = countFlags;
      offset += 1;
    } else if (countFlags < 0xc0) {
      result = (countFlags << 8 | buffer[offset + 1]) & 0x3fff;
      offset += 2;
    } else if (countFlags < 0xe0) {
      result = (countFlags << 16 | buffer[offset + 1] << 8 | buffer[offset + 2]) & 0x1fffff;
      offset += 3;
    } else if (countFlags < 0xf0) {
      result = (countFlags << 24 | buffer[offset + 1] << 16 | buffer[offset + 2] << 8 | buffer[offset + 3]) & 0x0fffffff;
      offset += 4;
    } else {
      result = (countFlags & 0x0f) << 28 | buffer[offset + 1] << 20 | buffer[offset + 2] << 12 | buffer[offset + 3] << 4 | buffer[offset + 4] & 0x0f; // x=((0xff & 0x0f)<<28) | (0xff<<20) | (0xff<<12) | (0xff<<4) | (0x0f & 0x0f);
      // TODO *val_p = uv < 0x80000000UL ? uv : -((int32_t) (0xffffffffUL - uv)) - 1;

      offset += 5;
    }

    if (offset > buffer.length) {
      throw new CramBufferOverrunError('Attempted to read beyond end of buffer; this file seems truncated.');
    }

    return [result, offset - initialOffset];
  },
  // parseLtf8(buffer, initialOffset) {
  //   let offset = initialOffset
  //   const countFlags = buffer[offset]
  //   let result
  //   if (countFlags < 0x80) {
  //     result = countFlags
  //     offset += 1
  //   } else if (countFlags < 0xc0) {
  //     result = ((buffer[offset] << 8) | buffer[offset + 1]) & 0x3fff
  //     offset += 2
  //   } else if (countFlags < 0xe0) {
  //     result =
  //       ((buffer[offset] << 16) |
  //         (buffer[offset + 1] << 8) |
  //         buffer[offset + 2]) &
  //       0x1fffff
  //     offset += 3
  //   } else if (countFlags < 0xf0) {
  //     result =
  //       ((buffer[offset] << 24) |
  //         (buffer[offset + 1] << 16) |
  //         (buffer[offset + 2] << 8) |
  //         buffer[offset + 3]) &
  //       0x0fffffff
  //     offset += 4
  //   } else if (countFlags < 0xf8) {
  //     result =
  //       ((buffer[offset] & 15) * Math.pow(2,32) + (buffer[offset + 1] << 24)) |
  //       ((buffer[offset + 2] << 16) |
  //         (buffer[offset + 3] << 8) |
  //         buffer[offset + 4])
  //     // TODO *val_p = uv < 0x80000000UL ? uv : -((int32_t) (0xffffffffUL - uv)) - 1;
  //     offset += 5
  //   } else if (countFlags < 0xfc) {
  //     result =
  //       ((((buffer[offset] & 7) << 8) | buffer[offset + 1]) * Math.pow(2,32) +
  //         (buffer[offset + 2] << 24)) |
  //       ((buffer[offset + 3] << 16) |
  //         (buffer[offset + 4] << 8) |
  //         buffer[offset + 5])
  //     offset += 6
  //   } else if (countFlags < 0xfe) {
  //     result =
  //       ((((buffer[offset] & 3) << 16) |
  //         (buffer[offset + 1] << 8) |
  //         buffer[offset + 2]) *
  //         Math.pow(2,32) +
  //         (buffer[offset + 3] << 24)) |
  //       ((buffer[offset + 4] << 16) |
  //         (buffer[offset + 5] << 8) |
  //         buffer[offset + 6])
  //     offset += 7
  //   } else if (countFlags < 0xff) {
  //     result = Long.fromBytesBE(buffer.slice(offset + 1, offset + 8))
  //     if (
  //       result.greaterThan(Number.MAX_SAFE_INTEGER) ||
  //       result.lessThan(Number.MIN_SAFE_INTEGER)
  //     )
  //       throw new CramUnimplementedError('integer overflow')
  //     result = result.toNumber()
  //     offset += 8
  //   } else {
  //     result = Long.fromBytesBE(buffer.slice(offset + 1, offset + 9))
  //     if (
  //       result.greaterThan(Number.MAX_SAFE_INTEGER) ||
  //       result.lessThan(Number.MIN_SAFE_INTEGER)
  //     )
  //       throw new CramUnimplementedError('integer overflow')
  //     result = result.toNumber()
  //     offset += 9
  //   }
  //   return [result, offset - initialOffset]
  // },
  parseItem: function parseItem(buffer, parser) {
    var startBufferPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var startFilePosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

    var _parser$parse = parser.parse(buffer),
        offset = _parser$parse.offset,
        result = _parser$parse.result;

    result._endPosition = offset + startFilePosition;
    result._size = offset - startBufferPosition;
    return result;
  },
  // this would be nice as a decorator, but i'm a little worried about
  // babel support for it going away or changing.
  // memoizes a method in the stupidest possible way, with no regard for the
  // arguments.  actually, this only works on methods that take no arguments
  tinyMemoize: function tinyMemoize(_class, methodName) {
    var method = _class.prototype[methodName];
    var memoAttrName = "_memo_".concat(methodName);

    _class.prototype[methodName] = function _tinyMemoized() {
      var _this = this;

      if (!(memoAttrName in this)) {
        var res = method.call(this);
        this[memoAttrName] = res;

        _promise.default.resolve(res).catch(function () {
          delete _this[memoAttrName];
        });
      }

      return this[memoAttrName];
    };
  },
  sequenceMD5: function sequenceMD5(seq) {
    return md5(seq.toUpperCase().replace(/[^\x21-\x7e]/g, ''));
  }
};