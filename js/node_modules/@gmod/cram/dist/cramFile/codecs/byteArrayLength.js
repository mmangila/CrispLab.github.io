"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

var _forEach = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/for-each"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/inherits"));

var _context;

var _require = require('../util'),
    tinyMemoize = _require.tinyMemoize;

var CramCodec = require('./_base');

var ByteArrayStopCodec =
/*#__PURE__*/
function (_CramCodec) {
  (0, _inherits2.default)(ByteArrayStopCodec, _CramCodec);

  function ByteArrayStopCodec() {
    var _this;

    var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var dataType = arguments.length > 1 ? arguments[1] : undefined;
    var instantiateCodec = arguments.length > 2 ? arguments[2] : undefined;
    (0, _classCallCheck2.default)(this, ByteArrayStopCodec);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(ByteArrayStopCodec).call(this, parameters, dataType));
    _this.instantiateCodec = instantiateCodec;
    if (dataType !== 'byteArray') throw new TypeError("byteArrayLength does not support data type ".concat(dataType));
    return _this;
  }

  (0, _createClass2.default)(ByteArrayStopCodec, [{
    key: "decode",
    value: function decode(slice, coreDataBlock, blocksByContentId, cursors) {
      var lengthCodec = this._getLengthCodec();

      var arrayLength = lengthCodec.decode(slice, coreDataBlock, blocksByContentId, cursors);

      var dataCodec = this._getDataCodec();

      var data = new Array(arrayLength);

      for (var i = 0; i < arrayLength; i += 1) {
        data[i] = dataCodec.decode(slice, coreDataBlock, blocksByContentId, cursors);
      }

      return data;
    } // memoize

  }, {
    key: "_getLengthCodec",
    value: function _getLengthCodec() {
      var encodingParams = this.parameters.lengthsEncoding;
      return this.instantiateCodec(encodingParams, 'int');
    } // memoize

  }, {
    key: "_getDataCodec",
    value: function _getDataCodec() {
      var encodingParams = this.parameters.valuesEncoding;
      return this.instantiateCodec(encodingParams, 'byte');
    }
  }]);
  return ByteArrayStopCodec;
}(CramCodec);

(0, _forEach.default)(_context = '_getLengthCodec _getDataCodec'.split(' ')).call(_context, function (method) {
  return tinyMemoize(ByteArrayStopCodec, method);
});
module.exports = ByteArrayStopCodec;