"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

var _fill = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/fill"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/toConsumableArray"));

var _map = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/map"));

var _values = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/values"));

var _parseInt2 = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/parse-int"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/slicedToArray"));

var _entries = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/entries"));

var _forEach = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/for-each"));

var _sort = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/sort"));

var _includes = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/includes"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/inherits"));

var _require = require('../../errors'),
    CramMalformedError = _require.CramMalformedError;

var CramCodec = require('./_base');

function numberOfSetBits(ii) {
  var i = ii - (ii >> 1) & 0x55555555;
  i = (i & 0x33333333) + (i >> 2 & 0x33333333);
  return (i + (i >> 4) & 0x0f0f0f0f) * 0x01010101 >> 24;
}

var HuffmanIntCodec =
/*#__PURE__*/
function (_CramCodec) {
  (0, _inherits2.default)(HuffmanIntCodec, _CramCodec);

  function HuffmanIntCodec() {
    var _context;

    var _this;

    var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var dataType = arguments.length > 1 ? arguments[1] : undefined;
    (0, _classCallCheck2.default)(this, HuffmanIntCodec);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(HuffmanIntCodec).call(this, parameters, dataType));

    if (!(0, _includes.default)(_context = ['byte', 'int']).call(_context, _this.dataType)) {
      throw new TypeError("".concat(_this.dataType, " decoding not yet implemented by HUFFMAN_INT codec"));
    }

    _this.buildCodeBook();

    _this.buildCodes();

    _this.buildCaches(); // if this is a degenerate zero-length huffman code, special-case the decoding


    if (_this.sortedCodes[0].bitLength === 0) _this._decode = _this._decodeZeroLengthCode;
    return _this;
  }

  (0, _createClass2.default)(HuffmanIntCodec, [{
    key: "buildCodeBook",
    value: function buildCodeBook() {
      var _this2 = this;

      // parse the parameters together into a `codes` data structure
      var codes = new Array(this.parameters.numCodes);

      for (var i = 0; i < this.parameters.numCodes; i += 1) {
        codes[i] = {
          symbol: this.parameters.symbols[i],
          bitLength: this.parameters.bitLengths[i]
        };
      } // sort the codes by bit length and symbol value


      codes = (0, _sort.default)(codes).call(codes, function (a, b) {
        return a.bitLength - b.bitLength || a.symbol - b.symbol;
      });
      this.codeBook = {};
      (0, _forEach.default)(codes).call(codes, function (code) {
        if (!_this2.codeBook[code.bitLength]) _this2.codeBook[code.bitLength] = [];

        _this2.codeBook[code.bitLength].push(code.symbol);
      });
    }
  }, {
    key: "buildCodes",
    value: function buildCodes() {
      var _context2,
          _this3 = this;

      this.codes = {};
      /*  new TreeMap<Integer, HuffmanBitCode>(); */

      var codeLength = 0;
      var codeValue = -1;
      (0, _forEach.default)(_context2 = (0, _entries.default)(this.codeBook)).call(_context2, function (_ref) {
        var _ref2 = (0, _slicedToArray2.default)(_ref, 2),
            bitLength = _ref2[0],
            symbols = _ref2[1];

        bitLength = (0, _parseInt2.default)(bitLength, 10);
        (0, _forEach.default)(symbols).call(symbols, function (symbol) {
          var code = {
            bitLength: bitLength,
            value: symbol
          };
          codeValue += 1;
          var delta = bitLength - codeLength; // new length?

          codeValue <<= delta; // pad with 0's

          code.bitCode = codeValue; // calculated: huffman code

          codeLength += delta; // adjust current code length

          if (numberOfSetBits(codeValue) > bitLength) throw new CramMalformedError('Symbol out of range');
          _this3.codes[symbol] = code;
        });
      });
    }
  }, {
    key: "buildCaches",
    value: function buildCaches() {
      var _context3, _context4, _context5, _context6, _context7, _context8;

      this.sortedCodes = (0, _sort.default)(_context3 = (0, _values.default)(this.codes)).call(_context3, function (a, b) {
        return a.bitLength - b.bitLength || a.bitCode - b.bitCode;
      }); // this.sortedValues = this.parameters.values.sort((a,b) => a-b)

      this.sortedByValue = (0, _sort.default)(_context4 = (0, _values.default)(this.codes)).call(_context4, function (a, b) {
        return a.value - b.value;
      });
      this.sortedValuesByBitCode = (0, _map.default)(_context5 = this.sortedCodes).call(_context5, function (c) {
        return c.value;
      });
      this.sortedBitCodes = (0, _map.default)(_context6 = this.sortedCodes).call(_context6, function (c) {
        return c.bitCode;
      });
      this.sortedBitLengthsByBitCode = (0, _map.default)(_context7 = this.sortedCodes).call(_context7, function (c) {
        return c.bitLength;
      });
      var maxBitCode = Math.max.apply(Math, (0, _toConsumableArray2.default)(this.sortedBitCodes));
      this.bitCodeToValue = (0, _fill.default)(_context8 = new Array(maxBitCode + 1)).call(_context8, -1);

      for (var i = 0; i < this.sortedBitCodes.length; i += 1) {
        this.bitCodeToValue[this.sortedCodes[i].bitCode] = i;
      }
    }
  }, {
    key: "decode",
    value: function decode(slice, coreDataBlock, blocksByContentId, cursors) {
      return this._decode(slice, coreDataBlock, cursors.coreBlock);
    } // _decodeNull() {
    //   return -1
    // }
    // the special case for zero-length codes

  }, {
    key: "_decodeZeroLengthCode",
    value: function _decodeZeroLengthCode() {
      return this.sortedCodes[0].value;
    }
  }, {
    key: "_decode",
    value: function _decode(slice, coreDataBlock, coreCursor) {
      var input = coreDataBlock.content;
      var prevLen = 0;
      var bits = 0;

      for (var i = 0; i < this.sortedCodes.length; i += 1) {
        var length = this.sortedCodes[i].bitLength;
        bits <<= length - prevLen;
        bits |= this._getBits(input, coreCursor, length - prevLen);
        prevLen = length;
        {
          var index = this.bitCodeToValue[bits];
          if (index > -1 && this.sortedBitLengthsByBitCode[index] === length) return this.sortedValuesByBitCode[index];

          for (var j = i; this.sortedCodes[j + 1].bitLength === length && j < this.sortedCodes.length; j += 1) {
            i += 1;
          }
        }
      }

      throw new CramMalformedError('Huffman symbol not found.');
    }
  }]);
  return HuffmanIntCodec;
}(CramCodec);

module.exports = HuffmanIntCodec;