"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/createClass"));

var _require = require('../../errors'),
    CramBufferOverrunError = _require.CramBufferOverrunError;

var validDataTypes = {
  int: true,
  byte: true,
  long: true,
  byteArray: true,
  byteArrayBlock: true
}; // codec base class

var CramCodec =
/*#__PURE__*/
function () {
  function CramCodec() {
    var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var dataType = arguments.length > 1 ? arguments[1] : undefined;
    (0, _classCallCheck2.default)(this, CramCodec);
    this.parameters = parameters;
    this.dataType = dataType;
    if (!dataType) throw new TypeError('must provide a data type to codec constructor');
    if (!validDataTypes[dataType]) throw new TypeError("invalid data type ".concat(dataType));
  } // decode(slice, coreDataBlock, blocksByContentId, cursors) {
  // }


  (0, _createClass2.default)(CramCodec, [{
    key: "_getBits",
    value: function _getBits(data, cursor, numBits) {
      var val = 0;
      if (cursor.bytePosition + (7 - cursor.bitPosition + numBits) / 8 > data.length) throw new CramBufferOverrunError('read error during decoding. the file seems to be truncated.');

      for (var dlen = numBits; dlen; dlen -= 1) {
        // get the next `dlen` bits in the input, put them in val
        val <<= 1;
        val |= data[cursor.bytePosition] >> cursor.bitPosition & 1;
        cursor.bitPosition -= 1;
        if (cursor.bitPosition < 0) cursor.bytePosition += 1;
        cursor.bitPosition &= 7;
      }

      return val;
    }
  }]);
  return CramCodec;
}();

module.exports = CramCodec;