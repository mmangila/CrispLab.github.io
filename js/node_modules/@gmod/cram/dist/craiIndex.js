"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime-corejs3/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/asyncToGenerator"));

var _sort = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/sort"));

var _entries = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/entries"));

var _forEach = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/for-each"));

var _parseInt = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/number/parse-int"));

var _bind = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/bind"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/slicedToArray"));

var _some = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/some"));

var _concat = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/concat"));

var _assign = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/assign"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/createClass"));

var AbortablePromiseCache = require('abortable-promise-cache').default;

var QuickLRU = require('quick-lru');

var _require = require('es6-promisify'),
    promisify = _require.promisify;

var zlib = require('zlib');

var gunzip = promisify(zlib.gunzip);

var _require2 = require('./io'),
    open = _require2.open;

var _require3 = require('./errors'),
    CramMalformedError = _require3.CramMalformedError;

var BAI_MAGIC = 21578050; // BAI\1

var Slice =
/*#__PURE__*/
function () {
  function Slice(args) {
    (0, _classCallCheck2.default)(this, Slice);
    (0, _assign.default)(this, args);
  }

  (0, _createClass2.default)(Slice, [{
    key: "toString",
    value: function toString() {
      var _context, _context2, _context3, _context4;

      return (0, _concat.default)(_context = (0, _concat.default)(_context2 = (0, _concat.default)(_context3 = (0, _concat.default)(_context4 = "".concat(this.start, ":")).call(_context4, this.span, ":")).call(_context3, this.containerStart, ":")).call(_context2, this.sliceStart, ":")).call(_context, this.sliceBytes);
    }
  }]);
  return Slice;
}();

function addRecordToIndex(index, record) {
  if ((0, _some.default)(record).call(record, function (el) {
    return el === undefined;
  })) {
    throw new CramMalformedError('invalid .crai index file');
  }

  var _record = (0, _slicedToArray2.default)(record, 6),
      seqId = _record[0],
      start = _record[1],
      span = _record[2],
      containerStart = _record[3],
      sliceStart = _record[4],
      sliceBytes = _record[5];

  if (!index[seqId]) index[seqId] = [];
  index[seqId].push(new Slice({
    start: start,
    span: span,
    containerStart: containerStart,
    sliceStart: sliceStart,
    sliceBytes: sliceBytes
  }));
}

var CraiIndex =
/*#__PURE__*/
function () {
  // A CRAM index (.crai) is a gzipped tab delimited file containing the following columns:
  // 1. Sequence id
  // 2. Alignment start
  // 3. Alignment span
  // 4. Container start byte position in the file
  // 5. Slice start byte position in the container data (‘blocks’)
  // 6. Slice size in bytes
  // Each line represents a slice in the CRAM file. Please note that all slices must be listed in index file.

  /**
   *
   * @param {object} args
   * @param {string} [args.path]
   * @param {string} [args.url]
   * @param {FileHandle} [args.filehandle]
   */
  function CraiIndex(args) {
    var _this = this,
        _context5;

    (0, _classCallCheck2.default)(this, CraiIndex);
    var filehandle = open(args.url, args.path, args.filehandle);
    this._parseCache = new AbortablePromiseCache({
      cache: new QuickLRU({
        maxSize: 1
      }),
      fill: function fill(data, signal) {
        return _this.parseIndex({
          signal: signal
        });
      }
    });
    this.readFile = (0, _bind.default)(_context5 = filehandle.readFile).call(_context5, filehandle);
  }

  (0, _createClass2.default)(CraiIndex, [{
    key: "parseIndex",
    value: function parseIndex() {
      var index = {};
      return this.readFile().then(function (data) {
        if (data[0] === 31 && data[1] === 139) return gunzip(data);
        return data;
      }).then(function (uncompressedBuffer) {
        var _context6;

        if (uncompressedBuffer.length > 4 && uncompressedBuffer.readUInt32LE(0) === BAI_MAGIC) {
          throw new CramMalformedError('invalid .crai index file. note: file appears to be a .bai index. this is technically legal but please open a github issue if you need support');
        } // interpret the text as regular ascii, since it is
        // supposed to be only digits and whitespace characters
        // this is written in a deliberately low-level fashion for performance,
        // because some .crai files can be pretty large.


        var currentRecord = [];
        var currentString = '';

        for (var i = 0; i < uncompressedBuffer.length; i += 1) {
          var charCode = uncompressedBuffer[i];

          if (charCode >= 48 && charCode <= 57 ||
          /* 0-9 */
          !currentString && charCode === 45
          /* leading - */
          ) {
              currentString += String.fromCharCode(charCode);
            } else if (charCode === 9
          /* \t */
          ) {
              currentRecord.push((0, _parseInt.default)(currentString, 10));
              currentString = '';
            } else if (charCode === 10
          /* \n */
          ) {
              currentRecord.push((0, _parseInt.default)(currentString, 10));
              currentString = '';
              addRecordToIndex(index, currentRecord);
              currentRecord = [];
            } else if (charCode !== 13
          /* \r */
          && charCode !== 32
          /* space */
          ) {
              // if there are other characters in the file besides
              // space and \r, something is wrong.
              throw new CramMalformedError('invalid .crai index file');
            }
        } // if the file ends without a \n, we need to flush our buffers


        if (currentString) {
          currentRecord.push((0, _parseInt.default)(currentString, 10));
        }

        if (currentRecord.length === 6) {
          addRecordToIndex(index, currentRecord);
        } // sort each of them by start


        (0, _forEach.default)(_context6 = (0, _entries.default)(index)).call(_context6, function (_ref) {
          var _ref2 = (0, _slicedToArray2.default)(_ref, 2),
              seqId = _ref2[0],
              ent = _ref2[1];

          index[seqId] = (0, _sort.default)(ent).call(ent, function (a, b) {
            return a.start - b.start || a.span - b.span;
          });
        });
        return index;
      });
    }
  }, {
    key: "getIndex",
    value: function getIndex() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return this._parseCache.get('index', null, opts.signal);
    }
    /**
     * @param {number} seqId
     * @returns {Promise} true if the index contains entries for
     * the given reference sequence ID, false otherwise
     */

  }, {
    key: "hasDataForReferenceSequence",
    value: function () {
      var _hasDataForReferenceSequence = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee(seqId) {
        return _regenerator.default.wrap(function _callee$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return this.getIndex();

              case 2:
                _context7.t0 = seqId;
                return _context7.abrupt("return", !!_context7.sent[_context7.t0]);

              case 4:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee, this);
      }));

      function hasDataForReferenceSequence(_x) {
        return _hasDataForReferenceSequence.apply(this, arguments);
      }

      return hasDataForReferenceSequence;
    }()
    /**
     * fetch index entries for the given range
     *
     * @param {number} seqId
     * @param {number} queryStart
     * @param {number} queryEnd
     *
     * @returns {Promise} promise for
     * an array of objects of the form
     * `{start, span, containerStart, sliceStart, sliceBytes }`
     */

  }, {
    key: "getEntriesForRange",
    value: function () {
      var _getEntriesForRange = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee2(seqId, queryStart, queryEnd) {
        var seqEntries, compare, bins, i;
        return _regenerator.default.wrap(function _callee2$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.next = 2;
                return this.getIndex();

              case 2:
                _context8.t0 = seqId;
                seqEntries = _context8.sent[_context8.t0];

                if (seqEntries) {
                  _context8.next = 6;
                  break;
                }

                return _context8.abrupt("return", []);

              case 6:
                compare = function compare(entry) {
                  var entryStart = entry.start;
                  var entryEnd = entry.start + entry.span;
                  if (entryStart >= queryEnd) return -1; // entry is ahead of query

                  if (entryEnd <= queryStart) return 1; // entry is behind query

                  return 0; // entry overlaps query
                };

                bins = [];

                for (i = 0; i < seqEntries.length; i += 1) {
                  if (compare(seqEntries[i]) === 0) {
                    bins.push(seqEntries[i]);
                  }
                }

                return _context8.abrupt("return", bins);

              case 10:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee2, this);
      }));

      function getEntriesForRange(_x2, _x3, _x4) {
        return _getEntriesForRange.apply(this, arguments);
      }

      return getEntriesForRange;
    }()
  }]);
  return CraiIndex;
}();

module.exports = CraiIndex;