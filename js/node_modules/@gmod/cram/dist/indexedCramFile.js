"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime-corejs3/regenerator"));

var _sort = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/sort"));

var _filter = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/filter"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/slicedToArray"));

var _entries = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/object/entries"));

var _forEach = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/for-each"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/toConsumableArray"));

var _promise = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/promise"));

var _concat = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/concat"));

var _map = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/map"));

var _reduce = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/reduce"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/createClass"));

var _require = require('./errors'),
    CramUnimplementedError = _require.CramUnimplementedError,
    CramSizeLimitError = _require.CramSizeLimitError;

var CramFile = require('./cramFile');

var IndexedCramFile =
/*#__PURE__*/
function () {
  /**
   *
   * @param {object} args
   * @param {CramFile} args.cram
   * @param {Index-like} args.index object that supports getEntriesForRange(seqId,start,end) -> Promise[Array[index entries]]
   * @param {number} [args.cacheSize] optional maximum number of CRAM records to cache.  default 20,000
   * @param {number} [args.fetchSizeLimit] optional maximum number of bytes to fetch in a single getRecordsForRange call.  Default 3 MiB.
   * @param {boolean} [args.checkSequenceMD5] - default true. if false, disables verifying the MD5
   * checksum of the reference sequence underlying a slice. In some applications, this check can cause an inconvenient amount (many megabases) of sequences to be fetched.
   */
  function IndexedCramFile(args) {
    (0, _classCallCheck2.default)(this, IndexedCramFile);
    // { cram, index, seqFetch /* fasta, fastaIndex */ }) {
    if (args.cram) this.cram = args.cram;else this.cram = new CramFile({
      url: args.cramUrl,
      path: args.cramPath,
      filehandle: args.cramFilehandle,
      seqFetch: args.seqFetch,
      checkSequenceMD5: args.checkSequenceMD5,
      cacheSize: args.cacheSize
    });
    if (!(this.cram instanceof CramFile)) throw new Error('invalid arguments: no cramfile');
    this.index = args.index;
    if (!this.index.getEntriesForRange) throw new Error('invalid arguments: not an index');
    this.fetchSizeLimit = args.fetchSizeLimit || 3000000;
  }
  /**
   *
   * @param {number} seq numeric ID of the reference sequence
   * @param {number} start start of the range of interest. 1-based closed coordinates.
   * @param {number} end end of the range of interest. 1-based closed coordinates.
   * @returns {Promise[Array[CramRecord]]}
   */


  (0, _createClass2.default)(IndexedCramFile, [{
    key: "getRecordsForRange",
    value: function () {
      var _getRecordsForRange = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee(seq, start, end) {
        var _context,
            _context2,
            _this = this,
            _context3,
            _concatInstanceProper,
            _context4;

        var opts,
            seqId,
            slices,
            totalSize,
            filter,
            sliceResults,
            ret,
            _context5,
            _context6,
            _context7,
            readNames,
            readIds,
            i,
            name,
            id,
            unmatedPairs,
            matePromises,
            _i,
            _name,
            mateSlices,
            mateBlocks,
            mateChunks,
            _i2,
            _mateChunks,
            mateRecordPromises,
            mateFeatPromises,
            mateTotalSize,
            _context8,
            newMateFeats,
            newMates,
            _args = arguments;

        return _regenerator.default.wrap(function _callee$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                opts = _args.length > 3 && _args[3] !== undefined ? _args[3] : {};
                opts.viewAsPairs = opts.viewAsPairs || false;
                opts.pairAcrossChr = opts.pairAcrossChr || false;
                opts.maxInsertSize = opts.maxInsertSize || 200000;

                if (!(typeof seq === 'string')) {
                  _context9.next = 6;
                  break;
                }

                throw new CramUnimplementedError('string sequence names not yet supported');

              case 6:
                seqId = seq;
                _context9.next = 9;
                return this.index.getEntriesForRange(seqId, start, end);

              case 9:
                slices = _context9.sent;
                totalSize = (0, _reduce.default)(_context = (0, _map.default)(slices).call(slices, function (s) {
                  return s.sliceBytes;
                })).call(_context, function (a, b) {
                  return a + b;
                }, 0);

                if (!(totalSize > this.fetchSizeLimit)) {
                  _context9.next = 13;
                  break;
                }

                throw new CramSizeLimitError((0, _concat.default)(_context2 = "data size of ".concat(totalSize.toLocaleString(), " bytes exceeded fetch size limit of ")).call(_context2, this.fetchSizeLimit.toLocaleString(), " bytes"));

              case 13:
                // TODO: do we need to merge or de-duplicate the blocks?
                // fetch all the slices and parse the feature data
                filter = function filter(feature) {
                  return feature.sequenceId === seq && feature.alignmentStart <= end && feature.alignmentStart + feature.lengthOnRef - 1 >= start;
                };

                _context9.next = 16;
                return _promise.default.all((0, _map.default)(slices).call(slices, function (slice) {
                  return _this.getRecordsInSlice(slice, filter);
                }));

              case 16:
                sliceResults = _context9.sent;
                ret = (_concatInstanceProper = (0, _concat.default)(_context3 = Array.prototype)).call.apply(_concatInstanceProper, (0, _concat.default)(_context4 = [_context3]).call(_context4, (0, _toConsumableArray2.default)(sliceResults)));

                if (!opts.viewAsPairs) {
                  _context9.next = 42;
                  break;
                }

                readNames = {};
                readIds = {};

                for (i = 0; i < ret.length; i += 1) {
                  name = ret[i].readName;
                  id = ret[i].uniqueId;
                  if (!readNames[name]) readNames[name] = 0;
                  readNames[name] += 1;
                  readIds[id] = 1;
                }

                unmatedPairs = {};
                (0, _forEach.default)(_context5 = (0, _entries.default)(readNames)).call(_context5, function (_ref) {
                  var _ref2 = (0, _slicedToArray2.default)(_ref, 2),
                      k = _ref2[0],
                      v = _ref2[1];

                  if (v === 1) unmatedPairs[k] = true;
                });
                matePromises = [];

                for (_i = 0; _i < ret.length; _i += 1) {
                  _name = ret[_i].readName;

                  if (unmatedPairs[_name] && ret[_i].mate && (ret[_i].mate.sequenceId === seqId || opts.pairAcrossChr) && Math.abs(ret[_i].alignmentStart - ret[_i].mate.alignmentStart) < opts.maxInsertSize) {
                    mateSlices = this.index.getEntriesForRange(ret[_i].mate.sequenceId, ret[_i].mate.alignmentStart, ret[_i].mate.alignmentStart + 1);
                    matePromises.push(mateSlices);
                  }
                }

                _context9.next = 28;
                return _promise.default.all(matePromises);

              case 28:
                mateBlocks = _context9.sent;
                mateChunks = [];

                for (_i2 = 0; _i2 < mateBlocks.length; _i2 += 1) {
                  (_mateChunks = mateChunks).push.apply(_mateChunks, (0, _toConsumableArray2.default)(mateBlocks[_i2]));
                } // filter out duplicates


                mateChunks = (0, _filter.default)(_context6 = (0, _sort.default)(mateChunks).call(mateChunks, function (a, b) {
                  return a.toString().localeCompare(b.toString());
                })).call(_context6, function (item, pos, ary) {
                  return !pos || item.toString() !== ary[pos - 1].toString();
                });
                mateRecordPromises = [];
                mateFeatPromises = [];
                mateTotalSize = (0, _reduce.default)(_context7 = (0, _map.default)(mateChunks).call(mateChunks, function (s) {
                  return s.sliceBytes;
                })).call(_context7, function (a, b) {
                  return a + b;
                }, 0);

                if (!(mateTotalSize > this.fetchSizeLimit)) {
                  _context9.next = 37;
                  break;
                }

                throw new Error((0, _concat.default)(_context8 = "mate data size of ".concat(mateTotalSize.toLocaleString(), " bytes exceeded fetch size limit of ")).call(_context8, this.fetchSizeLimit.toLocaleString(), " bytes"));

              case 37:
                (0, _forEach.default)(mateChunks).call(mateChunks, function (c) {
                  var recordPromise = _this.cram.featureCache.get(c.toString());

                  if (!recordPromise) {
                    recordPromise = _this.getRecordsInSlice(c, function () {
                      return true;
                    });

                    _this.cram.featureCache.set(c.toString(), recordPromise);
                  }

                  mateRecordPromises.push(recordPromise);
                  var featPromise = recordPromise.then(function (feats) {
                    var mateRecs = [];

                    for (var _i3 = 0; _i3 < feats.length; _i3 += 1) {
                      var feature = feats[_i3];

                      if (unmatedPairs[feature.readName] && !readIds[feature.uniqueId]) {
                        mateRecs.push(feature);
                      }
                    }

                    return mateRecs;
                  });
                  mateFeatPromises.push(featPromise);
                });
                _context9.next = 40;
                return _promise.default.all(mateFeatPromises);

              case 40:
                newMateFeats = _context9.sent;

                if (newMateFeats.length) {
                  newMates = (0, _reduce.default)(newMateFeats).call(newMateFeats, function (result, current) {
                    return (0, _concat.default)(result).call(result, current);
                  });
                  ret = (0, _concat.default)(ret).call(ret, newMates);
                }

              case 42:
                return _context9.abrupt("return", ret);

              case 43:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee, this);
      }));

      function getRecordsForRange(_x, _x2, _x3) {
        return _getRecordsForRange.apply(this, arguments);
      }

      return getRecordsForRange;
    }()
  }, {
    key: "getRecordsInSlice",
    value: function getRecordsInSlice(_ref3, filterFunction) {
      var containerStart = _ref3.containerStart,
          sliceStart = _ref3.sliceStart,
          sliceBytes = _ref3.sliceBytes;
      var container = this.cram.getContainerAtPosition(containerStart);
      var slice = container.getSlice(sliceStart, sliceBytes);
      return slice.getRecords(filterFunction);
    }
    /**
     *
     * @param {number} seqId
     * @returns {Promise} true if the CRAM file contains data for the given
     * reference sequence numerical ID
     */

  }, {
    key: "hasDataForReferenceSequence",
    value: function hasDataForReferenceSequence(seqId) {
      return this.index.hasDataForReferenceSequence(seqId);
    }
  }]);
  return IndexedCramFile;
}();

module.exports = IndexedCramFile;