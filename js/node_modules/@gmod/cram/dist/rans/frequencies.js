"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

var _fill = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/fill"));

var _require = require('../errors'),
    CramMalformedError = _require.CramMalformedError;

var Constants = require('./constants');

var Decoding = require('./decoding');

function assert(result) {
  if (!result) throw new CramMalformedError('assertion failed');
}

function readStatsO0(
/* ByteBuffer */
cp,
/* Decoding.AriDecoder */
decoder,
/* Decoding.RansDecSymbol[] */
syms) {
  // Pre-compute reverse lookup of frequency.
  var rle = 0;
  var x = 0;
  var j = cp.get() & 0xff;

  do {
    var _context;

    if (decoder.fc[j] == null) decoder.fc[j] = new Decoding.FC();
    decoder.fc[j].F = cp.get() & 0xff;

    if (decoder.fc[j].F >= 128) {
      decoder.fc[j].F &= ~128;
      decoder.fc[j].F = (decoder.fc[j].F & 127) << 8 | cp.get() & 0xff;
    }

    decoder.fc[j].C = x;
    Decoding.symbolInit(syms[j], decoder.fc[j].C, decoder.fc[j].F);
    /* Build reverse lookup table */

    if (!decoder.R) decoder.R = new Array(Constants.TOTFREQ);
    (0, _fill.default)(_context = decoder.R).call(_context, j, x, x + decoder.fc[j].F);
    x += decoder.fc[j].F;

    if (rle === 0 && j + 1 === (0xff & cp.getByteAt(cp.position()))) {
      j = cp.get() & 0xff;
      rle = cp.get() & 0xff;
    } else if (rle !== 0) {
      rle -= 1;
      j += 1;
    } else {
      j = cp.get() & 0xff;
    }
  } while (j !== 0);

  assert(x < Constants.TOTFREQ);
}

function readStatsO1(
/* ByteBuffer */
cp,
/*  Decoding.AriDecoder[] */
D,
/* Decoding.RansDecSymbol[][] */
syms) {
  var rlei = 0;
  var i = 0xff & cp.get();

  do {
    var rlej = 0;
    var x = 0;
    var j = 0xff & cp.get();
    if (D[i] == null) D[i] = new Decoding.AriDecoder();

    do {
      var _context2;

      if (D[i].fc[j] == null) D[i].fc[j] = new Decoding.FC();
      D[i].fc[j].F = 0xff & cp.get();

      if (D[i].fc[j].F >= 128) {
        D[i].fc[j].F &= ~128;
        D[i].fc[j].F = (D[i].fc[j].F & 127) << 8 | 0xff & cp.get();
      }

      D[i].fc[j].C = x;
      if (D[i].fc[j].F === 0) D[i].fc[j].F = Constants.TOTFREQ;
      if (syms[i][j] == null) syms[i][j] = new Decoding.RansDecSymbol();
      Decoding.symbolInit(syms[i][j], D[i].fc[j].C, D[i].fc[j].F);
      /* Build reverse lookup table */

      if (D[i].R == null) D[i].R = new Array(Constants.TOTFREQ);
      (0, _fill.default)(_context2 = D[i].R).call(_context2, j, x, x + D[i].fc[j].F);
      x += D[i].fc[j].F;
      assert(x <= Constants.TOTFREQ);

      if (rlej === 0 && j + 1 === (0xff & cp.getByteAt(cp.position()))) {
        j = 0xff & cp.get();
        rlej = 0xff & cp.get();
      } else if (rlej !== 0) {
        rlej -= 1;
        j += 1;
      } else {
        j = 0xff & cp.get();
      }
    } while (j !== 0);

    if (rlei === 0 && i + 1 === (0xff & cp.getByteAt(cp.position()))) {
      i = 0xff & cp.get();
      rlei = 0xff & cp.get();
    } else if (rlei !== 0) {
      rlei -= 1;
      i += 1;
    } else {
      i = 0xff & cp.get();
    }
  } while (i !== 0);
}

module.exports = {
  readStatsO0: readStatsO0,
  readStatsO1: readStatsO1
};