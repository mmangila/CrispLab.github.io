"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault");

var _fill = _interopRequireDefault(require("@babel/runtime-corejs3/core-js-stable/instance/fill"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs3/helpers/createClass"));

var _require = require('../errors'),
    CramMalformedError = _require.CramMalformedError;

var Decoding = require('./decoding');

var Frequencies = require('./frequencies');

var D04 = require('./d04');

var D14 = require('./d14'); // const /* int */ ORDER_BYTE_LENGTH = 1
// const /* int */ COMPRESSED_BYTE_LENGTH = 4


var
/* int */
RAW_BYTE_LENGTH = 4; // const /* int */ PREFIX_BYTE_LENGTH =
//   ORDER_BYTE_LENGTH + COMPRESSED_BYTE_LENGTH + RAW_BYTE_LENGTH
// enum ORDER {
//     ZERO, ONE;
//     static ORDER fromInt(const /* int */ value) {
//         try {
//             return ORDER.values()[value];
//         } catch (const ArrayIndexOutOfBoundsException e) {
//             throw new RuntimeException("Unknown rANS order: " + value);
//         }
//     }
// }
// static ByteBuffer compress(const ByteBuffer input, const ORDER order, const ByteBuffer out) {
//     if (input.remaining() == 0)
//         return EMPTY_BUFFER;
//     if (input.remaining() < 4)
//         return encode_order0_way4(input, out);
//     switch (order) {
//         case ZERO:
//             return encode_order0_way4(input, out);
//         case ONE:
//             return encode_order1_way4(input, out);
//         default:
//             throw new RuntimeException("Unknown rANS order: " + order);
//     }
// }
// static /* ByteBuffer */ allocateIfNeeded(/* const int */ in_size,
//                                            /* const ByteBuffer */ out_buf) {
//     const /* int */ compressedSize = (/* int */) (1.05 * in_size + 257 * 257 * 3 + 4);
//     if (out_buf == null)
//         return ByteBuffer.allocate(compressedSize);
//     if (out_buf.remaining() < compressedSize)
//         throw new RuntimeException("Insufficient buffer size.");
//     out_buf.order(ByteOrder.LITTLE_ENDIAN);
//     return out_buf;
// }
// static ByteBuffer encode_order0_way4(const ByteBuffer input,
//                                              ByteBuffer out_buf) {
//     const /* int */ in_size = input.remaining();
//     out_buf = allocateIfNeeded(in_size, out_buf);
//     const /* int */ freqTableStart = PREFIX_BYTE_LENGTH;
//     out_buf.position(freqTableStart);
//     const /* int */[] F = Frequencies.calcFrequencies_o0(in);
//     const RansEncSymbol[] syms = Frequencies.buildSyms_o0(F);
//     const ByteBuffer cp = out_buf.slice();
//     const /* int */ frequencyTable_size = Frequencies.writeFrequencies_o0(cp, F);
//     input.rewind();
//     const /* int */ compressedBlob_size = E04.compress(input, syms, cp);
//     finalizeCompressed(0, out_buf, in_size, frequencyTable_size,
//             compressedBlob_size);
//     return out_buf;
// }
// static ByteBuffer encode_order1_way4(const ByteBuffer input,
//                                              ByteBuffer out_buf) {
//     const /* int */ in_size = input.remaining();
//     out_buf = allocateIfNeeded(in_size, out_buf);
//     const /* int */ freqTableStart = PREFIX_BYTE_LENGTH;
//     out_buf.position(freqTableStart);
//     const /* int */[][] F = Frequencies.calcFrequencies_o1(in);
//     const RansEncSymbol[][] syms = Frequencies.buildSyms_o1(F);
//     const ByteBuffer cp = out_buf.slice();
//     const /* int */ frequencyTable_size = Frequencies.writeFrequencies_o1(cp, F);
//     input.rewind();
//     const /* int */ compressedBlob_size = E14.compress(input, syms, cp);
//     finalizeCompressed(1, out_buf, in_size, frequencyTable_size,
//             compressedBlob_size);
//     return out_buf;
// }
// static void finalizeCompressed(const /* int */ order, const ByteBuffer out_buf,
//                                        const /* int */ in_size, const /* int */ frequencyTable_size, const /* int */ compressedBlob_size) {
//     out_buf.limit(PREFIX_BYTE_LENGTH + frequencyTable_size
//             + compressedBlob_size);
//     out_buf.put(0, (byte) order);
//     out_buf.order(ByteOrder.LITTLE_ENDIAN);
//     const /* int */ compressedSizeOffset = ORDER_BYTE_LENGTH;
//     out_buf.putInt(compressedSizeOffset, frequencyTable_size
//             + compressedBlob_size);
//     const /* int */ rawSizeOffset = ORDER_BYTE_LENGTH + COMPRESSED_BYTE_LENGTH;
//     out_buf.putInt(rawSizeOffset, in_size);
//     out_buf.rewind();
// }

function
/* static ByteBuffer */
uncompressOrder0Way4(
/* const ByteBuffer  */
input,
/* const ByteBuffer  */
out) {
  // input.order(ByteOrder.LITTLE_ENDIAN);
  var D = new Decoding.AriDecoder();
  var syms = new Array(256);

  for (var i = 0; i < syms.length; i += 1) {
    syms[i] = new Decoding.Symbol();
  }

  Frequencies.readStatsO0(input, D, syms);
  D04.uncompress(input, D, syms, out);
  return out;
}

function
/* static ByteBuffer */
uncompressOrder1Way4(
/* const ByteBuffer */
input,
/* const ByteBuffer */
output) {
  var D = new Array(256);

  for (var i = 0; i < D.length; i += 1) {
    D[i] = new Decoding.AriDecoder();
  }

  var
  /* Decoding.RansDecSymbol[][]  */
  syms = new Array(256);

  for (var _i = 0; _i < syms.length; _i += 1) {
    syms[_i] = new Array(256);

    for (var j = 0; j < syms[_i].length; j += 1) {
      syms[_i][j] = new Decoding.Symbol();
    }
  }

  Frequencies.readStatsO1(input, D, syms);
  D14.uncompress(input, output, D, syms);
  return output;
}
/* compat layer to make a node buffer act like a java ByteBuffer */


var ByteBuffer =
/*#__PURE__*/
function () {
  function ByteBuffer(nodeBuffer) {
    var initialInputPosition = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    (0, _classCallCheck2.default)(this, ByteBuffer);
    this._buffer = nodeBuffer;
    this._position = initialInputPosition;
    this.length = nodeBuffer.length;
  }

  (0, _createClass2.default)(ByteBuffer, [{
    key: "get",
    value: function get() {
      var b = this._buffer[this._position];
      this._position += 1;
      return b;
    }
  }, {
    key: "getByte",
    value: function getByte() {
      return this.get();
    }
  }, {
    key: "getByteAt",
    value: function getByteAt(position) {
      return this._buffer[position];
    }
  }, {
    key: "position",
    value: function position() {
      return this._position;
    }
  }, {
    key: "put",
    value: function put(val) {
      this._buffer[this._position] = val;
      this._position += 1;
      return val;
    }
  }, {
    key: "putAt",
    value: function putAt(position, val) {
      this._buffer[position] = val;
      return val;
    }
  }, {
    key: "setPosition",
    value: function setPosition(pos) {
      this._position = pos;
      return pos;
    }
  }, {
    key: "getInt",
    value: function getInt() {
      var i = this._buffer.readInt32LE(this._position);

      this._position += 4;
      return i;
    }
  }, {
    key: "remaining",
    value: function remaining() {
      return this._buffer.length - this._position;
    }
  }]);
  return ByteBuffer;
}(); // static /* const */ ByteBuffer EMPTY_BUFFER = ByteBuffer.allocate(0);


function uncompress(inputBuffer, outputBuffer) {
  var initialInputPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

  if (inputBuffer.length === 0) {
    (0, _fill.default)(outputBuffer).call(outputBuffer, 0);
    return outputBuffer;
  }

  var input = new ByteBuffer(inputBuffer, initialInputPosition); // input.order(ByteOrder.LITTLE_ENDIAN);

  var order = input.get();
  if (order !== 0 && order !== 1) throw new CramMalformedError("Invalid rANS order ".concat(order));
  var
  /* int */
  inputSize = input.getInt();
  if (inputSize !== input.remaining() - RAW_BYTE_LENGTH) throw new CramMalformedError('Incorrect input length.');
  var
  /* int */
  outputSize = input.getInt();
  var output = new ByteBuffer(outputBuffer || Buffer.allocUnsafe(outputSize)); // TODO output.limit(outputSize)

  if (output.length < outputSize) throw new CramMalformedError("Output buffer too small to fit ".concat(outputSize, " bytes."));

  switch (order) {
    case 0:
      return uncompressOrder0Way4(input, output);

    case 1:
      return uncompressOrder1Way4(input, output);

    default:
      throw new CramMalformedError("Invalid rANS order: ".concat(order));
  }
}

module.exports = {
  uncompress: uncompress
};