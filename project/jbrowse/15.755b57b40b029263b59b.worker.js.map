{"version":3,"sources":["../../../node_modules/@gmod/bgzf-filehandle/dist/index.js","../../../node_modules/@gmod/bgzf-filehandle/dist/unzip.js","../../../node_modules/@gmod/bgzf-filehandle/dist/localFile.js","../../../node_modules/@gmod/bgzf-filehandle/dist/bgzFilehandle.js","../../../node_modules/@gmod/bgzf-filehandle/dist/gziIndex.js","../../../node_modules/@gmod/vcf/dist/index.js","../../../node_modules/@gmod/vcf/dist/parse.js","../../../node_modules/@gmod/vcf/dist/vcfReserved.js","../../../plugins/variants/src/VcfAdapter/VcfAdapter.ts"],"names":["BgzfFilehandle","require","_require","unzip","unzipChunk","unzipChunkSlice","module","exports","_interopRequireDefault","_regenerator","_asyncToGenerator2","zlib","gunzip","promisify","_require2","Z_SYNC_FLUSH","Inflate","pakoUnzip","_x","_pakoUnzip","apply","this","arguments","default","mark","_callee","inputData","strm","pos","i","chunks","inflator","remainingInput","result","wrap","_context","prev","next","slice","push","err","Error","msg","next_in","Buffer","from","avail_in","concat","abrupt","t0","message","match","stop","_unzipChunk","_callee2","cpos","dpos","blocks","cpositions","dpositions","_buffer","buffer","_context2","length","_unzipChunkSlice","_callee3","chunk","decompressedBlocks","_buffer2","len","origCpos","_context3","minv","blockPosition","dataPosition","maxv","_x2","_x3","_x4","nodeUnzip","input","finishFlush","constants","_classCallCheck2","_createClass2","fs","undefined","LocalFile","path","fdPromise","open","key","value","_read","buf","offset","position","fd","ret","sent","read","_stat","fstat","_slicedToArray2","GziIndex","BgzFilehandle","_ref","filehandle","gziFilehandle","gziPath","TypeError","gzi","compressedStat","stat","Object","t1","getUncompressedFileSize","t2","t3","t4","t5","size","blksize","assign","call","_getUncompressedFileSize","_ref2","_ref3","uncompressedPosition","_ref4","_ref5","lastBlockUncompressedSize","getLastBlock","allocUnsafe","bytesRead","readUInt32LE","_readAndUncompressBlock2","blockBuffer","_ref6","_ref7","_ref8","compressedPosition","_ref9","nextCompressedPosition","blockCompressedLength","unzippedBuffer","_callee4","blockPositions","destinationOffset","blockNum","uncompressedBuffer","_blockPositions$block","sourceOffset","sourceEnd","_context4","getRelevantBlocksForRead","_readAndUncompressBlock","Math","min","copy","_x5","_x6","_x7","Long","unsigned","long","fromBytesLE","greaterThan","Number","MAX_SAFE_INTEGER","lessThan","MIN_SAFE_INTEGER","toNumber","index","_readIndex","_readIndex2","numEntries","entries","bufSize","entryNumber","_readLongWithOverflow","Array","_getLastBlock","_getIndex","_getRelevantBlocksForRead","endPosition","relevant","compare","lowerBound","upperBound","searchPosition","comparison","entry","nextEntry","nextUncompressedPosition","Infinity","floor","ceil","VCF","_vcfReserved","Breakend","char","MateDirection","Join","MatePosition","Replacement","args","_this","header","headerLines","split","filter","line","strict","metadata","JSON","parse","stringify","INFO","InfoFields","FORMAT","GenotypeFields","ALT","AltTypes","FILTER","FilterTypes","forEach","startsWith","_parseMetadata","fields","thisHeader","correctHeader","every","samples","_line$trim$match$slic","trim","_line$trim$match$slic2","metaKey","metaVal","_this$_parseStructure","_parseStructuredMetaVal","_this$_parseStructure2","id","keyVals","_parseKeyValue","replace","ID","isNaN","filteredMetadata","_len","_key","str","pairSeparator","data","currKey","currValue","state","_this2","currChar","currField","substr","rest","variant","CHROM","POS","REF","QUAL","parseFloat","info","keys","items","map","val","itemType","getMetadata","console","warn","SVTYPE","_parseBreakend","bind","that","defineProperty","Variant","prototype","get","_parseGenotypes","stuff","breakendString","tokens","parsed","includes","tok","formatKeys","_this3","genotypes","sample","formatValue","formatIndex","thisValue","valueType","AA","Type","Description","AC","AD","ADF","ADR","AF","AN","BQ","CIGAR","DB","DP","END","H2","H3","MQ","MQ0","NS","SB","SOMATIC","VALIDATED","IMPRECISE","NOVEL","SVLEN","CIPOS","CIEND","HOMLEN","HOMSEQ","BKPTID","MEINFO","METRANS","DGVID","DBVARID","DBRIPID","MATEID","PARID","EVENT","CILEN","DPADJ","CN","CNADJ","CICN","CICNADJ","EC","FT","GL","GP","GQ","GT","HQ","PL","PQ","PS","DEL","INS","DUP","INV","CNV","NON_REF","PASS","readVcf","f","lines","refNames","join","VcfAdapter","config","setupP","vcfLocation","readConfObject","openLocation","readFile","fileContents","TextDecoder","decode","toString","decodeFileContents","a","parser","VcfFeature","parseLine","getLines","region","opts","ObservableCreate","observer","setup","refName","start","end","complete","signal","BaseFeatureDataAdapter","capabilities"],"mappings":"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","file":"15.755b57b40b029263b59b.worker.js","sourcesContent":["\"use strict\";var BgzfFilehandle = require('./bgzFilehandle');var _require =\nrequire('./unzip'),unzip = _require.unzip,unzipChunk = _require.unzipChunk,unzipChunkSlice = _require.unzipChunkSlice;\n\nmodule.exports = { BgzfFilehandle: BgzfFilehandle, unzip: unzip, unzipChunk: unzipChunk, unzipChunkSlice: unzipChunkSlice };","\"use strict\";var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");var _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));var _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\")); /* eslint-disable consistent-return */\nvar zlib = require('zlib');var _require =\nrequire('es6-promisify'),promisify = _require.promisify;\n\nvar gunzip = promisify(zlib.gunzip);var _require2 =\n\nrequire('pako'),Z_SYNC_FLUSH = _require2.Z_SYNC_FLUSH,Inflate = _require2.Inflate;\n\n// browserify-zlib, which is the zlib shim used by default in webpacked code,\n// does not properly uncompress bgzf chunks that contain more than\n// one bgzf block, so export an unzip function that uses pako directly\n// if we are running in a browser.\nfunction pakoUnzip(_x) {return _pakoUnzip.apply(this, arguments);}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// similar to pakounzip, except it does extra counting\n// to return the positions of compressed and decompressed\n// data offsets\nfunction _pakoUnzip() {_pakoUnzip = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(inputData) {var strm, pos, i, chunks, inflator, remainingInput, _inflator, result;return _regenerator.default.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:_context.prev = 0;pos = 0;i = 0;chunks = [];case 4:remainingInput = inputData.slice(pos);inflator = new Inflate();_inflator = inflator;strm = _inflator.strm;inflator.push(remainingInput, Z_SYNC_FLUSH);if (!inflator.err) {_context.next = 11;break;}throw new Error(inflator.msg);case 11:pos += strm.next_in;chunks[i] = Buffer.from(inflator.result);i += 1;case 14:if (strm.avail_in) {_context.next = 4;break;}case 15:result = Buffer.concat(chunks);return _context.abrupt(\"return\", result);case 19:_context.prev = 19;_context.t0 = _context[\"catch\"](0);if (!_context.t0.message.match(/incorrect header check/)) {_context.next = 23;break;}throw new Error('problem decompressing block: incorrect gzip header check');case 23:case \"end\":return _context.stop();}}}, _callee, null, [[0, 19]]);}));return _pakoUnzip.apply(this, arguments);}function unzipChunk(_x2) {return _unzipChunk.apply(this, arguments);}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// similar to unzipChunk above but slices (0,minv.dataPosition) and (maxv.dataPosition,end) off\nfunction _unzipChunk() {_unzipChunk = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2(inputData) {var strm, cpos, dpos, blocks, cpositions, dpositions, remainingInput, inflator, _buffer, buffer;return _regenerator.default.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:_context2.prev = 0;cpos = 0;dpos = 0;blocks = [];cpositions = [];dpositions = [];case 6:remainingInput = inputData.slice(cpos);inflator = new Inflate();strm = inflator.strm; // @ts-ignore\n            inflator.push(remainingInput, Z_SYNC_FLUSH);if (!inflator.err) {_context2.next = 12;break;}throw new Error(inflator.msg);case 12: // @ts-ignore\n            _buffer = Buffer.from(inflator.result);blocks.push(_buffer);cpositions.push(cpos);dpositions.push(dpos);cpos += strm.next_in;dpos += _buffer.length;case 18:if (strm.avail_in) {_context2.next = 6;break;}case 19:buffer = Buffer.concat(blocks);return _context2.abrupt(\"return\", { buffer: buffer, cpositions: cpositions, dpositions: dpositions });case 23:_context2.prev = 23;_context2.t0 = _context2[\"catch\"](0);if (!_context2.t0.message.match(/incorrect header check/)) {_context2.next = 27;break;}throw new Error('problem decompressing block: incorrect gzip header check');case 27:case \"end\":return _context2.stop();}}}, _callee2, null, [[0, 23]]);}));return _unzipChunk.apply(this, arguments);}function unzipChunkSlice(_x3, _x4) {return _unzipChunkSlice.apply(this, arguments);}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// in node, just use the native unzipping with Z_SYNC_FLUSH\nfunction _unzipChunkSlice() {_unzipChunkSlice = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee3(inputData, chunk) {var strm, cpos, dpos, decompressedBlocks, cpositions, dpositions, remainingInput, inflator, _buffer2, len, origCpos, buffer;return _regenerator.default.wrap(function _callee3$(_context3) {while (1) {switch (_context3.prev = _context3.next) {case 0:_context3.prev = 0;cpos = chunk.minv.blockPosition;dpos = chunk.minv.dataPosition;decompressedBlocks = [];cpositions = [];dpositions = [];case 6:remainingInput = inputData.slice(cpos - chunk.minv.blockPosition);inflator = new Inflate();strm = inflator.strm; // @ts-ignore\n            inflator.push(remainingInput, Z_SYNC_FLUSH);if (!inflator.err) {_context3.next = 12;break;}throw new Error(inflator.msg);case 12: // @ts-ignore\n            _buffer2 = Buffer.from(inflator.result);decompressedBlocks.push(_buffer2);len = _buffer2.length;cpositions.push(cpos);dpositions.push(dpos);if (decompressedBlocks.length === 1 && chunk.minv.dataPosition) {// this is the first chunk, trim it\n              decompressedBlocks[0] = decompressedBlocks[0].slice(chunk.minv.dataPosition);len = decompressedBlocks[0].length;}origCpos = cpos;cpos += strm.next_in;dpos += len;if (!(origCpos >= chunk.maxv.blockPosition)) {_context3.next = 26;break;} // this is the last chunk, trim it and stop decompressing\n            // note if it is the same block is minv it subtracts that already\n            // trimmed part of the slice length\n            decompressedBlocks[decompressedBlocks.length - 1] = decompressedBlocks[decompressedBlocks.length - 1].slice(0, chunk.maxv.blockPosition === chunk.minv.blockPosition ? chunk.maxv.dataPosition - chunk.minv.dataPosition + 1 : chunk.maxv.dataPosition + 1);cpositions.push(cpos);dpositions.push(dpos);return _context3.abrupt(\"break\", 27);case 26:if (strm.avail_in) {_context3.next = 6;break;}case 27:buffer = Buffer.concat(decompressedBlocks);return _context3.abrupt(\"return\", { buffer: buffer, cpositions: cpositions, dpositions: dpositions });case 31:_context3.prev = 31;_context3.t0 = _context3[\"catch\"](0);if (!_context3.t0.message.match(/incorrect header check/)) {_context3.next = 35;break;}throw new Error('problem decompressing block: incorrect gzip header check');case 35:case \"end\":return _context3.stop();}}}, _callee3, null, [[0, 31]]);}));return _unzipChunkSlice.apply(this, arguments);}function nodeUnzip(input) {return gunzip(input, { finishFlush: (zlib.constants || zlib).Z_SYNC_FLUSH });}module.exports = {\n  unzip: typeof __webpack_require__ === 'function' ? pakoUnzip : nodeUnzip, // eslint-disable-line\n  unzipChunk: unzipChunk,\n  unzipChunkSlice: unzipChunkSlice,\n  nodeUnzip: nodeUnzip,\n  pakoUnzip: pakoUnzip };","\"use strict\";var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");var _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));var _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));var _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));var _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));var fs =\n// eslint-disable-next-line camelcase\ntypeof __webpack_require__ !== 'function' ? require('fs-extra') : undefined;\n\n// LocalFile is pretty much just an implementation of the node 10+ fs.promises filehandle,\n// we can switch to that when the API is stable\nvar LocalFile = /*#__PURE__*/function () {\n  function LocalFile(path) {(0, _classCallCheck2.default)(this, LocalFile);\n    this.fdPromise = fs.open(path, 'r');\n    this.path = path;\n  }(0, _createClass2.default)(LocalFile, [{ key: \"read\", value: function () {var _read = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(\n\n      buf, offset, length, position) {var fd, ret;return _regenerator.default.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:_context.next = 2;return (\n                  this.fdPromise);case 2:fd = _context.sent;_context.next = 5;return (\n                  fs.read(fd, buf, offset, length, position));case 5:ret = _context.sent;return _context.abrupt(\"return\",\n                ret);case 7:case \"end\":return _context.stop();}}}, _callee, this);}));function read(_x, _x2, _x3, _x4) {return _read.apply(this, arguments);}return read;}() }, { key: \"stat\", value: function () {var _stat = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2() {var fd;return _regenerator.default.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:_context2.next = 2;return (\n\n\n\n                  this.fdPromise);case 2:fd = _context2.sent;return _context2.abrupt(\"return\",\n                fs.fstat(fd));case 4:case \"end\":return _context2.stop();}}}, _callee2, this);}));function stat() {return _stat.apply(this, arguments);}return stat;}() }]);return LocalFile;}();\n\n\n\nmodule.exports = LocalFile;","\"use strict\";var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");var _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));var _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));var _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));var _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));var _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));var _require = require('./unzip'),unzip = _require.unzip;\nvar LocalFile = require('./localFile');\nvar GziIndex = require('./gziIndex');var\n\nBgzFilehandle = /*#__PURE__*/function () {\n  function BgzFilehandle(_ref) {var filehandle = _ref.filehandle,path = _ref.path,gziFilehandle = _ref.gziFilehandle,gziPath = _ref.gziPath;(0, _classCallCheck2.default)(this, BgzFilehandle);\n    if (filehandle) this.filehandle = filehandle;else\n    if (path) this.filehandle = new LocalFile(path);else\n    throw new TypeError('either filehandle or path must be defined');\n\n    if (!gziFilehandle && !gziPath && !path)\n    throw new TypeError('either gziFilehandle or gziPath must be defined');\n\n    this.gzi = new GziIndex({\n      filehandle: gziFilehandle,\n      path: !gziFilehandle && !gziPath && path ? gziPath : \"\".concat(path, \".gzi\") });\n\n  }(0, _createClass2.default)(BgzFilehandle, [{ key: \"stat\", value: function () {var _stat = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee() {var compressedStat;return _regenerator.default.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:_context.next = 2;return (\n\n\n                  this.filehandle.stat());case 2:compressedStat = _context.sent;_context.t0 =\n                Object;_context.t1 = compressedStat;_context.next = 7;return (\n                  this.getUncompressedFileSize());case 7:_context.t2 = _context.sent;_context.t3 =\n                undefined;_context.t4 =\n                undefined;_context.t5 = { size: _context.t2, blocks: _context.t3, blksize: _context.t4 };return _context.abrupt(\"return\", _context.t0.assign.call(_context.t0, _context.t1, _context.t5));case 12:case \"end\":return _context.stop();}}}, _callee, this);}));function stat() {return _stat.apply(this, arguments);}return stat;}() }, { key: \"getUncompressedFileSize\", value: function () {var _getUncompressedFileSize = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2() {var _ref2, _ref3, uncompressedPosition, _ref4, size, buf, _ref5, bytesRead, lastBlockUncompressedSize;return _regenerator.default.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:_context2.next = 2;return (\n\n\n\n\n\n\n                  this.gzi.getLastBlock());case 2:_ref2 = _context2.sent;_ref3 = (0, _slicedToArray2.default)(_ref2, 2);uncompressedPosition = _ref3[1];_context2.next = 7;return (\n\n                  this.filehandle.stat());case 7:_ref4 = _context2.sent;size = _ref4.size;\n\n                buf = Buffer.allocUnsafe(4);\n                // note: there should be a 28-byte EOF marker (an empty block) at\n                // the end of the file, so we skip backward past that\n                _context2.next = 12;return this.filehandle.read(buf, 0, 4, size - 28 - 4);case 12:_ref5 = _context2.sent;bytesRead = _ref5.bytesRead;if (!(\n                bytesRead !== 4)) {_context2.next = 16;break;}throw new Error('read error');case 16:\n                lastBlockUncompressedSize = buf.readUInt32LE(0);return _context2.abrupt(\"return\",\n                uncompressedPosition + lastBlockUncompressedSize);case 18:case \"end\":return _context2.stop();}}}, _callee2, this);}));function getUncompressedFileSize() {return _getUncompressedFileSize.apply(this, arguments);}return getUncompressedFileSize;}() }, { key: \"_readAndUncompressBlock\", value: function () {var _readAndUncompressBlock2 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee3(\n\n\n\n      blockBuffer, _ref6, _ref7) {var _ref8, compressedPosition, _ref9, nextCompressedPosition, next, blockCompressedLength, unzippedBuffer;return _regenerator.default.wrap(function _callee3$(_context3) {while (1) {switch (_context3.prev = _context3.next) {case 0:_ref8 = (0, _slicedToArray2.default)(_ref6, 1),\n                compressedPosition = _ref8[0];_ref9 = (0, _slicedToArray2.default)(_ref7, 1),\n                nextCompressedPosition = _ref9[0];\n\n                next = nextCompressedPosition;if (\n                next) {_context3.next = 7;break;}_context3.next = 6;return (\n                  this.filehandle.stat());case 6:next = _context3.sent.size;case 7:\n\n\n                // read the compressed data into the block buffer\n                blockCompressedLength = next - compressedPosition;_context3.next = 10;return (\n\n                  this.filehandle.read(\n                  blockBuffer,\n                  0,\n                  blockCompressedLength,\n                  compressedPosition));case 10:_context3.next = 12;return (\n\n\n\n                  unzip(\n                  blockBuffer.slice(0, blockCompressedLength)));case 12:unzippedBuffer = _context3.sent;return _context3.abrupt(\"return\",\n\n\n                unzippedBuffer);case 14:case \"end\":return _context3.stop();}}}, _callee3, this);}));function _readAndUncompressBlock(_x, _x2, _x3) {return _readAndUncompressBlock2.apply(this, arguments);}return _readAndUncompressBlock;}() }, { key: \"read\", value: function () {var _read = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee4(\n\n\n      buf, offset, length, position) {var blockPositions, blockBuffer, destinationOffset, bytesRead, blockNum, uncompressedBuffer, _blockPositions$block, uncompressedPosition, sourceOffset, sourceEnd;return _regenerator.default.wrap(function _callee4$(_context4) {while (1) {switch (_context4.prev = _context4.next) {case 0:_context4.next = 2;return (\n\n                  this.gzi.getRelevantBlocksForRead(\n                  length,\n                  position));case 2:blockPositions = _context4.sent;\n\n                blockBuffer = Buffer.allocUnsafe(32768 * 2);\n                // uncompress the blocks and read from them one at a time to keep memory usage down\n                destinationOffset = offset;\n                bytesRead = 0;\n\n                blockNum = 0;case 7:if (!(\n                blockNum < blockPositions.length - 1)) {_context4.next = 18;break;}_context4.next = 10;return (\n\n\n\n                  this._readAndUncompressBlock(\n                  blockBuffer,\n                  blockPositions[blockNum],\n                  blockPositions[blockNum + 1]));case 10:uncompressedBuffer = _context4.sent;_blockPositions$block = (0, _slicedToArray2.default)(\n\n                blockPositions[blockNum], 2), uncompressedPosition = _blockPositions$block[1];\n                sourceOffset =\n                uncompressedPosition >= position ? 0 : position - uncompressedPosition;\n                sourceEnd =\n                Math.min(\n                position + length,\n                uncompressedPosition + uncompressedBuffer.length) -\n                uncompressedPosition;\n                if (sourceOffset >= 0 && sourceOffset < uncompressedBuffer.length) {\n                  uncompressedBuffer.copy(buf, destinationOffset, sourceOffset, sourceEnd);\n                  destinationOffset += sourceEnd - sourceOffset;\n                  bytesRead += sourceEnd - sourceOffset;\n                }case 15:blockNum += 1;_context4.next = 7;break;case 18:return _context4.abrupt(\"return\",\n\n\n                { bytesRead: bytesRead, buffer: buf });case 19:case \"end\":return _context4.stop();}}}, _callee4, this);}));function read(_x4, _x5, _x6, _x7) {return _read.apply(this, arguments);}return read;}() }]);return BgzFilehandle;}();\n\n\n\nmodule.exports = BgzFilehandle;","\"use strict\";var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");var _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));var _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));var _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));var _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));var Long = require('long');\nvar LocalFile = require('./localFile');\n\n// const COMPRESSED_POSITION = 0\nvar UNCOMPRESSED_POSITION = 1;var\n\nGziIndex = /*#__PURE__*/function () {\n  function GziIndex(_ref) {var filehandle = _ref.filehandle,path = _ref.path;(0, _classCallCheck2.default)(this, GziIndex);\n    if (filehandle) this.filehandle = filehandle;else\n    if (path) this.filehandle = new LocalFile(path);else\n    throw new TypeError('either filehandle or path must be defined');\n  }(0, _createClass2.default)(GziIndex, [{ key: \"_readLongWithOverflow\", value: function _readLongWithOverflow(\n\n    buf) {var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;var unsigned = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var long = Long.fromBytesLE(buf.slice(offset, offset + 8), unsigned);\n      if (\n      long.greaterThan(Number.MAX_SAFE_INTEGER) ||\n      long.lessThan(Number.MIN_SAFE_INTEGER))\n\n      throw new TypeError('integer overflow');\n\n      return long.toNumber();\n    } }, { key: \"_getIndex\", value: function _getIndex()\n\n    {\n      if (!this.index) this.index = this._readIndex();\n      return this.index;\n    } }, { key: \"_readIndex\", value: function () {var _readIndex2 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee() {var buf, numEntries, entries, bufSize, entryNumber, compressedPosition, uncompressedPosition;return _regenerator.default.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:\n\n\n                buf = Buffer.allocUnsafe(8);_context.next = 3;return (\n                  this.filehandle.read(buf, 0, 8, 0));case 3:\n                numEntries = this._readLongWithOverflow(buf, 0, true);if (\n                numEntries) {_context.next = 6;break;}return _context.abrupt(\"return\", [[0, 0]]);case 6:\n\n                entries = new Array(numEntries + 1);\n                entries[0] = [0, 0];\n\n                // TODO rewrite this to make an index-index that stays in memory\n                bufSize = 8 * 2 * numEntries;if (!(\n                bufSize > Number.MAX_SAFE_INTEGER)) {_context.next = 11;break;}throw (\n                  new TypeError('integer overflow'));case 11:\n                buf = Buffer.allocUnsafe(bufSize);_context.next = 14;return (\n                  this.filehandle.read(buf, 0, bufSize, 8));case 14:\n                for (entryNumber = 0; entryNumber < numEntries; entryNumber += 1) {\n                  compressedPosition = this._readLongWithOverflow(\n                  buf,\n                  entryNumber * 16);\n\n                  uncompressedPosition = this._readLongWithOverflow(\n                  buf,\n                  entryNumber * 16 + 8);\n\n                  entries[entryNumber + 1] = [compressedPosition, uncompressedPosition];\n                }return _context.abrupt(\"return\",\n\n                entries);case 16:case \"end\":return _context.stop();}}}, _callee, this);}));function _readIndex() {return _readIndex2.apply(this, arguments);}return _readIndex;}()\n\n\n    /**\n                                                                                                                                                                                    * @returns {object} the entry for the last block in the index\n                                                                                                                                                                                    */ }, { key: \"getLastBlock\", value: function () {var _getLastBlock = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2() {var entries;return _regenerator.default.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:_context2.next = 2;return (\n\n                  this._getIndex());case 2:entries = _context2.sent;if (\n                entries.length) {_context2.next = 5;break;}return _context2.abrupt(\"return\", undefined);case 5:return _context2.abrupt(\"return\",\n                entries[entries.length - 1]);case 6:case \"end\":return _context2.stop();}}}, _callee2, this);}));function getLastBlock() {return _getLastBlock.apply(this, arguments);}return getLastBlock;}()\n\n\n    /**\n                                                                                                                                                                                                               * get an array of block records that must be read to execute\n                                                                                                                                                                                                               * the given virtual read operation\n                                                                                                                                                                                                               *\n                                                                                                                                                                                                               * @param {number} position uncompressed read position\n                                                                                                                                                                                                               * @param {number} length uncompressed read length\n                                                                                                                                                                                                               * @returns {Promise} for an array of block records, the\n                                                                                                                                                                                                               * last of which should *not* be included in the read\n                                                                                                                                                                                                               */ }, { key: \"getRelevantBlocksForRead\", value: function () {var _getRelevantBlocksForRead = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee3(\n      length, position) {var endPosition, entries, relevant, compare, lowerBound, upperBound, searchPosition, comparison, i;return _regenerator.default.wrap(function _callee3$(_context3) {while (1) {switch (_context3.prev = _context3.next) {case 0:\n                endPosition = position + length;if (!(\n                length === 0)) {_context3.next = 3;break;}return _context3.abrupt(\"return\", []);case 3:_context3.next = 5;return (\n                  this._getIndex());case 5:entries = _context3.sent;\n                relevant = [];\n\n                // binary search to find the block that the\n                // read starts in and extend forward from that\n                compare = function compare(entry, nextEntry) {\n                  var uncompressedPosition = entry[UNCOMPRESSED_POSITION];\n                  var nextUncompressedPosition = nextEntry ?\n                  nextEntry[UNCOMPRESSED_POSITION] :\n                  Infinity;\n                  // block overlaps read start\n                  if (\n                  uncompressedPosition <= position &&\n                  nextUncompressedPosition > position)\n                  {\n                    return 0;\n                    // block is before read start\n                  }\n                  if (uncompressedPosition < position) {\n                    return -1;\n                  }\n                  // block is after read start\n                  return 1;\n                };\n\n                lowerBound = 0;\n                upperBound = entries.length - 1;\n                searchPosition = Math.floor(entries.length / 2);\n\n                comparison = compare(\n                entries[searchPosition],\n                entries[searchPosition + 1]);\n\n                while (comparison !== 0) {\n                  if (comparison > 0) {\n                    upperBound = searchPosition - 1;\n                  } else if (comparison < 0) {\n                    lowerBound = searchPosition + 1;\n                  }\n                  searchPosition = Math.ceil((upperBound - lowerBound) / 2) + lowerBound;\n                  comparison = compare(entries[searchPosition], entries[searchPosition + 1]);\n                }\n\n                // here's where we read forward\n                relevant.push(entries[searchPosition]);\n                i = searchPosition + 1;case 15:if (!(\n                i < entries.length)) {_context3.next = 22;break;}\n                relevant.push(entries[i]);if (!(\n                entries[i][UNCOMPRESSED_POSITION] >= endPosition)) {_context3.next = 19;break;}return _context3.abrupt(\"break\", 22);case 19:i += 1;_context3.next = 15;break;case 22:\n\n                if (relevant[relevant.length - 1][UNCOMPRESSED_POSITION] < endPosition) {\n                  relevant.push([]);\n                }return _context3.abrupt(\"return\",\n                relevant);case 24:case \"end\":return _context3.stop();}}}, _callee3, this);}));function getRelevantBlocksForRead(_x, _x2) {return _getRelevantBlocksForRead.apply(this, arguments);}return getRelevantBlocksForRead;}()\n\n\n    // /**\n    //  * get a virtual block record giving the position and length of a BGZF region that\n    //  * must be read to execute the given virtual read operation\n    //  *\n    //  * @param {number} position uncompressed file position we would like to start reading at\n    //  * @param {number} length number of uncompressed bytes we would like to read\n    //  * @returns {object} as `{compressedPosition, uncompressedPosition, compressedSize}`. If\n    //  * compressedSize is undefined, the read should end at the end of the file.\n    //  */\n    // async calculateMultiBlockRead(length, position) {\n    //   const entries = await this._getIndex()\n    //   const endPosition = position + length\n    //   let readStart\n    //   let readLength\n    //   let readUncompressedStart\n    //   for (let i = 0; i < entries.length; i += 1) {\n    //     const entry = entries[i]\n    //     if (readStart === undefined && entry.uncompressedPosition <= position) {\n    //       readStart = entry.compressedPosition\n    //       readUncompressedStart = entry.uncompressedPosition\n    //     }\n    //     if (\n    //       readLength === undefined &&\n    //       entry.uncompressedPosition >= endPosition\n    //     ) {\n    //       readLength = entry.compressedPosition - readStart\n    //     }\n    //   }\n\n    //   return {\n    //     compressedPosition: readStart,\n    //     uncompressedPosition: readUncompressedStart,\n    //     compressedSize: readLength,\n    //   }\n    // }\n  }]);return GziIndex;}();\n\nmodule.exports = GziIndex;","\"use strict\"; /** @module VCF */\nvar VCF = require('./parse');\n\nmodule.exports = VCF;","\"use strict\";var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");var _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));var _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));var _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));var _vcfReserved = _interopRequireDefault(require(\"./vcfReserved\"));var\n\nBreakend = /*#__PURE__*/function () {function Breakend() {(0, _classCallCheck2.default)(this, Breakend);}(0, _createClass2.default)(Breakend, [{ key: \"toString\", value: function toString()\n    {\n      var char = this.MateDirection === 'left' ? ']' : '[';\n      if (this.Join === 'left') {\n        return \"\".concat(char).concat(this.MatePosition).concat(char).concat(this.Replacement);\n      }\n      return \"\".concat(this.Replacement).concat(char).concat(this.MatePosition).concat(char);\n    } }]);return Breakend;}();\n\n\n/**\n                                * Class representing a VCF parser, instantiated with the VCF header.\n                                * @param {object} args\n                                * @param {string} args.header - The VCF header. Supports both LF and CRLF\n                                * newlines.\n                                * @param {boolean} args.strict - Whether to parse in strict mode or not (default true)\n                                */var\nVCF = /*#__PURE__*/function () {\n  function VCF(args) {var _this = this;(0, _classCallCheck2.default)(this, VCF);\n    if (!args || !args.header || !args.header.length) {\n      throw new Error('empty header received');\n    }\n    var headerLines = args.header.split(/[\\r\\n]+/).filter(function (line) {return line;});\n    if (!headerLines.length) {\n      throw new Error('no non-empty header lines specified');\n    }\n\n    // allow access to the Breakend class in case anybody wants to use it for checking\n    this.Breakend = Breakend;\n    this.strict = args.strict !== undefined ? args.strict : true; // true by default\n    this.metadata = JSON.parse(\n    JSON.stringify({\n      INFO: _vcfReserved.default.InfoFields,\n      FORMAT: _vcfReserved.default.GenotypeFields,\n      ALT: _vcfReserved.default.AltTypes,\n      FILTER: _vcfReserved.default.FilterTypes }));\n\n\n    headerLines.forEach(function (line) {\n      if (!line.startsWith('#')) {\n        throw new Error(\"Bad line in header:\\n\".concat(line));\n      }\n      if (line.startsWith('##')) {\n        _this._parseMetadata(line);\n      } else if (line) {\n        var fields = line.split('\\t');\n        var thisHeader = fields.slice(0, 8);\n        var correctHeader = [\n        '#CHROM',\n        'POS',\n        'ID',\n        'REF',\n        'ALT',\n        'QUAL',\n        'FILTER',\n        'INFO'];\n\n        if (fields.length < 8) {\n          throw new Error(\"VCF header missing columns:\\n\".concat(line));\n        } else if (fields.length === 9) {\n          throw new Error(\"VCF header has FORMAT but no samples:\\n\".concat(line));\n        } else if (\n        thisHeader.length !== correctHeader.length ||\n        !thisHeader.every(function (value, index) {return value === correctHeader[index];}))\n        {\n          throw new Error(\"VCF column headers not correct:\\n\".concat(line));\n        }\n        _this.samples = fields.slice(9);\n      }\n    });\n    if (!this.samples) throw new Error('VCF does not have a header line');\n  }\n\n  /**\n     * Parse a VCF metadata line (i.e. a line that starts with \"##\") and add its\n     * properties to the object.\n     * @param {string} line - A line from the VCF. Supports both LF and CRLF\n     * newlines.\n     */(0, _createClass2.default)(VCF, [{ key: \"_parseMetadata\", value: function _parseMetadata(\n    line) {var _line$trim$match$slic =\n      line.\n      trim().\n      match(/^##(.+?)=(.*)/).\n      slice(1, 3),_line$trim$match$slic2 = (0, _slicedToArray2.default)(_line$trim$match$slic, 2),metaKey = _line$trim$match$slic2[0],metaVal = _line$trim$match$slic2[1];\n      if (metaVal.startsWith('<')) {\n        if (!(metaKey in this.metadata)) {\n          this.metadata[metaKey] = {};\n        }var _this$_parseStructure =\n        this._parseStructuredMetaVal(metaVal),_this$_parseStructure2 = (0, _slicedToArray2.default)(_this$_parseStructure, 2),id = _this$_parseStructure2[0],keyVals = _this$_parseStructure2[1];\n        this.metadata[metaKey][id] = keyVals;\n      } else {\n        this.metadata[metaKey] = metaVal;\n      }\n    }\n\n    /**\n       * Parse a VCF header structured meta string (i.e. a meta value that starts\n       * with \"<ID=...\")\n       * @param {string} metaVal - The VCF metadata value\n       *\n       * @returns {Array} - Array with two entries, 1) a string of the metadata ID\n       * and 2) an object with the other key-value pairs in the metadata\n       */ }, { key: \"_parseStructuredMetaVal\", value: function _parseStructuredMetaVal(\n    metaVal) {\n      var keyVals = this._parseKeyValue(metaVal.replace(/^<|>$/g, ''), ',');\n      var id = keyVals.ID;\n      delete keyVals.ID;\n      if ('Number' in keyVals) {\n        if (!Number.isNaN(Number(keyVals.Number))) {\n          keyVals.Number = Number(keyVals.Number);\n        }\n      }\n      return [id, keyVals];\n    }\n\n    /**\n       * Get metadata filtered by the elements in args. For example, can pass\n       * ('INFO', 'DP') to only get info on an metadata tag that was like\n       * \"##INFO=<ID=DP,...>\"\n       * @param  {...string} args - List of metadata filter strings.\n       *\n       * @returns {any} An object, string, or number, depending on the filtering\n       */ }, { key: \"getMetadata\", value: function getMetadata()\n    {\n      var filteredMetadata = this.metadata;for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {args[_key] = arguments[_key];}\n      for (var i = 0; i < args.length; i += 1) {\n        filteredMetadata = filteredMetadata[args[i]];\n        if (!filteredMetadata) return filteredMetadata;\n      }\n      return filteredMetadata;\n    }\n\n    /**\n       * Sometimes VCFs have key-value strings that allow the separator within\n       * the value if it's in quotes, like:\n       * 'ID=DB,Number=0,Type=Flag,Description=\"dbSNP membership, build 129\"'\n       *\n       * Parse this at a low level since we can't just split at \",\" (or whatever\n       * separator). Above line would be parsed to:\n       * {ID: 'DB', Number: '0', Type: 'Flag', Description: 'dbSNP membership, build 129'}\n       * @param {string} str - Key-value pairs in a string\n       * @param {string} [pairSeparator] - A string that separates sets of key-value\n       * pairs\n       *\n       * @returns {object} An object containing the key-value pairs\n       */ }, { key: \"_parseKeyValue\", value: function _parseKeyValue(\n    str) {var pairSeparator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ';';\n      var data = {};\n      var currKey = '';\n      var currValue = '';\n      var state = 1; // states: 1: read key to = or pair sep, 2: read value to sep or quote, 3: read value to quote\n      for (var i = 0; i < str.length; i += 1) {\n        if (state === 1) {\n          // read key to = or pair sep\n          if (str[i] === '=') {\n            state = 2;\n          } else if (str[i] !== pairSeparator) {\n            currKey += str[i];\n          } else if (currValue === '') {\n            data[currKey] = null;\n            currKey = '';\n          }\n        } else if (state === 2) {\n          // read value to pair sep or quote\n          if (str[i] === pairSeparator) {\n            data[currKey] = currValue;\n            currKey = '';\n            currValue = '';\n            state = 1;\n          } else if (str[i] === '\"') {\n            state = 3;\n          } else currValue += str[i];\n        } else if (state === 3) {\n          // read value to quote\n          if (str[i] !== '\"') currValue += str[i];else\n          state = 2;\n        }\n      }\n      if (state === 2 || state === 3) {\n        data[currKey] = currValue;\n      } else if (state === 1) {\n        data[currKey] = null;\n      }\n      return data;\n    }\n\n    /**\n       * Parse a VCF line into an object like { CHROM POS ID REF ALT QUAL FILTER\n       * INFO } with SAMPLES optionally included if present in the VCF\n       * @param {string} line - A string of a line from a VCF. Supports both LF and\n       * CRLF newlines.\n       */ }, { key: \"parseLine\", value: function parseLine(\n    line) {var _this2 = this;\n      // eslint-disable-next-line no-param-reassign\n      line = line.trim();\n      if (!line.length) return undefined;\n      var currChar = 0;\n      for (var currField = 0; currChar < line.length; currChar += 1) {\n        if (line[currChar] === '\\t') {\n          currField += 1;\n        }\n        if (currField === 9) {\n          // reached genotypes, rest of fields are evaluated lazily\n          break;\n        }\n      }\n      var fields = line.substr(0, currChar).split('\\t');\n      var rest = line.substr(currChar + 1);\n      var variant = {\n        CHROM: fields[0],\n        POS: Number(fields[1]),\n        ID: fields[2] === '.' ? null : fields[2].split(';'),\n        REF: fields[3],\n        ALT: fields[4] === '.' ? null : fields[4].split(','),\n        QUAL: fields[5] === '.' ? null : parseFloat(fields[5]) };\n\n      if (fields[6] === '.') {\n        variant.FILTER = null;\n      } else if (fields[6] === 'PASS') {\n        variant.FILTER = 'PASS';\n      } else {\n        variant.FILTER = fields[6].split(';');\n      }\n      if (this.strict && fields[7] === undefined) {\n        throw new Error(\n        \"no INFO field specified, must contain at least a '.' (turn off strict mode to allow)\");\n\n      }\n      var info =\n      fields[7] === undefined || fields[7] === '.' ?\n      {} :\n      this._parseKeyValue(fields[7]);\n      Object.keys(info).forEach(function (key) {\n        var items;\n        if (info[key]) {\n          items = info[key].split(',');\n          items = items.map(function (val) {return val === '.' ? null : val;});\n        } else items = info[key];\n        var itemType = _this2.getMetadata('INFO', key, 'Type');\n        if (itemType) {\n          if (itemType === 'Integer' || itemType === 'Float') {\n            items = items.map(function (val) {\n              if (val === null) return null;\n              return Number(val);\n            });\n          } else if (itemType === 'Flag') {\n            if (info[key])\n              // eslint-disable-next-line no-console\n              console.warn(\"Info field \".concat(\n              key, \" is a Flag and should not have a value (got value \").concat(info[key], \")\"));else\n\n            items = true;\n          }\n        }\n        info[key] = items;\n      });\n      variant.INFO = info;\n\n      // if this has SVTYPE=BND, parse ALTS for breakend descriptions\n      if (variant.ALT && info && info.SVTYPE && info.SVTYPE[0] === 'BND') {\n        variant.ALT = variant.ALT.map(this._parseBreakend.bind(this));\n      }\n\n      // This creates a closure that allows us to attach \"SAMPLES\" as a lazy\n      // attribute\n\n      function Variant(stuff) {\n        Object.assign(this, stuff);\n      }\n\n      var that = this;\n\n      Object.defineProperty(Variant.prototype, 'SAMPLES', {\n        get: function get() {\n          var samples = that._parseGenotypes(fields[8], rest);\n\n          Object.defineProperty(this, 'SAMPLES', {\n            value: samples });\n\n\n          return samples;\n        } });\n\n\n      return new Variant(variant);\n    } }, { key: \"_parseBreakend\", value: function _parseBreakend(\n\n    breakendString) {\n      var tokens = breakendString.split(/[[\\]]/);\n      if (tokens.length > 1) {\n        var parsed = new Breakend();\n        parsed.MateDirection = breakendString.includes('[') ? 'right' : 'left';\n        for (var i = 0; i < tokens.length; i += 1) {\n          var tok = tokens[i];\n          if (tok) {\n            if (tok.includes(':')) {\n              // this is the remote location\n              parsed.MatePosition = tok;\n              parsed.Join = parsed.Replacement ? 'right' : 'left';\n            } else {\n              // this is the local alteration\n              parsed.Replacement = tok;\n            }\n          }\n        }\n        return parsed;\n      }\n      // if there is not more than one token, there are no [ or ] characters,\n      // so just return it unmodified\n      return breakendString;\n    } }, { key: \"_parseGenotypes\", value: function _parseGenotypes(\n\n    formatKeys, rest) {var _this3 = this;\n      // eslint-disable-next-line no-param-reassign\n      rest = rest.split('\\t');\n      var genotypes = {};\n      // eslint-disable-next-line no-param-reassign\n      formatKeys = formatKeys && formatKeys.split(':');\n      this.samples.forEach(function (sample, index) {\n        genotypes[sample] = {};\n        formatKeys.forEach(function (key) {\n          genotypes[sample][key] = null;\n        });\n        rest[index].split(':').forEach(function (formatValue, formatIndex) {\n          var thisValue;\n          if (\n          formatValue === '' ||\n          formatValue === '.' ||\n          formatValue === undefined)\n          {\n            thisValue = null;\n          } else {\n            thisValue = formatValue.\n            split(',').\n            map(function (val) {return val === '.' ? null : val;});\n            var valueType = _this3.getMetadata(\n            'FORMAT',\n            formatKeys[formatIndex],\n            'Type');\n\n            if ((valueType === 'Integer' || valueType === 'Float') && thisValue) {\n              thisValue = thisValue.map(function (val) {\n                if (!val) return null;\n                return Number(val);\n              });\n            }\n          }\n          genotypes[sample][formatKeys[formatIndex]] = thisValue;\n        }, {});\n      });\n      return genotypes;\n    } }]);return VCF;}();\n\n\nmodule.exports = VCF;","\"use strict\";Object.defineProperty(exports, \"__esModule\", { value: true });exports.default = void 0;var _default = {\n  // INFO fields\n  InfoFields: {\n    // from the VCF4.3 spec, https://samtools.github.io/hts-specs/VCFv4.3.pdf\n    AA: { Number: 1, Type: 'String', Description: 'Ancestral allele' },\n    AC: {\n      Number: 'A',\n      Type: 'Integer',\n      Description:\n      'Allele count in genotypes, for each ALT allele, in the same order as listed' },\n\n    AD: {\n      Number: 'R',\n      Type: 'Integer',\n      Description: 'Total read depth for each allele' },\n\n    ADF: {\n      Number: 'R',\n      Type: 'Integer',\n      Description: 'Read depth for each allele on the forward strand' },\n\n    ADR: {\n      Number: 'R',\n      Type: 'Integer',\n      Description: 'Read depth for each allele on the reverse strand' },\n\n    AF: {\n      Number: 'A',\n      Type: 'Float',\n      Description:\n      'Allele frequency for each ALT allele in the same order as listed (estimated from primary data, not called genotypes)' },\n\n    AN: {\n      Number: 1,\n      Type: 'Integer',\n      Description: 'Total number of alleles in called genotypes' },\n\n    BQ: {\n      Number: 1,\n      Type: 'Float',\n      Description: 'RMS base quality' },\n\n    CIGAR: {\n      Number: 1,\n      Type: 'Float',\n      Description:\n      'Cigar string describing how to align an alternate allele to the reference allele' },\n\n    DB: {\n      Number: 0,\n      Type: 'Flag',\n      Description: 'dbSNP membership' },\n\n    DP: {\n      Number: 1,\n      Type: 'Integer',\n      Description: 'combined depth across samples' },\n\n    END: {\n      Number: 1,\n      Type: 'Integer',\n      Description: 'End position (for use with symbolic alleles)' },\n\n    H2: {\n      Number: 0,\n      Type: 'Flag',\n      Description: 'HapMap2 membership' },\n\n    H3: {\n      Number: 0,\n      Type: 'Flag',\n      Description: 'HapMap3 membership' },\n\n    MQ: {\n      Number: 1,\n      Type: null,\n      Description: 'RMS mapping quality' },\n\n    MQ0: {\n      Number: 1,\n      Type: 'Integer',\n      Description: 'Number of MAPQ == 0 reads' },\n\n    NS: {\n      Number: 1,\n      Type: 'Integer',\n      Description: 'Number of samples with data' },\n\n    SB: {\n      Number: 4,\n      Type: 'Integer',\n      Description: 'Strand bias' },\n\n    SOMATIC: {\n      Number: 0,\n      Type: 'Flag',\n      Description: 'Somatic mutation (for cancer genomics)' },\n\n    VALIDATED: {\n      Number: 0,\n      Type: 'Flag',\n      Description: 'Validated by follow-up experiment' },\n\n    '1000G': {\n      Number: 0,\n      Type: 'Flag',\n      Description: '1000 Genomes membership' },\n\n    // specifically for structural variants\n    IMPRECISE: {\n      Number: 0,\n      Type: 'Flag',\n      Description: 'Imprecise structural variation' },\n\n    NOVEL: {\n      Number: 0,\n      Type: 'Flag',\n      Description: 'Indicates a novel structural variation' },\n\n    // For precise variants, END is POS + length of REF allele - 1,\n    // and the for imprecise variants the corresponding best estimate.\n    SVTYPE: {\n      Number: 1,\n      Type: 'String',\n      Description: 'Type of structural variant' },\n\n    // Value should be one of DEL, INS, DUP, INV, CNV, BND. This key can\n    // be derived from the REF/ALT fields but is useful for filtering.\n    SVLEN: {\n      Number: null,\n      Type: 'Integer',\n      Description: 'Difference in length between REF and ALT alleles' },\n\n    // One value for each ALT allele. Longer ALT alleles (e.g. insertions)\n    // have positive values, shorter ALT alleles (e.g. deletions)\n    // have negative values.\n    CIPOS: {\n      Number: 2,\n      Type: 'Integer',\n      Description: 'Confidence interval around POS for imprecise variants' },\n\n    CIEND: {\n      Number: 2,\n      Type: 'Integer',\n      Description: 'Confidence interval around END for imprecise variants' },\n\n    HOMLEN: {\n      Type: 'Integer',\n      Description:\n      'Length of base pair identical micro-homology at event breakpoints' },\n\n    HOMSEQ: {\n      Type: 'String',\n      Description:\n      'Sequence of base pair identical micro-homology at event breakpoints' },\n\n    BKPTID: {\n      Type: 'String',\n      Description: 'ID of the assembled alternate allele in the assembly file' },\n\n    // For precise variants, the consensus sequence the alternate allele assembly\n    // is derivable from the REF and ALT fields. However, the alternate allele\n    // assembly file may contain additional information about the characteristics\n    // of the alt allele contigs.\n    MEINFO: {\n      Number: 4,\n      Type: 'String',\n      Description: 'Mobile element info of the form NAME,START,END,POLARITY' },\n\n    METRANS: {\n      Number: 4,\n      Type: 'String',\n      Description:\n      'Mobile element transduction info of the form CHR,START,END,POLARITY' },\n\n    DGVID: {\n      Number: 1,\n      Type: 'String',\n      Description: 'ID of this element in Database of Genomic Variation' },\n\n    DBVARID: {\n      Number: 1,\n      Type: 'String',\n      Description: 'ID of this element in DBVAR' },\n\n    DBRIPID: {\n      Number: 1,\n      Type: 'String',\n      Description: 'ID of this element in DBRIP' },\n\n    MATEID: {\n      Number: null,\n      Type: 'String',\n      Description: 'ID of mate breakends' },\n\n    PARID: {\n      Number: 1,\n      Type: 'String',\n      Description: 'ID of partner breakend' },\n\n    EVENT: {\n      Number: 1,\n      Type: 'String',\n      Description: 'ID of event associated to breakend' },\n\n    CILEN: {\n      Number: 2,\n      Type: 'Integer',\n      Description:\n      'Confidence interval around the inserted material between breakend' },\n\n    DPADJ: { Type: 'Integer', Description: 'Read Depth of adjacency' },\n    CN: {\n      Number: 1,\n      Type: 'Integer',\n      Description: 'Copy number of segment containing breakend' },\n\n    CNADJ: {\n      Number: null,\n      Type: 'Integer',\n      Description: 'Copy number of adjacency' },\n\n    CICN: {\n      Number: 2,\n      Type: 'Integer',\n      Description: 'Confidence interval around copy number for the segment' },\n\n    CICNADJ: {\n      Number: null,\n      Type: 'Integer',\n      Description: 'Confidence interval around copy number for the adjacency' } },\n\n\n\n  // FORMAT fields\n  GenotypeFields: {\n    // from the VCF4.3 spec, https://samtools.github.io/hts-specs/VCFv4.3.pdf\n    AD: {\n      Number: 'R',\n      Type: 'Integer',\n      Description: 'Read depth for each allele' },\n\n    ADF: {\n      Number: 'R',\n      Type: 'Integer',\n      Description: 'Read depth for each allele on the forward strand' },\n\n    ADR: {\n      Number: 'R',\n      Type: 'Integer',\n      Description: 'Read depth for each allele on the reverse strand' },\n\n    DP: {\n      Number: 1,\n      Type: 'Integer',\n      Description: 'Read depth' },\n\n    EC: {\n      Number: 'A',\n      Type: 'Integer',\n      Description: 'Expected alternate allele counts' },\n\n    FT: {\n      Number: 1,\n      Type: 'String',\n      Description: 'Filter indicating if this genotype was \"called\"' },\n\n    GL: {\n      Number: 'G',\n      Type: 'Float',\n      Description: 'Genotype likelihoods' },\n\n    GP: {\n      Number: 'G',\n      Type: 'Float',\n      Description: 'Genotype posterior probabilities' },\n\n    GQ: {\n      Number: 1,\n      Type: 'Integer',\n      Description: 'Conditional genotype quality' },\n\n    GT: {\n      Number: 1,\n      Type: 'String',\n      Description: 'Genotype' },\n\n    HQ: {\n      Number: 2,\n      Type: 'Integer',\n      Description: 'Haplotype quality' },\n\n    MQ: {\n      Number: 1,\n      Type: 'Integer',\n      Description: 'RMS mapping quality' },\n\n    PL: {\n      Number: 'G',\n      Type: 'Integer',\n      Description:\n      'Phred-scaled genotype likelihoods rounded to the closest integer' },\n\n    PQ: {\n      Number: 1,\n      Type: 'Integer',\n      Description: 'Phasing quality' },\n\n    PS: {\n      Number: 1,\n      Type: 'Integer',\n      Description: 'Phase set' } },\n\n\n\n  // ALT fields\n  AltTypes: {\n    DEL: {\n      Description: 'Deletion relative to the reference' },\n\n    INS: {\n      Description: 'Insertion of novel sequence relative to the reference' },\n\n    DUP: {\n      Description: 'Region of elevated copy number relative to the reference' },\n\n    INV: {\n      Description: 'Inversion of reference sequence' },\n\n    CNV: {\n      Description:\n      'Copy number variable region (may be both deletion and duplication)' },\n\n    'DUP:TANDEM': {\n      Description: 'Tandem duplication' },\n\n    'DEL:ME': {\n      Description: 'Deletion of mobile element relative to the reference' },\n\n    'INS:ME': {\n      Description: 'Insertion of a mobile element relative to the reference' },\n\n    NON_REF: {\n      Description:\n      'Represents any possible alternative allele at this location' },\n\n    '*': {\n      Description:\n      'Represents any possible alternative allele at this location' } },\n\n\n\n  // FILTER fields\n  FilterTypes: {\n    PASS: {\n      Description: 'Passed all filters' } } };exports.default = _default;","import {\n  BaseFeatureDataAdapter,\n  BaseOptions,\n} from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { FileLocation, Region } from '@jbrowse/core/util/types'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport { Feature } from '@jbrowse/core/util/simpleFeature'\nimport { readConfObject } from '@jbrowse/core/configuration'\nimport { AnyConfigurationModel } from '@jbrowse/core/configuration/configurationSchema'\nimport VcfFeature from '../VcfTabixAdapter/VcfFeature'\nimport VCF from '@gmod/vcf'\nimport { unzip } from '@gmod/bgzf-filehandle'\n\nconst readVcf = (f: string) => {\n  const lines = f.split('\\n')\n  const header: string[] = []\n  const refNames: string[] = []\n  const rest: string[] = []\n  lines.forEach(line => {\n    if (line.startsWith('##contig')) {\n      refNames.push(line.split('##contig=<ID=')[1].split(',')[0])\n    } else if (line.startsWith('#')) {\n      header.push(line)\n    } else if (line) {\n      rest.push(line)\n    }\n  })\n  return { header: header.join('\\n'), lines: rest, refNames }\n}\n\nexport default class VcfAdapter extends BaseFeatureDataAdapter {\n  public static capabilities = ['getFeatures', 'getRefNames']\n\n  private setupP?: Promise<Feature[]>\n\n  public constructor(config: AnyConfigurationModel) {\n    super(config)\n  }\n\n  private async decodeFileContents() {\n    const vcfLocation = readConfObject(\n      this.config,\n      'vcfLocation',\n    ) as FileLocation\n\n    let fileContents = await openLocation(vcfLocation).readFile()\n\n    if (\n      typeof fileContents[0] === 'number' &&\n      fileContents[0] === 31 &&\n      typeof fileContents[1] === 'number' &&\n      fileContents[1] === 139 &&\n      typeof fileContents[2] === 'number' &&\n      fileContents[2] === 8\n    ) {\n      fileContents = new TextDecoder().decode(await unzip(fileContents))\n    } else {\n      fileContents = fileContents.toString()\n    }\n\n    return readVcf(fileContents)\n  }\n\n  public async getHeader() {\n    const { header } = await this.decodeFileContents()\n    return header\n  }\n\n  async getMetadata() {\n    const { header } = await this.decodeFileContents()\n    const parser = new VCF({ header: header })\n    return parser.getMetadata()\n  }\n\n  public async getLines() {\n    const { header, lines } = await this.decodeFileContents()\n\n    const parser = new VCF({ header: header })\n\n    return lines.map((line, index) => {\n      return new VcfFeature({\n        variant: parser.parseLine(line),\n        parser,\n        id: `${this.id}-vcf-${index}`,\n      })\n    })\n  }\n\n  public async setup() {\n    if (!this.setupP) {\n      this.setupP = this.getLines()\n    }\n    return this.setupP\n  }\n\n  public async getRefNames(_: BaseOptions = {}) {\n    const { refNames } = await this.decodeFileContents()\n    return refNames\n  }\n\n  public getFeatures(region: Region, opts: BaseOptions = {}) {\n    return ObservableCreate<Feature>(async observer => {\n      const feats = await this.setup()\n      feats.forEach(f => {\n        if (\n          f.get('refName') === region.refName &&\n          f.get('end') > region.start &&\n          f.get('start') < region.end\n        ) {\n          observer.next(f)\n        }\n      })\n      observer.complete()\n    }, opts.signal)\n  }\n\n  public freeResources(): void {}\n}\n"],"sourceRoot":""}